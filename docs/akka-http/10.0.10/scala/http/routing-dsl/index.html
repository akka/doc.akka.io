<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>High-level Server-Side API &bull; Akka HTTP</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka HTTP: Modern, fast, asynchronous, streaming-first HTTP server and client."/><link rel="canonical" href="https://doc.akka.io/docs/akka-http/10.0/scala/http/routing-dsl/index.html"/>
<script type="text/javascript" src="../../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>
<link rel="shortcut icon" href="../../../images/favicon.ico" />
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../../scala/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.10
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../../scala/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../scala/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../scala/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../scala/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../scala/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../scala/http/server-side/low-level-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html#high-level-server-side-api" class="active page">High-level Server-Side API</a>
  <ul>
    <li><a href="../../../scala/http/routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#longer-example" class="header">Longer Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
    <li><a href="../../../scala/http/routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
    <li><a href="../../../scala/http/routing-dsl/routes.html" class="page">Routes</a></li>
    <li><a href="../../../scala/http/routing-dsl/directives/index.html" class="page">Directives</a></li>
    <li><a href="../../../scala/http/routing-dsl/rejections.html" class="page">Rejections</a></li>
    <li><a href="../../../scala/http/routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
    <li><a href="../../../scala/http/routing-dsl/case-class-extraction.html" class="page">Case Class Extraction</a></li>
    <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
    <li><a href="../../../scala/http/routing-dsl/testkit.html" class="page">Route TestKit</a></li>
    <li><a href="../../../scala/http/routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
  </ul></li>
  <li><a href="../../../scala/http/server-side/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../scala/http/server-side/server-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../scala/http/server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  <li><a href="../../../scala/http/sse-support.html" class="page">Server-Sent Events Support</a></li>
  <li><a href="../../../scala/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a></li>
  <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
  <li><a href="../../../scala/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../scala/http/compatibility-guidelines.html" class="page">Compatibility Guidelines</a></li>
  <li><a href="../../../scala/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../../scala/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.10
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../../scala/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../scala/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../scala/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../scala/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../scala/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../scala/http/server-side/low-level-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html#high-level-server-side-api" class="active page">High-level Server-Side API</a>
  <ul>
    <li><a href="../../../scala/http/routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#longer-example" class="header">Longer Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
    <li><a href="../../../scala/http/routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
    <li><a href="../../../scala/http/routing-dsl/routes.html" class="page">Routes</a></li>
    <li><a href="../../../scala/http/routing-dsl/directives/index.html" class="page">Directives</a></li>
    <li><a href="../../../scala/http/routing-dsl/rejections.html" class="page">Rejections</a></li>
    <li><a href="../../../scala/http/routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
    <li><a href="../../../scala/http/routing-dsl/case-class-extraction.html" class="page">Case Class Extraction</a></li>
    <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
    <li><a href="../../../scala/http/routing-dsl/testkit.html" class="page">Route TestKit</a></li>
    <li><a href="../../../scala/http/routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
  </ul></li>
  <li><a href="../../../scala/http/server-side/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../scala/http/server-side/server-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../scala/http/server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  <li><a href="../../../scala/http/sse-support.html" class="page">Server-Sent Events Support</a></li>
  <li><a href="../../../scala/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a></li>
  <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
  <li><a href="../../../scala/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../scala/http/compatibility-guidelines.html" class="page">Compatibility Guidelines</a></li>
  <li><a href="../../../scala/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#high-level-server-side-api" name="high-level-server-side-api" class="anchor"><span class="anchor-link"></span></a>High-level Server-Side API</h1>
<p>In addition to the <a href="../server-side/low-level-api.html">Low-Level Server-Side API</a> Akka HTTP provides a very flexible &ldquo;Routing DSL&rdquo; for elegantly defining RESTful web services. It picks up where the low-level API leaves off and offers much of the higher-level functionality of typical web servers or frameworks, like deconstruction of URIs, content negotiation or static content serving.</p><div class="callout note "><div class="callout-title">Note</div>
<p>It is recommended to read the <a href="../implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a> section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-&ldquo;streaming first&rdquo; HTTP Servers.</p></div>
<div class="toc ">
<ul>
  <li><a href="../../../scala/http/routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html#longer-example" class="header">Longer Example</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
  <li><a href="../../../scala/http/routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
  <li><a href="../../../scala/http/routing-dsl/routes.html" class="page">Routes</a></li>
  <li><a href="../../../scala/http/routing-dsl/directives/index.html" class="page">Directives</a></li>
  <li><a href="../../../scala/http/routing-dsl/rejections.html" class="page">Rejections</a></li>
  <li><a href="../../../scala/http/routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
  <li><a href="../../../scala/http/routing-dsl/case-class-extraction.html" class="page">Case Class Extraction</a></li>
  <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
  <li><a href="../../../scala/http/routing-dsl/testkit.html" class="page">Route TestKit</a></li>
  <li><a href="../../../scala/http/routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
</ul>
</div>
<h2><a href="#minimal-example" name="minimal-example" class="anchor"><span class="anchor-link"></span></a>Minimal Example</h2>
<p>This is a complete, very basic Akka HTTP application relying on the Routing DSL:</p>
<pre class="prettyprint"><code class="language-scala">import akka.actor.ActorSystem
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer
import scala.io.StdIn

object WebServer {
  def main(args: Array[String]) {

    implicit val system = ActorSystem(&quot;my-system&quot;)
    implicit val materializer = ActorMaterializer()
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.dispatcher

    val route =
      path(&quot;hello&quot;) {
        get {
          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, &quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))
        }
      }

    val bindingFuture = Http().bindAndHandle(route, &quot;localhost&quot;, 8080)

    println(s&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done
  }
}</code></pre>
<p>It starts an HTTP Server on localhost and replies to GET requests to <code>/hello</code> with a simple response.</p><div class="callout warning "><div class="callout-title">API may change</div>
<p>The following example uses an experimental feature and its API is subjected to change in future releases of Akka HTTP. For further information about this marker, see <a href="https://doc.akka.io/docs/akka/2.4.19/common/binary-compatibility-rules.html#The_@DoNotInherit_and_@ApiMayChange_markers">The @DoNotInherit and @ApiMayChange markers</a> in the Akka documentation.</p></div>
<p>To help start a server Akka HTTP provides an experimental helper class called <code>HttpApp</code>. This is the same example as before rewritten using <code>HttpApp</code>:</p>
<pre class="prettyprint"><code class="language-scala">import akka.http.scaladsl.model.{ ContentTypes, HttpEntity }
import akka.http.scaladsl.server.HttpApp
import akka.http.scaladsl.server.Route

// Server definition
object WebServer extends HttpApp {
  override def routes: Route =
    path(&quot;hello&quot;) {
      get {
        complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, &quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))
      }
    }
}

// Starting the server
WebServer.startServer(&quot;localhost&quot;, 8080)</code></pre>
<p>See <a href="HttpApp.html">HttpApp Bootstrap</a> for more details about setting up a server using this approach.</p>
<a id="long-example"></a>
<h2><a href="#longer-example" name="longer-example" class="anchor"><span class="anchor-link"></span></a>Longer Example</h2>
<p>The following is an Akka HTTP route definition that tries to show off a few features. The resulting service does not really do anything useful but its definition should give you a feel for what an actual API definition with the Routing DSL will look like:</p>
<pre class="prettyprint"><code class="language-scala">import akka.actor.{ActorRef, ActorSystem}
import akka.http.scaladsl.coding.Deflate
import akka.http.scaladsl.marshalling.ToResponseMarshaller
import akka.http.scaladsl.model.StatusCodes.MovedPermanently
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.unmarshalling.FromRequestUnmarshaller
import akka.pattern.ask
import akka.stream.ActorMaterializer
import akka.util.Timeout

// types used by the API routes
type Money = Double // only for demo purposes, don&#39;t try this at home!
type TransactionResult = String
case class User(name: String)
case class Order(email: String, amount: Money)
case class Update(order: Order)
case class OrderItem(i: Int, os: Option[String], s: String)

// marshalling would usually be derived automatically using libraries
implicit val orderUM: FromRequestUnmarshaller[Order] = ???
implicit val orderM: ToResponseMarshaller[Order] = ???
implicit val orderSeqM: ToResponseMarshaller[Seq[Order]] = ???
implicit val timeout: Timeout = ??? // for actor asks
implicit val ec: ExecutionContext = ???
implicit val mat: ActorMaterializer = ???
implicit val sys: ActorSystem = ???

// backend entry points
def myAuthenticator: Authenticator[User] = ???
def retrieveOrdersFromDB: Seq[Order] = ???
def myDbActor: ActorRef = ???
def processOrderRequest(id: Int, complete: Order =&gt; Unit): Unit = ???

val route = {
  path(&quot;orders&quot;) {
    authenticateBasic(realm = &quot;admin area&quot;, myAuthenticator) { user =&gt;
      get {
        encodeResponseWith(Deflate) {
          complete {
            // marshal custom object with in-scope marshaller
            retrieveOrdersFromDB
          }
        }
      } ~
      post {
        // decompress gzipped or deflated requests if required
        decodeRequest {
          // unmarshal with in-scope unmarshaller
          entity(as[Order]) { order =&gt;
            complete {
              // ... write order to DB
              &quot;Order received&quot;
            }
          }
        }
      }
    }
  } ~
  // extract URI path element as Int
  pathPrefix(&quot;order&quot; / IntNumber) { orderId =&gt;
    pathEnd {
      (put | parameter(&#39;method ! &quot;put&quot;)) {
        // form extraction from multipart or www-url-encoded forms
        formFields((&#39;email, &#39;total.as[Money])).as(Order) { order =&gt;
          complete {
            // complete with serialized Future result
            (myDbActor ? Update(order)).mapTo[TransactionResult]
          }
        }
      } ~
      get {
        // debugging helper
        logRequest(&quot;GET-ORDER&quot;) {
          // use in-scope marshaller to create completer function
          completeWith(instanceOf[Order]) { completer =&gt;
            // custom
            processOrderRequest(orderId, completer)
          }
        }
      }
    } ~
    path(&quot;items&quot;) {
      get {
        // parameters to case class extraction
        parameters((&#39;size.as[Int], &#39;color ?, &#39;dangerous ? &quot;no&quot;))
          .as(OrderItem) { orderItem =&gt;
            // ... route using case class instance created from
            // required and optional query parameters
            complete(&quot;&quot;) // hide
          }
      }
    }
  } ~
  pathPrefix(&quot;documentation&quot;) {
    // optionally compresses the response with Gzip or Deflate
    // if the client accepts compressed responses
    encodeResponse {
      // serve up static content from a JAR resource
      getFromResourceDirectory(&quot;docs&quot;)
    }
  } ~
  path(&quot;oldApi&quot; / Remaining) { pathRest =&gt;
    redirect(&quot;http://oldapi.example.com/&quot; + pathRest, MovedPermanently)
  }
}</code></pre>
<a id="handling-http-server-failures-high-level-scala"></a>
<h2><a href="#handling-http-server-failures-in-the-high-level-api" name="handling-http-server-failures-in-the-high-level-api" class="anchor"><span class="anchor-link"></span></a>Handling HTTP Server failures in the High-Level API</h2>
<p>There are various situations when failure may occur while initialising or running an Akka HTTP server. Akka by default will log all these failures, however sometimes one may want to react to failures in addition to them just being logged, for example by shutting down the actor system, or notifying some external monitoring end-point explicitly.</p>
<h3><a href="#bind-failures" name="bind-failures" class="anchor"><span class="anchor-link"></span></a>Bind failures</h3>
<p>For example the server might be unable to bind to the given port. For example when the port is already taken by another application, or if the port is privileged (i.e. only usable by <code>root</code>). In this case the &ldquo;binding future&rdquo; will fail immediately, and we can react to it by listening on the Future&rsquo;s completion:</p>
<pre class="prettyprint"><code class="language-scala">import akka.actor.ActorSystem
import akka.http.scaladsl.Http
import akka.http.scaladsl.Http.ServerBinding
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer

import scala.concurrent.Future

object WebServer {
  def main(args: Array[String]) {
    implicit val system = ActorSystem()
    implicit val materializer = ActorMaterializer()
    // needed for the future foreach in the end
    implicit val executionContext = system.dispatcher

    val handler = get {
      complete(&quot;Hello world!&quot;)
    }

    // let&#39;s say the OS won&#39;t allow us to bind to 80.
    val (host, port) = (&quot;localhost&quot;, 80)
    val bindingFuture: Future[ServerBinding] =
      Http().bindAndHandle(handler, host, port)

    bindingFuture.failed.foreach { ex =&gt;
      log.error(ex, &quot;Failed to bind to {}:{}!&quot;, host, port)
    }
  }
}</code></pre><div class="callout note "><div class="callout-title">Note</div>
<p>For a more low-level overview of the kinds of failures that can happen and also more fine-grained control over them refer to the <a href="../server-side/low-level-api.html#handling-http-server-failures-low-level">Handling HTTP Server failures in the Low-Level API</a> documentation.</p></div>
<h3><a href="#failures-and-exceptions-inside-the-routing-dsl" name="failures-and-exceptions-inside-the-routing-dsl" class="anchor"><span class="anchor-link"></span></a>Failures and exceptions inside the Routing DSL</h3>
<p>Exception handling within the Routing DSL is done by providing <code>ExceptionHandler</code> s which are documented in-depth in the <a href="exception-handling.html">Exception Handling</a> section of the documentation. You can use them to transform exceptions into <code>HttpResponse</code> s with appropriate error codes and human-readable failure descriptions.</p>
<h3><a href="#file-uploads" name="file-uploads" class="anchor"><span class="anchor-link"></span></a>File uploads</h3>
<p>For high level directives to handle uploads see the <a href="directives/file-upload-directives/index.html">FileUploadDirectives</a>.</p>
<p>Handling a simple file upload from for example a browser form with a <em>file</em> input can be done by accepting a <em>Multipart.FormData</em> entity, note that the body parts are <em>Source</em> rather than all available right away, and so is the individual body part payload so you will need to consume those streams both for the file and for the form fields.</p>
<p>Here is a simple example which just dumps the uploaded file into a temporary file on disk, collects some form fields and saves an entry to a fictive database:</p>
<pre class="prettyprint"><code class="language-scala">val uploadVideo =
  path(&quot;video&quot;) {
    entity(as[Multipart.FormData]) { formData =&gt;

      // collect all parts of the multipart as it arrives into a map
      val allPartsF: Future[Map[String, Any]] = formData.parts.mapAsync[(String, Any)](1) {

        case b: BodyPart if b.name == &quot;file&quot; =&gt;
          // stream into a file as the chunks of it arrives and return a future
          // file to where it got stored
          val file = File.createTempFile(&quot;upload&quot;, &quot;tmp&quot;)
          b.entity.dataBytes.runWith(FileIO.toPath(file.toPath)).map(_ =&gt;
            (b.name -&gt; file))

        case b: BodyPart =&gt;
          // collect form field values
          b.toStrict(2.seconds).map(strict =&gt;
            (b.name -&gt; strict.entity.data.utf8String))

      }.runFold(Map.empty[String, Any])((map, tuple) =&gt; map + tuple)

      val done = allPartsF.map { allParts =&gt;
        // You would have some better validation/unmarshalling here
        db.create(Video(
          file = allParts(&quot;file&quot;).asInstanceOf[File],
          title = allParts(&quot;title&quot;).asInstanceOf[String],
          author = allParts(&quot;author&quot;).asInstanceOf[String]))
      }

      // when processing have finished create a response for the user
      onSuccess(allPartsF) { allParts =&gt;
        complete {
          &quot;ok!&quot;
        }
      }
    }
  }</code></pre>
<p>You can transform the uploaded files as they arrive rather than storing them in a temporary file as in the previous example. In this example we accept any number of <code>.csv</code> files, parse those into lines and split each line before we send it to an actor for further processing:</p>
<pre class="prettyprint"><code class="language-scala">val splitLines = Framing.delimiter(ByteString(&quot;\n&quot;), 256)

val csvUploads =
  path(&quot;metadata&quot; / LongNumber) { id =&gt;
    entity(as[Multipart.FormData]) { formData =&gt;
      val done: Future[Done] = formData.parts.mapAsync(1) {
        case b: BodyPart if b.filename.exists(_.endsWith(&quot;.csv&quot;)) =&gt;
          b.entity.dataBytes
            .via(splitLines)
            .map(_.utf8String.split(&quot;,&quot;).toVector)
            .runForeach(csv =&gt;
              metadataActor ! MetadataActor.Entry(id, csv))
        case _ =&gt; Future.successful(Done)
      }.runWith(Sink.ignore)

      // when processing have finished create a response for the user
      onSuccess(done) { _ =&gt;
        complete {
          &quot;ok!&quot;
        }
      }
    }
  }</code></pre>
<h2><a href="#configuring-server-side-https" name="configuring-server-side-https" class="anchor"><span class="anchor-link"></span></a>Configuring Server-side HTTPS</h2>
<p>For detailed documentation about configuring and using HTTPS on the server-side refer to <a href="../server-side/server-https-support.html">Server-Side HTTPS Support</a>.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../../scala/http/server-side/low-level-api.html"><i class="icon-prev"></i> <span class="link-prev">Low-Level Server-Side API</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../../scala/http/routing-dsl/overview.html">Routing DSL Overview <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="http://github.com/akka/akka-http/tree/master/docs/src/main/paradox/scala/http/routing-dsl/index.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka HTTP is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../../js/groups.js"></script>
<script type="text/javascript" src="../../../js/page.js"></script>
<script type="text/javascript" src="../../../js/magellan.js"></script>

<style type="text/css">@import "../../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var version = "10.0.10";

var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
