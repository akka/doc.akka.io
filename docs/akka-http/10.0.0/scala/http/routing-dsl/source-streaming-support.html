<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Source Streaming · Akka HTTP</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='akka-http-docs'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../js/page.js"></script>
<link rel="stylesheet" type="text/css" href="../../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>

<!--
<link rel="shortcut icon" href="../../../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../../../index.html" >
<span class="home-icon">⌂</span>Akka HTTP
</a>
<div class="version-number">
10.0.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../../../java.html">Java Documentation</a>
  <ul>
    <li><a href="../../../java/http/index.html">Akka HTTP</a>
    <ul>
      <li><a href="../../../java/http/introduction.html">Introduction</a></li>
      <li><a href="../../../java/http/configuration.html">Configuration</a></li>
      <li><a href="../../../java/http/http-model.html">HTTP Model</a></li>
      <li><a href="../../../java/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
      <li><a href="../../../java/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
      <li><a href="../../../java/http/server-side/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
      <li><a href="../../../java/http/routing-dsl/index.html">High-level Server-Side API</a></li>
      <li><a href="../../../java/http/server-side/websocket-support.html">Server-Side WebSocket Support</a></li>
      <li><a href="../../../java/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
      <li><a href="../../../java/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
      <li><a href="../../../java/http/migration-guide/index.html">Migration Guides (Java)</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../../../scala.html">Scala Documentation</a>
  <ul>
    <li><a href="../../../scala/http/index.html">Akka HTTP</a>
    <ul>
      <li><a href="../../../scala/http/introduction.html">Introduction</a></li>
      <li><a href="../../../scala/http/configuration.html">Configuration</a></li>
      <li><a href="../../../scala/http/common/http-model.html">HTTP Model</a></li>
      <li><a href="../../../scala/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
      <li><a href="../../../scala/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
      <li><a href="../../../scala/http/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
      <li><a href="../../../scala/http/routing-dsl/index.html">High-level Server-Side API</a></li>
      <li><a href="../../../scala/http/websocket-support.html">Server-Side WebSocket Support</a></li>
      <li><a href="../../../scala/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
      <li><a href="../../../scala/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
      <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html">Handling blocking operations in Akka HTTP</a></li>
      <li><a href="../../../scala/http/migration-guide/index.html">Migration Guides</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../../../security.html">Security announcements</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../../../index.html">Akka HTTP</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../../../index.html" >
<span class="home-icon">⌂</span>Akka HTTP
</a>
<div class="version-number">
10.0.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../../../java.html">Java Documentation</a>
  <ul>
    <li><a href="../../../java/http/index.html">Akka HTTP</a>
    <ul>
      <li><a href="../../../java/http/introduction.html">Introduction</a></li>
      <li><a href="../../../java/http/configuration.html">Configuration</a></li>
      <li><a href="../../../java/http/http-model.html">HTTP Model</a></li>
      <li><a href="../../../java/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
      <li><a href="../../../java/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
      <li><a href="../../../java/http/server-side/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
      <li><a href="../../../java/http/routing-dsl/index.html">High-level Server-Side API</a></li>
      <li><a href="../../../java/http/server-side/websocket-support.html">Server-Side WebSocket Support</a></li>
      <li><a href="../../../java/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
      <li><a href="../../../java/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
      <li><a href="../../../java/http/migration-guide/index.html">Migration Guides (Java)</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../../../scala.html">Scala Documentation</a>
  <ul>
    <li><a href="../../../scala/http/index.html">Akka HTTP</a>
    <ul>
      <li><a href="../../../scala/http/introduction.html">Introduction</a></li>
      <li><a href="../../../scala/http/configuration.html">Configuration</a></li>
      <li><a href="../../../scala/http/common/http-model.html">HTTP Model</a></li>
      <li><a href="../../../scala/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
      <li><a href="../../../scala/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
      <li><a href="../../../scala/http/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
      <li><a href="../../../scala/http/routing-dsl/index.html">High-level Server-Side API</a></li>
      <li><a href="../../../scala/http/websocket-support.html">Server-Side WebSocket Support</a></li>
      <li><a href="../../../scala/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
      <li><a href="../../../scala/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
      <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html">Handling blocking operations in Akka HTTP</a></li>
      <li><a href="../../../scala/http/migration-guide/index.html">Migration Guides</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../../../security.html">Security announcements</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../../../index.html">Akka HTTP</a></li>
  <li><a href="../../../scala.html">Scala Documentation</a></li>
  <li><a href="../../../scala/http/index.html">Akka HTTP</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html">High-level Server-Side API</a></li>
  <li>Source Streaming</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<a id="json-streaming-scala"></a>
<h1><a href="#source-streaming" name="source-streaming" class="anchor"><span class="anchor-link"></span></a>Source Streaming</h1>
<p>Akka HTTP supports completing a request with an Akka <code>Source[T, _]</code>, which makes it possible to easily build and consume streaming end-to-end APIs which apply back-pressure throughout the entire stack. </p>
<p>It is possible to complete requests with raw <code>Source[ByteString, _]</code>, however often it is more convenient to stream on an element-by-element basis, and allow Akka HTTP to handle the rendering internally - for example as a JSON array, or CSV stream (where each element is separated by a new-line).</p>
<p>In the following sections we investigate how to make use of the JSON Streaming infrastructure, however the general hints apply to any kind of element-by-element streaming you could imagine.</p>
<h1><a href="#json-streaming" name="json-streaming" class="anchor"><span class="anchor-link"></span></a>JSON Streaming</h1>
<p><a href="https://en.wikipedia.org/wiki/JSON_Streaming">JSON Streaming</a> is a term referring to streaming a (possibly infinite) stream of element as independent JSON objects as a continuous HTTP request or response. The elements are most often separated using newlines, however do not have to be. Concatenating elements side-by-side or emitting &ldquo;very long&rdquo; JSON array is also another use case.</p>
<p>In the below examples, we&rsquo;ll be referring to the <code>Tweet</code> and <code>Measurement</code> case classes as our model, which are defined as:</p>
<pre class="prettyprint"><code class="language-scala">case class Tweet(uid: Int, txt: String)
case class Measurement(id: String, value: Int)</code></pre>
<p>And as always with spray-json, we provide our (Un)Marshaller instances as implicit values using the <code>jsonFormat##</code> method to generate them statically:</p>
<pre class="prettyprint"><code class="language-scala">object MyJsonProtocol
  extends akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
  with spray.json.DefaultJsonProtocol {

  implicit val tweetFormat = jsonFormat2(Tweet.apply)
  implicit val measurementFormat = jsonFormat2(Measurement.apply)
}</code></pre>
<h2><a href="#responding-with-json-streams" name="responding-with-json-streams" class="anchor"><span class="anchor-link"></span></a>Responding with JSON Streams</h2>
<p>In this example we implement an API representing an infinite stream of tweets, very much like Twitter&rsquo;s <a href="https://dev.twitter.com/streaming/overview">Streaming API</a>.</p>
<p>Firstly, we&rsquo;ll need to get some additional marshalling infrastructure set up, that is able to marshal to and from an Akka Streams <code>Source[T,_]</code>. One such trait, containing the needed marshallers is <code>SprayJsonSupport</code>, which uses spray-json (a high performance json parser library), and is shipped as part of Akka HTTP in the <code>akka-http-spray-json</code> module.</p>
<p>Once the general infrastructure is prepared we import our model&rsquo;s marshallers, generated by spray-json (Step 1), and enable JSON Streaming by making an implicit <code>EntityStreamingSupport</code> instance available (Step 2). Akka HTTP pre-packages JSON and CSV entity streaming support, however it is simple to add your own, in case you&rsquo;d like to stream a different content type (for example plists or protobuf).</p>
<p>The final step is simply completing a request using a Source of tweets, as simple as that:</p>
<pre class="prettyprint"><code class="language-scala">// [1] import &quot;my protocol&quot;, for marshalling Tweet objects:
import MyJsonProtocol._

// [2] pick a Source rendering support trait:
// Note that the default support renders the Source as JSON Array
implicit val jsonStreamingSupport: JsonEntityStreamingSupport = EntityStreamingSupport.json()

val route =
  path(&quot;tweets&quot;) {
    // [3] simply complete a request with a source of tweets:
    val tweets: Source[Tweet, NotUsed] = getTweets
    complete(tweets)
  }

// tests ------------------------------------------------------------
val AcceptJson = Accept(MediaRange(MediaTypes.`application/json`))
val AcceptXml = Accept(MediaRange(MediaTypes.`text/xml`))

Get(&quot;/tweets&quot;).withHeaders(AcceptJson) ~&gt; route ~&gt; check {
  responseAs[String] shouldEqual
    &quot;&quot;&quot;[&quot;&quot;&quot; +
    &quot;&quot;&quot;{&quot;uid&quot;:1,&quot;txt&quot;:&quot;#Akka rocks!&quot;},&quot;&quot;&quot; +
    &quot;&quot;&quot;{&quot;uid&quot;:2,&quot;txt&quot;:&quot;Streaming is so hot right now!&quot;},&quot;&quot;&quot; +
    &quot;&quot;&quot;{&quot;uid&quot;:3,&quot;txt&quot;:&quot;You cannot enter the same river twice.&quot;}&quot;&quot;&quot; +
    &quot;&quot;&quot;]&quot;&quot;&quot;
}

// endpoint can only marshal Json, so it will *reject* requests for application/xml:
Get(&quot;/tweets&quot;).withHeaders(AcceptXml) ~&gt; route ~&gt; check {
  handled should ===(false)
  rejection should ===(UnacceptedResponseContentTypeRejection(Set(ContentTypes.`application/json`)))
}</code></pre>
<p>The reason the <code>EntityStreamingSupport</code> has to be enabled explicitly is that one might want to configure how the stream should be rendered. We&rsquo;ll discuss this in depth in the next section though.</p>
<h3><a href="#customising-response-rendering-mode" name="customising-response-rendering-mode" class="anchor"><span class="anchor-link"></span></a>Customising response rendering mode</h3>
<p>Since it is not always possible to directly and confidently answer the question of how a stream of <code>T</code> should look on the wire, the <code>EntityStreamingSupport</code> traits come into play and allow fine-tuning the streams rendered representation.</p>
<p>For example, in case of JSON Streaming, there isn&rsquo;t really one standard about rendering the response. Some APIs prefer to render multiple JSON objects in a line-by-line fashion (Twitter&rsquo;s streaming APIs for example), while others simply return very large arrays, which could be streamed as well. </p>
<p>Akka defaults to the second one (streaming a JSON Array), as it is correct JSON and clients not expecting a streaming API would still be able to consume it in a naive way if they&rsquo;d want to. </p>
<p>The line-by-line approach however is also pretty popular even though it is not valid JSON. It&rsquo;s relatively simplicity for client-side parsing is a strong point in case to pick this format for your Streaming APIs. Below we demonstrate how to reconfigure the support trait to render the JSON as </p>
<pre class="prettyprint"><code class="language-scala">import MyJsonProtocol._

// Configure the EntityStreamingSupport to render the elements as:
// {&quot;example&quot;:42}
// {&quot;example&quot;:43}
// ...
// {&quot;example&quot;:1000}
val start = ByteString.empty
val sep = ByteString(&quot;\n&quot;)
val end = ByteString.empty

implicit val jsonStreamingSupport = EntityStreamingSupport.json()
  .withFramingRenderer(Flow[ByteString].intersperse(start, sep, end))

val route =
  path(&quot;tweets&quot;) {
    // [3] simply complete a request with a source of tweets:
    val tweets: Source[Tweet, NotUsed] = getTweets
    complete(tweets)
  }

// tests ------------------------------------------------------------
val AcceptJson = Accept(MediaRange(MediaTypes.`application/json`))

Get(&quot;/tweets&quot;).withHeaders(AcceptJson) ~&gt; route ~&gt; check {
  responseAs[String] shouldEqual
    &quot;&quot;&quot;{&quot;uid&quot;:1,&quot;txt&quot;:&quot;#Akka rocks!&quot;}&quot;&quot;&quot; + &quot;\n&quot; +
    &quot;&quot;&quot;{&quot;uid&quot;:2,&quot;txt&quot;:&quot;Streaming is so hot right now!&quot;}&quot;&quot;&quot; + &quot;\n&quot; +
    &quot;&quot;&quot;{&quot;uid&quot;:3,&quot;txt&quot;:&quot;You cannot enter the same river twice.&quot;}&quot;&quot;&quot;
}</code></pre>
<p>Another interesting feature is parallel marshalling. Since marshalling can potentially take much time, it is possible to marshal multiple elements of the stream in parallel. This is simply a configuration option on <code>EntityStreamingSupport</code> and is configurable like this:</p>
<pre class="prettyprint"><code class="language-scala">import MyJsonProtocol._
implicit val jsonStreamingSupport: JsonEntityStreamingSupport =
  EntityStreamingSupport.json()
    .withParallelMarshalling(parallelism = 8, unordered = false)

path(&quot;tweets&quot;) {
  val tweets: Source[Tweet, NotUsed] = getTweets
  complete(tweets)
}</code></pre>
<p>The above shown mode preserves ordering of the Source&rsquo;s elements, which may sometimes be a required property, for example when streaming a strictly ordered dataset. Sometimes the concept of strict-order does not apply to the data being streamed though, which allows us to exploit this property and use an <code>unordered</code> rendering.</p>
<p>This also is a configuration option and is used as shown below. Effectively this will allow Akka&rsquo;s marshalling infrastructure to concurrently marshall up to <code>parallelism</code> elements and emit the first which is marshalled onto the <code>HttpResponse</code>:</p>
<pre class="prettyprint"><code class="language-scala">import MyJsonProtocol._
implicit val jsonStreamingSupport: JsonEntityStreamingSupport =
  EntityStreamingSupport.json()
    .withParallelMarshalling(parallelism = 8, unordered = true)

path(&quot;tweets&quot; / &quot;unordered&quot;) {
  val tweets: Source[Tweet, NotUsed] = getTweets
  complete(tweets)
}</code></pre>
<p>This allows us to <em>potentially</em> render elements faster onto the HttpResponse, since it can avoid &ldquo;head of line blocking&rdquo;, in case one element in front of the stream takes a long time to marshall, yet others after it are very quick to marshall.</p>
<h2><a href="#consuming-json-streaming-uploads" name="consuming-json-streaming-uploads" class="anchor"><span class="anchor-link"></span></a>Consuming JSON Streaming uploads</h2>
<p>Sometimes the client may be sending a streaming request, for example an embedded device initiated a connection with the server and is feeding it with one line of measurement data.</p>
<p>In this example, we want to consume this data in a streaming fashion from the request entity, and also apply back-pressure to the underlying TCP connection, if the server can not cope with the rate of incoming data (back-pressure will be applied automatically thanks to using Akka HTTP/Streams).</p>
<pre class="prettyprint"><code class="language-scala">// [1] import &quot;my protocol&quot;, for unmarshalling Measurement objects:
import MyJsonProtocol._

// [2] enable Json Streaming
implicit val jsonStreamingSupport = EntityStreamingSupport.json()

// prepare your persisting logic here
val persistMetrics = Flow[Measurement]

val route =
  path(&quot;metrics&quot;) {
    // [3] extract Source[Measurement, _]
    entity(asSourceOf[Measurement]) { measurements =&gt;
      // alternative syntax:
      // entity(as[Source[Measurement, NotUsed]]) { measurements =&gt;
      val measurementsSubmitted: Future[Int] =
        measurements
          .via(persistMetrics)
          .runFold(0) { (cnt, _) =&gt; cnt + 1 }

      complete {
        measurementsSubmitted.map(n =&gt; Map(&quot;msg&quot; -&gt; s&quot;&quot;&quot;Total metrics received: $n&quot;&quot;&quot;))
      }
    }
  }

// tests ------------------------------------------------------------
// uploading an array or newline separated values works out of the box
val data = HttpEntity(
  ContentTypes.`application/json`,
  &quot;&quot;&quot;
    |{&quot;id&quot;:&quot;temp&quot;,&quot;value&quot;:32}
    |{&quot;id&quot;:&quot;temp&quot;,&quot;value&quot;:31}
    |
  &quot;&quot;&quot;.stripMargin)

Post(&quot;/metrics&quot;, entity = data) ~&gt; route ~&gt; check {
  status should ===(StatusCodes.OK)
  responseAs[String] should ===(&quot;&quot;&quot;{&quot;msg&quot;:&quot;Total metrics received: 2&quot;}&quot;&quot;&quot;)
}

// the FramingWithContentType will reject any content type that it does not understand:
val xmlData = HttpEntity(
  ContentTypes.`text/xml(UTF-8)`,
  &quot;&quot;&quot;|&lt;data id=&quot;temp&quot; value=&quot;32&quot;/&gt;
     |&lt;data id=&quot;temp&quot; value=&quot;31&quot;/&gt;&quot;&quot;&quot;.stripMargin)

Post(&quot;/metrics&quot;, entity = xmlData) ~&gt; route ~&gt; check {
  handled should ===(false)
  rejection should ===(UnsupportedRequestContentTypeRejection(Set(ContentTypes.`application/json`)))
}</code></pre>
<h2><a href="#simple-csv-streaming-example" name="simple-csv-streaming-example" class="anchor"><span class="anchor-link"></span></a>Simple CSV streaming example</h2>
<p>Akka HTTP provides another <code>EntityStreamingSupport</code> out of the box, namely <code>csv</code> (comma-separated values). For completeness, we demonstrate its usage in the below snippet. As you&rsquo;ll notice, switching between streaming modes is fairly simple, one only has to make sure that an implicit <code>Marshaller</code> of the requested type is available, and that the streaming support operates on the same <code>Content-Type</code> as the rendered values. Otherwise you&rsquo;ll see an error during runtime that the marshaller did not expose the expected content type and thus we can not render the streaming response).</p>
<pre class="prettyprint"><code class="language-scala">// [1] provide a marshaller to ByteString
implicit val tweetAsCsv = Marshaller.strict[Tweet, ByteString] { t =&gt;
  Marshalling.WithFixedContentType(ContentTypes.`text/csv(UTF-8)`, () =&gt; {
    val txt = t.txt.replaceAll(&quot;,&quot;, &quot;.&quot;)
    val uid = t.uid
    ByteString(List(uid, txt).mkString(&quot;,&quot;))
  })
}

// [2] enable csv streaming:
implicit val csvStreaming = EntityStreamingSupport.csv()

val route =
  path(&quot;tweets&quot;) {
    val tweets: Source[Tweet, NotUsed] = getTweets
    complete(tweets)
  }

// tests ------------------------------------------------------------
val AcceptCsv = Accept(MediaRange(MediaTypes.`text/csv`))

Get(&quot;/tweets&quot;).withHeaders(AcceptCsv) ~&gt; route ~&gt; check {
  responseAs[String] shouldEqual
    &quot;1,#Akka rocks!&quot; + &quot;\n&quot; +
    &quot;2,Streaming is so hot right now!&quot; + &quot;\n&quot; +
    &quot;3,You cannot enter the same river twice.&quot;
}</code></pre>
<h2><a href="#implementing-custom-entitystreamingsupport-traits" name="implementing-custom-entitystreamingsupport-traits" class="anchor"><span class="anchor-link"></span></a>Implementing custom EntityStreamingSupport traits</h2>
<p>The <code>EntityStreamingSupport</code> infrastructure is open for extension and not bound to any single format, content type or marshalling library. The provided JSON support does not rely on Spray JSON directly, but uses <code>Marshaller[T, ByteString]</code> instances, which can be provided using any JSON marshalling library (such as Circe, Jawn or Play JSON).</p>
<p>When implementing a custom support trait, one should simply extend the <code>EntityStreamingSupport</code> abstract class, and implement all of it&rsquo;s methods. It&rsquo;s best to use the existing implementations as a guideline.</p>
<div class="nav-next">
<p><strong>Next:</strong> <a href="../../../scala/http/routing-dsl/testkit.html">Route TestKit</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html#source-streaming">Source Streaming</a>
  <ul>
    <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html#json-streaming">JSON Streaming</a>
    <ul>
      <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html#responding-with-json-streams">Responding with JSON Streams</a></li>
      <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html#consuming-json-streaming-uploads">Consuming JSON Streaming uploads</a></li>
      <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html#simple-csv-streaming-example">Simple CSV streaming example</a></li>
      <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html#implementing-custom-entitystreamingsupport-traits">Implementing custom EntityStreamingSupport traits</a></li>
    </ul></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2016</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../../../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../../js/magellan.js"></script>

<style type="text/css">@import "../../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

</html>
