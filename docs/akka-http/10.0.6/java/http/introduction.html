<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
  <title>Introduction · Akka HTTP</title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content='akka-http-docs'/>
  <link
      href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc"
      rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="../../lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="../../js/page.js"></script>
  <link rel="stylesheet" type="text/css" href="../../lib/normalize.css/normalize.css"/>
  <link rel="stylesheet" type="text/css" href="../../lib/foundation/dist/foundation.min.css"/>
  <link rel="stylesheet" type="text/css" href="../../css/page.css"/>


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"/>
</head>

<body>
<div class="off-canvas-wrapper">
  <div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

    <div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
      <nav class="off-canvas-nav">
        <div class="nav-home">
        <a href="../../index.html" >
        <span class="home-icon">⌂</span>Akka HTTP
        </a>
        <div class="version-number">
        10.0.6
        </div>
        </div>
        <div class="nav-toc">
        <ul>
          <li><a href="../../security.html">Security announcements</a></li>
          <li><a href="../../release-notes.html">Release Notes</a></li>
          <li><a href="../../java.html">Java Documentation</a>
          <ul>
            <li><a href="../../java/http/index.html">Akka HTTP</a>
            <ul>
              <li><a href="../../java/http/introduction.html" class="active">Introduction</a></li>
              <li><a href="../../java/http/configuration.html">Configuration</a></li>
              <li><a href="../../java/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
              <li><a href="../../java/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
              <li><a href="../../java/http/server-side/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
              <li><a href="../../java/http/routing-dsl/index.html">High-level Server-Side API</a></li>
              <li><a href="../../java/http/server-side/websocket-support.html">Server-Side WebSocket Support</a></li>
              <li><a href="../../java/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
              <li><a href="../../java/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
              <li><a href="../../java/http/migration-guide/index.html">Migration Guides (Java)</a></li>
            </ul></li>
          </ul></li>
          <li><a href="../../scala.html">Scala Documentation</a>
          <ul>
            <li><a href="../../scala/http/index.html">Akka HTTP</a>
            <ul>
              <li><a href="../../scala/http/introduction.html">Introduction</a></li>
              <li><a href="../../scala/http/configuration.html">Configuration</a></li>
              <li><a href="../../scala/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
              <li><a href="../../scala/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
              <li><a href="../../scala/http/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
              <li><a href="../../scala/http/routing-dsl/index.html">High-level Server-Side API</a></li>
              <li><a href="../../scala/http/websocket-support.html">Server-Side WebSocket Support</a></li>
              <li><a href="../../scala/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
              <li><a href="../../scala/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
              <li><a href="../../scala/http/handling-blocking-operations-in-akka-http-routes.html">Handling blocking operations in Akka HTTP</a></li>
              <li><a href="../../scala/http/migration-guide/index.html">Migration Guides</a></li>
            </ul></li>
          </ul></li>
        </ul>
        </div>

      </nav>
    </div>

    <div class="off-canvas-content" data-off-canvas-content>

      <header class="site-header expanded row">
        <div class="small-12 column">
          <a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>

          <img src="../../css/../mini-akka-logo.png" alt="Akka logo" style="float: left"/> <div class="title"><a href="../../index.html">Akka HTTP</a></div>


          <div style="position: relative; right:0; min-width:25%" class="float-right">
            <input type="search" id="search" class="form-control" style="margin: 10px 0;" placeholder="Search the docs..."/>
          </div>

        </div>
      </header>

      <div class="expanded row">

        <div class="medium-3 large-2 show-for-medium column">

          <nav class="site-nav">
            <div class="nav-home">
            <a href="../../index.html" >
            <span class="home-icon">⌂</span>Akka HTTP
            </a>
            <div class="version-number">
            10.0.6
            </div>
            </div>
            <div class="nav-toc">
            <ul>
              <li><a href="../../security.html">Security announcements</a></li>
              <li><a href="../../release-notes.html">Release Notes</a></li>
              <li><a href="../../java.html">Java Documentation</a>
              <ul>
                <li><a href="../../java/http/index.html">Akka HTTP</a>
                <ul>
                  <li><a href="../../java/http/introduction.html" class="active">Introduction</a></li>
                  <li><a href="../../java/http/configuration.html">Configuration</a></li>
                  <li><a href="../../java/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
                  <li><a href="../../java/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
                  <li><a href="../../java/http/server-side/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
                  <li><a href="../../java/http/routing-dsl/index.html">High-level Server-Side API</a></li>
                  <li><a href="../../java/http/server-side/websocket-support.html">Server-Side WebSocket Support</a></li>
                  <li><a href="../../java/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
                  <li><a href="../../java/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
                  <li><a href="../../java/http/migration-guide/index.html">Migration Guides (Java)</a></li>
                </ul></li>
              </ul></li>
              <li><a href="../../scala.html">Scala Documentation</a>
              <ul>
                <li><a href="../../scala/http/index.html">Akka HTTP</a>
                <ul>
                  <li><a href="../../scala/http/introduction.html">Introduction</a></li>
                  <li><a href="../../scala/http/configuration.html">Configuration</a></li>
                  <li><a href="../../scala/http/common/index.html">Common Abstractions (Client- and Server-Side)</a></li>
                  <li><a href="../../scala/http/implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a></li>
                  <li><a href="../../scala/http/low-level-server-side-api.html">Low-Level Server-Side API</a></li>
                  <li><a href="../../scala/http/routing-dsl/index.html">High-level Server-Side API</a></li>
                  <li><a href="../../scala/http/websocket-support.html">Server-Side WebSocket Support</a></li>
                  <li><a href="../../scala/http/client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></li>
                  <li><a href="../../scala/http/server-side-https-support.html">Server-Side HTTPS Support</a></li>
                  <li><a href="../../scala/http/handling-blocking-operations-in-akka-http-routes.html">Handling blocking operations in Akka HTTP</a></li>
                  <li><a href="../../scala/http/migration-guide/index.html">Migration Guides</a></li>
                </ul></li>
              </ul></li>
            </ul>
            </div>

          </nav>
        </div>

        <div class="small-12 medium-9 large-10 column">
          <section class="site-content">

            <div class="page-header row">
              <div class="medium-12 show-for-medium column">
                <div class="nav-breadcrumbs">
                  <ul>
                    <li><a href="../../index.html">Akka HTTP</a></li>
                    <li><a href="../../java.html">Java Documentation</a></li>
                    <li><a href="../../java/http/index.html">Akka HTTP</a></li>
                    <li>Introduction</li>
                  </ul>
                </div>
              </div>
            </div>

            <div class="page-content row">
              <div class="small-12 large-9 column" id="docs">

<h1><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h1>
<p>The Akka HTTP modules implement a full server- and client-side HTTP stack on top of <em>akka-actor</em> and <em>akka-stream</em>. It&rsquo;s not a web-framework but rather a more general toolkit for providing and consuming HTTP-based services. While interaction with a browser is of course also in scope it is not the primary focus of Akka HTTP.</p>
<p>Akka HTTP follows a rather open design and many times offers several different API levels for &ldquo;doing the same thing&rdquo;. You get to pick the API level of abstraction that is most suitable for your application. This means that, if you have trouble achieving something using a high-level API, there&rsquo;s a good chance that you can get it done with a low-level API, which offers more flexibility but might require you to write more application code.</p>
<h2><a href="#philosophy" name="philosophy" class="anchor"><span class="anchor-link"></span></a>Philosophy</h2>
<p>Akka HTTP has been driven with a clear focus on providing tools for building integration layers rather than application cores. As such it regards itself as a suite of libraries rather than a framework.</p>
<p>A framework, as we’d like to think of the term, gives you a “frame”, in which you build your application. It comes with a lot of decisions already pre-made and provides a foundation including support structures that lets you get started and deliver results quickly. In a way a framework is like a skeleton onto which you put the “flesh” of your application in order to have it come alive. As such frameworks work best if you choose them before you start application development and try to stick to the frameworks “way of doing things” as you go along.</p>
<p>For example, if you are building a browser-facing web application it makes sense to choose a web framework and build your application on top of it because the “core” of the application is the interaction of a browser with your code on the web-server. The framework makers have chosen one “proven” way of designing such applications and let you “fill in the blanks” of a more or less flexible “application-template”. Being able to rely on best-practice architecture like this can be a great asset for getting things done quickly.</p>
<p>However, if your application is not primarily a web application because its core is not browser-interaction but some specialized maybe complex business service and you are merely trying to connect it to the world via a REST/HTTP interface a web-framework might not be what you need. In this case the application architecture should be dictated by what makes sense for the core not the interface layer. Also, you probably won’t benefit from the possibly existing browser-specific framework components like view templating, asset management, JavaScript- and CSS generation/manipulation/minification, localization support, AJAX support, etc.</p>
<p>Akka HTTP was designed specifically as “not-a-framework”, not because we don’t like frameworks, but for use cases where a framework is not the right choice. Akka HTTP is made for building integration layers based on HTTP and as such tries to “stay on the sidelines”. Therefore you normally don’t build your application “on top of” Akka HTTP, but you build your application on top of whatever makes sense and use Akka HTTP merely for the HTTP integration needs.</p>
<p>On the other hand, if you prefer to build your applications with the guidance of a framework, you should give Play Framework or Lagom a try, which both use Akka internally.</p>
<h2><a href="#using-akka-http" name="using-akka-http" class="anchor"><span class="anchor-link"></span></a>Using Akka HTTP</h2>
<p>Akka HTTP is provided in a separate jar file, to use it make sure to include the following dependency:</p>
<pre class="prettyprint"><code class="language-sbt">&quot;com.typesafe.akka&quot; %% &quot;akka-http&quot; % &quot;10.0.6&quot; 
</code></pre>
<p>Dependency declarations for other build tools (like Gradle or Maven) can be found <a href="https://akka.io/docs/#akka-http">here</a>.</p>
<p>Mind that <code>akka-http</code> comes in two modules: <code>akka-http</code> and <code>akka-http-core</code>. Because <code>akka-http</code> depends on <code>akka-http-core</code> you don&rsquo;t need to bring the latter explicitly. Still you may need to this in case you rely solely on low-level API.</p>
<h2><a href="#routing-dsl-for-http-servers" name="routing-dsl-for-http-servers" class="anchor"><span class="anchor-link"></span></a>Routing DSL for HTTP servers</h2>
<p>The high-level, routing API of Akka HTTP provides a DSL to describe HTTP &ldquo;routes&rdquo; and how they should be handled. Each route is composed of one or more level of <code>Directive</code> s that narrows down to handling one specific type of request.</p>
<p>For example one route might start with matching the <code>path</code> of the request, only matching if it is &ldquo;/hello&rdquo;, then narrowing it down to only handle HTTP <code>get</code> requests and then <code>complete</code> those with a string literal, which will be sent back as a HTTP OK with the string as response body.</p>
<p>Transforming request and response bodies between over-the-wire formats and objects to be used in your application is done separately from the route declarations, in marshallers, which are pulled in implicitly using the &ldquo;magnet&rdquo; pattern. This means that you can <code>complete</code> a request with any kind of object a as long as there is an implicit marshaller available in scope.</p>
<p>JSON support is possible in <code>akka-http</code> by the use of Jackson, an external artifact (see <a href="common/json-support.html#json-support-via-jackson">JSON Support</a> for details).</p>
<p>The <code>Route</code> created using the Route DSL is then &ldquo;bound&rdquo; to a port to start serving HTTP requests:</p>
<pre class="prettyprint"><code class="language-java">import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.http.javadsl.ConnectHttp;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.model.HttpRequest;
import akka.http.javadsl.model.HttpResponse;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Flow;

import java.util.concurrent.CompletionStage;

public class HttpServerMinimalExampleTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem system = ActorSystem.create(&quot;routes&quot;);

    final Http http = Http.get(system);
    final ActorMaterializer materializer = ActorMaterializer.create(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerMinimalExampleTest app = new HttpServerMinimalExampleTest();

    final Flow&lt;HttpRequest, HttpResponse, NotUsed&gt; routeFlow = app.createRoute().flow(system, materializer);
    final CompletionStage&lt;ServerBinding&gt; binding = http.bindAndHandle(routeFlow,
        ConnectHttp.toHost(&quot;localhost&quot;, 8080), materializer);

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  private Route createRoute() {
    return route(
        path(&quot;hello&quot;, () -&gt;
            get(() -&gt;
                complete(&quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))));
  }
}</code></pre>
<p>A common use case is to reply to a request using a model object having the marshaller transform it into JSON. In this case shown by two separate routes. The first route queries an asynchronous database and marshalls the <code>CompletionStage&lt;Optional&lt;Item&gt;&gt;</code> result into a JSON response. The second unmarshalls an <code>Order</code> from the incoming request saves it to the database and replies with an OK when done.</p>
<pre class="prettyprint"><code class="language-java">import akka.Done;
import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.http.javadsl.ConnectHttp;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.marshallers.jackson.Jackson;
import akka.http.javadsl.model.HttpRequest;
import akka.http.javadsl.model.HttpResponse;
import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Flow;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import static akka.http.javadsl.server.PathMatchers.longSegment;

public class JacksonExampleTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem system = ActorSystem.create(&quot;routes&quot;);

    final Http http = Http.get(system);
    final ActorMaterializer materializer = ActorMaterializer.create(system);

    //In order to access all directives we need an instance where the routes are define.
    JacksonExampleTest app = new JacksonExampleTest();

    final Flow&lt;HttpRequest, HttpResponse, NotUsed&gt; routeFlow = app.createRoute().flow(system, materializer);
    final CompletionStage&lt;ServerBinding&gt; binding = http.bindAndHandle(routeFlow,
      ConnectHttp.toHost(&quot;localhost&quot;, 8080), materializer);

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
      .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
      .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  // (fake) async database query api
  private CompletionStage&lt;Optional&lt;Item&gt;&gt; fetchItem(long itemId) {
    return CompletableFuture.completedFuture(Optional.of(new Item(&quot;foo&quot;, itemId)));
  }

  // (fake) async database query api
  private CompletionStage&lt;Done&gt; saveOrder(final Order order) {
    return CompletableFuture.completedFuture(Done.getInstance());
  }

  private Route createRoute() {

    return route(
      get(() -&gt;
        pathPrefix(&quot;item&quot;, () -&gt;
          path(longSegment(), (Long id) -&gt; {
            final CompletionStage&lt;Optional&lt;Item&gt;&gt; futureMaybeItem = fetchItem(id);
            return onSuccess(() -&gt; futureMaybeItem, maybeItem -&gt;
              maybeItem.map(item -&gt; completeOK(item, Jackson.marshaller()))
                .orElseGet(() -&gt; complete(StatusCodes.NOT_FOUND, &quot;Not Found&quot;))
            );
          }))),
      post(() -&gt;
        path(&quot;create-order&quot;, () -&gt;
          entity(Jackson.unmarshaller(Order.class), order -&gt; {
            CompletionStage&lt;Done&gt; futureSaved = saveOrder(order);
            return onSuccess(() -&gt; futureSaved, done -&gt;
              complete(&quot;order created&quot;)
            );
          })))
    );
  }

  private static class Item {

    final String name;
    final long id;

    @JsonCreator
    Item(@JsonProperty(&quot;name&quot;) String name,
         @JsonProperty(&quot;id&quot;) long id) {
      this.name = name;
      this.id = id;
    }

    public String getName() {
      return name;
    }

    public long getId() {
      return id;
    }
  }

  private static class Order {

    final List&lt;Item&gt; items;

    @JsonCreator
    Order(@JsonProperty(&quot;items&quot;) List&lt;Item&gt; items) {
      this.items = items;
    }

    public List&lt;Item&gt; getItems() {
      return items;
    }
  }
}</code></pre>
<p>The logic for the marshalling and unmarshalling JSON in this example is provided by the &ldquo;Jackson&rdquo; library (details on how to use that here: <a href="common/json-support.html#json-support-via-jackson">JSON Support</a>).</p>
<p>One of the strengths of Akka HTTP is that streaming data is at its heart meaning that both request and response bodies can be streamed through the server achieving constant memory usage even for very large requests or responses. Streaming responses will be backpressured by the remote client so that the server will not push data faster than the client can handle, streaming requests means that the server decides how fast the remote client can push the data of the request body.</p>
<p>Example that streams random numbers as long as the client accepts them:</p>
<pre class="prettyprint"><code class="language-java">import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.http.javadsl.ConnectHttp;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.model.*;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Flow;
import akka.stream.javadsl.Source;
import akka.util.ByteString;

import java.util.Random;
import java.util.concurrent.CompletionStage;
import java.util.stream.Stream;

public class HttpServerStreamRandomNumbersTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem system = ActorSystem.create(&quot;routes&quot;);

    final Http http = Http.get(system);
    final ActorMaterializer materializer = ActorMaterializer.create(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerStreamRandomNumbersTest app = new HttpServerStreamRandomNumbersTest();

    final Flow&lt;HttpRequest, HttpResponse, NotUsed&gt; routeFlow = app.createRoute().flow(system, materializer);
    final CompletionStage&lt;ServerBinding&gt; binding = http.bindAndHandle(routeFlow,
        ConnectHttp.toHost(&quot;localhost&quot;, 8080), materializer);

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }


  private Route createRoute() {
    final Random rnd = new Random();
    // streams are re-usable so we can define it here
    // and use it for every request
    Source&lt;Integer, NotUsed&gt; numbers = Source.fromIterator(() -&gt; Stream.generate(rnd::nextInt).iterator());

    return route(
        path(&quot;random&quot;, () -&gt;
            get(() -&gt;
                complete(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,
                    // transform each number to a chunk of bytes
                    numbers.map(x -&gt; ByteString.fromString(x + &quot;\n&quot;)))))));
  }
}</code></pre>
<p>Connecting to this service with a slow HTTP client would backpressure so that the next random number is produced on demand with constant memory usage on the server. This can be seen using curl and limiting the rate <code>curl --limit-rate 50b 127.0.0.1:8080/random</code></p>
<p>Akka HTTP routes easily interacts with actors. In this example one route allows for placing bids in a fire-and-forget style while the second route contains a request-response interaction with an actor. The resulting response is rendered as json and returned when the response arrives from the actor.</p>
<pre class="prettyprint"><code class="language-java">import akka.NotUsed;
import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import akka.actor.AbstractActor;
import akka.event.Logging;
import akka.event.LoggingAdapter;
import akka.http.javadsl.ConnectHttp;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.marshallers.jackson.Jackson;
import akka.http.javadsl.model.HttpRequest;
import akka.http.javadsl.model.HttpResponse;
import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import akka.http.javadsl.unmarshalling.StringUnmarshallers;
import akka.japi.pf.ReceiveBuilder;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Flow;
import akka.util.Timeout;
import scala.concurrent.duration.FiniteDuration;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.TimeUnit;

import static akka.pattern.PatternsCS.ask;


public class HttpServerActorInteractionExample extends AllDirectives {

  private final ActorRef auction;

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem system = ActorSystem.create(&quot;routes&quot;);

    final Http http = Http.get(system);
    final ActorMaterializer materializer = ActorMaterializer.create(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerActorInteractionExample app = new HttpServerActorInteractionExample(system);

    final Flow&lt;HttpRequest, HttpResponse, NotUsed&gt; routeFlow = app.createRoute().flow(system, materializer);
    final CompletionStage&lt;ServerBinding&gt; binding = http.bindAndHandle(routeFlow,
      ConnectHttp.toHost(&quot;localhost&quot;, 8080), materializer);

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
      .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
      .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  private HttpServerActorInteractionExample(final ActorSystem system) {
    auction = system.actorOf(Auction.props(), &quot;auction&quot;);
  }

  private Route createRoute() {
    return route(
      path(&quot;auction&quot;, () -&gt; route(
        put(() -&gt;
          parameter(StringUnmarshallers.INTEGER, &quot;bid&quot;, bid -&gt;
            parameter(&quot;user&quot;, user -&gt; {
              // place a bid, fire-and-forget
              auction.tell(new Bid(user, bid), ActorRef.noSender());
              return complete(StatusCodes.ACCEPTED, &quot;bid placed&quot;);
            })
          )),
        get(() -&gt; {
          final Timeout timeout = Timeout.durationToTimeout(FiniteDuration.apply(5, TimeUnit.SECONDS));
          // query the actor for the current auction state
          CompletionStage&lt;Bids&gt; bids = ask(auction, new GetBids(), timeout).thenApply((Bids.class::cast));
          return completeOKWithFuture(bids, Jackson.marshaller());
        }))));
  }

  static class Bid {
    final String userId;
    final int offer;

    Bid(String userId, int offer) {
      this.userId = userId;
      this.offer = offer;
    }
  }

  static class GetBids {

  }

  static class Bids {
    public final List&lt;Bid&gt; bids;

    Bids(List&lt;Bid&gt; bids) {
      this.bids = bids;
    }
  }

  // compiles only against Akka 2.4, see migration guide for how to rewrite for Akka 2.5
  static class Auction extends AbstractActor {

    private final LoggingAdapter log = Logging.getLogger(context().system(), this);

    List&lt;HttpServerActorInteractionExample.Bid&gt; bids = new ArrayList&lt;&gt;();

    static Props props() {
      return Props.create(Auction.class);
    }

    public Auction() {
      receive(ReceiveBuilder.
        match(HttpServerActorInteractionExample.Bid.class, bid -&gt; {
          bids.add(bid);
          log.info(&quot;Bid complete: {}, {}&quot;, bid.userId, bid.offer);
        }).
        match(HttpServerActorInteractionExample.GetBids.class, m -&gt; {
          sender().tell(new HttpServerActorInteractionExample.Bids(bids), self());
        }).
        matchAny(o -&gt; log.info(&quot;Invalid message&quot;)).
        build()
      );
    }
  }
}</code></pre>
<p>Again the logic for the marshalling and unmarshalling JSON in this example is provided by the &ldquo;Jackson&rdquo; library (details on how to use that here: <a href="common/json-support.html#json-support-via-jackson">JSON Support</a>)</p>
<p>Read more about the details of the high level APIs in the section <a href="routing-dsl/index.html#http-high-level-server-side-api">High-level Server-Side API</a>.</p>
<h2><a href="#low-level-http-server-apis" name="low-level-http-server-apis" class="anchor"><span class="anchor-link"></span></a>Low-level HTTP server APIs</h2>
<p>The low-level Akka HTTP server APIs allows for handling connections or individual requests by accepting <code>HttpRequest</code> s and answering them by producing <code>HttpResponse</code> s. This is provided by the <code>akka-http-core</code> module. APIs for handling such request-responses as function calls and as a <code>Flow&lt;HttpRequest, HttpResponse, NotUsed&gt;</code> are available.</p>
<pre class="prettyprint"><code class="language-java">import akka.actor.ActorSystem;
import akka.http.javadsl.ConnectHttp;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.model.ContentTypes;
import akka.http.javadsl.model.HttpResponse;
import akka.http.javadsl.model.StatusCodes;
import akka.stream.ActorMaterializer;
import akka.stream.Materializer;
import akka.util.ByteString;

import java.util.concurrent.CompletionStage;

public class HttpServerLowLevelExample {

  public static void main(String[] args) throws Exception {
    ActorSystem system = ActorSystem.create();

    try {
      final Materializer materializer = ActorMaterializer.create(system);
      CompletionStage&lt;ServerBinding&gt; serverBindingFuture =
        Http.get(system).bindAndHandleSync(
          request -&gt; {
            if (request.getUri().path().equals(&quot;/&quot;))
              return HttpResponse.create().withEntity(ContentTypes.TEXT_HTML_UTF8,
                ByteString.fromString(&quot;&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;&quot;));
            else if (request.getUri().path().equals(&quot;/ping&quot;))
              return HttpResponse.create().withEntity(ByteString.fromString(&quot;PONG!&quot;));
            else if (request.getUri().path().equals(&quot;/crash&quot;))
              throw new RuntimeException(&quot;BOOM!&quot;);
            else {
              request.discardEntityBytes(materializer);
              return HttpResponse.create().withStatus(StatusCodes.NOT_FOUND).withEntity(&quot;Unknown resource!&quot;);
            }
          }, ConnectHttp.toHost(&quot;localhost&quot;, 8080), materializer);

      System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
      System.in.read(); // let it run until user presses return

      serverBindingFuture
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done

    } catch (RuntimeException e) {
      system.terminate();
    }
  }
}</code></pre>
<p>Read more details about the low level APIs in the section <a href="server-side/low-level-server-side-api.html#http-low-level-server-side-api">Low-Level Server-Side API</a>.</p>
<h2><a href="#http-client-api" name="http-client-api" class="anchor"><span class="anchor-link"></span></a>HTTP client API</h2>
<p>The client APIs provide methods for calling a HTTP server using the same <code>HttpRequest</code> and <code>HttpResponse</code> abstractions that Akka HTTP server uses but adds the concept of connection pools to allow multiple requests to the same server to be handled more performantly by re-using TCP connections to the server.</p>
<p>Example simple request:</p>
<pre class="prettyprint"><code class="language-java">import akka.actor.ActorSystem;
import akka.http.javadsl.Http;
import akka.http.javadsl.model.HttpRequest;
import akka.http.javadsl.model.HttpResponse;
import akka.stream.ActorMaterializer;
import akka.stream.Materializer;

import java.util.concurrent.CompletionStage;

public class ClientSingleRequestExample {

  public static void main(String[] args) {
    final ActorSystem system = ActorSystem.create();
    final Materializer materializer = ActorMaterializer.create(system);

    final CompletionStage&lt;HttpResponse&gt; responseFuture =
      Http.get(system)
        .singleRequest(HttpRequest.create(&quot;https://akka.io&quot;), materializer);
  }
}</code></pre>
<p>Read more about the details of the client APIs in the section <a href="client-side/index.html#http-client-side">Consuming HTTP-based Services (Client-Side)</a>.</p>
<h2><a href="#the-modules-that-make-up-akka-http" name="the-modules-that-make-up-akka-http" class="anchor"><span class="anchor-link"></span></a>The modules that make up Akka HTTP</h2>
<p>Akka HTTP is structured into several modules:</p>
<dl>
  <dt>akka-http
  </dt>
  <dd>Higher-level functionality, like (un)marshalling, (de)compression as well as a powerful DSL for defining HTTP-based APIs on the server-side, this is the recommended way to write HTTP servers with Akka HTTP. Details can be found in the section <a href="routing-dsl/index.html#http-high-level-server-side-api">High-level Server-Side API</a></dd>
  <dt>akka-http-core
  </dt>
  <dd>A complete, mostly low-level, server- and client-side implementation of HTTP (incl. WebSockets) Details can be found in sections <a href="server-side/low-level-server-side-api.html#http-low-level-server-side-api">Low-Level Server-Side API</a> and <a href="client-side/index.html#http-client-side">Consuming HTTP-based Services (Client-Side)</a></dd>
  <dt>akka-http-testkit
  </dt>
  <dd>A test harness and set of utilities for verifying server-side service implementations</dd>
  <dt>akka-http-jackson
  </dt>
  <dd>Predefined glue-code for (de)serializing custom types from/to JSON with <a href="https://github.com/FasterXML/jackson">jackson</a></dd>
</dl>

                <div>
                  <div class="source-github">
                  The source code for this page can be found <a href="http://github.com/akka/akka-http/tree/master/docs/src/main/paradox/java/http/introduction.md">here</a>.
                  </div>

                </div>

                <div class="nav-next">
                  <p><strong>Next:</strong> <a href="../../java/http/configuration.html">Configuration</a></p>
                </div>
              </div>
              <div class="large-3 show-for-large column" data-sticky-container>
                <nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
                  <div class="page-nav">
                    <div class="nav-title">On this page:</div>
                    <div class="nav-toc">
                      <ul>
                        <li><a href="../../java/http/introduction.html#introduction">Introduction</a>
                        <ul>
                          <li><a href="../../java/http/introduction.html#philosophy">Philosophy</a></li>
                          <li><a href="../../java/http/introduction.html#using-akka-http">Using Akka HTTP</a></li>
                          <li><a href="../../java/http/introduction.html#routing-dsl-for-http-servers">Routing DSL for HTTP servers</a></li>
                          <li><a href="../../java/http/introduction.html#low-level-http-server-apis">Low-level HTTP server APIs</a></li>
                          <li><a href="../../java/http/introduction.html#http-client-api">HTTP client API</a></li>
                          <li><a href="../../java/http/introduction.html#the-modules-that-make-up-akka-http">The modules that make up Akka HTTP</a></li>
                        </ul></li>
                      </ul>
                    </div>
                  </div>
                </nav>
              </div>
            </div>

          </section>
        </div>

      </div>

      <footer class="site-footer">

        <section class="site-footer-base">
          <div class="expanded row">
            <div class="small-12 large-12 column">
              <div class="row site-footer-content clearfix">
                <div class="float-right">
		  Last updated: May 03, 2017
		</div>
                <div class="float-left">
		  &copy; 2017 <a href="https://www.lightbend.com/">Lightbend Inc.</a>
		  <span class="license">Akka HTTP is Open Source and available under the Apache 2 License.</span>
                </div>
              </div>
            </div>
          </div>
        </section>
      </footer>

    </div>
  </div>
</div>

<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
  var version = '10.0.6'; // replaced by paradox

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) {
    lang = "java";
  }

  docsearch({
    apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
    indexName: 'akka-http',
    inputSelector: '#search',
    algoliaOptions: {'facetFilters': ["version:" + version, "language:" + lang]},
    debug: false // Set debug to true if you want to inspect the dropdown
  });
</script>
</body>

<script type="text/javascript" src="../../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../js/magellan.js"></script>

<style type="text/css">@import "../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function () {
  window.prettyPrint && prettyPrint()
});</script>

</html>
