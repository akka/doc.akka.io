<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Rejections &bull; Akka HTTP</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka HTTP: Modern, fast, asynchronous, streaming-first HTTP server and client."/><link rel="canonical" href="https://doc.akka.io/docs/akka-http/10.0/scala/http/routing-dsl/rejections.html"/>
<script type="text/javascript" src="../../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>
<link rel="shortcut icon" href="../../../images/favicon.ico" />
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../../scala/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../../scala/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../scala/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../scala/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../scala/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../scala/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../scala/http/low-level-server-side-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html" class="page">High-level Server-Side API</a>
  <ul>
    <li><a href="../../../scala/http/routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#longer-example" class="header">Longer Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
    <li><a href="../../../scala/http/routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
    <li><a href="../../../scala/http/routing-dsl/routes.html" class="page">Routes</a></li>
    <li><a href="../../../scala/http/routing-dsl/directives/index.html" class="page">Directives</a></li>
    <li><a href="../../../scala/http/routing-dsl/rejections.html#rejections" class="active page">Rejections</a>
    <ul>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#predefined-rejections" class="header">Predefined Rejections</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#the-rejectionhandler" class="header">The RejectionHandler</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#rejection-cancellation" class="header">Rejection Cancellation</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#empty-rejections" class="header">Empty Rejections</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#customizing-rejection-handling" class="header">Customizing Rejection Handling</a></li>
    </ul></li>
    <li><a href="../../../scala/http/routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
    <li><a href="../../../scala/http/routing-dsl/case-class-extraction.html" class="page">Case Class Extraction</a></li>
    <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
    <li><a href="../../../scala/http/routing-dsl/testkit.html" class="page">Route TestKit</a></li>
    <li><a href="../../../scala/http/routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
  </ul></li>
  <li><a href="../../../scala/http/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../scala/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a></li>
  <li><a href="../../../scala/http/server-side-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
  <li><a href="../../../scala/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../scala/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../../scala/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../../scala/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../scala/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../scala/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../scala/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../scala/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../scala/http/low-level-server-side-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html" class="page">High-level Server-Side API</a>
  <ul>
    <li><a href="../../../scala/http/routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#longer-example" class="header">Longer Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
    <li><a href="../../../scala/http/routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
    <li><a href="../../../scala/http/routing-dsl/routes.html" class="page">Routes</a></li>
    <li><a href="../../../scala/http/routing-dsl/directives/index.html" class="page">Directives</a></li>
    <li><a href="../../../scala/http/routing-dsl/rejections.html#rejections" class="active page">Rejections</a>
    <ul>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#predefined-rejections" class="header">Predefined Rejections</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#the-rejectionhandler" class="header">The RejectionHandler</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#rejection-cancellation" class="header">Rejection Cancellation</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#empty-rejections" class="header">Empty Rejections</a></li>
      <li><a href="../../../scala/http/routing-dsl/rejections.html#customizing-rejection-handling" class="header">Customizing Rejection Handling</a></li>
    </ul></li>
    <li><a href="../../../scala/http/routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
    <li><a href="../../../scala/http/routing-dsl/case-class-extraction.html" class="page">Case Class Extraction</a></li>
    <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
    <li><a href="../../../scala/http/routing-dsl/testkit.html" class="page">Route TestKit</a></li>
    <li><a href="../../../scala/http/routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
  </ul></li>
  <li><a href="../../../scala/http/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../scala/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a></li>
  <li><a href="../../../scala/http/server-side-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
  <li><a href="../../../scala/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../scala/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<a id="rejections-scala"></a>
<h1><a href="#rejections" name="rejections" class="anchor"><span class="anchor-link"></span></a>Rejections</h1>
<p>In the chapter about constructing <a href="routes.html#routes">Routes</a> the <code>~</code> operator was introduced, which connects two routes in a way that allows a second route to get a go at a request if the first route &ldquo;rejected&rdquo; it. The concept of &ldquo;rejections&rdquo; is used by Akka HTTP for maintaining a more functional overall architecture and in order to be able to properly handle all kinds of error scenarios.</p>
<p>When a filtering directive, like the <a href="directives/method-directives/get.html#get">get</a> directive, cannot let the request pass through to its inner route because the filter condition is not satisfied (e.g. because the incoming request is not a GET request) the directive doesn&rsquo;t immediately complete the request with an error response. Doing so would make it impossible for other routes chained in after the failing filter to get a chance to handle the request. Rather, failing filters &ldquo;reject&rdquo; the request in the same way as by explicitly calling <code>requestContext.reject(...)</code>.</p>
<p>After having been rejected by a route the request will continue to flow through the routing structure and possibly find another route that can complete it. If there are more rejections all of them will be picked up and collected.</p>
<p>If the request cannot be completed by (a branch of) the route structure an enclosing <a href="directives/execution-directives/handleRejections.html#handlerejections">handleRejections</a> directive can be used to convert a set of rejections into an <code>HttpResponse</code> (which, in most cases, will be an error response). <code>Route.seal</code> internally wraps its argument route with the <a href="directives/execution-directives/handleRejections.html#handlerejections">handleRejections</a> directive in order to &ldquo;catch&rdquo; and handle any rejection.</p>
<h2><a href="#predefined-rejections" name="predefined-rejections" class="anchor"><span class="anchor-link"></span></a>Predefined Rejections</h2>
<p>A rejection encapsulates a specific reason why a route was not able to handle a request. It is modeled as an object of type <code>Rejection</code>. Akka HTTP comes with a set of <a href="https://doc.akka.io/api/akka-http/10.0.9/akka/http/scaladsl/server/Rejection.html">predefined rejections</a>, which are used by the many <a href="directives/alphabetically.html#predefined-directives">predefined directives</a>.</p>
<p>Rejections are gathered up over the course of a Route evaluation and finally converted to <code>HttpResponse</code> replies by the <a href="directives/execution-directives/handleRejections.html#handlerejections">handleRejections</a> directive if there was no way for the request to be completed.</p>
<a id="the-rejectionhandler"></a>
<h2><a href="#the-rejectionhandler" name="the-rejectionhandler" class="anchor"><span class="anchor-link"></span></a>The RejectionHandler</h2>
<p>The <a href="directives/execution-directives/handleRejections.html#handlerejections">handleRejections</a> directive delegates the actual job of converting a list of rejections to its argument, a <a href="https://doc.akka.io/api/akka-http/10.0.9/akka/http/scaladsl/server/RejectionHandler.html">RejectionHandler</a>, which is defined like this:</p>
<pre class="prettyprint"><code class="language-scala">trait RejectionHandler extends (immutable.Seq[Rejection] =&gt; Option[Route])
</code></pre>
<p>Since a <code>RejectionHandler</code> returns an <code>Option[Route]</code> it can choose whether it would like to handle the current set of rejections or not. If it returns <code>None</code> the rejections will simply continue to flow through the route structure.</p>
<p>The default <code>RejectionHandler</code> applied by the top-level glue code that turns a <code>Route</code> into a <code>Flow</code> or async handler function for the <a href="../low-level-server-side-api.html#http-low-level-server-side-api">low-level API</a> (via <code>Route.handlerFlow</code> or <code>Route.asyncHandler</code>) will handle <em>all</em> rejections that reach it.</p>
<h2><a href="#rejection-cancellation" name="rejection-cancellation" class="anchor"><span class="anchor-link"></span></a>Rejection Cancellation</h2>
<p>As you can see from its definition above the <code>RejectionHandler</code> doesn&rsquo;t handle single rejections but a whole list of them. This is because some route structure produce several &ldquo;reasons&rdquo; why a request could not be handled.</p>
<p>Take this route structure for example:</p>
<pre class="prettyprint"><code class="language-scala">import akka.http.scaladsl.coding.Gzip

val route =
  path(&quot;order&quot;) {
    get {
      complete(&quot;Received GET&quot;)
    } ~
    post {
      decodeRequestWith(Gzip) {
        complete(&quot;Received compressed POST&quot;)
      }
    }
  }</code></pre>
<p>For uncompressed POST requests this route structure would initially yield two rejections:</p>
<ul>
  <li>a <code>MethodRejection</code> produced by the <a href="directives/method-directives/get.html#get">get</a> directive (which rejected because the request is not a GET request)</li>
  <li>an <code>UnsupportedRequestEncodingRejection</code> produced by the <a href="directives/coding-directives/decodeRequestWith.html#decoderequestwith">decodeRequestWith</a> directive (which only accepts gzip-compressed requests here)</li>
</ul>
<p>In reality the route even generates one more rejection, a <code>TransformationRejection</code> produced by the <a href="directives/method-directives/post.html#post">post</a> directive. It &ldquo;cancels&rdquo; all other potentially existing <em>MethodRejections</em>, since they are invalid after the <a href="directives/method-directives/post.html#post">post</a> directive allowed the request to pass (after all, the route structure <em>can</em> deal with POST requests). These types of rejection cancellations are resolved <em>before</em> a <code>RejectionHandler</code> sees the rejection list. So, for the example above the <code>RejectionHandler</code> will be presented with only a single-element rejection list, containing nothing but the <code>UnsupportedRequestEncodingRejection</code>.</p>
<a id="empty-rejections"></a>
<h2><a href="#empty-rejections" name="empty-rejections" class="anchor"><span class="anchor-link"></span></a>Empty Rejections</h2>
<p>Since rejections are passed around in a list (or rather immutable <code>Seq</code>) you might ask yourself what the semantics of an empty rejection list are. In fact, empty rejection lists have well defined semantics. They signal that a request was not handled because the respective resource could not be found. Akka HTTP reserves the special status of &ldquo;empty rejection&rdquo; to this most common failure a service is likely to produce.</p>
<p>So, for example, if the <a href="directives/path-directives/path.html#path">path</a> directive rejects a request it does so with an empty rejection list. The <a href="directives/host-directives/host.html#host">host</a> directive behaves in the same way.</p>
<h2><a href="#customizing-rejection-handling" name="customizing-rejection-handling" class="anchor"><span class="anchor-link"></span></a>Customizing Rejection Handling</h2>
<p>If you&rsquo;d like to customize the way certain rejections are handled you&rsquo;ll have to write a custom <a href="#the-rejectionhandler">RejectionHandler</a>. Here is an example:</p>
<pre class="prettyprint"><code class="language-scala">import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server._
import StatusCodes._
import Directives._

object MyApp extends App {
  implicit def myRejectionHandler =
    RejectionHandler.newBuilder()
      .handle { case MissingCookieRejection(cookieName) =&gt;
        complete(HttpResponse(BadRequest, entity = &quot;No cookies, no service!!!&quot;))
      }
      .handle { case AuthorizationFailedRejection =&gt;
        complete((Forbidden, &quot;You&#39;re out of your depth!&quot;))
      }
      .handle { case ValidationRejection(msg, _) =&gt;
        complete((InternalServerError, &quot;That wasn&#39;t valid! &quot; + msg))
      }
      .handleAll[MethodRejection] { methodRejections =&gt;
        val names = methodRejections.map(_.supported.name)
        complete((MethodNotAllowed, s&quot;Can&#39;t do that! Supported: ${names mkString &quot; or &quot;}!&quot;))
      }
      .handleNotFound { complete((NotFound, &quot;Not here!&quot;)) }
      .result()

  implicit val system = ActorSystem()
  implicit val materializer = ActorMaterializer()

  val route: Route =
    // ... some route structure

  Http().bindAndHandle(route, &quot;localhost&quot;, 8080)
}</code></pre>
<p>The easiest way to construct a <code>RejectionHandler</code> is via the <code>RejectionHandler.Builder</code> that Akka HTTP provides. After having created a new <code>Builder</code> instance with <code>RejectionHandler.newBuilder()</code> you can attach handling logic for certain types of rejections through three helper methods:</p>
<dl>
  <dt>handle</dt>
  <dd>Handles certain rejections with the given partial function. The partial function simply produces a <code>Route</code> which is run when the rejection is &ldquo;caught&rdquo;. This makes the full power of the Routing DSL available for defining rejection handlers and even allows for recursing back into the main route structure if required.</dd>
  <dt>handleAll[T &lt;: Rejection]
  </dt>
  <dd>Handles all rejections of a certain type at the same time. This is useful for cases where your need access to more than the first rejection of a certain type, e.g. for producing the error message to an unsupported request method.</dd>
  <dt>handleNotFound</dt>
  <dd>As described <a href="#empty-rejections">above</a> &ldquo;Resource Not Found&rdquo; is special as it is represented with an empty rejection set. The <code>handleNotFound</code> helper let&rsquo;s you specify the &ldquo;recovery route&rdquo; for this case.</dd>
</dl>
<p>Even though you could handle several different rejection types in a single partial function supplied to <code>handle</code> it is recommended to split these up into distinct <code>handle</code> attachments instead. This way the priority between rejections is properly defined via the order of your <code>handle</code> clauses rather than the (sometimes hard to predict or control) order of rejections in the rejection set.</p>
<p>Once you have defined your custom <code>RejectionHandler</code> you have two options for &ldquo;activating&rdquo; it:</p>
<ol>
  <li>Bring it into implicit scope at the top-level.</li>
  <li>Supply it as argument to the <a href="directives/execution-directives/handleRejections.html#handlerejections">handleRejections</a> directive.</li>
</ol>
<p>In the first case your handler will be &ldquo;sealed&rdquo; (which means that it will receive the default handler as a fallback for all cases your handler doesn&rsquo;t handle itself) and used for all rejections that are not handled within the route structure itself.</p>
<p>The second case allows you to restrict the applicability of your handler to certain branches of your route structure.</p>
<h3><a href="#customising-rejection-http-responses" name="customising-rejection-http-responses" class="anchor"><span class="anchor-link"></span></a>Customising rejection HTTP Responses</h3>
<p>It is also possible to customise just the responses that are returned by a defined rejection handler. This can be useful for example if you like the rejection messages and status codes of the default handler, however you&rsquo;d like to wrap those responses in JSON or some other content type.</p>
<p>Please note that since those are not 200 responses, a different content type than the one that was sent in a client&rsquo;s <code>Accept</code> header <em>is</em> legal. Thus the default handler renders such rejections as <code>text/plain</code>.</p>
<p>In order to customise the HTTP Responses of an existing handler you can call the <code>mapRejectionResponse</code> method on such handler as shown in the example below:</p>
<pre class="prettyprint"><code class="language-scala">import akka.http.scaladsl.model._
import akka.http.scaladsl.server.RejectionHandler

implicit def myRejectionHandler =
  RejectionHandler.default
    .mapRejectionResponse {
      case res @ HttpResponse(_, _, ent: HttpEntity.Strict, _) =&gt;
        // since all Akka default rejection responses are Strict this will handle all rejections
        val message = ent.data.utf8String.replaceAll(&quot;\&quot;&quot;, &quot;&quot;&quot;\&quot;&quot;&quot;&quot;)
        
        // we copy the response in order to keep all headers and status code, wrapping the message as hand rolled JSON
        // you could the entity using your favourite marshalling library (e.g. spray json or anything else) 
        res.copy(entity = HttpEntity(ContentTypes.`application/json`, s&quot;&quot;&quot;{&quot;rejection&quot;: &quot;$message&quot;}&quot;&quot;&quot;))
        
      case x =&gt; x // pass through all other types of responses
    }

val route =
  Route.seal(
    path(&quot;hello&quot;) {
      complete(&quot;Hello there&quot;)
    }
  )

// tests:
Get(&quot;/nope&quot;) ~&gt; route ~&gt; check {
  status should === (StatusCodes.NotFound)
  contentType should === (ContentTypes.`application/json`)
  responseAs[String] should ===(&quot;&quot;&quot;{&quot;rejection&quot;: &quot;The requested resource could not be found.&quot;}&quot;&quot;&quot;)
}

val anotherRoute =
  Route.seal(
    validate(check = false, &quot;Whoops, bad request!&quot;) {
      complete(&quot;Hello there&quot;) 
    }
  )

// tests:
Get(&quot;/hello&quot;) ~&gt; anotherRoute ~&gt; check {
  status should === (StatusCodes.BadRequest)
  contentType should === (ContentTypes.`application/json`)
  responseAs[String] should ===(&quot;&quot;&quot;{&quot;rejection&quot;: &quot;Whoops, bad request!&quot;}&quot;&quot;&quot;)
}</code></pre>
<h4><a href="#adding-the-unmatched-route-in-handlenotfound" name="adding-the-unmatched-route-in-handlenotfound" class="anchor"><span class="anchor-link"></span></a>Adding the unmatched route in handleNotFound</h4>
<p>Since rejection handlers are routes themselves, it is possible to do anything you could possibly want inside such handler. For example you may want to include the path which was not found in the response to the client, this is as simple as using the <code>extractUnmatchedPath</code> and completing the route with it.</p>
<pre class="prettyprint"><code class="language-scala">import akka.http.scaladsl.model._
import akka.http.scaladsl.model.StatusCodes._
import akka.http.scaladsl.server._
import Directives._

implicit def myRejectionHandler =
  RejectionHandler.newBuilder()
    .handleNotFound { 
      extractUnmatchedPath { p =&gt;
        complete((NotFound, s&quot;The path you requested [${p}] does not exist.&quot;))
      }
    }
    .result()</code></pre>
<p>If you want to add even more information you can obtain the full request by using <code>extractRequest</code> as well.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../../scala/http/routing-dsl/directives/custom-directives.html"><i class="icon-prev"></i> <span class="link-prev">Custom Directives</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../../scala/http/routing-dsl/exception-handling.html">Exception Handling <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="http://github.com/akka/akka-http/tree/master/docs/src/main/paradox/scala/http/routing-dsl/rejections.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka HTTP is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../../js/groups.js"></script>
<script type="text/javascript" src="../../../js/page.js"></script>
<script type="text/javascript" src="../../../js/magellan.js"></script>

<style type="text/css">@import "../../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var version = "10.0.9";

var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
