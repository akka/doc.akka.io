<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Route TestKit &bull; Akka HTTP</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka HTTP: Modern, fast, asynchronous, streaming-first HTTP server and client."/><link rel="canonical" href="https://doc.akka.io/docs/akka-http/10.0/scala/http/routing-dsl/testkit.html"/>
<script type="text/javascript" src="../../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>
<link rel="shortcut icon" href="../../../images/favicon.ico" />
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../../scala/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../../scala/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../scala/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../scala/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../scala/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../scala/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../scala/http/low-level-server-side-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html" class="page">High-level Server-Side API</a>
  <ul>
    <li><a href="../../../scala/http/routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#longer-example" class="header">Longer Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
    <li><a href="../../../scala/http/routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
    <li><a href="../../../scala/http/routing-dsl/routes.html" class="page">Routes</a></li>
    <li><a href="../../../scala/http/routing-dsl/directives/index.html" class="page">Directives</a></li>
    <li><a href="../../../scala/http/routing-dsl/rejections.html" class="page">Rejections</a></li>
    <li><a href="../../../scala/http/routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
    <li><a href="../../../scala/http/routing-dsl/case-class-extraction.html" class="page">Case Class Extraction</a></li>
    <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
    <li><a href="../../../scala/http/routing-dsl/testkit.html#route-testkit" class="active page">Route TestKit</a>
    <ul>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#usage" class="header">Usage</a></li>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#testing-sealed-routes" class="header">Testing sealed Routes</a></li>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#testing-route-fragments" class="header">Testing Route fragments</a></li>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#examples" class="header">Examples</a></li>
    </ul></li>
    <li><a href="../../../scala/http/routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
  </ul></li>
  <li><a href="../../../scala/http/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../scala/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a></li>
  <li><a href="../../../scala/http/server-side-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
  <li><a href="../../../scala/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../scala/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../../scala/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../../scala/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../scala/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../scala/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../scala/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../scala/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../scala/http/low-level-server-side-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../scala/http/routing-dsl/index.html" class="page">High-level Server-Side API</a>
  <ul>
    <li><a href="../../../scala/http/routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#longer-example" class="header">Longer Example</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
    <li><a href="../../../scala/http/routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
    <li><a href="../../../scala/http/routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
    <li><a href="../../../scala/http/routing-dsl/routes.html" class="page">Routes</a></li>
    <li><a href="../../../scala/http/routing-dsl/directives/index.html" class="page">Directives</a></li>
    <li><a href="../../../scala/http/routing-dsl/rejections.html" class="page">Rejections</a></li>
    <li><a href="../../../scala/http/routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
    <li><a href="../../../scala/http/routing-dsl/case-class-extraction.html" class="page">Case Class Extraction</a></li>
    <li><a href="../../../scala/http/routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
    <li><a href="../../../scala/http/routing-dsl/testkit.html#route-testkit" class="active page">Route TestKit</a>
    <ul>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#usage" class="header">Usage</a></li>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#testing-sealed-routes" class="header">Testing sealed Routes</a></li>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#testing-route-fragments" class="header">Testing Route fragments</a></li>
      <li><a href="../../../scala/http/routing-dsl/testkit.html#examples" class="header">Examples</a></li>
    </ul></li>
    <li><a href="../../../scala/http/routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
  </ul></li>
  <li><a href="../../../scala/http/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../scala/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a></li>
  <li><a href="../../../scala/http/server-side-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../scala/http/handling-blocking-operations-in-akka-http-routes.html" class="page">Handling blocking operations in Akka HTTP</a></li>
  <li><a href="../../../scala/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../scala/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#route-testkit" name="route-testkit" class="anchor"><span class="anchor-link"></span></a>Route TestKit</h1>
<p>One of Akka HTTP&rsquo;s design goals is good testability of the created services. For services built with the Routing DSL Akka HTTP provides a dedicated testkit that makes efficient testing of route logic easy and convenient. This &ldquo;route test DSL&rdquo; is made available with the <em>akka-http-testkit</em> module. To use it include the following dependency:</p>
<pre class="prettyprint"><code class="language-sbt">&quot;com.typesafe.akka&quot; %% &quot;akka-http-testkit&quot; % &quot;10.0.9&quot;
</code></pre>
<h2><a href="#usage" name="usage" class="anchor"><span class="anchor-link"></span></a>Usage</h2>
<p>Here is an example of what a simple test with the routing testkit might look like using the built-in support for <a href="http://www.scalatest.org">scalatest</a> and <a href="http://etorreborre.github.io/specs2/">specs2</a>:</p>
<dl>
  <dt>ScalaTest</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import org.scalatest.{ Matchers, WordSpec }
import akka.http.scaladsl.model.StatusCodes
import akka.http.scaladsl.testkit.ScalatestRouteTest
import akka.http.scaladsl.server._
import Directives._

class FullTestKitExampleSpec extends WordSpec with Matchers with ScalatestRouteTest {

  val smallRoute =
    get {
      pathSingleSlash {
        complete {
          &quot;Captain on the bridge!&quot;
        }
      } ~
      path(&quot;ping&quot;) {
        complete(&quot;PONG!&quot;)
      }
    }

  &quot;The service&quot; should {

    &quot;return a greeting for GET requests to the root path&quot; in {
      // tests:
      Get() ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;Captain on the bridge!&quot;
      }
    }

    &quot;return a &#39;PONG!&#39; response for GET requests to /ping&quot; in {
      // tests:
      Get(&quot;/ping&quot;) ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;PONG!&quot;
      }
    }

    &quot;leave GET requests to other paths unhandled&quot; in {
      // tests:
      Get(&quot;/kermit&quot;) ~&gt; smallRoute ~&gt; check {
        handled shouldBe false
      }
    }

    &quot;return a MethodNotAllowed error for PUT requests to the root path&quot; in {
      // tests:
      Put() ~&gt; Route.seal(smallRoute) ~&gt; check {
        status shouldEqual StatusCodes.MethodNotAllowed
        responseAs[String] shouldEqual &quot;HTTP method not allowed, supported methods: GET&quot;
      }
    }
  }
}</code></pre></dd>
  <dt>specs2</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import org.specs2.mutable.Specification
import akka.http.scaladsl.model.StatusCodes
import akka.http.scaladsl.testkit.Specs2RouteTest
import akka.http.scaladsl.server._
import Directives._

class FullSpecs2TestKitExampleSpec extends Specification with Specs2RouteTest {

  val smallRoute =
    get {
      pathSingleSlash {
        complete {
          &quot;Captain on the bridge!&quot;
        }
      } ~
      path(&quot;ping&quot;) {
        complete(&quot;PONG!&quot;)
      }
    }

  &quot;The service&quot; should {

    &quot;return a greeting for GET requests to the root path&quot; in {
      // tests:
      Get() ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;Captain on the bridge!&quot;
      }
    }

    &quot;return a &#39;PONG!&#39; response for GET requests to /ping&quot; in {
      // tests:
      Get(&quot;/ping&quot;) ~&gt; smallRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;PONG!&quot;
      }
    }

    &quot;leave GET requests to other paths unhandled&quot; in {
      // tests:
      Get(&quot;/kermit&quot;) ~&gt; smallRoute ~&gt; check {
        handled should beFalse
      }
    }

    &quot;return a MethodNotAllowed error for PUT requests to the root path&quot; in {
      // tests:
      Put() ~&gt; Route.seal(smallRoute) ~&gt; check {
        status shouldEqual StatusCodes.MethodNotAllowed
        responseAs[String] shouldEqual &quot;HTTP method not allowed, supported methods: GET&quot;
      }
    }
  }
}</code></pre></dd>
</dl>
<p>The basic structure of a test built with the testkit is this (expression placeholder in all-caps):</p>
<pre><code>REQUEST ~&gt; ROUTE ~&gt; check {
  ASSERTIONS
}
</code></pre>
<p>In this template <em>REQUEST</em> is an expression evaluating to an <code>HttpRequest</code> instance. In most cases your test will, in one way or another, extend from <code>RouteTest</code> which itself mixes in the <code>akka.http.scaladsl.client.RequestBuilding</code> trait, which gives you a concise and convenient way of constructing test requests. <a id="^1" href="#1">[1]</a></p>
<p><em>ROUTE</em> is an expression evaluating to a <a href="routes.html#routes">Route</a>. You can specify one inline or simply refer to the route structure defined in your service.</p>
<p>The final element of the <code>~&gt;</code> chain is a <code>check</code> call, which takes a block of assertions as parameter. In this block you define your requirements onto the result produced by your route after having processed the given request. Typically you use one of the defined &ldquo;inspectors&rdquo; to retrieve a particular element of the routes response and express assertions against it using the test DSL provided by your test framework. For example, with <a href="http://www.scalatest.org">scalatest</a>, in order to verify that your route responds to the request with a status 200 response, you&rsquo;d use the <code>status</code> inspector and express an assertion like this:</p>
<pre class="prettyprint"><code class="language-scala">status shouldEqual 200
</code></pre>
<p>The following inspectors are defined:</p>
<table>
  <thead>
    <tr>
      <th>Inspector </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>charset: HttpCharset</code> </td>
      <td>Identical to <code>contentType.charset</code> </td>
    </tr>
    <tr>
      <td><code>chunks: Seq[HttpEntity.ChunkStreamPart]</code> </td>
      <td>Returns the entity chunks produced by the route. If the entity is not <code>chunked</code> returns <code>Nil</code>. </td>
    </tr>
    <tr>
      <td><code>closingExtension: String</code> </td>
      <td>Returns chunk extensions the route produced with its last response chunk. If the response entity is unchunked returns the empty string. </td>
    </tr>
    <tr>
      <td><code>contentType: ContentType</code> </td>
      <td>Identical to <code>responseEntity.contentType</code> </td>
    </tr>
    <tr>
      <td><code>definedCharset: Option[HttpCharset]</code> </td>
      <td>Identical to <code>contentType.definedCharset</code> </td>
    </tr>
    <tr>
      <td><code>entityAs[T :FromEntityUnmarshaller]: T</code> </td>
      <td>Unmarshals the response entity using the in-scope <code>FromEntityUnmarshaller</code> for the given type. Any errors in the process trigger a test failure. </td>
    </tr>
    <tr>
      <td><code>handled: Boolean</code> </td>
      <td>Indicates whether the route produced an <code>HttpResponse</code> for the request. If the route rejected the request <code>handled</code> evaluates to <code>false</code>. </td>
    </tr>
    <tr>
      <td><code>header(name: String): Option[HttpHeader]</code> </td>
      <td>Returns the response header with the given name or <code>None</code> if no such header is present in the response. </td>
    </tr>
    <tr>
      <td><code>header[T &lt;: HttpHeader]: Option[T]</code> </td>
      <td>Identical to <code>response.header[T]</code> </td>
    </tr>
    <tr>
      <td><code>headers: Seq[HttpHeader]</code> </td>
      <td>Identical to <code>response.headers</code> </td>
    </tr>
    <tr>
      <td><code>mediaType: MediaType</code> </td>
      <td>Identical to <code>contentType.mediaType</code> </td>
    </tr>
    <tr>
      <td><code>rejection: Rejection</code> </td>
      <td>The rejection produced by the route. If the route did not produce exactly one rejection a test failure is triggered. </td>
    </tr>
    <tr>
      <td><code>rejections: Seq[Rejection]</code> </td>
      <td>The rejections produced by the route. If the route did not reject the request a test failure is triggered. </td>
    </tr>
    <tr>
      <td><code>response: HttpResponse</code> </td>
      <td>The <code>HttpResponse</code> returned by the route. If the route did not return an <code>HttpResponse</code> instance (e.g. because it rejected the request) a test failure is triggered.</td>
    </tr>
    <tr>
      <td><code>responseAs[T: FromResponseUnmarshaller]: T</code> </td>
      <td>Unmarshals the response entity using the in-scope <code>FromResponseUnmarshaller</code> for the given type. Any errors in the process trigger a test failure. </td>
    </tr>
    <tr>
      <td><code>responseEntity: HttpEntity</code> </td>
      <td>Returns the response entity. </td>
    </tr>
    <tr>
      <td><code>status: StatusCode</code> </td>
      <td>Identical to <code>response.status</code> </td>
    </tr>
    <tr>
      <td><code>trailer: Seq[HttpHeader]</code> </td>
      <td>Returns the list of trailer headers the route produced with its last chunk. If the response entity is unchunked returns <code>Nil</code>. </td>
    </tr>
  </tbody>
</table>
<blockquote>
  <p><a id="1" href="#^1">[1]</a> If the request URI is relative it will be made absolute using an implicitly available instance of <code>DefaultHostInfo</code> whose value is &ldquo;<a href="http://example.com">http://example.com</a>&rdquo; by default. This mirrors the behavior of akka-http-core which always produces absolute URIs for incoming request based on the request URI and the <code>Host</code>-header of the request. You can customize this behavior by bringing a custom instance of <code>DefaultHostInfo</code> into scope.</p>
</blockquote>
<h2><a href="#testing-sealed-routes" name="testing-sealed-routes" class="anchor"><span class="anchor-link"></span></a>Testing sealed Routes</h2>
<p>The section above describes how to test a &ldquo;regular&rdquo; branch of your route structure, which reacts to incoming requests with HTTP response parts or rejections. Sometimes, however, you will want to verify that your service also translates <a href="rejections.html#rejections-scala">Rejections</a> to HTTP responses in the way you expect.</p>
<p>You do this by wrapping your route with the <code>akka.http.scaladsl.server.Route.seal</code>. The <code>seal</code> wrapper applies the logic of the in-scope <a href="exception-handling.html#exception-handling-scala">ExceptionHandler</a> and <a href="rejections.html#the-rejectionhandler">RejectionHandler</a> to all exceptions and rejections coming back from the route, and translates them to the respective <code>HttpResponse</code>.</p>
<p>Note that explicit call on the <code>akka.http.scaladsl.server.Route.seal</code> method is needed in test code, but in your application code it is not necessary. As described in <a href="routes.html#sealing-a-route">Sealing a Route</a>, your application code only needs to bring implicit rejection and exception handlers in scope.</p>
<h2><a href="#testing-route-fragments" name="testing-route-fragments" class="anchor"><span class="anchor-link"></span></a>Testing Route fragments</h2>
<p>Since the testkit is request-based, you cannot test requests that are illegal or impossible in HTTP. One such instance is testing a route that begins with the <code>pathEnd</code> directive, such as <code>routeFragment</code> here:</p>
<pre class="prettyprint"><code class="language-scala">pathEnd {
  get {
    complete {
      &quot;Fragments of imagination&quot;
    }
  }
}</code></pre>
<p>You might create a route such as this to be able to compose it into another route such as:</p>
<pre class="prettyprint"><code class="language-scala">import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server.Route

object RouteFragment {
  val route: Route = pathEnd {
    get {
      complete(&quot;example&quot;)
    }
  }
}

object API {
  pathPrefix(&quot;version&quot;) {
    RouteFragment.route
  }
}</code></pre>
<p>However, it is impossible to unit test this Route directly using testkit, since it is impossible to create an empty HTTP request. To test this type of route, embed it in a synthetic route in your test, such as <code>testRoute</code> in the example above.</p>
<p>This is what the full working test looks like:</p>
<pre class="prettyprint"><code class="language-scala">import org.scalatest.{Matchers, WordSpec}
import akka.http.scaladsl.model.StatusCodes
import akka.http.scaladsl.testkit.ScalatestRouteTest
import akka.http.scaladsl.server._
import Directives._

class TestKitFragmentSpec extends WordSpec with Matchers with ScalatestRouteTest {

  val routeFragment =
      pathEnd {
        get {
          complete {
            &quot;Fragments of imagination&quot;
          }
        }
      }

  // Synthetic route to enable pathEnd testing
  val testRoute = {
    pathPrefix(&quot;test&quot;) {
      routeFragment
    }
  }

  &quot;The service&quot; should {
    &quot;return a greeting for GET requests&quot; in {
      // tests:
      Get(&quot;/test&quot;) ~&gt; testRoute ~&gt; check {
        responseAs[String] shouldEqual &quot;Fragments of imagination&quot;
      }
    }

    &quot;return a MethodNotAllowed error for PUT requests to the root path&quot; in {
      // tests:
      Put(&quot;/test&quot;) ~&gt; Route.seal(testRoute) ~&gt; check {
        status shouldEqual StatusCodes.MethodNotAllowed
      }
    }
  }
}</code></pre>
<h2><a href="#examples" name="examples" class="anchor"><span class="anchor-link"></span></a>Examples</h2>
<p>A great pool of examples are the tests for all the predefined directives in Akka HTTP. They can be found <a href="http://github.com/akka/akka-http/tree/v10.0.9/akka-http-tests/src/test/scala/akka/http/scaladsl/server/directives/">here</a>.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../../scala/http/routing-dsl/source-streaming-support.html"><i class="icon-prev"></i> <span class="link-prev">Source Streaming</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../../scala/http/routing-dsl/HttpApp.html">HttpApp Bootstrap <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="http://github.com/akka/akka-http/tree/master/docs/src/main/paradox/scala/http/routing-dsl/testkit.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka HTTP is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../../js/groups.js"></script>
<script type="text/javascript" src="../../../js/page.js"></script>
<script type="text/javascript" src="../../../js/magellan.js"></script>

<style type="text/css">@import "../../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var version = "10.0.9";

var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
