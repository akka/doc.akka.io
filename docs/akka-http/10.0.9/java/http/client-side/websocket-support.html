<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Client-Side WebSocket Support &bull; Akka HTTP</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka HTTP: Modern, fast, asynchronous, streaming-first HTTP server and client."/><link rel="canonical" href="https://doc.akka.io/docs/akka-http/10.0/java/http/client-side/websocket-support.html"/>
<script type="text/javascript" src="../../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>
<link rel="shortcut icon" href="../../../images/favicon.ico" />
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../../java/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../../java/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../java/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../java/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../java/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../java/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../java/http/server-side/low-level-server-side-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../java/http/routing-dsl/index.html" class="page">High-level Server-Side API</a></li>
  <li><a href="../../../java/http/server-side/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../java/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a>
  <ul>
    <li><a href="../../../java/http/client-side/request-level.html" class="page">Request-Level Client-Side API</a></li>
    <li><a href="../../../java/http/client-side/host-level.html" class="page">Host-Level Client-Side API</a></li>
    <li><a href="../../../java/http/client-side/connection-level.html" class="page">Connection-Level Client-Side API</a></li>
    <li><a href="../../../java/http/client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
    <li><a href="../../../java/http/client-side/client-https-support.html" class="page">Client-Side HTTPS Support</a></li>
    <li><a href="../../../java/http/client-side/client-transport.html" class="page">Pluggable Client Transports / HTTPS Proxy Support</a></li>
    <li><a href="../../../java/http/client-side/websocket-support.html#client-side-websocket-support" class="active page">Client-Side WebSocket Support</a>
    <ul>
      <li><a href="../../../java/http/client-side/websocket-support.html#message" class="header">Message</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#singlewebsocketrequest" class="header">singleWebSocketRequest</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#websocketclientflow" class="header">webSocketClientFlow</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#websocketclientlayer" class="header">webSocketClientLayer</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#half-closed-websockets" class="header">Half-Closed WebSockets</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../../../java/http/server-side-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../java/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../java/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../../java/http/index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.0.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../../java/http/security.html" class="page">Security Announcements</a></li>
  <li><a href="../../../java/http/introduction.html" class="page">Introduction</a></li>
  <li><a href="../../../java/http/configuration.html" class="page">Configuration</a></li>
  <li><a href="../../../java/http/common/index.html" class="page">Common Abstractions (Client- and Server-Side)</a></li>
  <li><a href="../../../java/http/implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  <li><a href="../../../java/http/server-side/low-level-server-side-api.html" class="page">Low-Level Server-Side API</a></li>
  <li><a href="../../../java/http/routing-dsl/index.html" class="page">High-level Server-Side API</a></li>
  <li><a href="../../../java/http/server-side/websocket-support.html" class="page">Server-Side WebSocket Support</a></li>
  <li><a href="../../../java/http/client-side/index.html" class="page">Consuming HTTP-based Services (Client-Side)</a>
  <ul>
    <li><a href="../../../java/http/client-side/request-level.html" class="page">Request-Level Client-Side API</a></li>
    <li><a href="../../../java/http/client-side/host-level.html" class="page">Host-Level Client-Side API</a></li>
    <li><a href="../../../java/http/client-side/connection-level.html" class="page">Connection-Level Client-Side API</a></li>
    <li><a href="../../../java/http/client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
    <li><a href="../../../java/http/client-side/client-https-support.html" class="page">Client-Side HTTPS Support</a></li>
    <li><a href="../../../java/http/client-side/client-transport.html" class="page">Pluggable Client Transports / HTTPS Proxy Support</a></li>
    <li><a href="../../../java/http/client-side/websocket-support.html#client-side-websocket-support" class="active page">Client-Side WebSocket Support</a>
    <ul>
      <li><a href="../../../java/http/client-side/websocket-support.html#message" class="header">Message</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#singlewebsocketrequest" class="header">singleWebSocketRequest</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#websocketclientflow" class="header">webSocketClientFlow</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#websocketclientlayer" class="header">webSocketClientLayer</a></li>
      <li><a href="../../../java/http/client-side/websocket-support.html#half-closed-websockets" class="header">Half-Closed WebSockets</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../../../java/http/server-side-https-support.html" class="page">Server-Side HTTPS Support</a></li>
  <li><a href="../../../java/http/migration-guide/index.html" class="page">Migration Guides</a></li>
  <li><a href="../../../java/http/release-notes.html" class="page">Release Notes</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<a id="client-side-websocket-support-java"></a>
<h1><a href="#client-side-websocket-support" name="client-side-websocket-support" class="anchor"><span class="anchor-link"></span></a>Client-Side WebSocket Support</h1>
<p>Client side WebSocket support is available through <code>Http.singleWebSocketRequest</code> , <code>Http.webSocketClientFlow</code> and <code>Http.webSocketClientLayer</code>.</p>
<p>A WebSocket consists of two streams of messages, incoming messages (a <code>Sink</code>) and outgoing messages (a <code>Source</code>) where either may be signalled first; or even be the only direction in which messages flow during the lifetime of the connection. Therefore a WebSocket connection is modelled as either something you connect a <code>Flow&lt;Message, Message, Mat&gt;</code> to or a <code>Flow&lt;Message, Message, Mat&gt;</code> that you connect a <code>Source&lt;Message, Mat&gt;</code> and a <code>Sink&lt;Message, Mat&gt;</code> to.</p>
<p>A WebSocket request starts with a regular HTTP request which contains an <code>Upgrade</code> header (and possibly other regular HTTP request properties), so in addition to the flow of messages there also is an initial response from the server, this is modelled with <code>WebSocketUpgradeResponse</code>.</p>
<p>The methods of the WebSocket client API handle the upgrade to WebSocket on connection success and materializes the connected WebSocket stream. If the connection fails, for example with a <code>404 NotFound</code> error, this regular HTTP result can be found in <code>WebSocketUpgradeResponse.response</code></p><div class="callout note "><div class="callout-title">Note</div>
<p>Make sure to read and understand the section about <a href="#half-closed-client-websockets-java">Half-Closed WebSockets</a> as the behavior when using WebSockets for one-way communication may not be what you would expect.</p></div>
<h2><a href="#message" name="message" class="anchor"><span class="anchor-link"></span></a>Message</h2>
<p>Messages sent and received over a WebSocket can be either <code>TextMessage</code> s or <code>BinaryMessage</code> s and each of those can be either strict (all data in one chunk) or streamed. In typical applications messages will be strict as WebSockets are usually deployed to communicate using small messages not stream data, the protocol does however allow this (by not marking the first fragment as final, as described in <a href="https://tools.ietf.org/html/rfc6455#section-5.2">RFC 6455 section 5.2</a>).</p>
<p>The strict text is available from <code>TextMessage.getStrictText</code> and strict binary data from <code>BinaryMessage.getStrictData</code>.</p>
<p>For streamed messages <code>BinaryMessage.getStreamedData</code> and <code>TextMessage.getStreamedText</code> is used to access the data. In these cases the data is provided as a <code>Source&lt;ByteString, NotUsed&gt;</code> for binary and <code>Source&lt;String, NotUsed&gt;</code> for text messages.</p>
<h2><a href="#singlewebsocketrequest" name="singlewebsocketrequest" class="anchor"><span class="anchor-link"></span></a>singleWebSocketRequest</h2>
<p><code>singleWebSocketRequest</code> takes a <code>WebSocketRequest</code> and a flow it will connect to the source and sink of the WebSocket connection. It will trigger the request right away and returns a tuple containing a <code>CompletionStage&lt;WebSocketUpgradeResponse&gt;</code> and the materialized value from the flow passed to the method.</p>
<p>The future will succeed when the WebSocket connection has been established or the server returned a regular HTTP response, or fail if the connection fails with an exception.</p>
<p>Simple example sending a message and printing any incoming message:</p>
<pre class="prettyprint"><code class="language-java">ActorSystem system = ActorSystem.create();
Materializer materializer = ActorMaterializer.create(system);
Http http = Http.get(system);

// print each incoming text message
// would throw exception on non strict or binary message
final Sink&lt;Message, CompletionStage&lt;Done&gt;&gt; printSink =
  Sink.foreach((message) -&gt;
    System.out.println(&quot;Got message: &quot; + message.asTextMessage().getStrictText())
  );

// send this as a message over the WebSocket
final Source&lt;Message, NotUsed&gt; helloSource =
  Source.single(TextMessage.create(&quot;hello world&quot;));

// the CompletionStage&lt;Done&gt; is the materialized value of Sink.foreach
// and it is completed when the stream completes
final Flow&lt;Message, Message, CompletionStage&lt;Done&gt;&gt; flow =
  Flow.fromSinkAndSourceMat(printSink, helloSource, Keep.left());

final Pair&lt;CompletionStage&lt;WebSocketUpgradeResponse&gt;, CompletionStage&lt;Done&gt;&gt; pair =
  http.singleWebSocketRequest(
    WebSocketRequest.create(&quot;ws://echo.websocket.org&quot;),
    flow,
    materializer
  );

// The first value in the pair is a CompletionStage&lt;WebSocketUpgradeResponse&gt; that
// completes when the WebSocket request has connected successfully (or failed)
final CompletionStage&lt;Done&gt; connected = pair.first().thenApply(upgrade -&gt; {
  // just like a regular http request we can access response status which is available via upgrade.response.status
  // status code 101 (Switching Protocols) indicates that server support WebSockets
  if (upgrade.response().status().equals(StatusCodes.SWITCHING_PROTOCOLS)) {
    return Done.getInstance();
  } else {
    throw new RuntimeException(&quot;Connection failed: &quot; + upgrade.response().status());
  }
});

// the second value is the completion of the sink from above
// in other words, it completes when the WebSocket disconnects
final CompletionStage&lt;Done&gt; closed = pair.second();

// in a real application you would not side effect here
// and handle errors more carefully
connected.thenAccept(done -&gt; System.out.println(&quot;Connected&quot;));
closed.thenAccept(done -&gt; System.out.println(&quot;Connection closed&quot;));
</code></pre>
<p>The websocket request may also include additional headers, like in this example, HTTP Basic Auth:</p>
<pre class="prettyprint"><code class="language-java">http.singleWebSocketRequest(
  WebSocketRequest.create(&quot;ws://example.com:8080/some/path&quot;)
    .addHeader(Authorization.basic(&quot;johan&quot;, &quot;correcthorsebatterystaple&quot;)),
  flow,
  materializer);</code></pre>
<h2><a href="#websocketclientflow" name="websocketclientflow" class="anchor"><span class="anchor-link"></span></a>webSocketClientFlow</h2>
<p><code>webSocketClientFlow</code> takes a request, and returns a <code>Flow&lt;Message, Message, CompletionStage&lt;WebSocketUpgradeResponse&gt;&gt;</code>.</p>
<p>The future that is materialized from the flow will succeed when the WebSocket connection has been established or the server returned a regular HTTP response, or fail if the connection fails with an exception.</p><div class="callout note "><div class="callout-title">Note</div>
<p>The <code>Flow</code> that is returned by this method can only be materialized once. For each request a new flow must be acquired by calling the method again.</p></div>
<p>Simple example sending a message and printing any incoming message:</p>
<pre class="prettyprint"><code class="language-java">ActorSystem system = ActorSystem.create();
Materializer materializer = ActorMaterializer.create(system);
Http http = Http.get(system);

// print each incoming text message
// would throw exception on non strict or binary message
Sink&lt;Message, CompletionStage&lt;Done&gt;&gt; printSink =
  Sink.foreach((message) -&gt;
      System.out.println(&quot;Got message: &quot; + message.asTextMessage().getStrictText())
  );

// send this as a message over the WebSocket
Source&lt;Message, NotUsed&gt; helloSource =
  Source.single(TextMessage.create(&quot;hello world&quot;));


Flow&lt;Message, Message, CompletionStage&lt;WebSocketUpgradeResponse&gt;&gt; webSocketFlow =
  http.webSocketClientFlow(WebSocketRequest.create(&quot;ws://echo.websocket.org&quot;));


Pair&lt;CompletionStage&lt;WebSocketUpgradeResponse&gt;, CompletionStage&lt;Done&gt;&gt; pair =
  helloSource.viaMat(webSocketFlow, Keep.right())
    .toMat(printSink, Keep.both())
    .run(materializer);


// The first value in the pair is a CompletionStage&lt;WebSocketUpgradeResponse&gt; that
// completes when the WebSocket request has connected successfully (or failed)
CompletionStage&lt;WebSocketUpgradeResponse&gt; upgradeCompletion = pair.first();

// the second value is the completion of the sink from above
// in other words, it completes when the WebSocket disconnects
CompletionStage&lt;Done&gt; closed = pair.second();

CompletionStage&lt;Done&gt; connected = upgradeCompletion.thenApply(upgrade-&gt;
{
  // just like a regular http request we can access response status which is available via upgrade.response.status
  // status code 101 (Switching Protocols) indicates that server support WebSockets
  if (upgrade.response().status().equals(StatusCodes.SWITCHING_PROTOCOLS)) {
    return Done.getInstance();
  } else {
    throw new RuntimeException((&quot;Connection failed: &quot; + upgrade.response().status()));
  }
});

// in a real application you would not side effect here
// and handle errors more carefully
connected.thenAccept(done -&gt; System.out.println(&quot;Connected&quot;));
closed.thenAccept(done -&gt; System.out.println(&quot;Connection closed&quot;));
</code></pre>
<h2><a href="#websocketclientlayer" name="websocketclientlayer" class="anchor"><span class="anchor-link"></span></a>webSocketClientLayer</h2>
<p>Just like the <a href="connection-level.html#http-client-layer-java">Stand-Alone HTTP Layer Usage</a> for regular HTTP requests, the WebSocket layer can be used fully detached from the underlying TCP interface. The same scenarios as described for regular HTTP requests apply here.</p>
<p>The returned layer forms a <code>BidiFlow&lt;Message, SslTlsOutbound, SslTlsInbound, Message, CompletionStage&lt;WebSocketUpgradeResponse&gt;&gt;</code>.</p>
<a id="half-closed-client-websockets-java"></a>
<h2><a href="#half-closed-websockets" name="half-closed-websockets" class="anchor"><span class="anchor-link"></span></a>Half-Closed WebSockets</h2>
<p>The Akka HTTP WebSocket API does not support half-closed connections which means that if the either stream completes the entire connection is closed (after a &ldquo;Closing Handshake&rdquo; has been exchanged or a timeout of 3 seconds has passed). This may lead to unexpected behavior, for example if we are trying to only consume messages coming from the server, like this:</p>
<pre class="prettyprint"><code class="language-java"><br/>// we may expect to be able to to just tail
// the server websocket output like this
final Flow&lt;Message, Message, NotUsed&gt; flow =
  Flow.fromSinkAndSource(
    Sink.foreach(System.out::println),
    Source.empty());

http.singleWebSocketRequest(
  WebSocketRequest.create(&quot;ws://example.com:8080/some/path&quot;),
  flow,
  materializer);
</code></pre>
<p>This will in fact quickly close the connection because of the <code>Source.empty</code> being completed immediately when the stream is materialized. To solve this you can make sure to not complete the outgoing source by using for example <code>Source.maybe</code> like this:</p>
<pre class="prettyprint"><code class="language-java"><br/>// using Source.maybe materializes into a completable future
// which will allow us to complete the source later
final Flow&lt;Message, Message, CompletableFuture&lt;Optional&lt;Message&gt;&gt;&gt; flow =
  Flow.fromSinkAndSourceMat(
    Sink.foreach(System.out::println),
    Source.maybe(),
    Keep.right());

final Pair&lt;CompletionStage&lt;WebSocketUpgradeResponse&gt;, CompletableFuture&lt;Optional&lt;Message&gt;&gt;&gt; pair =
  http.singleWebSocketRequest(
    WebSocketRequest.create(&quot;ws://example.com:8080/some/path&quot;),
    flow,
    materializer);

// at some later time we want to disconnect
pair.second().complete(Optional.empty());</code></pre>
<p>This will keep the outgoing source from completing, but without emitting any elements until the <code>CompletableFuture</code> is manually completed which makes the <code>Source</code> complete and the connection to close.</p>
<p>The same problem holds true if emitting a finite number of elements, as soon as the last element is reached the <code>Source</code> will close and cause the connection to close. To avoid that you can concatenate <code>Source.maybe</code> to the finite stream:</p>
<pre class="prettyprint"><code class="language-java"><br/>// emit &quot;one&quot; and then &quot;two&quot; and then keep the source from completing
final Source&lt;Message, CompletableFuture&lt;Optional&lt;Message&gt;&gt;&gt; source =
  Source.from(Arrays.&lt;Message&gt;asList(TextMessage.create(&quot;one&quot;), TextMessage.create(&quot;two&quot;)))
    .concatMat(Source.maybe(), Keep.right());

final Flow&lt;Message, Message, CompletableFuture&lt;Optional&lt;Message&gt;&gt;&gt; flow =
  Flow.fromSinkAndSourceMat(
    Sink.foreach(System.out::println),
    source,
    Keep.right());

final Pair&lt;CompletionStage&lt;WebSocketUpgradeResponse&gt;, CompletableFuture&lt;Optional&lt;Message&gt;&gt;&gt; pair =
  http.singleWebSocketRequest(
    WebSocketRequest.create(&quot;ws://example.com:8080/some/path&quot;),
    flow,
    materializer);

// at some later time we want to disconnect
pair.second().complete(Optional.empty());</code></pre>
<p>Scenarios that exist with the two streams in a WebSocket and possible ways to deal with it:</p>
<table>
  <thead>
    <tr>
      <th>Scenario </th>
      <th>Possible solution </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Two-way communication </td>
      <td><code>Flow.fromSinkAndSource</code>, or <code>Flow.map</code> for a request-response protocol</td>
    </tr>
    <tr>
      <td>Infinite incoming stream, no outgoing </td>
      <td><code>Flow.fromSinkAndSource(someSink, Source.maybe())</code> </td>
    </tr>
    <tr>
      <td>Infinite outgoing stream, no incoming </td>
      <td><code>Flow.fromSinkAndSource(Sink.ignore(), yourSource)</code> </td>
    </tr>
  </tbody>
</table>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../../java/http/client-side/client-transport.html"><i class="icon-prev"></i> <span class="link-prev">Pluggable Client Transports / HTTPS Proxy Support</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../../java/http/server-side-https-support.html">Server-Side HTTPS Support <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="http://github.com/akka/akka-http/tree/master/docs/src/main/paradox/java/http/client-side/websocket-support.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka HTTP is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../../js/groups.js"></script>
<script type="text/javascript" src="../../../js/page.js"></script>
<script type="text/javascript" src="../../../js/magellan.js"></script>

<style type="text/css">@import "../../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var version = "10.0.9";

var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["version:" + version, "language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
