<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Routing DSL &bull; Akka HTTP</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka Http: Modern, fast, asynchronous, streaming-first HTTP server and client."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka-http/current/routing-dsl/index.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-7.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-1.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="../images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="../images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="../images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="../images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="../images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="../images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="../images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.1.12
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security.html" class="page">! Security Announcements !</a></li>
  <li><a href="../release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="../introduction.html" class="page">1. Introduction</a></li>
  <li><a href="../usage.html" class="page">2. Usage</a></li>
  <li><a href="../common/index.html" class="page">3. Data Types &amp; Abstractions</a></li>
  <li><a href="../server-side/index.html" class="page">4. Server API</a>
  <ul>
    <li><a href="../server-side/low-level-api.html" class="page">Core Server API</a></li>
    <li><a href="../routing-dsl/index.html#routing-dsl" class="active page">Routing DSL</a>
    <ul>
      <li><a href="../routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
      <li><a href="../routing-dsl/index.html#longer-example" class="header group-scala">Longer Example</a></li>
      <li><a href="../routing-dsl/index.html#interaction-with-akka-typed" class="header">Interaction with Akka Typed</a></li>
      <li><a href="../routing-dsl/index.html#dynamic-routing-example" class="header">Dynamic Routing Example</a></li>
      <li><a href="../routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
      <li><a href="../routing-dsl/index.html#file-uploads" class="header">File uploads</a></li>
      <li><a href="../routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
      <li><a href="../routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
      <li><a href="../routing-dsl/routes.html" class="page">Routes</a></li>
      <li><a href="../routing-dsl/directives/index.html" class="page">Directives</a></li>
      <li><a href="../routing-dsl/rejections.html" class="page">Rejections</a></li>
      <li><a href="../routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
      <li><a href="../routing-dsl/case-class-extraction.html" class="page group-scala">Case Class Extraction</a></li>
      <li><a href="../routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
      <li><a href="../routing-dsl/testkit.html" class="page">Route TestKit</a></li>
      <li><a href="../routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
    </ul></li>
    <li><a href="../server-side/websocket-support.html" class="page">Server WebSocket Support</a></li>
    <li><a href="../server-side/server-https-support.html" class="page">Server HTTPS Support</a></li>
    <li><a href="../server-side/graceful-termination.html" class="page">Graceful termination</a></li>
    <li><a href="../server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../client-side/index.html" class="page">5. Client API</a></li>
  <li><a href="../extensions.html" class="page">6. Extensions</a></li>
  <li><a href="../technologies.html" class="page">7. Supported Technologies</a></li>
  <li><a href="../tipsandtricks.html" class="page">8. Tips And Tricks</a></li>
  <li><a href="../contributing.html" class="page">9. Contributing</a></li>
  <li><a href="../reference.html" class="page">10. Reference</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka HTTP</a></h1>
</div>
<div class="nav-header-version">
Version 10.1.12
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security.html" class="page">! Security Announcements !</a></li>
  <li><a href="../release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="../introduction.html" class="page">1. Introduction</a></li>
  <li><a href="../usage.html" class="page">2. Usage</a></li>
  <li><a href="../common/index.html" class="page">3. Data Types &amp; Abstractions</a></li>
  <li><a href="../server-side/index.html" class="page">4. Server API</a>
  <ul>
    <li><a href="../server-side/low-level-api.html" class="page">Core Server API</a></li>
    <li><a href="../routing-dsl/index.html#routing-dsl" class="active page">Routing DSL</a>
    <ul>
      <li><a href="../routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
      <li><a href="../routing-dsl/index.html#longer-example" class="header group-scala">Longer Example</a></li>
      <li><a href="../routing-dsl/index.html#interaction-with-akka-typed" class="header">Interaction with Akka Typed</a></li>
      <li><a href="../routing-dsl/index.html#dynamic-routing-example" class="header">Dynamic Routing Example</a></li>
      <li><a href="../routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
      <li><a href="../routing-dsl/index.html#file-uploads" class="header">File uploads</a></li>
      <li><a href="../routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
      <li><a href="../routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
      <li><a href="../routing-dsl/routes.html" class="page">Routes</a></li>
      <li><a href="../routing-dsl/directives/index.html" class="page">Directives</a></li>
      <li><a href="../routing-dsl/rejections.html" class="page">Rejections</a></li>
      <li><a href="../routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
      <li><a href="../routing-dsl/case-class-extraction.html" class="page group-scala">Case Class Extraction</a></li>
      <li><a href="../routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
      <li><a href="../routing-dsl/testkit.html" class="page">Route TestKit</a></li>
      <li><a href="../routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
    </ul></li>
    <li><a href="../server-side/websocket-support.html" class="page">Server WebSocket Support</a></li>
    <li><a href="../server-side/server-https-support.html" class="page">Server HTTPS Support</a></li>
    <li><a href="../server-side/graceful-termination.html" class="page">Graceful termination</a></li>
    <li><a href="../server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="../client-side/index.html" class="page">5. Client API</a></li>
  <li><a href="../extensions.html" class="page">6. Extensions</a></li>
  <li><a href="../technologies.html" class="page">7. Supported Technologies</a></li>
  <li><a href="../tipsandtricks.html" class="page">8. Tips And Tricks</a></li>
  <li><a href="../contributing.html" class="page">9. Contributing</a></li>
  <li><a href="../reference.html" class="page">10. Reference</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#routing-dsl" name="routing-dsl" class="anchor"><span class="anchor-link"></span></a>Routing DSL</h1>
<p>In addition to the <a href="../server-side/low-level-api.html">Core Server API</a> Akka HTTP provides a very flexible &ldquo;Routing DSL&rdquo; for elegantly defining RESTful web services. It picks up where the low-level API leaves off and offers much of the higher-level functionality of typical web servers or frameworks, like deconstruction of URIs, content negotiation or static content serving.</p><div class="callout note "><div class="callout-title">Note</div>
<p>It is recommended to read the <a href="../implications-of-streaming-http-entity.html">Implications of the streaming nature of Request/Response Entities</a> section, as it explains the underlying full-stack streaming concepts, which may be unexpected when coming from a background with non-&ldquo;streaming first&rdquo; HTTP Servers.</p></div>
<div class="toc ">
<ul>
  <li><a href="../routing-dsl/index.html#minimal-example" class="header">Minimal Example</a></li>
  <li><a href="../routing-dsl/index.html#longer-example" class="header group-scala">Longer Example</a></li>
  <li><a href="../routing-dsl/index.html#interaction-with-akka-typed" class="header">Interaction with Akka Typed</a></li>
  <li><a href="../routing-dsl/index.html#dynamic-routing-example" class="header">Dynamic Routing Example</a></li>
  <li><a href="../routing-dsl/index.html#handling-http-server-failures-in-the-high-level-api" class="header">Handling HTTP Server failures in the High-Level API</a></li>
  <li><a href="../routing-dsl/index.html#file-uploads" class="header">File uploads</a></li>
  <li><a href="../routing-dsl/index.html#configuring-server-side-https" class="header">Configuring Server-side HTTPS</a></li>
  <li><a href="../routing-dsl/overview.html" class="page">Routing DSL Overview</a></li>
  <li><a href="../routing-dsl/routes.html" class="page">Routes</a></li>
  <li><a href="../routing-dsl/directives/index.html" class="page">Directives</a></li>
  <li><a href="../routing-dsl/rejections.html" class="page">Rejections</a></li>
  <li><a href="../routing-dsl/exception-handling.html" class="page">Exception Handling</a></li>
  <li><a href="../routing-dsl/case-class-extraction.html" class="page group-scala">Case Class Extraction</a></li>
  <li><a href="../routing-dsl/source-streaming-support.html" class="page">Source Streaming</a></li>
  <li><a href="../routing-dsl/testkit.html" class="page">Route TestKit</a></li>
  <li><a href="../routing-dsl/HttpApp.html" class="page">HttpApp Bootstrap</a></li>
</ul>
</div>
<h2><a href="#minimal-example" name="minimal-example" class="anchor"><span class="anchor-link"></span></a>Minimal Example</h2>
<p>This is a complete, very basic Akka HTTP application relying on the Routing DSL:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L318-L348" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer
import scala.io.StdIn

object WebServer {
  def main(args: Array[String]) {

    implicit val system = ActorSystem(&quot;my-system&quot;)
    implicit val materializer = ActorMaterializer()
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.dispatcher

    val route =
      path(&quot;hello&quot;) {
        get {
          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, &quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))
        }
      }

    val bindingFuture = Http().bindAndHandle(route, &quot;localhost&quot;, 8080)

    println(s&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/java/docs/http/javadsl/HttpServerMinimalExampleTest.java#L7-L51" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.http.javadsl.ConnectHttp;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.model.HttpRequest;
import akka.http.javadsl.model.HttpResponse;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Flow;

import java.util.concurrent.CompletionStage;

public class HttpServerMinimalExampleTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem system = ActorSystem.create(&quot;routes&quot;);

    final Http http = Http.get(system);
    final ActorMaterializer materializer = ActorMaterializer.create(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerMinimalExampleTest app = new HttpServerMinimalExampleTest();

    final Flow&lt;HttpRequest, HttpResponse, NotUsed&gt; routeFlow = app.createRoute().flow(system, materializer);
    final CompletionStage&lt;ServerBinding&gt; binding = http.bindAndHandle(routeFlow,
        ConnectHttp.toHost(&quot;localhost&quot;, 8080), materializer);

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  private Route createRoute() {
    return concat(
        path(&quot;hello&quot;, () -&gt;
            get(() -&gt;
                complete(&quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))));
  }
}</code></pre></dd>
</dl>
<p>It starts an HTTP Server on localhost and replies to GET requests to <code>/hello</code> with a simple response.</p><div class="callout warning "><div class="callout-title">API may change</div>
<p>The following example uses an experimental feature and its API is subjected to change in future releases of Akka HTTP. For further information about this marker, see <a href="https://doc.akka.io/docs/akka/2.5.26/common/binary-compatibility-rules.html#the-donotinherit-and-apimaychange-markers">The @DoNotInherit and @ApiMayChange markers</a> in the Akka documentation.</p></div>
<p>To help start a server Akka HTTP provides an experimental helper class called <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.12/?akka/http/javadsl/server/HttpApp.html" title="akka.http.javadsl.server.HttpApp"><code>HttpApp</code></a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.12/akka/http/scaladsl/server/HttpApp.html" title="akka.http.scaladsl.server.HttpApp"><code>HttpApp</code></a></span>. This is the same example as before rewritten using <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.12/?akka/http/javadsl/server/HttpApp.html" title="akka.http.javadsl.server.HttpApp"><code>HttpApp</code></a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.12/akka/http/scaladsl/server/HttpApp.html" title="akka.http.scaladsl.server.HttpApp"><code>HttpApp</code></a></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala/docs/http/scaladsl/HttpAppExampleSpec.scala#L15-L30" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.http.scaladsl.model.{ ContentTypes, HttpEntity }
import akka.http.scaladsl.server.HttpApp
import akka.http.scaladsl.server.Route

// Server definition
object WebServer extends HttpApp {
  override def routes: Route =
    path(&quot;hello&quot;) {
      get {
        complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, &quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))
      }
    }
}

// Starting the server
WebServer.startServer(&quot;localhost&quot;, 8080)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/java/docs/http/javadsl/server/HttpAppExampleTest.java#L49-L71" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>// Server definition
class MinimalHttpApp extends HttpApp {
  @Override
  protected Route routes() {
    return path(&quot;hello&quot;, () -&gt;
      get(() -&gt;
        complete(&quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;)
      )
    );
  }
}

// Starting the server
final MinimalHttpApp myServer = new MinimalHttpApp();
myServer.startServer(&quot;localhost&quot;, 8080);</code></pre></dd>
</dl>
<p>See <a href="HttpApp.html">HttpApp Bootstrap</a> for more details about setting up a server using this approach.</p><div class="group-scala">
<h2><a href="#longer-example" name="longer-example" class="anchor"><span class="anchor-link"></span></a>Longer Example</h2>
<p>The following is an Akka HTTP route definition that tries to show off a few features. The resulting service does not really do anything useful but its definition should give you a feel for what an actual API definition with the Routing DSL will look like:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L354-L461" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ ActorRef, ActorSystem }
import akka.http.scaladsl.coding.Deflate
import akka.http.scaladsl.marshalling.ToResponseMarshaller
import akka.http.scaladsl.model.StatusCodes.MovedPermanently
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.unmarshalling.FromRequestUnmarshaller
import akka.pattern.ask
import akka.stream.ActorMaterializer
import akka.util.Timeout

// types used by the API routes
type Money = Double // only for demo purposes, don&#39;t try this at home!
type TransactionResult = String
case class User(name: String)
case class Order(email: String, amount: Money)
case class Update(order: Order)
case class OrderItem(i: Int, os: Option[String], s: String)

// marshalling would usually be derived automatically using libraries
implicit val orderUM: FromRequestUnmarshaller[Order] = ???
implicit val orderM: ToResponseMarshaller[Order] = ???
implicit val orderSeqM: ToResponseMarshaller[Seq[Order]] = ???
implicit val timeout: Timeout = ??? // for actor asks
implicit val ec: ExecutionContext = ???
implicit val mat: ActorMaterializer = ???
implicit val sys: ActorSystem = ???

// backend entry points
def myAuthenticator: Authenticator[User] = ???
def retrieveOrdersFromDB: Seq[Order] = ???
def myDbActor: ActorRef = ???
def processOrderRequest(id: Int, complete: Order =&gt; Unit): Unit = ???

val route = concat(
  path(&quot;orders&quot;) {
    authenticateBasic(realm = &quot;admin area&quot;, myAuthenticator) { user =&gt;
      concat(
        get {
          encodeResponseWith(Deflate) {
            complete {
              // marshal custom object with in-scope marshaller
              retrieveOrdersFromDB
            }
          }
        },
        post {
          // decompress gzipped or deflated requests if required
          decodeRequest {
            // unmarshal with in-scope unmarshaller
            entity(as[Order]) { order =&gt;
              complete {
                // ... write order to DB
                &quot;Order received&quot;
              }
            }
          }
        })
    }
  },
  // extract URI path element as Int
  pathPrefix(&quot;order&quot; / IntNumber) { orderId =&gt;
    concat(
      pathEnd {
        concat(
          (put | parameter(&#39;method ! &quot;put&quot;)) {
            // form extraction from multipart or www-url-encoded forms
            formFields((&#39;email, &#39;total.as[Money])).as(Order) { order =&gt;
              complete {
                // complete with serialized Future result
                (myDbActor ? Update(order)).mapTo[TransactionResult]
              }
            }
          },
          get {
            // debugging helper
            logRequest(&quot;GET-ORDER&quot;) {
              // use in-scope marshaller to create completer function
              completeWith(instanceOf[Order]) { completer =&gt;
                // custom
                processOrderRequest(orderId, completer)
              }
            }
          })
      },
      path(&quot;items&quot;) {
        get {
          // parameters to case class extraction
          parameters((&#39;size.as[Int], &#39;color ?, &#39;dangerous ? &quot;no&quot;))
            .as(OrderItem) { orderItem =&gt;
              // ... route using case class instance created from
              // required and optional query parameters
            }
        }
      })
  },
  pathPrefix(&quot;documentation&quot;) {
    // optionally compresses the response with Gzip or Deflate
    // if the client accepts compressed responses
    encodeResponse {
      // serve up static content from a JAR resource
      getFromResourceDirectory(&quot;docs&quot;)
    }
  },
  path(&quot;oldApi&quot; / Remaining) { pathRest =&gt;
    redirect(&quot;http://oldapi.example.com/&quot; + pathRest, MovedPermanently)
  }
)</code></pre></div>
<h2><a href="#interaction-with-akka-typed" name="interaction-with-akka-typed" class="anchor"><span class="anchor-link"></span></a>Interaction with Akka Typed</h2>
<p>Since Akka version <code>2.5.22</code>, Akka typed became ready for production, Akka HTTP, however, is still using the untyped <code>ActorSystem</code>. This following example will demonstrate how to use Akka HTTP and Akka Typed together within the same application.</p>
<p>We will create a small web server responsible to record build jobs with its state and duration, query jobs by id and status, and clear the job history.</p>
<p>First let&rsquo;s start by defining the <code>Behavior</code> that will act as a repository for the build job information, this isn&rsquo;t strictly needed for our sample but just to have an actual actor to interact with:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala-2.12+/docs/http/scaladsl/HttpServerWithTypedSample.scala#L10-L51" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.typed.{ ActorRef, Behavior }
import akka.actor.typed.scaladsl.Behaviors

object JobRepository {

  // Definition of the a build job and its possible status values
  sealed trait Status
  object Successful extends Status
  object Failed extends Status

  final case class Job(id: Long, projectName: String, status: Status, duration: Long)
  final case class Jobs(jobs: Seq[Job])

  // Trait defining successful and failure responses
  sealed trait Response
  case object OK extends Response
  final case class KO(reason: String) extends Response

  // Trait and its implementations representing all possible messages that can be sent to this Behavior
  sealed trait Command
  final case class AddJob(job: Job, replyTo: ActorRef[Response]) extends Command
  final case class GetJobById(id: Long, replyTo: ActorRef[Option[Job]]) extends Command
  final case class GetJobByStatus(status: Status, replyTo: ActorRef[Seq[Job]]) extends Command
  final case class ClearJobs(replyTo: ActorRef[Response]) extends Command

  // This behavior handles all possible incoming messages and keeps the state in the function parameter
  def apply(jobs: Map[Long, Job] = Map.empty): Behavior[Command] = Behaviors.receiveMessage {
    case AddJob(job, replyTo) if jobs.contains(job.id) =&gt;
      replyTo ! KO(&quot;Job already exists&quot;)
      Behaviors.same
    case AddJob(job, replyTo) =&gt;
      replyTo ! OK
      JobRepository(jobs.+(job.id -&gt; job))
    case GetJobById(id, replyTo) =&gt;
      replyTo ! jobs.get(id)
      Behaviors.same
    case ClearJobs(replyTo) =&gt;
      replyTo ! OK
      JobRepository(Map.empty)
  }

}</code></pre></dd>
</dl>
<p>Then, let&rsquo;s define the JSON marshaller and unmarshallers for the HTTP routes:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala-2.12+/docs/http/scaladsl/HttpServerWithTypedSample.scala#L55-L83" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
import spray.json.DefaultJsonProtocol
import spray.json.DeserializationException
import spray.json.JsString
import spray.json.JsValue
import spray.json.RootJsonFormat

trait JsonSupport extends SprayJsonSupport {
  // import the default encoders for primitive types (Int, String, Lists etc)
  import DefaultJsonProtocol._
  import JobRepository._

  implicit object StatusFormat extends RootJsonFormat[Status] {
    def write(status: Status): JsValue = status match {
      case Failed     =&gt; JsString(&quot;Failed&quot;)
      case Successful =&gt; JsString(&quot;Successful&quot;)
    }

    def read(json: JsValue): Status = json match {
      case JsString(&quot;Failed&quot;)     =&gt; Failed
      case JsString(&quot;Successful&quot;) =&gt; Successful
      case _                      =&gt; throw new DeserializationException(&quot;Status unexpected&quot;)
    }
  }

  implicit val jobFormat = jsonFormat4(Job)

  implicit val jobsFormat = jsonFormat1(Jobs)
}</code></pre></dd>
</dl>
<p>Next step is to define the <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.12/?akka/http/javadsl/server/Route.html" title="akka.http.javadsl.server.Route"><code>Route</code></a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.12/akka/http/scaladsl/server/Route$.html" title="akka.http.scaladsl.server.Route"><code>Route</code></a></span> that will communicate with the previously defined behavior and handle all its possible responses:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala-2.12+/docs/http/scaladsl/HttpServerWithTypedSample.scala#L87-L142" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.typed.ActorSystem
import akka.util.Timeout

import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.model.StatusCodes
import akka.http.scaladsl.server.Route

import scala.concurrent.duration._
import scala.concurrent.Future

class JobRoutes(buildJobRepository: ActorRef[JobRepository.Command])(implicit system: ActorSystem[_]) extends JsonSupport {

  import akka.actor.typed.scaladsl.AskPattern.Askable

  // asking someone requires a timeout and a scheduler, if the timeout hits without response
  // the ask is failed with a TimeoutException
  implicit val timeout: Timeout = 3.seconds
  // implicit scheduler only needed in 2.5
  // in 2.6 having an implicit typed ActorSystem in scope is enough if you import AskPattern.schedulerFromActorSystem
  implicit val scheduler = system.scheduler

  lazy val theJobRoutes: Route =
    pathPrefix(&quot;jobs&quot;) {
      concat(
        pathEnd {
          concat(
            post {
              entity(as[JobRepository.Job]) { job =&gt;
                val operationPerformed: Future[JobRepository.Response] =
                  buildJobRepository.ask(JobRepository.AddJob(job, _))
                onSuccess(operationPerformed) {
                  case JobRepository.OK         =&gt; complete(&quot;Job added&quot;)
                  case JobRepository.KO(reason) =&gt; complete(StatusCodes.InternalServerError -&gt; reason)
                }
              }
            },
            delete {
              val operationPerformed: Future[JobRepository.Response] =
                buildJobRepository.ask(JobRepository.ClearJobs(_))
              onSuccess(operationPerformed) {
                case JobRepository.OK         =&gt; complete(&quot;Jobs cleared&quot;)
                case JobRepository.KO(reason) =&gt; complete(StatusCodes.InternalServerError -&gt; reason)
              }
            }
          )
        },
        (get &amp; path(LongNumber)) { id =&gt;
          val maybeJob: Future[Option[JobRepository.Job]] =
            buildJobRepository.ask(JobRepository.GetJobById(id, _))
          rejectEmptyResponse {
            complete(maybeJob)
          }
        }
      )
    }
}</code></pre></dd>
</dl>
<p>Finally, we create a <code>Behavior</code> that bootstraps the web server and use it as the root behavior of our actor system:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala-2.12+/docs/http/scaladsl/HttpServerWithTypedSample.scala#L150-L224" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.typed.PostStop
import akka.actor.typed.scaladsl.adapter._
import akka.stream.ActorMaterializer
import akka.http.scaladsl.Http.ServerBinding
import akka.http.scaladsl.Http

import scala.concurrent.ExecutionContextExecutor
import scala.util.{ Success, Failure }

object Server {

  sealed trait Message
  private final case class StartFailed(cause: Throwable) extends Message
  private final case class Started(binding: ServerBinding) extends Message
  case object Stop extends Message

  def apply(host: String, port: Int): Behavior[Message] = Behaviors.setup { ctx =&gt;

    implicit val system = ctx.system
    // http doesn&#39;t know about akka typed so provide untyped system
    implicit val untypedSystem: akka.actor.ActorSystem = ctx.system.toClassic
    // implicit materializer only required in Akka 2.5
    // in 2.6 having an implicit classic or typed ActorSystem in scope is enough
    implicit val materializer: ActorMaterializer = ActorMaterializer()(ctx.system.toClassic)
    implicit val ec: ExecutionContextExecutor = ctx.system.executionContext

    val buildJobRepository = ctx.spawn(JobRepository(), &quot;JobRepository&quot;)
    val routes = new JobRoutes(buildJobRepository)

    val serverBinding: Future[Http.ServerBinding] =
      Http.apply().bindAndHandle(routes.theJobRoutes, host, port)
    ctx.pipeToSelf(serverBinding) {
      case Success(binding) =&gt; Started(binding)
      case Failure(ex)      =&gt; StartFailed(ex)
    }

    def running(binding: ServerBinding): Behavior[Message] =
      Behaviors.receiveMessagePartial[Message] {
        case Stop =&gt;
          ctx.log.info(
            &quot;Stopping server http://{}:{}/&quot;,
            binding.localAddress.getHostString,
            binding.localAddress.getPort)
          Behaviors.stopped
      }.receiveSignal {
        case (_, PostStop) =&gt;
          binding.unbind()
          Behaviors.same
      }

    def starting(wasStopped: Boolean): Behaviors.Receive[Message] =
      Behaviors.receiveMessage[Message] {
        case StartFailed(cause) =&gt;
          throw new RuntimeException(&quot;Server failed to start&quot;, cause)
        case Started(binding) =&gt;
          ctx.log.info(
            &quot;Server online at http://{}:{}/&quot;,
            binding.localAddress.getHostString,
            binding.localAddress.getPort)
          if (wasStopped) ctx.self ! Stop
          running(binding)
        case Stop =&gt;
          // we got a stop message but haven&#39;t completed starting yet,
          // we cannot stop until starting has completed
          starting(wasStopped = true)
      }

    starting(wasStopped = false)
  }
}

def main(args: Array[String]) {
  val system: ActorSystem[Server.Message] =
    ActorSystem(Server(&quot;localhost&quot;, 8080), &quot;BuildJobsServer&quot;)
}</code></pre></dd>
</dl>
<p>Note that the <code>akka.actor.typed.ActorSystem</code> is converted with <code>toClassic</code>, which comes from <code>import akka.actor.typed.scaladsl.adapter._</code>. If you are using an earlier version than Akka 2.5.26 this conversion method is named <code>toUntyped</code>.</p>
<h2><a href="#dynamic-routing-example" name="dynamic-routing-example" class="anchor"><span class="anchor-link"></span></a>Dynamic Routing Example</h2>
<p>As the routes are evaluated for each request, it is possible to make changes at runtime. Please note that every access may happen on a separated thread, so any shared mutable state must be thread safe.</p>
<p>The following is an Akka HTTP route definition that allows dynamically adding new or updating mock endpoints with associated request-response pairs at runtime.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L723-L754" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class MockDefinition(path: String, requests: Seq[JsValue], responses: Seq[JsValue])
implicit val format = jsonFormat3(MockDefinition)

@volatile var state = Map.empty[String, Map[JsValue, JsValue]]

// fixed route to update state
val fixedRoute: Route = post {
  pathSingleSlash {
    entity(as[MockDefinition]) { mock =&gt;
      val mapping = mock.requests.zip(mock.responses).toMap
      state = state + (mock.path -&gt; mapping)
      complete(&quot;ok&quot;)
    }
  }
}

// dynamic routing based on current state
val dynamicRoute: Route = ctx =&gt; {
  val routes = state.map {
    case (segment, responses) =&gt;
      post {
        path(segment) {
          entity(as[JsValue]) { input =&gt;
            complete(responses.get(input))
          }
        }
      }
  }
  concat(routes.toList: _*)(ctx)
}

val route = fixedRoute ~ dynamicRoute</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/java/docs/http/javadsl/HttpServerDynamicRoutingExampleTest.java#L45-L101" target="_blank" title="Go to snippet source"></a><code class="language-java">final private Map&lt;String, Map&lt;JsonNode, JsonNode&gt;&gt; state = new ConcurrentHashMap&lt;&gt;();

private Route createRoute() {
  // fixed route to update state
  Route fixedRoute = post(() -&gt;
    pathSingleSlash(() -&gt;
      entity(Jackson.unmarshaller(MockDefinition.class), mock -&gt; {
        Map&lt;JsonNode, JsonNode&gt; mappings = new HashMap&lt;&gt;();
        int size = Math.min(mock.getRequests().size(), mock.getResponses().size());
        for (int i = 0; i &lt; size; i++) {
          mappings.put(mock.getRequests().get(i), mock.getResponses().get(i));
        }
        state.put(mock.getPath(), mappings);
        return complete(&quot;ok&quot;);
      })
    )
  );

  // dynamic routing based on current state
  Route dynamicRoute = post(() -&gt;
    state.entrySet().stream().map(mock -&gt;
      path(mock.getKey(), () -&gt;
        entity(Jackson.unmarshaller(JsonNode.class), input -&gt;
          complete(StatusCodes.OK, mock.getValue().get(input), Jackson.marshaller())
        )
      )
    ).reduce(reject(), Route::orElse)
  );

  return concat(fixedRoute, dynamicRoute);
}

private static class MockDefinition {
  private final String path;
  private final List&lt;JsonNode&gt; requests;
  private final List&lt;JsonNode&gt; responses;

  public MockDefinition(@JsonProperty(&quot;path&quot;) String path,
                        @JsonProperty(&quot;requests&quot;) List&lt;JsonNode&gt; requests,
                        @JsonProperty(&quot;responses&quot;) List&lt;JsonNode&gt; responses) {
    this.path = path;
    this.requests = requests;
    this.responses = responses;
  }

  public String getPath() {
    return path;
  }

  public List&lt;JsonNode&gt; getRequests() {
    return requests;
  }

  public List&lt;JsonNode&gt; getResponses() {
    return responses;
  }
}</code></pre></dd>
</dl>
<p>For example, let&rsquo;s say we do a POST request with body:</p>
<pre class="prettyprint"><code class="language-json">{
  &quot;path&quot;: &quot;test&quot;,
  &quot;requests&quot;: [
    {&quot;id&quot;: 1},
    {&quot;id&quot;: 2}
  ],
  &quot;responses&quot;: [
    {&quot;amount&quot;: 1000},
    {&quot;amount&quot;: 2000}
  ]
}
</code></pre>
<p>Subsequent POST request to <code>/test</code> with body <code>{&quot;id&quot;: 1}</code> will be responded with <code>{&quot;amount&quot;: 1000}</code>.</p>
<h2><a href="#handling-http-server-failures-in-the-high-level-api" name="handling-http-server-failures-in-the-high-level-api" class="anchor"><span class="anchor-link"></span></a>Handling HTTP Server failures in the High-Level API</h2>
<p>There are various situations when failure may occur while initialising or running an Akka HTTP server. Akka by default will log all these failures, however sometimes one may want to react to failures in addition to them just being logged, for example by shutting down the actor system, or notifying some external monitoring end-point explicitly.</p>
<h3><a href="#bind-failures" name="bind-failures" class="anchor"><span class="anchor-link"></span></a>Bind failures</h3>
<p>For example the server might be unable to bind to the given port. For example when the port is already taken by another application, or if the port is privileged (i.e. only usable by <code>root</code>). In this case the &ldquo;binding future&rdquo; will fail immediately, and we can react to it by listening on the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>&rsquo;s completion:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala/docs/http/scaladsl/HttpServerExampleSpec.scala#L48-L76" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem
import akka.http.scaladsl.Http
import akka.http.scaladsl.Http.ServerBinding
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer

import scala.concurrent.Future

object WebServer {
  def main(args: Array[String]) {
    implicit val system = ActorSystem()
    implicit val materializer = ActorMaterializer()
    // needed for the future foreach in the end
    implicit val executionContext = system.dispatcher

    val handler = get {
      complete(&quot;Hello world!&quot;)
    }

    // let&#39;s say the OS won&#39;t allow us to bind to 80.
    val (host, port) = (&quot;localhost&quot;, 80)
    val bindingFuture: Future[ServerBinding] =
      Http().bindAndHandle(handler, host, port)

    bindingFuture.failed.foreach { ex =&gt;
      log.error(ex, &quot;Failed to bind to {}:{}!&quot;, host, port)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/java/docs/http/javadsl/server/HighLevelServerBindFailureExample.java#L8-L43" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>import akka.NotUsed;
import akka.actor.ActorSystem;
import akka.http.javadsl.ConnectHttp;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.model.HttpRequest;
import akka.http.javadsl.model.HttpResponse;
import akka.http.javadsl.server.Route;
import akka.http.javadsl.Http;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Flow;

import java.io.IOException;
import java.util.concurrent.CompletionStage;

public class HighLevelServerBindFailureExample {
  public static void main(String[] args) throws IOException {
    // boot up server using the route as defined below
    final ActorSystem system = ActorSystem.create();
    final ActorMaterializer materializer = ActorMaterializer.create(system);

    final HighLevelServerExample app = new HighLevelServerExample();
    final Route route = app.createRoute();

    final Flow&lt;HttpRequest, HttpResponse, NotUsed&gt; handler = route.flow(system, materializer);
    final CompletionStage&lt;ServerBinding&gt; binding = Http.get(system).bindAndHandle(handler, ConnectHttp.toHost(&quot;127.0.0.1&quot;, 8080), materializer);

    binding.exceptionally(failure -&gt; {
      System.err.println(&quot;Something very bad happened! &quot; + failure.getMessage());
      system.terminate();
      return null;
    });

    system.terminate();
  }
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>For a more low-level overview of the kinds of failures that can happen and also more fine-grained control over them refer to the <a href="../server-side/low-level-api.html#handling-http-server-failures-low-level">Handling HTTP Server failures in the Low-Level API</a> documentation.</p></div>
<h3><a href="#failures-and-exceptions-inside-the-routing-dsl" name="failures-and-exceptions-inside-the-routing-dsl" class="anchor"><span class="anchor-link"></span></a>Failures and exceptions inside the Routing DSL</h3>
<p>Exception handling within the Routing DSL is done by providing <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.12/?akka/http/javadsl/server/ExceptionHandler.html" title="akka.http.javadsl.server.ExceptionHandler"><code>ExceptionHandler</code></a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.12/akka/http/scaladsl/server/ExceptionHandler.html" title="akka.http.scaladsl.server.ExceptionHandler"><code>ExceptionHandler</code></a></span> s which are documented in-depth in the <a href="exception-handling.html">Exception Handling</a> section of the documentation. You can use them to transform exceptions into <span class="group-java"><a href="https://doc.akka.io/japi/akka-http/10.1.12/?akka/http/javadsl/model/HttpResponse.html" title="akka.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka-http/10.1.12/akka/http/scaladsl/model/HttpResponse.html" title="akka.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span> s with appropriate error codes and human-readable failure descriptions.</p>
<h2><a href="#file-uploads" name="file-uploads" class="anchor"><span class="anchor-link"></span></a>File uploads</h2>
<p>For high level directives to handle uploads see the <a href="directives/file-upload-directives/index.html">FileUploadDirectives</a>.</p>
<p>Handling a simple file upload from for example a browser form with a <em>file</em> input can be done by accepting a <em>Multipart.FormData</em> entity, note that the body parts are <em>Source</em> rather than all available right away, and so is the individual body part payload so you will need to consume those streams both for the file and for the form fields.</p>
<p>Here is a simple example which just dumps the uploaded file into a temporary file on disk, collects some form fields and saves an entry to a fictive database:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala/docs/http/scaladsl/server/FileUploadExamplesSpec.scala#L31-L67" target="_blank" title="Go to snippet source"></a><code class="language-scala">val uploadVideo =
  path(&quot;video&quot;) {
    entity(as[Multipart.FormData]) { formData =&gt;

      // collect all parts of the multipart as it arrives into a map
      val allPartsF: Future[Map[String, Any]] = formData.parts.mapAsync[(String, Any)](1) {

        case b: BodyPart if b.name == &quot;file&quot; =&gt;
          // stream into a file as the chunks of it arrives and return a future
          // file to where it got stored
          val file = File.createTempFile(&quot;upload&quot;, &quot;tmp&quot;)
          b.entity.dataBytes.runWith(FileIO.toPath(file.toPath)).map(_ =&gt;
            (b.name -&gt; file))

        case b: BodyPart =&gt;
          // collect form field values
          b.toStrict(2.seconds).map(strict =&gt;
            (b.name -&gt; strict.entity.data.utf8String))

      }.runFold(Map.empty[String, Any])((map, tuple) =&gt; map + tuple)

      val done = allPartsF.map { allParts =&gt;
        // You would have some better validation/unmarshalling here
        db.create(Video(
          file = allParts(&quot;file&quot;).asInstanceOf[File],
          title = allParts(&quot;title&quot;).asInstanceOf[String],
          author = allParts(&quot;author&quot;).asInstanceOf[String]))
      }

      // when processing have finished create a response for the user
      onSuccess(allPartsF) { allParts =&gt;
        complete {
          &quot;ok!&quot;
        }
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/java/docs/http/javadsl/server/FileUploadExamplesTest.java#L34-L98" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.http.javadsl.server.Directives.complete;
import static akka.http.javadsl.server.Directives.entity;
import static akka.http.javadsl.server.Directives.onSuccess;
import static akka.http.javadsl.server.Directives.path;

  path(&quot;video&quot;, () -&gt;
  entity(Unmarshaller.entityToMultipartFormData(), formData -&gt; {
    // collect all parts of the multipart as it arrives into a map
    final CompletionStage&lt;Map&lt;String, Object&gt;&gt; allParts =
      formData.getParts().mapAsync(1, bodyPart -&gt; {
        if (&quot;file&quot;.equals(bodyPart.getName())) {
          // stream into a file as the chunks of it arrives and return a CompletionStage
          // file to where it got stored
          final File file = File.createTempFile(&quot;upload&quot;, &quot;tmp&quot;);
          return bodyPart.getEntity().getDataBytes()
            .runWith(FileIO.toPath(file.toPath()), materializer)
            .thenApply(ignore -&gt;
              new Pair&lt;String, Object&gt;(bodyPart.getName(), file)
            );
        } else {
          // collect form field values
          return bodyPart.toStrict(2 * 1000, materializer)
            .thenApply(strict -&gt;
              new Pair&lt;String, Object&gt;(bodyPart.getName(),
                strict.getEntity().getData().utf8String())
            );
        }
      }).runFold(new HashMap&lt;String, Object&gt;(), (acc, pair) -&gt; {
        acc.put(pair.first(), pair.second());
        return acc;
      }, materializer);

    // simulate a DB call
    final CompletionStage&lt;Void&gt; done = allParts.thenCompose(map -&gt;
      // You would have some better validation/unmarshalling here
      DB.create((File) map.get(&quot;file&quot;),
        (String) map.get(&quot;title&quot;),
        (String) map.get(&quot;author&quot;)
      ));

    // when processing have finished create a response for the user
    return onSuccess(allParts, x -&gt; complete(&quot;ok!&quot;));
  })
);</code></pre></dd>
</dl>
<p>You can transform the uploaded files as they arrive rather than storing them in a temporary file as in the previous example. In this example we accept any number of <code>.csv</code> files, parse those into lines and split each line before we send it to an actor for further processing:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/scala/docs/http/scaladsl/server/FileUploadExamplesSpec.scala#L78-L100" target="_blank" title="Go to snippet source"></a><code class="language-scala">val splitLines = Framing.delimiter(ByteString(&quot;\n&quot;), 256)

val csvUploads =
  path(&quot;metadata&quot; / LongNumber) { id =&gt;
    entity(as[Multipart.FormData]) { formData =&gt;
      val done: Future[Done] = formData.parts.mapAsync(1) {
        case b: BodyPart if b.filename.exists(_.endsWith(&quot;.csv&quot;)) =&gt;
          b.entity.dataBytes
            .via(splitLines)
            .map(_.utf8String.split(&quot;,&quot;).toVector)
            .runForeach(csv =&gt;
              metadataActor ! MetadataActor.Entry(id, csv))
        case _ =&gt; Future.successful(Done)
      }.runWith(Sink.ignore)

      // when processing have finished create a response for the user
      onSuccess(done) { _ =&gt;
        complete {
          &quot;ok!&quot;
        }
      }
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/test/java/docs/http/javadsl/server/FileUploadExamplesTest.java#L42-L138" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.http.javadsl.server.Directives.complete;
import static akka.http.javadsl.server.Directives.entity;
import static akka.http.javadsl.server.Directives.onComplete;
import static akka.http.javadsl.server.Directives.path;

Route csvUploads() {
  final Flow&lt;ByteString, ByteString, NotUsed&gt; splitLines =
    Framing.delimiter(ByteString.fromString(&quot;\n&quot;), 256);

  return path(segment(&quot;metadata&quot;).slash(longSegment()), id -&gt;
    entity(Unmarshaller.entityToMultipartFormData(), formData -&gt; {

      final CompletionStage&lt;Done&gt; done = formData.getParts().mapAsync(1, bodyPart -&gt;
        bodyPart.getFilename().filter(name -&gt; name.endsWith(&quot;.csv&quot;)).map(ignored -&gt;
          bodyPart.getEntity().getDataBytes()
            .via(splitLines)
            .map(bs -&gt; bs.utf8String().split(&quot;,&quot;))
            .runForeach(csv -&gt;
                metadataActor.tell(new Entry(id, csv), ActorRef.noSender()),
              materializer)
        ).orElseGet(() -&gt;
          // in case the uploaded file is not a CSV
          CompletableFuture.completedFuture(Done.getInstance()))
      ).runWith(Sink.ignore(), materializer);

      // when processing have finished create a response for the user
      return onComplete(() -&gt; done, ignored -&gt; complete(&quot;ok!&quot;));
    })
  );
}</code></pre></dd>
</dl>
<h2><a href="#configuring-server-side-https" name="configuring-server-side-https" class="anchor"><span class="anchor-link"></span></a>Configuring Server-side HTTPS</h2>
<p>For detailed documentation about configuring and using HTTPS on the server-side refer to <a href="../server-side/server-https-support.html">Server-Side HTTPS Support</a>.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../server-side/low-level-api.html"><i class="icon-prev"></i> <span class="link-prev">Core Server API</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../routing-dsl/overview.html">Routing DSL Overview <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka-http/tree/v10.1.12/docs/src/main/paradox/routing-dsl/index.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<div>Akka HTTP is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-1970 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '0ccbb8bf5148554a406fbf07df0a93b9',
indexName: 'akka-http',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>


</body>
</html>
