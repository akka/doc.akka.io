<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Testing &bull; Akka Enhancements</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka Enhancements is a suite of useful components that complement Akka."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka-enhancements/current/persistence-dc/testing.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-7.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-1.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_setDomainName', '']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="../images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="../images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="../images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="../images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="../images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="../images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="../images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Enhancements</a></h1>
</div>
<div class="nav-header-version">
Version 1.1.16
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../akka-resilience-enhancements.html" class="page">Akka Resilience Enhancements</a></li>
  <li><a href="../akka-persistence-enhancements.html" class="page">Akka Persistence Enhancements</a>
  <ul>
    <li><a href="../persistence-dc/index.html" class="page">Akka Multi-DC Persistence</a>
    <ul>
      <li><a href="../persistence-dc/index.html#akka-persistence-basics" class="header">Akka Persistence basics</a></li>
      <li><a href="../persistence-dc/index.html#motivation" class="header">Motivation</a></li>
      <li><a href="../persistence-dc/index.html#approach" class="header">Approach</a></li>
      <li><a href="../persistence-dc/index.html#dependency" class="header">Dependency</a></li>
      <li><a href="../persistence-dc/index.html#getting-started" class="header">Getting started</a></li>
      <li><a href="../persistence-dc/index.html#resolving-conflicting-updates" class="header">Resolving conflicting updates</a></li>
      <li><a href="../persistence-dc/index.html#side-effects" class="header">Side effects</a></li>
      <li><a href="../persistence-dc/index.html#failures" class="header">Failures</a></li>
      <li><a href="../persistence-dc/index.html#snapshots" class="header">Snapshots</a></li>
      <li><a href="../persistence-dc/index.html#passivating-and-stopping-entities" class="header">Passivating and stopping entities</a></li>
      <li><a href="../persistence-dc/index.html#tagging-events" class="header">Tagging Events</a></li>
      <li><a href="../persistence-dc/index.html#testing" class="header">Testing</a></li>
      <li><a href="../persistence-dc/index.html#how-it-works" class="header">How it works</a></li>
      <li><a href="../persistence-dc/index.html#hot-standby" class="header">Hot-standby</a></li>
      <li><a href="../persistence-dc/index.html#speculative-replication-optimization" class="header">Speculative Replication Optimization</a></li>
      <li><a href="../persistence-dc/index.html#custom-crdt-implementation" class="header group-scala">Custom CRDT implementation</a></li>
      <li><a href="../persistence-dc/index.html#migration-from-to-persistentactor" class="header">Migration from/to PersistentActor</a></li>
      <li><a href="../persistence-dc/index.html#configuration" class="header">Configuration</a></li>
      <li><a href="../persistence-dc/index.html#api-docs" class="header">API docs</a></li>
      <li><a href="../persistence-dc/testing.html#testing" class="active page">Testing</a>
      <ul>
        <li><a href="../persistence-dc/testing.html#dependency" class="header">Dependency</a></li>
        <li><a href="../persistence-dc/testing.html#testing-side-effects" class="header">Testing side effects</a></li>
        <li><a href="../persistence-dc/testing.html#testing-recovery" class="header">Testing recovery</a></li>
        <li><a href="../persistence-dc/testing.html#snapshotting" class="header">Snapshotting</a></li>
        <li><a href="../persistence-dc/testing.html#timeouts-and-timers" class="header">Timeouts and Timers</a></li>
        <li><a href="../persistence-dc/testing.html#integration-testing" class="header">Integration testing</a></li>
        <li><a href="../persistence-dc/testing.html#multi-jvm-testing" class="header group-scala">Multi-JVM testing</a></li>
      </ul></li>
      <li><a href="../persistence-dc/cassandra.html" class="page">Cassandra</a></li>
      <li><a href="../persistence-dc/examples.html" class="page">Additional Examples</a></li>
    </ul></li>
    <li><a href="../gdpr/index.html" class="page">GDPR for Akka Persistence</a></li>
    <li><a href="../akka-persistence-enhancements-release-notes.html" class="page">Akka Persistence Enhancements Release Notes</a></li>
  </ul></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Enhancements</a></h1>
</div>
<div class="nav-header-version">
Version 1.1.16
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../akka-resilience-enhancements.html" class="page">Akka Resilience Enhancements</a></li>
  <li><a href="../akka-persistence-enhancements.html" class="page">Akka Persistence Enhancements</a>
  <ul>
    <li><a href="../persistence-dc/index.html" class="page">Akka Multi-DC Persistence</a>
    <ul>
      <li><a href="../persistence-dc/index.html#akka-persistence-basics" class="header">Akka Persistence basics</a></li>
      <li><a href="../persistence-dc/index.html#motivation" class="header">Motivation</a></li>
      <li><a href="../persistence-dc/index.html#approach" class="header">Approach</a></li>
      <li><a href="../persistence-dc/index.html#dependency" class="header">Dependency</a></li>
      <li><a href="../persistence-dc/index.html#getting-started" class="header">Getting started</a></li>
      <li><a href="../persistence-dc/index.html#resolving-conflicting-updates" class="header">Resolving conflicting updates</a></li>
      <li><a href="../persistence-dc/index.html#side-effects" class="header">Side effects</a></li>
      <li><a href="../persistence-dc/index.html#failures" class="header">Failures</a></li>
      <li><a href="../persistence-dc/index.html#snapshots" class="header">Snapshots</a></li>
      <li><a href="../persistence-dc/index.html#passivating-and-stopping-entities" class="header">Passivating and stopping entities</a></li>
      <li><a href="../persistence-dc/index.html#tagging-events" class="header">Tagging Events</a></li>
      <li><a href="../persistence-dc/index.html#testing" class="header">Testing</a></li>
      <li><a href="../persistence-dc/index.html#how-it-works" class="header">How it works</a></li>
      <li><a href="../persistence-dc/index.html#hot-standby" class="header">Hot-standby</a></li>
      <li><a href="../persistence-dc/index.html#speculative-replication-optimization" class="header">Speculative Replication Optimization</a></li>
      <li><a href="../persistence-dc/index.html#custom-crdt-implementation" class="header group-scala">Custom CRDT implementation</a></li>
      <li><a href="../persistence-dc/index.html#migration-from-to-persistentactor" class="header">Migration from/to PersistentActor</a></li>
      <li><a href="../persistence-dc/index.html#configuration" class="header">Configuration</a></li>
      <li><a href="../persistence-dc/index.html#api-docs" class="header">API docs</a></li>
      <li><a href="../persistence-dc/testing.html#testing" class="active page">Testing</a>
      <ul>
        <li><a href="../persistence-dc/testing.html#dependency" class="header">Dependency</a></li>
        <li><a href="../persistence-dc/testing.html#testing-side-effects" class="header">Testing side effects</a></li>
        <li><a href="../persistence-dc/testing.html#testing-recovery" class="header">Testing recovery</a></li>
        <li><a href="../persistence-dc/testing.html#snapshotting" class="header">Snapshotting</a></li>
        <li><a href="../persistence-dc/testing.html#timeouts-and-timers" class="header">Timeouts and Timers</a></li>
        <li><a href="../persistence-dc/testing.html#integration-testing" class="header">Integration testing</a></li>
        <li><a href="../persistence-dc/testing.html#multi-jvm-testing" class="header group-scala">Multi-JVM testing</a></li>
      </ul></li>
      <li><a href="../persistence-dc/cassandra.html" class="page">Cassandra</a></li>
      <li><a href="../persistence-dc/examples.html" class="page">Additional Examples</a></li>
    </ul></li>
    <li><a href="../gdpr/index.html" class="page">GDPR for Akka Persistence</a></li>
    <li><a href="../akka-persistence-enhancements-release-notes.html" class="page">Akka Persistence Enhancements Release Notes</a></li>
  </ul></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#testing" name="testing" class="anchor"><span class="anchor-link"></span></a>Testing</h1>
<p>The <code>akka-persistence-multi-dc-testkit</code> module provides a <code>Simulator</code> for unit testing replicated entities without using a database. Fine-grained control is available for inspecting side effects and simulating various scenario&rsquo;s and replication orderings.</p>
<p>For more realistic but more heavy &lsquo;integration test&rsquo;-style tests you might want to consider writing a <a href="#integration-testing">Multi JVM Test</a> in addition to simulator-based tests.</p>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use the simulator and the Cassandra launcher described below you will need the <code>akka-persistence-multi-dc-testkit</code> dependency:</p>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre><code>// Add Lightbend Platform to your build as documented at https://developer.lightbend.com/docs/lightbend-platform/introduction/getting-started/subscription-and-credentials.html
&quot;com.lightbend.akka&quot; %% &quot;akka-persistence-multi-dc-testkit&quot; % &quot;1.1.16&quot; % Test
</code></pre></dd>
  <dt>Gradle</dt>
  <dd>
  <pre><code>// Add Lightbend Platform to your build as documented at https://developer.lightbend.com/docs/lightbend-platform/introduction/getting-started/subscription-and-credentials.html
dependencies {
  testCompile group: &#39;com.lightbend.akka&#39;, name: &#39;akka-persistence-multi-dc-testkit_2.12&#39;, version: &#39;1.1.16&#39;
}
</code></pre></dd>
  <dt>Maven</dt>
  <dd>
  <pre><code>&lt;!-- Add Lightbend Platform to your build as documented at https://developer.lightbend.com/docs/lightbend-platform/introduction/getting-started/subscription-and-credentials.html --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.lightbend.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-persistence-multi-dc-testkit_2.12&lt;/artifactId&gt;
  &lt;version&gt;1.1.16&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre></dd>
</dl><p>Before you can access this library, you&rsquo;ll need to <a href="https://developer.lightbend.com/docs/lightbend-platform/introduction/getting-started/subscription-and-credentials.html">configure the Lightbend repository and credentials in your build</a>.</p>
<h3><a href="#basic-simulator-usage" name="basic-simulator-usage" class="anchor"><span class="anchor-link"></span></a>Basic simulator usage</h3>
<p>A simple use of the simulator might look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import BuggyEntity._
val simulator = createSimulator(() =&gt; new BuggyEntity(), selfDc = allDcs.head, allDcs)

simulator.runCommand(Append(&quot;Hello&quot;))
simulator.replicatedEvent(Appended(&quot; World&quot;))
simulator.runCommand(Append(&quot;foo&quot;), Append(&quot;bar&quot;))

simulator.state() should ===(&quot;Hello Worldfoobar&quot;)
simulator.events().length should ===(4)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Simulator&lt;Commands.Command, Events.Event, String&gt; simulator = createSimulator(() -&gt; new BuggyEntity());
simulator.runCommand(new Commands.Append(&quot;Hello&quot;));
simulator.replicatedEvent(new Events.Appended(&quot; World&quot;));
simulator.runCommand(new Commands.Append(&quot;foo&quot;), new Commands.Append(&quot;bar&quot;));

assertEquals(&quot;Hello Worldfoobar&quot;, simulator.state());
assertEquals(4, simulator.getEvents().size());</code></pre></dd>
</dl>
<p>The <code>createSimulator</code> helper method is a convenience method that makes it easy to create a <code>Simulator</code> under a mostly-empty <code>ActorSystem</code> and makes sure its lifecycle is correctly tied into your test framework of choice. For example, under <span class="group-scala">scalatest</span><span class="group-java">junit</span> the complete test might look like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import scala.concurrent.{ Future, Promise }
import akka.actor.ActorRef
import akka.persistence.multidc.scaladsl.{ Effect, EffectFactories, ReplicatedEntity }
import org.scalatest.{ Matchers, WordSpecLike }
class SimulatorSpec extends WordSpecLike with ScalatestSimulator with Matchers {
  import SimulatorSpec._

  val allDcs = Set(&quot;DC-A&quot;, &quot;DC-B&quot;)

  &quot;The simulator&quot; should {
    &quot;allow writing a test controlling replication manually&quot; in {
      import BuggyEntity._
      val simulator = createSimulator(() =&gt; new BuggyEntity(), selfDc = allDcs.head, allDcs)

      simulator.runCommand(Append(&quot;Hello&quot;))
      simulator.replicatedEvent(Appended(&quot; World&quot;))
      simulator.runCommand(Append(&quot;foo&quot;), Append(&quot;bar&quot;))

      simulator.state() should ===(&quot;Hello Worldfoobar&quot;)
      simulator.events().length should ===(4)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import akka.actor.ActorSystem;
import akka.persistence.multidc.javadsl.ReplicatedEntity;
import akka.persistence.multidc.testkit.Simulator;
import akka.testkit.javadsl.TestKit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.function.Supplier;

import static org.junit.Assert.assertEquals;

public class BasicTest extends JUnitSuite {
  private static ActorSystem system;

  @BeforeClass
  public static void startActorSystem() {
    system = ActorSystem.create(&quot;test&quot;);
  }

  private String selfDc = &quot;DC-A&quot;;
  private Set&lt;String&gt; allDcs = new HashSet&lt;&gt;(Arrays.asList(selfDc, &quot;DC-B&quot;));

  public &lt;C, E, S&gt; Simulator&lt;C, E, S&gt; createSimulator(Supplier&lt;ReplicatedEntity&lt;C, E, S&gt;&gt; entityCtor) {
    return Simulator.&lt;C, E, S&gt;create(entityCtor, system, selfDc, allDcs, Optional.empty());
  }

  @Test
  public void testBasicSimulator() {
    Simulator&lt;Commands.Command, Events.Event, String&gt; simulator = createSimulator(() -&gt; new BuggyEntity());
    simulator.runCommand(new Commands.Append(&quot;Hello&quot;));
    simulator.replicatedEvent(new Events.Appended(&quot; World&quot;));
    simulator.runCommand(new Commands.Append(&quot;foo&quot;), new Commands.Append(&quot;bar&quot;));

    assertEquals(&quot;Hello Worldfoobar&quot;, simulator.state());
    assertEquals(4, simulator.getEvents().size());
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
  }
}</code></pre></dd>
</dl>
<p>For the sake of completeness, the entity under test looks like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">/**
 * This entity is buggy because replica&#39;s will end up in different states when events are persisted
 * concurrently in different data centres.
 */
object BuggyEntity {

  sealed trait Command
  case class Append(string: String) extends Command
  case class Get(replyTo: ActorRef) extends Command

  sealed trait Event
  case class Appended(string: String) extends Event

  type State = String
}

class BuggyEntity extends ReplicatedEntity[BuggyEntity.Command, BuggyEntity.Event, BuggyEntity.State] {
  import BuggyEntity._
  override val initialState = &quot;&quot;

  override def commandHandler = CommandHandler { (ctx, state, cmd) =&gt;
    cmd match {
      case Get(replyTo) =&gt;
        replyTo ! state
        Effect.none
      case Append(string) =&gt;
        Effect.persist(Appended(string))
    }
  }

  override def eventHandler(state: State, event: Event): State = event match {
    case Appended(string) =&gt; state + string
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import akka.persistence.multidc.javadsl.CommandHandler;
import akka.persistence.multidc.javadsl.EventHandler;
import akka.persistence.multidc.javadsl.ReplicatedEntity;

/**
 * This entity is buggy because replica&#39;s will end up in different states when events are persisted
 * concurrently in different data centres.
 */
public class BuggyEntity extends ReplicatedEntity&lt;Commands.Command, Events.Event, String&gt; {
  @Override
  public String initialState() {
    return &quot;&quot;;
  }

  @Override
  public CommandHandler&lt;Commands.Command, Events.Event, String&gt; commandHandler() {
    return commandHandlerBuilder(Commands.Command.class)
        .matchCommand(Commands.Get.class, (ctx, state, get) -&gt; {
          ctx.getSender().tell(state, ctx.getSelf());
          return Effect().none();
        })
        .matchCommand(Commands.Append.class, (ctx, state, append) -&gt; {
          return Effect().persist(new Events.Appended(append.string));
        })
        .build();
  }

  @Override
  public EventHandler&lt;Events.Event, String&gt; eventHandler() {
    return eventHandlerBuilder(Events.Event.class)
        .matchEvent(Events.Appended.class, (state, appended) -&gt; {
          return state + appended.string;
        })
        .build();
  }
}</code></pre></dd>
</dl>
<h2><a href="#testing-side-effects" name="testing-side-effects" class="anchor"><span class="anchor-link"></span></a>Testing side effects</h2>
<p>To demonstrate some more advanced testing scenario&rsquo;s, we introduce a <code>ReliableDeliverer</code> actor implementation which we will test. This actor implements an &ldquo;at-least-once&rdquo; delivery: after accepting a task and persisting the intent of performing some async action, we immediately send a <code>DeliveryScheduled</code> acknowledgement to the sender. Then we attempt to perform some async call, retrying in case of restarts, sending a final <code>DeliveryAcknowledged</code> at a best-effort basis. Typically you might also want to trigger retries with a <code>Timer</code>, but this has been left out of this example for brevity.</p>
<p>The actor under test looks like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object ReliableDeliverer {
  sealed trait Command
  case class Deliver(payload: String) extends Command
  sealed abstract class InternalCommand extends Command
  case class ActionPerformed(payload: String) extends InternalCommand

  case object DeliveryScheduled
  case object DeliveryAcknowledged

  sealed trait Event
  case class Promised(payload: String) extends Event
  case class Acknowledged(payload: String) extends Event

  case class State(pendingPayloads: List[String])
}
class ReliableDeliverer(useThisDcDuringRecovery: Boolean = true) extends ReplicatedEntity[ReliableDeliverer.Command, ReliableDeliverer.Event, ReliableDeliverer.State] {
  import akka.pattern.pipe
  import ReliableDeliverer._

  // Transient mutable state (not part of the state managed by event sourcing)
  // which means it will be lost when the actor is restarted, and delivery acknowledgements
  // might go missing even though the delivery is in fact retried.
  var acknowledgementsTo: Map[String, ActorRef] = Map.empty

  override val initialState = State(List.empty)

  override def commandHandler = CommandHandler { (ctx, state, cmd) =&gt;
    cmd match {
      case Deliver(payload) =&gt;
        import ctx.dispatcher
        acknowledgementsTo = acknowledgementsTo.updated(payload, ctx.sender())
        Effect.persist(Promised(payload))
          .andThen(_ =&gt; performAsyncCall(payload).pipeTo(ctx.self))
          .andThen(_ =&gt; ctx.sender() ! DeliveryScheduled)
      case ActionPerformed(payload) =&gt;
        Effect.persist(Acknowledged(payload))
          .andThen { _ =&gt;
            acknowledgementsTo.get(payload).foreach(_ ! DeliveryAcknowledged)
            acknowledgementsTo = acknowledgementsTo - payload
          }
    }
  }

  override def eventHandler(state: State, event: Event): State = event match {
    case Promised(payload) =&gt;
      state.copy(state.pendingPayloads :+ payload)
    case Acknowledged(payload) =&gt;
      state.copy(state.pendingPayloads.filter(_ != payload))
  }

  override def recoveryCompleted(ctx: ActorContext, state: State): Effect[Event, State] = {
    if (useThisDcDuringRecovery) {
      import ctx.dispatcher
      state.pendingPayloads.foreach(payload =&gt; performAsyncCall(payload).pipeTo(ctx.self))
    }

    Effect.none
  }

  def performAsyncCall(payload: String): Future[ActionPerformed] = ???
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.reliabledeliverer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import akka.Done;
import akka.actor.ActorRef;
import akka.persistence.multidc.javadsl.CommandHandler;
import akka.persistence.multidc.javadsl.Effect;
import akka.persistence.multidc.javadsl.EventHandler;
import akka.persistence.multidc.javadsl.ReplicatedEntity;

import static akka.pattern.PatternsCS.pipe;

public class ReliableDeliverer extends ReplicatedEntity&lt;Commands.Command, Events.Event, List&lt;String&gt;&gt; {
  private boolean useThisDcDuringRecovery;

  // Transient mutable state (not part of the state managed by event sourcing)
  private Map&lt;String, ActorRef&gt; acknowledgementsTo = new HashMap&lt;&gt;();

  public ReliableDeliverer(boolean useThisDcDuringRecovery) {
    this.useThisDcDuringRecovery = useThisDcDuringRecovery;
  }

  @Override
  public List&lt;String&gt; initialState() {
    return new ArrayList&lt;&gt;();
  }

  @Override
  public CommandHandler&lt;Commands.Command, Events.Event, List&lt;String&gt;&gt; commandHandler() {
    return commandHandlerBuilder(Commands.Command.class)
      .matchCommand(Commands.Deliver.class, (ctx, state, deliver) -&gt; {
        acknowledgementsTo.put(deliver.payload, ctx.getSender());
        return Effect().persist(new Events.Promised(deliver.payload))
          .andThen(s -&gt; pipe(performAsyncCall(deliver.payload), ctx.getDispatcher()).to(ctx.getSelf()))
          .andThen(s -&gt; ctx.getSender().tell(Messages.DeliveryScheduled.getInstance(), ctx.getSelf()));
      })
      .matchCommand(Commands.ActionPerformed.class, (ctx, state, actionPerformed) -&gt; {
        return Effect().persist(new Events.Acknowledged(actionPerformed.payload))
          .andThen(s -&gt; {
            ActorRef sender = acknowledgementsTo.get(actionPerformed.payload);
            if (sender != null) {
              sender.tell(Messages.DeliveryAcknowledged.getInstance(), ActorRef.noSender());
              acknowledgementsTo.remove(actionPerformed.payload);
            }
          });
      })
      .build();
  }

  @Override
  public EventHandler&lt;Events.Event, List&lt;String&gt;&gt; eventHandler() {
    return eventHandlerBuilder(Events.Event.class)
      .matchEvent(Events.Promised.class, (state, event) -&gt; {
        List&lt;String&gt; newState = new ArrayList&lt;&gt;(state);
        newState.add(event.payload);
        return newState;
      })
      .matchEvent(Events.Acknowledged.class, (state, event) -&gt; {
        List&lt;String&gt; newState = new ArrayList&lt;&gt;(state);
        newState.remove(event.payload);
        return newState;
      })
      .build();
  }

  @Override
  public Effect&lt;Events.Event, List&lt;String&gt;&gt; recoveryCompleted(ActorContext ctx, List&lt;String&gt; state) {
    if (useThisDcDuringRecovery) {
      for (String payload : state) {
        pipe(performAsyncCall(payload), ctx.getDispatcher()).to(ctx.getSelf());
      }
    }

    return Effect().none();
  }

  CompletableFuture&lt;Commands.ActionPerformed&gt; performAsyncCall(String payload) {
    throw new UnsupportedOperationException();
  }
}</code></pre></dd>
</dl>
<p>Testing that it indeed sends both a <code>DeliveryScheduled</code> and a <code>DeliveryAcknowledged</code> back to the sender for the &ldquo;happy path&rdquo; scenario can be demonstrated with the following test:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import ReliableDeliverer._
import akka.testkit.CallingThreadDispatcher

val simulator = createSimulator(() =&gt; new ReliableDeliverer() {
  override def performAsyncCall(payload: String): Future[ActionPerformed] = Future.successful(ActionPerformed(payload))
}, selfDc = allDcs.head, allDcs, Some(CallingThreadDispatcher.Id))
simulator.runCommand(Deliver(&quot;Some Payload&quot;))
simulator.responses shouldBe Seq(DeliveryScheduled)
simulator.selfMessages shouldBe Seq(ActionPerformed(&quot;Some Payload&quot;))

simulator.runCommand(ActionPerformed(&quot;Some Payload&quot;))
simulator.responses shouldBe Seq(DeliveryScheduled, DeliveryAcknowledged)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.reliabledeliverer;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

import akka.Done;
import akka.actor.ActorSystem;
import akka.persistence.multidc.javadsl.ReplicatedEntity;
import akka.persistence.multidc.testkit.Simulator;
import akka.persistence.multidc.testkit.reliabledeliverer.ReliableDeliverer;
import akka.persistence.multidc.testkit.reliabledeliverer.Commands;
import akka.persistence.multidc.testkit.reliabledeliverer.Events;
import akka.persistence.multidc.testkit.reliabledeliverer.Messages;
import akka.testkit.javadsl.TestKit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import static org.junit.Assert.assertTrue;

public class SenderTest extends JUnitSuite {
  private static ActorSystem system;

  @BeforeClass
  public static void startActorSystem() {
    system = ActorSystem.create(&quot;test&quot;);
  }

  private String selfDc = &quot;DC-A&quot;;
  private Set&lt;String&gt; allDcs = new HashSet&lt;&gt;(Arrays.asList(selfDc, &quot;DC-B&quot;));

  public &lt;C, E, S&gt; Simulator&lt;C, E, S&gt; createSimulator(Supplier&lt;ReplicatedEntity&lt;C, E, S&gt;&gt; entityCtor) {
    return Simulator.&lt;C, E, S&gt;create(entityCtor, system, selfDc, allDcs, Optional.empty());
  }

  @Test
  public void testObserveResponseToSender() {
    Simulator&lt;Commands.Command, Events.Event, List&lt;String&gt;&gt; simulator = createSimulator(() -&gt; new ReliableDeliverer(true) {
      @Override
      CompletableFuture&lt;Commands.ActionPerformed&gt; performAsyncCall(String payload) {
        return CompletableFuture.completedFuture(new Commands.ActionPerformed(payload));
      }
    });
    simulator.runCommand(new Commands.Deliver(&quot;Some Payload&quot;));
    assertTrue(simulator.getResponses().contains(Messages.DeliveryScheduled.getInstance()));
    assertTrue(simulator.getSelfMessages().contains(new Commands.ActionPerformed(&quot;Some Payload&quot;)));

    simulator.runCommand(new Commands.ActionPerformed(&quot;Some Payload&quot;));
    assertTrue(simulator.getResponses().contains(Messages.DeliveryAcknowledged.getInstance()));
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
  }
}</code></pre></dd>
</dl>
<h2><a href="#testing-recovery" name="testing-recovery" class="anchor"><span class="anchor-link"></span></a>Testing recovery</h2>
<p>Of course it is important to test the logic of your replicated entity is also consistent after recovery. The simulator provides a convenient <code>.restart()</code> method to start a new instance of the replicated entity and apply the recovery logic. Do note that this does not actually restart the actor system used for hosting the tests.</p>
<p>To demonstrate testing recovery, we can for example show the recovery behavior of the <code>ReliableDeliverer</code> actor introduced in the previous section:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import ReliableDeliverer._

var futureToReturn = Promise[ActionPerformed]().future

val simulator = createSimulator(() =&gt; new ReliableDeliverer() {
  override def performAsyncCall(payload: String): Future[ActionPerformed] = futureToReturn
}, selfDc = allDcs.head, allDcs, Some(CallingThreadDispatcher.Id))
simulator.runCommand(Deliver(&quot;Some Payload&quot;))
simulator.responses shouldBe Seq(DeliveryScheduled)

futureToReturn = Future.successful(ActionPerformed(&quot;Some Payload&quot;))
simulator.restart()

simulator.selfMessages shouldBe Seq(ActionPerformed(&quot;Some Payload&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.reliabledeliverer;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

import akka.actor.ActorSystem;
import akka.persistence.multidc.javadsl.ReplicatedEntity;
import akka.persistence.multidc.testkit.Simulator;
import akka.persistence.multidc.testkit.reliabledeliverer.ReliableDeliverer;
import akka.persistence.multidc.testkit.reliabledeliverer.Commands;
import akka.persistence.multidc.testkit.reliabledeliverer.Events;
import akka.persistence.multidc.testkit.reliabledeliverer.Messages;
import akka.testkit.CallingThreadDispatcher;
import akka.testkit.javadsl.TestKit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;

public class RecoveryTest extends JUnitSuite {
  private static ActorSystem system;

  @BeforeClass
  public static void startActorSystem() {
    system = ActorSystem.create(&quot;test&quot;);
  }

  private String selfDc = &quot;DC-A&quot;;
  private Set&lt;String&gt; allDcs = new HashSet&lt;&gt;(Arrays.asList(selfDc, &quot;DC-B&quot;));

  public &lt;C, E, S&gt; Simulator&lt;C, E, S&gt; createSimulator(Supplier&lt;ReplicatedEntity&lt;C, E, S&gt;&gt; entityCtor, String dispatcherId) {
    return Simulator.&lt;C, E, S&gt;create(entityCtor, system, selfDc, allDcs, Optional.of(dispatcherId));
  }

  @Test
  public void testObserveResponseToSender() {
    final Holder&lt;CompletableFuture&lt;Commands.ActionPerformed&gt;&gt; futureToReturn = new Holder&lt;&gt;(new CompletableFuture&lt;&gt;());

    Simulator&lt;Commands.Command, Events.Event, List&lt;String&gt;&gt; simulator = createSimulator(() -&gt; new ReliableDeliverer(true) {
      @Override
      CompletableFuture&lt;Commands.ActionPerformed&gt; performAsyncCall(String payload) {
        System.out.println(&quot;Returning &quot; + futureToReturn.value);
        return futureToReturn.value;
      }
    }, CallingThreadDispatcher.Id());
    simulator.runCommand(new Commands.Deliver(&quot;Some Payload&quot;));
    assertTrue(simulator.getResponses().contains(Messages.DeliveryScheduled.getInstance()));
    assertFalse(simulator.getSelfMessages().contains(new Commands.ActionPerformed(&quot;Some Payload&quot;)));

    futureToReturn.value = CompletableFuture.completedFuture(new Commands.ActionPerformed(&quot;Some Payload&quot;));
    simulator.restart();

    assertTrue(simulator.getSelfMessages().contains(new Commands.ActionPerformed(&quot;Some Payload&quot;)));
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
  }
}</code></pre></dd>
</dl>
<h2><a href="#snapshotting" name="snapshotting" class="anchor"><span class="anchor-link"></span></a>Snapshotting</h2>
<p>When snapshots are used to make recovery more efficient:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object Snapshotting {
  sealed trait Command
  case class Append(string: String) extends Command
  case object Get extends Command
  case object EventsHandled extends Command

  sealed trait Event
  case class Appended(string: String) extends Event

  type State = String
}
class Snapshotting extends ReplicatedEntity[Snapshotting.Command, Snapshotting.Event, Snapshotting.State] {
  import Snapshotting._

  override val initialState = &quot;&quot;

  // Sneaky unmanaged state:
  var eventsHandled = 0

  override def commandHandler = CommandHandler { (ctx, state, cmd) =&gt;
    cmd match {
      case Get =&gt;
        ctx.sender() ! state
        Effect.none
      case EventsHandled =&gt;
        ctx.sender() ! eventsHandled
        Effect.none
      case Append(string) =&gt;
        Effect.persist(Appended(string))
    }
  }

  override def eventHandler(state: State, event: Event): State = event match {
    case Appended(string) =&gt;
      eventsHandled = eventsHandled + 1
      state + string
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.snapshotting;

import akka.persistence.multidc.javadsl.CommandHandler;
import akka.persistence.multidc.javadsl.EventHandler;
import akka.persistence.multidc.javadsl.ReplicatedEntity;

public class Snapshotting extends ReplicatedEntity&lt;Commands.Command, Events.Appended, String&gt; {

  // Sneaky unmanaged state:
  private Integer eventsHandled = 0;

  @Override
  public String initialState() {
    return &quot;&quot;;
  }

  @Override
  public CommandHandler&lt;Commands.Command, Events.Appended, String&gt; commandHandler() {
    return commandHandlerBuilder(Commands.Command.class)
      .matchCommand(Commands.Get.class, (ctx, state, get) -&gt; {
        ctx.getSender().tell(state, ctx.getSelf());
        return Effect().none();
      })
      .matchCommand(Commands.EventsHandled.class, (ctx, state, eventsHandled) -&gt; {
        ctx.getSender().tell(this.eventsHandled, ctx.getSelf());
        return Effect().none();
      })
      .matchCommand(Commands.Append.class, (ctx, state, append) -&gt; {
        return Effect().persist(new Events.Appended(append.string));
      })
      .build();
  }

  @Override
  public EventHandler&lt;Events.Appended, String&gt; eventHandler() {
    return eventHandlerBuilder(Events.Appended.class)
      .matchEvent(Events.Appended.class, (state, appended) -&gt; {
        eventsHandled++;
        return state + appended.string;
      })
      .build();
  }
}</code></pre></dd>
</dl>
<p>The simulator correctly takes this into account and replays the events starting from the point of the snapshot:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import Snapshotting._
val simulator = createSimulator(() =&gt; new Snapshotting(), selfDc = allDcs.head, allDcs)
simulator.runCommand(Append(&quot;First&quot;))
simulator.takeSnapshot()
simulator.runCommand(Append(&quot;Second&quot;))

simulator.runCommand(Get)
simulator.runCommand(EventsHandled)
simulator.responses() shouldBe Seq(&quot;FirstSecond&quot;, 2)

simulator.restart()

simulator.runCommand(Get)
simulator.runCommand(EventsHandled)
// TODO perhaps reading the responses should clear them as a side effect, like expectMessage etc
simulator.responses() shouldBe Seq(&quot;FirstSecond&quot;, 2, &quot;FirstSecond&quot;, 1)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.snapshotting;

import akka.actor.ActorSystem;
import akka.persistence.multidc.javadsl.ReplicatedEntity;
import akka.persistence.multidc.testkit.Simulator;
import akka.testkit.javadsl.TestKit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.function.Supplier;

import static org.junit.Assert.assertTrue;

public class SnapshottingTest extends JUnitSuite {
  private static ActorSystem system;

  @BeforeClass
  public static void startActorSystem() {
    system = ActorSystem.create(&quot;test&quot;);
  }

  private String selfDc = &quot;DC-A&quot;;
  private Set&lt;String&gt; allDcs = new HashSet&lt;&gt;(Arrays.asList(selfDc, &quot;DC-B&quot;));

  public &lt;C, E, S&gt; Simulator&lt;C, E, S&gt; createSimulator(Supplier&lt;ReplicatedEntity&lt;C, E, S&gt;&gt; entityCtor) {
    return Simulator.&lt;C, E, S&gt;create(entityCtor, system, selfDc, allDcs, Optional.empty());
  }

  @Test
  public void testSnapshotting() {
    Simulator&lt;Commands.Command, Events.Appended, String&gt; simulator = createSimulator(() -&gt; new Snapshotting());
    simulator.runCommand(new Commands.Append(&quot;First&quot;));
    simulator.takeSnapshot();
    simulator.runCommand(new Commands.Append(&quot;Second&quot;));

    simulator.runCommand(new Commands.Get());
    assertTrue(simulator.responses().contains(&quot;FirstSecond&quot;));
    simulator.runCommand(new Commands.EventsHandled());
    assertTrue(simulator.responses().contains(2));
    simulator.clearResponses();

    simulator.restart();

    simulator.runCommand(new Commands.Get());
    assertTrue(simulator.responses().contains(&quot;FirstSecond&quot;));
    simulator.runCommand(new Commands.EventsHandled());
    assertTrue(simulator.responses().contains(1));
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
  }
}</code></pre></dd>
</dl>
<h2><a href="#timeouts-and-timers" name="timeouts-and-timers" class="anchor"><span class="anchor-link"></span></a>Timeouts and Timers</h2>
<p>In the following example we have a test that shuts itself down when its receive timeout has been triggered:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">class StopWhenIdle extends ReplicatedEntity[Unit, Unit, Unit] {
  override def initialState: Unit = ()

  override def commandHandler = CommandHandler {
    (_, _, _) =&gt; Effect.unhandled
  }.onReceiveTimeout {
    case (ctx, state) =&gt; Effect.stop
  }

  override def eventHandler(state: Unit, event: Unit): Unit = ()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.stopwhenidle;

import akka.persistence.multidc.javadsl.CommandHandler;
import akka.persistence.multidc.javadsl.EventHandler;
import akka.persistence.multidc.javadsl.ReplicatedEntity;

public class StopWhenIdle extends ReplicatedEntity&lt;Void, Void, Void&gt; {
  @Override
  public Void initialState() {
    return null;
  }

  @Override
  public CommandHandler&lt;Void, Void, Void&gt; commandHandler() {
    return commandHandlerBuilder(Void.class)
      .onReceiveTimeout((ctx, state, rt) -&gt; Effect().stop())
      .build();
  }

  @Override
  public EventHandler&lt;Void, Void&gt; eventHandler() {
    return null;
  }
}</code></pre></dd>
</dl>
<p>In its test, a receive timeout can be explicitly triggered:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val simulator = createSimulator(() =&gt; new StopWhenIdle(), selfDc = allDcs.head, allDcs)
simulator.triggerReceiveTimeout()
simulator.stopped() shouldBe true</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.stopwhenidle;

import akka.actor.ActorSystem;
import akka.persistence.multidc.javadsl.ReplicatedEntity;
import akka.persistence.multidc.testkit.Simulator;
import akka.testkit.javadsl.TestKit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

import static org.junit.Assert.assertTrue;

public class ReceiveTimeoutTest extends JUnitSuite {
  private static ActorSystem system;

  @BeforeClass
  public static void startActorSystem() {
    system = ActorSystem.create(&quot;test&quot;);
  }

  private String selfDc = &quot;DC-A&quot;;
  private Set&lt;String&gt; allDcs = new HashSet&lt;&gt;(Arrays.asList(selfDc, &quot;DC-B&quot;));

  public &lt;C, E, S&gt; Simulator&lt;C, E, S&gt; createSimulator(Supplier&lt;ReplicatedEntity&lt;C, E, S&gt;&gt; entityCtor) {
    return Simulator.&lt;C, E, S&gt;create(entityCtor, system, selfDc, allDcs, Optional.empty());
  }

  @Test
  public void testReceiveTimeout() {
    Simulator simulator = createSimulator(() -&gt; new StopWhenIdle());
    simulator.triggerReceiveTimeout();
    assertTrue(simulator.stopped());
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
  }
}</code></pre></dd>
</dl>
<p>When a replicated entity uses the powerful Timers API:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object Ticking {
  case object TickKey

  sealed trait Command
  case object FirstTick extends Command

  case object Tick
}

class Ticking extends ReplicatedEntity[Ticking.Command, Int, Int] {
  import scala.concurrent.duration._
  import Ticking._

  override val initialState = 0

  override def commandHandler = CommandHandler { (ctx, state, cmd) =&gt;
    cmd match {
      case FirstTick =&gt;
        ctx.timers.startPeriodicTimer(TickKey, Tick, 1.second)
        Effect.none
    }
  }.onTimer[Tick.type] { (ctx, state, tick) =&gt;
    tick match {
      case Tick =&gt; Effect.persist(1)
    }
  }

  override def eventHandler(state: Int, event: Int): Int = state + event
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.timers;

import java.util.concurrent.TimeUnit;

import scala.concurrent.duration.Duration;

import akka.persistence.multidc.javadsl.CommandHandler;
import akka.persistence.multidc.javadsl.EventHandler;
import akka.persistence.multidc.javadsl.ReplicatedEntity;

import akka.persistence.multidc.testkit.timers.Tick;
import akka.persistence.multidc.testkit.timers.FirstTick;

public class Ticking extends ReplicatedEntity&lt;FirstTick, Integer, Integer&gt; {
  public static final Object TICK_KEY = &quot;TickKey&quot;;

  @Override
  public Integer initialState() {
    return 0;
  }

  @Override
  public CommandHandler&lt;FirstTick, Integer, Integer&gt; commandHandler() {
    return commandHandlerBuilder(FirstTick.class)
      .matchCommand(FirstTick.class, (ctx, state, firstTick) -&gt; {
        // FIXME Java API for setting timers, not taking a FiniteDuration
        ctx.getTimers().startPeriodicTimer(TICK_KEY, Tick.getInstance(), Duration.create(1, TimeUnit.SECONDS));
        return Effect().none();
      })
      .onTimer(Tick.class, (ctx, state, tick) -&gt; {
        return Effect().persist(1);
      })
      .build();
  }

  @Override
  public EventHandler&lt;Integer, Integer&gt; eventHandler() {
    return eventHandlerBuilder(Integer.class)
      .matchAny((state, event) -&gt; state + event);
  }
}</code></pre></dd>
</dl>
<p>The simulator API allows timers to be inspected and triggered:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import Ticking._
val simulator = createSimulator(() =&gt; new Ticking(), selfDc = allDcs.head, allDcs)
simulator.runCommand(FirstTick)

simulator.isTimerActive(TickKey) shouldBe true
simulator.triggerTimer(TickKey)

simulator.isTimerActive(TickKey) shouldBe true
simulator.state shouldBe 1</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">package akka.persistence.multidc.testkit.timers;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.function.Supplier;

import akka.actor.ActorSystem;

import akka.persistence.multidc.javadsl.ReplicatedEntity;
import akka.persistence.multidc.testkit.timers.Tick;
import akka.persistence.multidc.testkit.timers.FirstTick;

import akka.testkit.javadsl.TestKit;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import akka.persistence.multidc.testkit.Simulator;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertEquals;

public class TimerTest extends JUnitSuite {
  private static ActorSystem system;

  @BeforeClass
  public static void startActorSystem() {
    system = ActorSystem.create(&quot;test&quot;);
  }

  private String selfDc = &quot;DC-A&quot;;
  private Set&lt;String&gt; allDcs = new HashSet&lt;&gt;(Arrays.asList(selfDc, &quot;DC-B&quot;));


  public &lt;C, E, S&gt; Simulator&lt;C, E, S&gt; createSimulator(Supplier&lt;ReplicatedEntity&lt;C, E, S&gt;&gt; entityCtor) {
    return Simulator.&lt;C, E, S&gt;create(entityCtor, system, selfDc, allDcs, Optional.empty());
  }

  @Test
  public void testTimers() {
    Simulator&lt;FirstTick, Integer, Integer&gt; simulator = createSimulator(() -&gt; new Ticking());
    simulator.runCommand(FirstTick.getInstance());

    assertTrue(simulator.isTimerActive(Ticking.TICK_KEY));
    simulator.triggerTimer(Ticking.TICK_KEY);

    assertTrue(simulator.isTimerActive(Ticking.TICK_KEY));
    assertEquals(Integer.valueOf(1), simulator.state());
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
  }
}</code></pre></dd>
</dl>
<h2><a href="#integration-testing" name="integration-testing" class="anchor"><span class="anchor-link"></span></a>Integration testing</h2>
<p>It is also possible to test your replicated entity using an integration test. Such a test starts a number of actor systems, and provides some tools to simulate failures. These would typically connect to a real cassandra instance, making them more faithful but also rather heavy.</p>
<p>To make it easier to spawn a temporary Cassandra instance for testing <code>akka-persistence-multi-dc-testkit</code> provides a <code>CassandraLifecycle</code> utility. This can be relatively easily hooked into your test framework, for example for <span class="group-scala">scalatest your could use a trait</span><span class="group-java">JUnit you could initialize it</span> like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import akka.testkit.TestKitBase
import akka.persistence.cassandra.testkit.CassandraLauncher
import org.scalatest.BeforeAndAfterAll
import org.scalatest.Suite

trait CassandraLifecycleScalatest extends BeforeAndAfterAll { this: TestKitBase with Suite =&gt;

  import CassandraLifecycle._

  def systemName: String

  def cassandraConfigResource: String = CassandraLauncher.DefaultTestConfigResource

  override protected def beforeAll(): Unit = {
    startCassandra(systemName, cassandraConfigResource)
    awaitPersistenceInit(system)
    super.beforeAll()
  }

  override protected def afterAll(): Unit = {
    shutdown(system, verifySystemShutdown = true)
    stopCassandra()
    super.afterAll()
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import akka.persistence.multidc.testkit.CassandraLifecycle;
import akka.persistence.multidc.testkit.PersistenceMultiDcTestKit;


public class AuctionExampleTest extends JUnitSuite {
  private static ActorSystem system;
  private static ActorSystem otherSystem;

  @BeforeClass
  public static void setupSystems() {
    system = createSystem(&quot;DC-A&quot;);
    CassandraLifecycle.startCassandra(system.name(), CassandraLauncher.DefaultTestConfigResource());
    CassandraLifecycle.awaitPersistenceInit(system);

    otherSystem = createSystem(&quot;DC-B&quot;);
    CassandraLifecycle.awaitPersistenceInit(otherSystem);
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
    TestKit.shutdownActorSystem(otherSystem, true);
    CassandraLifecycle.stopCassandra();
  }
}</code></pre></dd>
</dl>
<p>Combined with <code>PersistenceMultiDcTestKit</code> you can write tests that verify the behavior when replication between systems is temporarily suspended. You will need to add <code>persistenceMultiDcTestSettings</code> to your actor system configuration.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import akka.persistence.multidc.testkit.PersistenceMultiDcTestKit._

    // Include persistenceMultiDcTestSettings in your ActorSystem configuration
    // to allow suspending replication through PersistenceMultiDcTestKit
    .withFallback(persistenceMultiDcTestSettings(&quot;AuctionExampleSpec&quot;, dc, allDcs)))

&quot;correctly resolve concurrent writes when replication is temporarily suspended&quot; in
  new TestSetup(&quot;test6&quot;) {
    disableReplication(otherSystem, system)

    nodeA ! OfferBid(&quot;Mary&quot;, 42)
    nodeB ! OfferBid(&quot;Paul&quot;, 43)

    expectHighestBid(nodeA, &quot;Mary&quot;, 12)

    enableReplication(otherSystem, system)

    awaitAssert {
      expectHighestBid(nodeA, &quot;Paul&quot;, 42)
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import akka.persistence.multidc.testkit.PersistenceMultiDcTestKit;

      // Include persistenceMultiDcTestSettings in your ActorSystem configuration
      // to allow suspending replication through PersistenceMultiDcTestKit
      .withFallback(PersistenceMultiDcTestKit.persistenceMultiDcTestSettings(&quot;auctionTest&quot;, dc, JAPI.seq(&quot;DC-A&quot;, &quot;DC-B&quot;))));

@Test
public void correctlyResolveConcurrentWritesWhenReplicationIsTemporarilySuspended() throws Exception {
  new TestSetup(&quot;test6&quot;) {
    {
      PersistenceMultiDcTestKit.disableReplication(otherSystem, system);

      nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
      nodeB.tell(new OfferBid(&quot;Paul&quot;, 43), ActorRef.noSender());

      expectHighestBid(nodeA, &quot;Mary&quot;, 12);

      PersistenceMultiDcTestKit.enableReplication(otherSystem, system);

      awaitAssert(() -&gt; {
        expectHighestBid(nodeA, &quot;Paul&quot;, 42);
        return null;
      });

    }
  };
}</code></pre></dd>
</dl>
<p>A full example, testing the auction actor described <a href="auction-example.html">here</a>, might look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import java.time.Instant
import scala.concurrent.duration._

import com.typesafe.config.ConfigFactory

import akka.actor.{ ActorRef, ActorSystem, Props }
import akka.persistence.multidc.PersistenceMultiDcSettings

import org.scalatest.BeforeAndAfterAll
import org.scalatest.Matchers
import org.scalatest.WordSpecLike
import org.scalatest.BeforeAndAfter
import akka.persistence.multidc.testkit._
import akka.persistence.multidc.testkit.PersistenceMultiDcTestKit._


import akka.testkit.ImplicitSender
import akka.testkit.TestKit

object AuctionExampleSpec {
  val allDcs = Seq(&quot;DC-A&quot;, &quot;DC-B&quot;)

  val clusterConfig = ConfigFactory.parseString(&quot;&quot;&quot;
    akka.actor.provider = &quot;cluster&quot;
    akka.remote.netty.tcp.port = 0
    akka.remote.classic.netty.tcp.port = 0
    akka.remote.artery.canonical.port = 0
    akka.remote.artery.canonical.hostname = 127.0.0.1
    akka.cluster.jmx.multi-mbeans-in-same-jvm = on

    # avoid eager init in tests
    akka.persistence.multi-data-center.hot-standby.enabled = off

    # FIXME when using Akka 2.6 we should use Jackson or JavaSerializable
    akka.actor.allow-java-serialization = on
    akka.actor.warn-about-java-serializer-usage = off

    # speed up joining and such
    akka.cluster.gossip-interval = 500 ms
  &quot;&quot;&quot;)

  def createSystem(dc: String = allDcs.head) =
    ActorSystem(
      &quot;AuctionExampleSpec&quot;,
      clusterConfig
        .withFallback(CassandraLifecycle.config)
        // Include persistenceMultiDcTestSettings in your ActorSystem configuration
        // to allow suspending replication through PersistenceMultiDcTestKit
        .withFallback(persistenceMultiDcTestSettings(&quot;AuctionExampleSpec&quot;, dc, allDcs)))


}

class AuctionExampleSpec extends TestKit(AuctionExampleSpec.createSystem())
  with ImplicitSender
  with WordSpecLike
  with Matchers
  with BeforeAndAfterAll
  with BeforeAndAfter
  with CassandraLifecycleScalatest {
  import AuctionExampleSpec._

  val systemName = &quot;AuctionExampleSpec&quot;
  val settings = PersistenceMultiDcSettings(system)

  val otherSystem = createSystem(allDcs(1))
  val otherSettings = PersistenceMultiDcSettings(otherSystem)

  val allSystems = Seq(system, otherSystem)

  class TestSetup(testName: String) {
    val minimumBid = 12
    val auctionSetupA = AuctionSetup(&quot;bicycle&quot;, Bid(&quot;me&quot;, minimumBid, Instant.now(), &quot;&quot;),
      closingAt = Instant.now().plusSeconds(60), responsibleForClosing = true)
    val auctionSetupB = auctionSetupA.copy(responsibleForClosing = false)

    val nodeA = system.actorOf(auctionProps(s&quot;bikeAuction-$testName&quot;, auctionSetupA, settings), s&quot;auction-A-$testName&quot;)
    val nodeB = otherSystem.actorOf(auctionProps(s&quot;bikeAuction-$testName&quot;, auctionSetupB, otherSettings), s&quot;auction-B-$testName&quot;)

    def expectHighestBid(node: ActorRef): Bid = {
      node ! GetHighestBid
      expectMsgType[Bid]
    }
    def expectHighestBid(node: ActorRef, bidder: String, expected: MoneyAmount): Unit = {
      val bid = expectHighestBid(node)
      bid.offer shouldEqual expected
      bid.bidder shouldEqual bidder
    }
    def expectClosed(node: ActorRef): Unit = {
      node ! IsClosed
      expectMsg(true)
    }
  }

  &quot;AuctionExample&quot; should {
    &quot;propagate highest bid to replicated actor&quot; in new TestSetup(&quot;test1&quot;) {
      // simple bidding
      nodeA ! OfferBid(&quot;Mary&quot;, 42)
      expectHighestBid(nodeA, &quot;Mary&quot;, minimumBid) // ebay style, still the minimum offer

      nodeA ! OfferBid(&quot;Paul&quot;, 41)
      expectHighestBid(nodeA, &quot;Mary&quot;, 41) // ebay style, now updated to the highest counter offer

      awaitAssert {
        // check that results have propagated to b
        expectHighestBid(nodeB, &quot;Mary&quot;, 41) // ebay style, now updated to the highest counter offer
      }

      // make sure that first bidder still keeps the crown
      nodeB ! OfferBid(&quot;c&quot;, 42)
      expectHighestBid(nodeB, &quot;Mary&quot;, 42)
    }

    &quot;eventually resolve conflicting bids during auction if bids are highest (but different) in each dc&quot; in new TestSetup(&quot;test2&quot;) {
      // highest bid comes first
      nodeA ! OfferBid(&quot;Mary&quot;, 42)
      nodeB ! OfferBid(&quot;Paul&quot;, 41)

      awaitAssert {
        expectHighestBid(nodeA, &quot;Mary&quot;, 41)
        expectHighestBid(nodeB, &quot;Mary&quot;, 41)
      }

      // highest bid comes second
      nodeA ! OfferBid(&quot;Paul&quot;, 50)
      nodeB ! OfferBid(&quot;Kat&quot;, 60)

      awaitAssert {
        expectHighestBid(nodeA, &quot;Kat&quot;, 50)
        expectHighestBid(nodeB, &quot;Kat&quot;, 50)
      }
    }
    &quot;eventually resolve conflicting bids during auction if bids are highest and equal (but different time) in each dc&quot; in
      new TestSetup(&quot;test3&quot;) {
        nodeA ! OfferBid(&quot;Mary&quot;, 15)
        expectHighestBid(nodeA, &quot;Mary&quot;, 12)

        nodeB ! OfferBid(&quot;Paul&quot;, 15)

        awaitAssert {
          expectHighestBid(nodeA, &quot;Mary&quot;, 15)
          expectHighestBid(nodeB, &quot;Mary&quot;, 15)
        }
      }

    &quot;eventually come to a consistent final result&quot; in
      new TestSetup(&quot;test4&quot;) {
        nodeA ! OfferBid(&quot;Mary&quot;, 42)
        nodeB ! OfferBid(&quot;Paul&quot;, 43)
        Thread.sleep(3000)

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeA ! Finish

        awaitAssert {
          expectClosed(nodeA)
          expectClosed(nodeB)
        }

        expectHighestBid(nodeA, &quot;Paul&quot;, 43)
        expectHighestBid(nodeB, &quot;Paul&quot;, 43)
      }

    &quot;eventually come to a consistent final result when finishing is initiated on node B&quot; in
      new TestSetup(&quot;test5&quot;) {
        nodeA ! OfferBid(&quot;Mary&quot;, 42)
        nodeB ! OfferBid(&quot;Paul&quot;, 43)
        Thread.sleep(3000)

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeB ! Finish

        awaitAssert {
          expectClosed(nodeA)
          expectClosed(nodeB)
        }

        expectHighestBid(nodeA, &quot;Paul&quot;, 43)
        expectHighestBid(nodeB, &quot;Paul&quot;, 43)
      }

    &quot;correctly resolve concurrent writes when replication is temporarily suspended&quot; in
      new TestSetup(&quot;test6&quot;) {
        disableReplication(otherSystem, system)

        nodeA ! OfferBid(&quot;Mary&quot;, 42)
        nodeB ! OfferBid(&quot;Paul&quot;, 43)

        expectHighestBid(nodeA, &quot;Mary&quot;, 12)

        enableReplication(otherSystem, system)

        awaitAssert {
          expectHighestBid(nodeA, &quot;Paul&quot;, 42)
        }
      }
  }

  after {
    allSystems.foreach { sys =&gt;
      enableAllReplicationTo(sys)
    }
  }

  override protected def afterAll(): Unit = {
    allSystems.foreach(sys =&gt; shutdown(sys))
    super.afterAll()
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import java.io.Serializable;
import java.time.Instant;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;

import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import akka.japi.JAPI;
import akka.persistence.cassandra.testkit.CassandraLauncher;
import akka.persistence.multidc.PersistenceMultiDcSettings;
import akka.testkit.javadsl.TestKit;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import akka.persistence.multidc.testkit.CassandraLifecycle;
import akka.persistence.multidc.testkit.PersistenceMultiDcTestKit;


import scala.concurrent.duration.Duration;

import static org.junit.Assert.assertEquals;

public class AuctionExampleTest extends JUnitSuite {

  static class Bid implements Serializable {
    final String bidder;
    final int offer;
    final Instant timestamp;
    final String originDc;

    Bid(String bidder, int offer, Instant timestamp, String originDc) {
      this.bidder = bidder;
      this.offer = offer;
      this.timestamp = timestamp;
      this.originDc = originDc;
    }

    Bid withOffer(int offer) {
      return new Bid(bidder, offer, timestamp, originDc);
    }
  }


  // commands
  interface AuctionCommand extends Serializable {}
  static class OfferBid implements AuctionCommand {
    final String bidder;
    final int offer;
    public OfferBid(String bidder, int offer) {
      this.bidder = bidder;
      this.offer = offer;
    }
  }
  // An auction coordinator needs to schedule this event to each replica
  static class Finish implements AuctionCommand {
    static final Finish INSTANCE = new Finish();
    private Finish() {}
  }
  static class GetHighestBid implements AuctionCommand {
    static final GetHighestBid INSTANCE = new GetHighestBid();
    private GetHighestBid() {}
  }
  static class IsClosed implements AuctionCommand {
    static final IsClosed INSTANCE = new IsClosed();
    private IsClosed() {}
  }
  // Internal, should not be sent from the outside
  private static class Close implements AuctionCommand {
    static final Close INSTANCE = new Close();
    private Close() {}
  }

  // events
  interface AuctionEvent extends Serializable {}
  static class BidRegistered implements AuctionEvent {
    final Bid bid;
    public BidRegistered(Bid bid) {
      this.bid = bid;
    }
  }
  static class AuctionFinished implements AuctionEvent {
    final String atDc;
    public AuctionFinished(String atDc) {
      this.atDc = atDc;
    }
  }
  static class WinnerDecided implements AuctionEvent {
    final String atDc;
    final Bid winningBid;
    final int highestCounterOffer;
    public WinnerDecided(String atDc, Bid winningBid, int highestCounterOffer) {
      this.atDc = atDc;
      this.winningBid = winningBid;
      this.highestCounterOffer = highestCounterOffer;
    }
  }


  static class AuctionState {

    final boolean stillRunning;
    final Bid highestBid;
    // in ebay style auctions, we need to keep track of current highest counter offer
    final int highestCounterOffer;
    final Set&lt;String&gt; finishedAtDc;

    AuctionState(boolean stillRunning, Bid highestBid, int highestCounterOffer, Set&lt;String&gt; finishedAtDc) {
      this.stillRunning = stillRunning;
      this.highestBid = highestBid;
      this.highestCounterOffer = highestCounterOffer;
      this.finishedAtDc = finishedAtDc;
    }

    AuctionState withNewHighestBid(Bid bid) {
      assert(stillRunning);
      assert(isHigherBid(bid, highestBid));
      return new AuctionState(stillRunning, bid, highestBid.offer, finishedAtDc); // keep last highest bid around
    }


    AuctionState withTooLowBid(Bid bid) {
      assert(stillRunning);
      assert(isHigherBid(highestBid, bid));
      return new AuctionState(stillRunning, highestBid, Math.max(highestCounterOffer, bid.offer), finishedAtDc);
    }

    static Boolean isHigherBid(Bid first, Bid second) {
      return first.offer &gt; second.offer ||
        (first.offer == second.offer &amp;&amp; first.timestamp.isBefore(second.timestamp)) || // if equal, first one wins
        // If timestamps are equal, choose by dc where the offer was submitted
        // In real auctions, this last comparison should be deterministic but unpredictable, so that submitting to a
        // particular DC would not be an advantage.
        (first.offer == second.offer &amp;&amp; first.timestamp.equals(second.timestamp) &amp;&amp; first.originDc.compareTo(second.originDc) &lt; 0);
    }

    AuctionState addFinishedAtDc(String dc) {
      Set&lt;String&gt; s = new HashSet&lt;&gt;(finishedAtDc);
      s.add(dc);
      return new AuctionState(false, highestBid, highestCounterOffer, Collections.unmodifiableSet(s));
    }

    public AuctionState close() {
      return new AuctionState(
          false,
          highestBid,
          highestCounterOffer,
          Collections.emptySet()
      );
    }

    public boolean isClosed() {
      return !stillRunning &amp;&amp; finishedAtDc.isEmpty();
    }
  }

  private static final String FINISH_TIMER = &quot;FinishTimer&quot;;

  static class AuctionSetup {
    final String name;
    final Bid initialBid; // the initial bid is basically the minimum price bidden at start time by the owner
    final Instant closingAt;
    final boolean responsibleForClosing;
    public AuctionSetup(String name, Bid initialBid, Instant closingAt, boolean responsibleForClosing) {
      this.name = name;
      this.initialBid = initialBid;
      this.closingAt = closingAt;
      this.responsibleForClosing = responsibleForClosing;
    }
  }

  static class AuctionEntity extends ReplicatedEntity&lt;AuctionCommand, AuctionEvent, AuctionState&gt; {

    final AuctionSetup auctionSetup;

    public AuctionEntity(AuctionSetup auctionSetup) {
      this.auctionSetup = auctionSetup;
    }

    @Override
    public AuctionState initialState() {
      return new AuctionState(
          true,
          auctionSetup.initialBid,
          auctionSetup.initialBid.offer,
          Collections.emptySet());
    }

    @Override
    public CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; commandHandler() {
      return byStateCommandHandlerBuilder(AuctionState.class)
          .matchState(state -&gt; state.stillRunning, running())
          .matchAny(finished());
    }

    private CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; running() {
      return commandHandlerBuilder(AuctionCommand.class)
          .matchCommand(OfferBid.class, (ctx, state, offerBid) -&gt; {
            return Effect().persist(new BidRegistered(new Bid(offerBid.bidder, offerBid.offer,
                Instant.ofEpochMilli(currentTimeMillis()), selfDc())));
          }).matchExactCommand(GetHighestBid.INSTANCE, (ctx, state, query) -&gt; {
            ctx.getSender().tell(state.highestBid.withOffer(state.highestCounterOffer), getSelf());
            return Effect().none();
          }).matchExactCommand(Finish.INSTANCE, (ctx, state, finish) -&gt; {
            log().info(&quot;Finish&quot;);
            return Effect().persist(new AuctionFinished(selfDc()));
          }).matchExactCommand(Close.INSTANCE, (ctx, state, close) -&gt; {
            log().warning(&quot;Premature close&quot;);
            // Close should only be triggered when we have already finished
            return Effect().unhandled();
          }).matchExactCommand(IsClosed.INSTANCE, (ctx, state, query) -&gt; {
            ctx.getSender().tell(false, getSelf());
            return Effect().none();
          }).build();
    }

    private CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; finished() {
      return commandHandlerBuilder(AuctionCommand.class)
          .matchCommand(OfferBid.class, (ctx, state, offerBid) -&gt; {
            // auction finished, no more bids accepted
            return Effect().unhandled();
          }).matchExactCommand(GetHighestBid.INSTANCE, (ctx, state, query) -&gt; {
            ctx.getSender().tell(state.highestBid, getSelf());
            return Effect().none();
          }).matchExactCommand(Finish.INSTANCE, (ctx, state, finish) -&gt; {
            log().info(&quot;Finish&quot;);
            return Effect().persist(new AuctionFinished(selfDc()));
          }).matchExactCommand(Close.INSTANCE, (ctx, state, close) -&gt; {
            log().info(&quot;Close&quot;);
            // TODO send email (before or after persisting)
            return Effect().persist(new WinnerDecided(selfDc(), state.highestBid, state.highestCounterOffer));
          }).matchExactCommand(IsClosed.INSTANCE, (ctx, state, query) -&gt; {
              ctx.getSender().tell(state.isClosed(), getSelf());
              return Effect().none();
          }).build();
    }

    @Override
    public EventHandler&lt;AuctionEvent, AuctionState&gt; eventHandler() {
      return eventHandlerBuilder(AuctionEvent.class)
          .matchEvent(BidRegistered.class, (state, event) -&gt; {
            if (AuctionState.isHigherBid(event.bid, state.highestBid)) {
              return state.withNewHighestBid(event.bid);
            } else {
              return state.withTooLowBid(event.bid);
            }
          }).matchEvent(AuctionFinished.class, (state, event) -&gt; {
            if (state.isClosed())
              return state; // already closed
            else
              return state.addFinishedAtDc(event.atDc);
          }).matchEvent(WinnerDecided.class, (state, event) -&gt; {
            return state.close();
          })
          .build();
    }

    private boolean shouldClose(AuctionState state) {
      return auctionSetup.responsibleForClosing &amp;&amp; !state.isClosed() &amp;&amp;
          getAllDcs().equals(state.finishedAtDc);
    }

    private void triggerCloseIfNeeded(ActorContext ctx, AuctionState state) {
      if (shouldClose(state))
        ctx.getSelf().tell(Close.INSTANCE, ctx.getSelf());
    }


    @Override
    public Effect&lt;AuctionEvent, AuctionState&gt; eventTrigger(EventTriggerContext ctx,
                              AuctionState state, AuctionEvent event) {
      if (event instanceof AuctionFinished &amp;&amp; !state.isClosed()) {
        AuctionFinished finished = (AuctionFinished) event;
        log().info(&quot;AuctionFinished at {}, already finished at [{}]&quot;,
            finished.atDc, state.finishedAtDc);
        ActorContext actorCtx = ctx.actorContext();
        if (state.finishedAtDc.contains(getSelfDc())) {
          triggerCloseIfNeeded(actorCtx, state);
        } else {
          log().info(&quot;Sending finish to self&quot;);
          actorCtx.getSelf().tell(Finish.INSTANCE, actorCtx.getSelf());
        }
      }

      return Effect().none();
    }

    @Override
    public Effect&lt;AuctionEvent, AuctionState&gt; recoveryCompleted(ActorContext ctx, AuctionState state) {
      triggerCloseIfNeeded(ctx, state);

      long millisUntilClosing = auctionSetup.closingAt.toEpochMilli() - currentTimeMillis();
      ctx.getTimers().startSingleTimer(FINISH_TIMER, Finish.INSTANCE,
          Duration.create(millisUntilClosing, TimeUnit.MILLISECONDS));
      return Effect().none();
    }

  }

  static Props auctionProps(String pid, AuctionSetup auctionSetup, PersistenceMultiDcSettings settings) {
    return ReplicatedEntity.props(
        AuctionCommand.class,
        &quot;auction&quot;,
        pid,
        () -&gt; new AuctionEntity(auctionSetup),
        settings);
  }


  static private class TestSetup extends TestKit {
    final String testName;
    final int minimumBid = 12;
    final AuctionSetup auctionSetupA;
    final AuctionSetup auctionSetupB;
    final ActorRef nodeA;
    final ActorRef nodeB;

    TestSetup(String testName) {
      super(system);
      this.testName = testName;
      auctionSetupA = new AuctionSetup(&quot;bicycle&quot;, new Bid(&quot;me&quot;, minimumBid, Instant.now(),
          &quot;&quot;), Instant.now().plusSeconds(60), true);
      auctionSetupB = new AuctionSetup(&quot;bicycle&quot;, new Bid(&quot;me&quot;, minimumBid, Instant.now(),
          &quot;&quot;), Instant.now().plusSeconds(60), false);

      PersistenceMultiDcSettings settings = PersistenceMultiDcSettings.create(system);
      PersistenceMultiDcSettings otherSettings = PersistenceMultiDcSettings.create(otherSystem);

      nodeA = system.actorOf(auctionProps(&quot;bikeAuction-&quot; + testName, auctionSetupA, settings), &quot;auction-A-&quot; + testName);
      nodeB = otherSystem.actorOf(auctionProps(&quot;bikeAuction-&quot; + testName, auctionSetupB, otherSettings), &quot;auction-B-&quot; + testName);
    }

    Bid expectHighestBid(ActorRef node) {
        node.tell(GetHighestBid.INSTANCE, getTestActor());
        return expectMsgClass(Bid.class);
    }

    void expectHighestBid(ActorRef node, String bidder, int expected) {
        Bid bid = expectHighestBid(node);
        assertEquals(expected, bid.offer);
        assertEquals(bidder, bid.bidder);
    }

    void expectClosed(ActorRef node) {
      node.tell(IsClosed.INSTANCE, getTestActor());
      expectMsg(true);
    }

  }

  private static Config clusterConfig = ConfigFactory.parseString(String.join(&quot;\n&quot;,
    &quot;akka.actor.provider = \&quot;cluster\&quot;&quot;,
    &quot;akka.remote.netty.tcp.port = 0&quot;,
    &quot;akka.remote.classic.netty.tcp.port = 0&quot;,
    &quot;akka.remote.artery.canonical.port = 0&quot;,
    &quot;akka.remote.artery.canonical.hostname = 127.0.0.1&quot;,
    &quot;akka.cluster.jmx.multi-mbeans-in-same-jvm = on&quot;,
    // avoid eager init in tests
    &quot;akka.persistence.multi-data-center.hot-standby.enabled = off&quot;,
    // FIXME when using Akka 2.6 we should use Jackson or JavaSerializable
    &quot;akka.actor.allow-java-serialization = on&quot;,
    &quot;akka.actor.warn-about-java-serializer-usage = off&quot;,
    // speed up joining and such
    &quot;akka.cluster.gossip-interval = 500 ms&quot;));

  private static ActorSystem createSystem(String dc) {
    return ActorSystem.create(
      &quot;auctionTest&quot;,
      clusterConfig
        .withFallback(CassandraLifecycle.config())
        // Include persistenceMultiDcTestSettings in your ActorSystem configuration
        // to allow suspending replication through PersistenceMultiDcTestKit
        .withFallback(PersistenceMultiDcTestKit.persistenceMultiDcTestSettings(&quot;auctionTest&quot;, dc, JAPI.seq(&quot;DC-A&quot;, &quot;DC-B&quot;))));

  }

  private static ActorSystem system;
  private static ActorSystem otherSystem;

  @BeforeClass
  public static void setupSystems() {
    system = createSystem(&quot;DC-A&quot;);
    CassandraLifecycle.startCassandra(system.name(), CassandraLauncher.DefaultTestConfigResource());
    CassandraLifecycle.awaitPersistenceInit(system);

    otherSystem = createSystem(&quot;DC-B&quot;);
    CassandraLifecycle.awaitPersistenceInit(otherSystem);
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
    TestKit.shutdownActorSystem(otherSystem, true);
    CassandraLifecycle.stopCassandra();
  }

  @Test
  public void propagateHighestBidToReplicatedActor() {
    new TestSetup(&quot;test-1&quot;) {
      {
        // simple bidding
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        expectHighestBid(nodeA, &quot;Mary&quot;, minimumBid); // ebay style, still the minimum offer

        nodeA.tell(new OfferBid(&quot;Paul&quot;, 41), ActorRef.noSender());
        expectHighestBid(nodeA, &quot;Mary&quot;, 41); // ebay style, now updated to the highest counter offer

        awaitAssert(
            () -&gt; {
              expectHighestBid(nodeB, &quot;Mary&quot;, 41);
              return null;
            });

        awaitAssert(
            () -&gt; {
              // check that results have propagated to b
              expectHighestBid(nodeB, &quot;Mary&quot;, 41); // ebay style, now updated to the highest counter offer
              return null;
            }
        );

        // make sure that first bidder still keeps the crown
        nodeB.tell(new OfferBid(&quot;c&quot;, 42), ActorRef.noSender());
        expectHighestBid(nodeB, &quot;Mary&quot;, 42);
      }
    };
  }


  @Test
  public void eventuallyResolveConflictingBidsDuringAuctionIfBidsAreHighestButDifferentInEachDc() {
    new TestSetup(&quot;test-2&quot;) {
      {
        // highest bid comes first
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 41), ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectHighestBid(nodeA, &quot;Mary&quot;, 41);
          expectHighestBid(nodeB, &quot;Mary&quot;, 41);
          return null;
        });


        // highest bid comes second
        nodeA.tell(new OfferBid(&quot;Paul&quot;, 50), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Kat&quot;, 60), ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectHighestBid(nodeA, &quot;Kat&quot;, 50);
          expectHighestBid(nodeB, &quot;Kat&quot;, 50);
          return null;
        });
      }
    };
  }

  @Test
  public void eventuallyResolveConflictingBidsDuringAuctionIfBidsAreHighestAndEqualButDifferentTimeInEachDc() {
    new TestSetup(&quot;test3&quot;) {
      {
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 15), ActorRef.noSender());
        expectHighestBid(nodeA, &quot;Mary&quot;, 12);

        nodeB.tell(new OfferBid(&quot;Paul&quot;, 15), ActorRef.noSender());

        awaitAssert(() -&gt; {
            expectHighestBid(nodeA, &quot;Mary&quot;, 15);
            expectHighestBid(nodeB, &quot;Mary&quot;, 15);
            return null;
        });
      }
    };
  }

  @Test
  public void eventuallyComeToAConsistentFinalResult() throws Exception {
    new TestSetup(&quot;test4&quot;) {
      {
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 43), ActorRef.noSender());
        Thread.sleep(3000);

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeA.tell(Finish.INSTANCE, ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectClosed(nodeA);
          expectClosed(nodeB);
          return null;
        });

        expectHighestBid(nodeA, &quot;Paul&quot;, 43);
        expectHighestBid(nodeB, &quot;Paul&quot;, 43);
      }
    };
  }

  @Test
  public void eventuallyComeToAConsistentFinalResultWhenFinishingIsInitiatedOnNodeB() throws Exception {
    new TestSetup(&quot;test5&quot;) {
      {
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 43), ActorRef.noSender());
        Thread.sleep(3000);

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeB.tell(Finish.INSTANCE, ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectClosed(nodeA);
          expectClosed(nodeB);
          return null;
        });

        expectHighestBid(nodeA, &quot;Paul&quot;, 43);
        expectHighestBid(nodeB, &quot;Paul&quot;, 43);
      }
    };
  }

  @Test
  public void correctlyResolveConcurrentWritesWhenReplicationIsTemporarilySuspended() throws Exception {
    new TestSetup(&quot;test6&quot;) {
      {
        PersistenceMultiDcTestKit.disableReplication(otherSystem, system);

        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 43), ActorRef.noSender());

        expectHighestBid(nodeA, &quot;Mary&quot;, 12);

        PersistenceMultiDcTestKit.enableReplication(otherSystem, system);

        awaitAssert(() -&gt; {
          expectHighestBid(nodeA, &quot;Paul&quot;, 42);
          return null;
        });

      }
    };
  }
}</code></pre></dd>
</dl><div class="group-scala">
<h2><a href="#multi-jvm-testing" name="multi-jvm-testing" class="anchor"><span class="anchor-link"></span></a>Multi-JVM testing</h2>
<p>A <a href="https://doc.akka.io/docs/akka/2.5/multi-jvm-testing.html">Multi JVM Test</a> is even more heavyweight, as it will spawn an entire new JVM for each cluster node. This does allow for even more production-like tests, however bear in mind that it is also harder to interpret any failures.</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.duration._

import com.typesafe.config.ConfigFactory
import akka.actor.{ ActorSystem, PoisonPill, Props }
import akka.cluster.Cluster
import akka.cluster.sharding.{ ClusterSharding, ClusterShardingSettings, ShardRegion }
import akka.persistence.multidc.PersistenceMultiDcSettings
import akka.persistence.multidc.scaladsl.ReplicatedEntity

import org.scalatest.concurrent.ScalaFutures
import org.scalatest.{ BeforeAndAfterAll, Matchers, WordSpecLike }
import akka.testkit.TestProbe
import akka.remote.testkit.MultiNodeConfig
import akka.remote.testkit.MultiNodeSpec
import akka.persistence.multidc.testkit.CassandraLifecycle
import akka.persistence.multidc.testkit.ContactPoints
import akka.persistence.multidc.internal.MultiNodeClusterSpec
import akka.persistence.multidc.testkit.MultiNodeSessionProvider

object ShardedReplicatedEntitySpec extends MultiNodeConfig {
  final val CassPort = 50100

  val dc1node1 = role(&quot;dc1-node1&quot;)
  val dc1node2 = role(&quot;dc1-node2&quot;)
  val dc2node3 = role(&quot;dc2-node3&quot;)
  val dc2node4 = role(&quot;dc2-node4&quot;)

  commonConfig(ConfigFactory.parseString(
    s&quot;&quot;&quot;
      akka.loglevel = DEBUG
      akka.actor.provider = cluster
      akka.testconductor.barrier-timeout = 60 s
      cassandra-journal-multi-dc.keyspace = ShardedReplicatedEntitySpec
      cassandra-snapshot-store.keyspace = ShardedReplicatedEntitySpecSnapshot
      cassandra-journal-multi-dc.port = $CassPort
      cassandra-snapshot-store.port = $CassPort
      cassandra-journal-multi-dc.session-provider = ${classOf[MultiNodeSessionProvider].getName}
      cassandra-snapshot-store.session-provider = ${classOf[MultiNodeSessionProvider].getName}

      # avoid eager init in tests
      akka.persistence.multi-data-center.hot-standby.enabled = off

      # FIXME when using Akka 2.6 we should use Jackson or JavaSerializable
      akka.actor.allow-java-serialization = on
      akka.actor.warn-about-java-serializer-usage = off

      # speed up joining and such
      akka.cluster.gossip-interval = 500 ms
    &quot;&quot;&quot;).withFallback(CassandraLifecycle.config))

  nodeConfig(dc1node1, dc1node2) {
    ConfigFactory.parseString(
      &quot;&quot;&quot;
        |akka.cluster.multi-data-center.self-data-center = DC-1
        |akka.persistence.multi-data-center.all-data-centers = [DC-1, DC-2]
      &quot;&quot;&quot;.stripMargin)
  }

  nodeConfig(dc2node3, dc2node4) {
    ConfigFactory.parseString(
      &quot;&quot;&quot;
        |akka.cluster.multi-data-center.self-data-center = DC-2
        |akka.persistence.multi-data-center.all-data-centers = [DC-1, DC-2]
      &quot;&quot;&quot;.stripMargin)
  }

  case class CommandEnvelope(id: Long, command: Command)

  sealed trait Command
  case class UsageReport(usage: Long, timestamp: Long) extends Command
  case object GetUsage extends Command
  case object Stop extends Command

  sealed trait Event
  case class UsageReported(usage: Long, timestamp: Long) extends Event

  case class State(totalUsage: Long, timestamp: Long)

  def serverProps()(implicit system: ActorSystem): Props =
    ReplicatedEntity.clusterShardingProps(&quot;server&quot;, () =&gt; new Server, PersistenceMultiDcSettings(system))

  class Server() extends ReplicatedEntity[Command, Event, State] {
    override def initialState: State = State(0, -1)

    override def commandHandler = CommandHandler {
      case (ctx, _, UsageReport(usage, ts)) =&gt; Effect.persist(UsageReported(usage, ts))
      case (ctx, state, GetUsage) =&gt;
        ctx.sender() ! state
        Effect.none
      case (ctx, _, Stop) =&gt;
        ctx.self ! PoisonPill
        Effect.none
    }

    override def eventHandler(currentState: State, event: Event): State = event match {
      case UsageReported(usage, ts) =&gt; State(currentState.totalUsage + usage, ts)
    }
  }
}

class ShardedReplicatedEntitySpecMultiJvmNode1 extends ShardedReplicatedEntitySpec
class ShardedReplicatedEntitySpecMultiJvmNode2 extends ShardedReplicatedEntitySpec
class ShardedReplicatedEntitySpecMultiJvmNode3 extends ShardedReplicatedEntitySpec
class ShardedReplicatedEntitySpecMultiJvmNode4 extends ShardedReplicatedEntitySpec

abstract class ShardedReplicatedEntitySpec extends MultiNodeSpec(ShardedReplicatedEntitySpec)
  with MultiNodeClusterSpec with WordSpecLike with Matchers with ScalaFutures with BeforeAndAfterAll {
  import ShardedReplicatedEntitySpec._
  import CassandraLifecycle._

  val extractEntityId: ShardRegion.ExtractEntityId = {
    case CommandEnvelope(id, command) =&gt; (id.toString, command)
  }

  val numberOfShards = 100
  val extractShardId: ShardRegion.ExtractShardId = {
    case CommandEnvelope(id, _) =&gt; (id % numberOfShards).toString
    case ShardRegion.StartEntity(id) =&gt;
      // StartEntity is used by remembering entities feature
      (id.toLong % numberOfShards).toString
  }

  override def beforeAll() = {
    val CassHost = node(dc1node1).address.host.get

    ContactPoints(system).completeAddressDefaultClusterId(CassHost)
    runOn(dc1node1) {
      startCassandra(CassHost, CassPort, system.name)
      awaitPersistenceInit(system)
    }
    enterBarrier(&quot;cassandra-init&quot;)

    runOn(dc1node2, dc2node3, dc2node4) {
      awaitPersistenceInit(system)
    }
    enterBarrier(&quot;persistence-init&quot;)
  }

  &quot;sharded replicated entity&quot; should {
    &quot;replicate events&quot; in {
      runOn(dc1node1) {
        Cluster(system).join(node(dc1node1).address)
      }

      runOn(dc2node3) {
        Cluster(system).join(node(dc2node3).address)
      }

      enterBarrier(&quot;cluster-init-1&quot;)

      runOn(dc1node2) {
        Cluster(system).join(node(dc1node1).address)
      }

      runOn(dc2node4) {
        Cluster(system).join(node(dc2node3).address)
      }

      enterBarrier(&quot;cluster-init-2&quot;)

      val region = ClusterSharding(system).start(
        typeName = &quot;Server&quot;,
        entityProps = serverProps(),
        settings = ClusterShardingSettings(system),
        extractEntityId = extractEntityId,
        extractShardId = extractShardId)

      // this will be sent once on all nodes
      region ! CommandEnvelope(1, UsageReport(1, 1))

      within(10.seconds) {
        val probe = TestProbe()
        awaitAssert {
          region.tell(CommandEnvelope(1, GetUsage), probe.ref)
          probe.expectMsg(3.second, State(4, 1))
        }
      }

      enterBarrier(&quot;first-message-done&quot;)

      runOn(dc1node1) {
        // stop replicated entity on the DC-A
        region ! CommandEnvelope(1, Stop)
      }

      runOn(dc2node3) {
        // send commands to replicated entity on DC-B
        region ! CommandEnvelope(1, UsageReport(1, 2))
        region ! CommandEnvelope(1, UsageReport(1, 3))
        region ! CommandEnvelope(1, UsageReport(1, 4))

        within(10.seconds) {
          val probe = TestProbe()
          awaitAssert {
            region.tell(CommandEnvelope(1, GetUsage), probe.ref)
            probe.expectMsg(3.second, State(7, 4))
          }
        }
      }

      enterBarrier(&quot;commands-sent-single-dc&quot;)

      runOn(dc1node1) {
        // bring back replicated entity on the DC-A
        within(10.seconds) {
          val probe = TestProbe()
          awaitAssert {
            region.tell(CommandEnvelope(1, GetUsage), probe.ref)
            probe.expectMsg(3.second, State(7, 4))
          }
        }
      }

      enterBarrier(&quot;finish&quot;)
    }
  }

}</code></pre></div>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../persistence-dc/index.html"><i class="icon-prev"></i> <span class="link-prev">Akka Multi-DC Persistence</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../persistence-dc/cassandra.html">Cassandra <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<!-- no source links for private github repository -->

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<p class="legal">
&copy; 2011-2020 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- hook for including project specific javascript into the generated docs -->

</body>
</html>
