<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Auction Example &bull; Akka Enhancements</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka Enhancements is a suite of useful components that complement Akka."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka-enhancements/current/persistence-dc/auction-example.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-7.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-1.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_setDomainName', '']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="../images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="../images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="../images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="../images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="../images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="../images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="../images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Enhancements</a></h1>
</div>
<div class="nav-header-version">
Version 1.1.13
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../akka-resilience-enhancements.html" class="page">Akka Resilience Enhancements</a></li>
  <li><a href="../akka-persistence-enhancements.html" class="page">Akka Persistence Enhancements</a>
  <ul>
    <li><a href="../persistence-dc/index.html" class="page">Akka Multi-DC Persistence</a>
    <ul>
      <li><a href="../persistence-dc/index.html#akka-persistence-basics" class="header">Akka Persistence basics</a></li>
      <li><a href="../persistence-dc/index.html#motivation" class="header">Motivation</a></li>
      <li><a href="../persistence-dc/index.html#approach" class="header">Approach</a></li>
      <li><a href="../persistence-dc/index.html#dependency" class="header">Dependency</a></li>
      <li><a href="../persistence-dc/index.html#getting-started" class="header">Getting started</a></li>
      <li><a href="../persistence-dc/index.html#resolving-conflicting-updates" class="header">Resolving conflicting updates</a></li>
      <li><a href="../persistence-dc/index.html#side-effects" class="header">Side effects</a></li>
      <li><a href="../persistence-dc/index.html#failures" class="header">Failures</a></li>
      <li><a href="../persistence-dc/index.html#snapshots" class="header">Snapshots</a></li>
      <li><a href="../persistence-dc/index.html#passivating-and-stopping-entities" class="header">Passivating and stopping entities</a></li>
      <li><a href="../persistence-dc/index.html#tagging-events" class="header">Tagging Events</a></li>
      <li><a href="../persistence-dc/index.html#testing" class="header">Testing</a></li>
      <li><a href="../persistence-dc/index.html#how-it-works" class="header">How it works</a></li>
      <li><a href="../persistence-dc/index.html#hot-standby" class="header">Hot-standby</a></li>
      <li><a href="../persistence-dc/index.html#speculative-replication-optimization" class="header">Speculative Replication Optimization</a></li>
      <li><a href="../persistence-dc/index.html#custom-crdt-implementation" class="header group-scala">Custom CRDT implementation</a></li>
      <li><a href="../persistence-dc/index.html#migration-from-to-persistentactor" class="header">Migration from/to PersistentActor</a></li>
      <li><a href="../persistence-dc/index.html#configuration" class="header">Configuration</a></li>
      <li><a href="../persistence-dc/index.html#api-docs" class="header">API docs</a></li>
      <li><a href="../persistence-dc/testing.html" class="page">Testing</a></li>
      <li><a href="../persistence-dc/cassandra.html" class="page">Cassandra</a></li>
      <li><a href="../persistence-dc/examples.html" class="page">Additional Examples</a>
      <ul>
        <li><a href="../persistence-dc/auction-example.html#auction-example" class="active page">Auction Example</a>
        <ul>
          <li><a href="../persistence-dc/auction-example.html#open-questions" class="header">Open questions</a></li>
          <li><a href="../persistence-dc/auction-example.html#complete-example-source-code" class="header">Complete example source code</a></li>
        </ul></li>
        <li><a href="../persistence-dc/shopping-cart-example.html" class="page">Shopping Cart Example</a></li>
        <li><a href="../persistence-dc/plane-seats-example.html" class="page">Plane Seats Example</a></li>
      </ul></li>
    </ul></li>
    <li><a href="../gdpr/index.html" class="page">GDPR for Akka Persistence</a></li>
    <li><a href="../akka-persistence-enhancements-release-notes.html" class="page">Akka Persistence Enhancements Release Notes</a></li>
  </ul></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Enhancements</a></h1>
</div>
<div class="nav-header-version">
Version 1.1.13
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../akka-resilience-enhancements.html" class="page">Akka Resilience Enhancements</a></li>
  <li><a href="../akka-persistence-enhancements.html" class="page">Akka Persistence Enhancements</a>
  <ul>
    <li><a href="../persistence-dc/index.html" class="page">Akka Multi-DC Persistence</a>
    <ul>
      <li><a href="../persistence-dc/index.html#akka-persistence-basics" class="header">Akka Persistence basics</a></li>
      <li><a href="../persistence-dc/index.html#motivation" class="header">Motivation</a></li>
      <li><a href="../persistence-dc/index.html#approach" class="header">Approach</a></li>
      <li><a href="../persistence-dc/index.html#dependency" class="header">Dependency</a></li>
      <li><a href="../persistence-dc/index.html#getting-started" class="header">Getting started</a></li>
      <li><a href="../persistence-dc/index.html#resolving-conflicting-updates" class="header">Resolving conflicting updates</a></li>
      <li><a href="../persistence-dc/index.html#side-effects" class="header">Side effects</a></li>
      <li><a href="../persistence-dc/index.html#failures" class="header">Failures</a></li>
      <li><a href="../persistence-dc/index.html#snapshots" class="header">Snapshots</a></li>
      <li><a href="../persistence-dc/index.html#passivating-and-stopping-entities" class="header">Passivating and stopping entities</a></li>
      <li><a href="../persistence-dc/index.html#tagging-events" class="header">Tagging Events</a></li>
      <li><a href="../persistence-dc/index.html#testing" class="header">Testing</a></li>
      <li><a href="../persistence-dc/index.html#how-it-works" class="header">How it works</a></li>
      <li><a href="../persistence-dc/index.html#hot-standby" class="header">Hot-standby</a></li>
      <li><a href="../persistence-dc/index.html#speculative-replication-optimization" class="header">Speculative Replication Optimization</a></li>
      <li><a href="../persistence-dc/index.html#custom-crdt-implementation" class="header group-scala">Custom CRDT implementation</a></li>
      <li><a href="../persistence-dc/index.html#migration-from-to-persistentactor" class="header">Migration from/to PersistentActor</a></li>
      <li><a href="../persistence-dc/index.html#configuration" class="header">Configuration</a></li>
      <li><a href="../persistence-dc/index.html#api-docs" class="header">API docs</a></li>
      <li><a href="../persistence-dc/testing.html" class="page">Testing</a></li>
      <li><a href="../persistence-dc/cassandra.html" class="page">Cassandra</a></li>
      <li><a href="../persistence-dc/examples.html" class="page">Additional Examples</a>
      <ul>
        <li><a href="../persistence-dc/auction-example.html#auction-example" class="active page">Auction Example</a>
        <ul>
          <li><a href="../persistence-dc/auction-example.html#open-questions" class="header">Open questions</a></li>
          <li><a href="../persistence-dc/auction-example.html#complete-example-source-code" class="header">Complete example source code</a></li>
        </ul></li>
        <li><a href="../persistence-dc/shopping-cart-example.html" class="page">Shopping Cart Example</a></li>
        <li><a href="../persistence-dc/plane-seats-example.html" class="page">Plane Seats Example</a></li>
      </ul></li>
    </ul></li>
    <li><a href="../gdpr/index.html" class="page">GDPR for Akka Persistence</a></li>
    <li><a href="../akka-persistence-enhancements-release-notes.html" class="page">Akka Persistence Enhancements Release Notes</a></li>
  </ul></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#auction-example" name="auction-example" class="anchor"><span class="anchor-link"></span></a>Auction Example</h1>
<p><span class="group-scala">Having to use CRDTs for replication might seem like a severe constraint because the set of predefined CRDTs is quite limited.</span> In this example we want to show that real-world applications can be implemented by designing events in a way that they don&rsquo;t conflict. In the end, you will end up with a solution based on a custom CRDT.</p>
<p>We are building a small auction service. An auction is represented by one replicated actor. It should have the following operations:</p>
<ul>
  <li>Place a bid</li>
  <li>Get the currently highest bid</li>
  <li>Finish the auction</li>
</ul>
<p>We model those operations as commands to be sent to the auction actor:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">case class Bid(bidder: String, offer: MoneyAmount, timestamp: Instant, originDc: String)

// commands
sealed trait AuctionCommand
case class OfferBid(bidder: String, offer: MoneyAmount) extends AuctionCommand
case object Finish extends AuctionCommand // A timer needs to schedule this event at each replica
case object GetHighestBid extends AuctionCommand
case object IsClosed extends AuctionCommand
private case object Close extends AuctionCommand // Internal, should not be sent from the outside</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">static class Bid implements Serializable {
  final String bidder;
  final int offer;
  final Instant timestamp;
  final String originDc;

  Bid(String bidder, int offer, Instant timestamp, String originDc) {
    this.bidder = bidder;
    this.offer = offer;
    this.timestamp = timestamp;
    this.originDc = originDc;
  }

  Bid withOffer(int offer) {
    return new Bid(bidder, offer, timestamp, originDc);
  }
}


// commands
interface AuctionCommand extends Serializable {}
static class OfferBid implements AuctionCommand {
  final String bidder;
  final int offer;
  public OfferBid(String bidder, int offer) {
    this.bidder = bidder;
    this.offer = offer;
  }
}
// An auction coordinator needs to schedule this event to each replica
static class Finish implements AuctionCommand {
  static final Finish INSTANCE = new Finish();
  private Finish() {}
}
static class GetHighestBid implements AuctionCommand {
  static final GetHighestBid INSTANCE = new GetHighestBid();
  private GetHighestBid() {}
}
static class IsClosed implements AuctionCommand {
  static final IsClosed INSTANCE = new IsClosed();
  private IsClosed() {}
}
// Internal, should not be sent from the outside
private static class Close implements AuctionCommand {
  static final Close INSTANCE = new Close();
  private Close() {}
}</code></pre></dd>
</dl>
<p>The auction entity is an event-sourced persistent actor. These events are used to persist state changes:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// events
sealed trait AuctionEvent
case class BidRegistered(bid: Bid) extends AuctionEvent
case class AuctionFinished(atDc: String) extends AuctionEvent
case class WinnerDecided(atDc: String, winningBid: Bid, highestCounterOffer: MoneyAmount) extends AuctionEvent</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// events
interface AuctionEvent extends Serializable {}
static class BidRegistered implements AuctionEvent {
  final Bid bid;
  public BidRegistered(Bid bid) {
    this.bid = bid;
  }
}
static class AuctionFinished implements AuctionEvent {
  final String atDc;
  public AuctionFinished(String atDc) {
    this.atDc = atDc;
  }
}
static class WinnerDecided implements AuctionEvent {
  final String atDc;
  final Bid winningBid;
  final int highestCounterOffer;
  public WinnerDecided(String atDc, Bid winningBid, int highestCounterOffer) {
    this.atDc = atDc;
    this.winningBid = winningBid;
    this.highestCounterOffer = highestCounterOffer;
  }
}</code></pre></dd>
</dl>
<p>You may have noticed here, that we include the <code>highestCounterOffer</code> in the <code>AuctionFinished</code> event. This is because we use a popular auction style where the winner does not have to pay the highest bidden price but only just enough to beat the second highest bid.</p>
<p>Let&rsquo;s have a look at the auction entity that will handle incoming commands:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">case class AuctionSetup(
  name:                  String,
  initialBid:            Bid, // the initial bid is basically the minimum price bidden at start time by the owner
  closingAt:             Instant,
  responsibleForClosing: Boolean)

class AuctionEntity(auctionSetup: AuctionSetup)
  extends ReplicatedEntity[AuctionCommand, AuctionEvent, AuctionState] {

  override def initialState: AuctionState =
    AuctionState(
      phase = Running,
      highestBid = auctionSetup.initialBid,
      highestCounterOffer = auctionSetup.initialBid.offer)

  override def commandHandler: CommandHandler = {
    CommandHandler.byState {
      case AuctionState(Running, _, _) =&gt; running
      case _                           =&gt; finished
    }
  }

  private val running: CommandHandler = {
    CommandHandler {
      case (_, _, OfferBid(bidder, offer)) =&gt;
        Effect.persist(BidRegistered(Bid(bidder, offer, Instant.ofEpochMilli(currentTimeMillis()), selfDc)))
      case (ctx, state, GetHighestBid) =&gt;
        ctx.sender() ! state.highestBid.copy(offer = state.highestCounterOffer)
        Effect.none
      case (_, _, Finish) =&gt;
        log.info(&quot;Finish&quot;)
        Effect.persist(AuctionFinished(selfDc))
      case (_, _, Close) =&gt;
        log.warning(&quot;Premature close&quot;)
        // Close should only be triggered when we have already finished
        Effect.unhandled
      case (ctx, _, IsClosed) =&gt;
        ctx.sender() ! false
        Effect.none
    }
  }

  private val finished: CommandHandler = {
    CommandHandler {
      case (ctx, state, GetHighestBid) =&gt;
        ctx.sender() ! state.highestBid
        Effect.none
      case (ctx, state, IsClosed) =&gt;
        ctx.sender() ! (state.phase == Closed)
        Effect.none
      case (ctx, _, Finish) =&gt;
        log.info(&quot;Finish&quot;)
        Effect.persist(AuctionFinished(selfDc))
      case (_, state, Close) =&gt;
        log.info(&quot;Close&quot;)
        require(shouldClose(state))
        // TODO send email (before or after persisting)
        Effect.persist(WinnerDecided(selfDc, state.highestBid, state.highestCounterOffer))
      case (_, _, _: OfferBid) =&gt;
        // auction finished, no more bids accepted
        Effect.unhandled
    }
  }

  override def eventHandler(state: AuctionState, event: AuctionEvent): AuctionState =
    state.applyEvent(event)

  private def shouldClose(state: AuctionState): Boolean = {
    auctionSetup.responsibleForClosing &amp;&amp; (state.phase match {
      case Closing(alreadyFinishedAtDc) =&gt; allDcs.diff(alreadyFinishedAtDc).isEmpty
      case _                            =&gt; false
    })
  }

  private def triggerCloseIfNeeded(ctx: ActorContext, state: AuctionState): Unit = {
    if (shouldClose(state)) ctx.self ! Close
  }

  override def eventTrigger(
    ctx:   EventTriggerContext,
    state: AuctionState, event: AuctionEvent): Effect[AuctionEvent, AuctionState] = {
    event match {
      case finished: AuctionFinished =&gt;
        state.phase match {
          case Closing(alreadyFinishedAtDc) =&gt;
            log.info(&quot;AuctionFinished at {}, already finished at [{}]&quot;, finished.atDc,
              alreadyFinishedAtDc.mkString(&quot;, &quot;))
            if (alreadyFinishedAtDc(selfDc)) {
              triggerCloseIfNeeded(ctx.actorContext, state)
            } else {
              log.info(&quot;Sending finish to self&quot;)
              ctx.actorContext.self ! Finish
            }

          case _ =&gt; // no trigger for this state
        }
      case _ =&gt; // no trigger for this event
    }
    Effect.none
  }

  override def recoveryCompleted(ctx: ActorContext, state: AuctionState): Effect[AuctionEvent, AuctionState] = {
    triggerCloseIfNeeded(ctx, state)

    val millisUntilClosing = auctionSetup.closingAt.toEpochMilli - currentTimeMillis()
    ctx.timers.startSingleTimer(FinishTimer, Finish, millisUntilClosing.millis)

    Effect.none
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">static class AuctionSetup {
  final String name;
  final Bid initialBid; // the initial bid is basically the minimum price bidden at start time by the owner
  final Instant closingAt;
  final boolean responsibleForClosing;
  public AuctionSetup(String name, Bid initialBid, Instant closingAt, boolean responsibleForClosing) {
    this.name = name;
    this.initialBid = initialBid;
    this.closingAt = closingAt;
    this.responsibleForClosing = responsibleForClosing;
  }
}

static class AuctionEntity extends ReplicatedEntity&lt;AuctionCommand, AuctionEvent, AuctionState&gt; {

  final AuctionSetup auctionSetup;

  public AuctionEntity(AuctionSetup auctionSetup) {
    this.auctionSetup = auctionSetup;
  }

  @Override
  public AuctionState initialState() {
    return new AuctionState(
        true,
        auctionSetup.initialBid,
        auctionSetup.initialBid.offer,
        Collections.emptySet());
  }

  @Override
  public CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; commandHandler() {
    return byStateCommandHandlerBuilder(AuctionState.class)
        .matchState(state -&gt; state.stillRunning, running())
        .matchAny(finished());
  }

  private CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; running() {
    return commandHandlerBuilder(AuctionCommand.class)
        .matchCommand(OfferBid.class, (ctx, state, offerBid) -&gt; {
          return Effect().persist(new BidRegistered(new Bid(offerBid.bidder, offerBid.offer,
              Instant.ofEpochMilli(currentTimeMillis()), selfDc())));
        }).matchExactCommand(GetHighestBid.INSTANCE, (ctx, state, query) -&gt; {
          ctx.getSender().tell(state.highestBid.withOffer(state.highestCounterOffer), getSelf());
          return Effect().none();
        }).matchExactCommand(Finish.INSTANCE, (ctx, state, finish) -&gt; {
          log().info(&quot;Finish&quot;);
          return Effect().persist(new AuctionFinished(selfDc()));
        }).matchExactCommand(Close.INSTANCE, (ctx, state, close) -&gt; {
          log().warning(&quot;Premature close&quot;);
          // Close should only be triggered when we have already finished
          return Effect().unhandled();
        }).matchExactCommand(IsClosed.INSTANCE, (ctx, state, query) -&gt; {
          ctx.getSender().tell(false, getSelf());
          return Effect().none();
        }).build();
  }

  private CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; finished() {
    return commandHandlerBuilder(AuctionCommand.class)
        .matchCommand(OfferBid.class, (ctx, state, offerBid) -&gt; {
          // auction finished, no more bids accepted
          return Effect().unhandled();
        }).matchExactCommand(GetHighestBid.INSTANCE, (ctx, state, query) -&gt; {
          ctx.getSender().tell(state.highestBid, getSelf());
          return Effect().none();
        }).matchExactCommand(Finish.INSTANCE, (ctx, state, finish) -&gt; {
          log().info(&quot;Finish&quot;);
          return Effect().persist(new AuctionFinished(selfDc()));
        }).matchExactCommand(Close.INSTANCE, (ctx, state, close) -&gt; {
          log().info(&quot;Close&quot;);
          // TODO send email (before or after persisting)
          return Effect().persist(new WinnerDecided(selfDc(), state.highestBid, state.highestCounterOffer));
        }).matchExactCommand(IsClosed.INSTANCE, (ctx, state, query) -&gt; {
            ctx.getSender().tell(state.isClosed(), getSelf());
            return Effect().none();
        }).build();
  }

  @Override
  public EventHandler&lt;AuctionEvent, AuctionState&gt; eventHandler() {
    return eventHandlerBuilder(AuctionEvent.class)
        .matchEvent(BidRegistered.class, (state, event) -&gt; {
          if (AuctionState.isHigherBid(event.bid, state.highestBid)) {
            return state.withNewHighestBid(event.bid);
          } else {
            return state.withTooLowBid(event.bid);
          }
        }).matchEvent(AuctionFinished.class, (state, event) -&gt; {
          if (state.isClosed())
            return state; // already closed
          else
            return state.addFinishedAtDc(event.atDc);
        }).matchEvent(WinnerDecided.class, (state, event) -&gt; {
          return state.close();
        })
        .build();
  }

  private boolean shouldClose(AuctionState state) {
    return auctionSetup.responsibleForClosing &amp;&amp; !state.isClosed() &amp;&amp;
        getAllDcs().equals(state.finishedAtDc);
  }

  private void triggerCloseIfNeeded(ActorContext ctx, AuctionState state) {
    if (shouldClose(state))
      ctx.getSelf().tell(Close.INSTANCE, ctx.getSelf());
  }


  @Override
  public Effect&lt;AuctionEvent, AuctionState&gt; eventTrigger(EventTriggerContext ctx,
                            AuctionState state, AuctionEvent event) {
    if (event instanceof AuctionFinished &amp;&amp; !state.isClosed()) {
      AuctionFinished finished = (AuctionFinished) event;
      log().info(&quot;AuctionFinished at {}, already finished at [{}]&quot;,
          finished.atDc, state.finishedAtDc);
      ActorContext actorCtx = ctx.actorContext();
      if (state.finishedAtDc.contains(getSelfDc())) {
        triggerCloseIfNeeded(actorCtx, state);
      } else {
        log().info(&quot;Sending finish to self&quot;);
        actorCtx.getSelf().tell(Finish.INSTANCE, actorCtx.getSelf());
      }
    }

    return Effect().none();
  }

  @Override
  public Effect&lt;AuctionEvent, AuctionState&gt; recoveryCompleted(ActorContext ctx, AuctionState state) {
    triggerCloseIfNeeded(ctx, state);

    long millisUntilClosing = auctionSetup.closingAt.toEpochMilli() - currentTimeMillis();
    ctx.getTimers().startSingleTimer(FINISH_TIMER, Finish.INSTANCE,
        Duration.create(millisUntilClosing, TimeUnit.MILLISECONDS));
    return Effect().none();
  }

}</code></pre></dd>
</dl>
<p>The auction entity is started with the initial parameters for the auction. As seen before, replicated entities need to be parameterized with the types for commands and events and also for the internal state.</p>
<p>In the <code>initialState</code> method, a replicated entity needs to define its original state. In our case, it&rsquo;s straightforward to initialize the initial state from our initialization parameters as given in the <code>AuctionSetup</code> instance. The minimum bid is in our case modelled as an <code>initialBid</code>.</p>
<p>The <code>actions</code> defines how to react to external commands. In our case, for <code>OfferBid</code> and <code>AuctionFinished</code> we do nothing more than to emit events corresponding to the command. For <code>GetHighestBid</code> we respond with details from the state. Note, that we overwrite the actual offer of the highest bid here with the amount of the <code>highestCounterOffer</code>. This is done to follow the popular auction style where the actual highest bid is never publicly revealed.</p>
<p>Let&rsquo;s have a look at our state class, <code>AuctionState</code> which also represents the CRDT in our example.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>private val FinishTimer = &quot;FinishTimer&quot;

case class AuctionState(
  phase:               AuctionPhase,
  highestBid:          Bid,
  highestCounterOffer: MoneyAmount // in ebay style auctions, we need to keep track of current highest counter offer
) {

  def applyEvent(event: AuctionEvent): AuctionState =
    event match {
      case BidRegistered(b) =&gt;
        if (isHigherBid(b, highestBid)) withNewHighestBid(b)
        else withTooLowBid(b)
      case AuctionFinished(atDc) =&gt;
        phase match {
          case Running =&gt;
            copy(phase = Closing(Set(atDc)))
          case Closing(alreadyFinishedDcs) =&gt;
            copy(phase = Closing(alreadyFinishedDcs + atDc))
          case _ =&gt;
            this
        }
      case _: WinnerDecided =&gt;
        copy(phase = Closed)
    }

  def withNewHighestBid(bid: Bid): AuctionState = {
    require(phase != Closed)
    require(isHigherBid(bid, highestBid))
    copy(
      highestBid = bid,
      highestCounterOffer = highestBid.offer // keep last highest bid around
    )
  }
  def withTooLowBid(bid: Bid): AuctionState = {
    require(phase != Closed)
    require(isHigherBid(highestBid, bid))
    copy(highestCounterOffer = highestCounterOffer.max(bid.offer)) // update highest counter offer
  }

  def isHigherBid(first: Bid, second: Bid): Boolean =
    first.offer &gt; second.offer ||
      (first.offer == second.offer &amp;&amp; first.timestamp.isBefore(second.timestamp)) || // if equal, first one wins
      // If timestamps are equal, choose by dc where the offer was submitted
      // In real auctions, this last comparison should be deterministic but unpredictable, so that submitting to a
      // particular DC would not be an advantage.
      (first.offer == second.offer &amp;&amp; first.timestamp.equals(second.timestamp) &amp;&amp; first.originDc.compareTo(second.originDc) &lt; 0)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">static class AuctionState {

  final boolean stillRunning;
  final Bid highestBid;
  // in ebay style auctions, we need to keep track of current highest counter offer
  final int highestCounterOffer;
  final Set&lt;String&gt; finishedAtDc;

  AuctionState(boolean stillRunning, Bid highestBid, int highestCounterOffer, Set&lt;String&gt; finishedAtDc) {
    this.stillRunning = stillRunning;
    this.highestBid = highestBid;
    this.highestCounterOffer = highestCounterOffer;
    this.finishedAtDc = finishedAtDc;
  }

  AuctionState withNewHighestBid(Bid bid) {
    assert(stillRunning);
    assert(isHigherBid(bid, highestBid));
    return new AuctionState(stillRunning, bid, highestBid.offer, finishedAtDc); // keep last highest bid around
  }


  AuctionState withTooLowBid(Bid bid) {
    assert(stillRunning);
    assert(isHigherBid(highestBid, bid));
    return new AuctionState(stillRunning, highestBid, Math.max(highestCounterOffer, bid.offer), finishedAtDc);
  }

  static Boolean isHigherBid(Bid first, Bid second) {
    return first.offer &gt; second.offer ||
      (first.offer == second.offer &amp;&amp; first.timestamp.isBefore(second.timestamp)) || // if equal, first one wins
      // If timestamps are equal, choose by dc where the offer was submitted
      // In real auctions, this last comparison should be deterministic but unpredictable, so that submitting to a
      // particular DC would not be an advantage.
      (first.offer == second.offer &amp;&amp; first.timestamp.equals(second.timestamp) &amp;&amp; first.originDc.compareTo(second.originDc) &lt; 0);
  }

  AuctionState addFinishedAtDc(String dc) {
    Set&lt;String&gt; s = new HashSet&lt;&gt;(finishedAtDc);
    s.add(dc);
    return new AuctionState(false, highestBid, highestCounterOffer, Collections.unmodifiableSet(s));
  }

  public AuctionState close() {
    return new AuctionState(
        false,
        highestBid,
        highestCounterOffer,
        Collections.emptySet()
    );
  }

  public boolean isClosed() {
    return !stillRunning &amp;&amp; finishedAtDc.isEmpty();
  }
}</code></pre></dd>
</dl>
<p>The state consists of a flag that keeps track of whether the auction is still active, the currently highest bid, and the highest counter offer so far.</p>
<p>In the <code>eventHandler</code>, we handle persisted events to drive the state change. When a new bid is registered,</p>
<ul>
  <li>it needs to be decided whether the new bid is the winning bid or not</li>
  <li>the state needs to be updated accordingly</li>
</ul>
<p>The point of CRDTs is that the state must be end up being the same regardless of the order the events have been processed. We can see how this works in the auction example: we are only interested in the highest bid, so, if we can define an ordering on all bids, it should suffice to compare the new bid with currently highest to eventually end up with the globally highest regardless of the order in which the events come in.</p>
<p>The ordering between bids is crucial, therefore. We need to ensure that it is deterministic and does not depend on local state outside of our state class so that all replicas come to the same result. We define the ordering as this:</p>
<ul>
  <li>A higher bid wins.</li>
  <li>If there&rsquo;s a tie between the two highest bids, the bid that was registered earlier wins. For that we keep track of the  (local) timestamp the bid was registered.</li>
  <li>We need to make sure that no timestamp is used twice in the same DC (missing in this example).</li>
  <li>If there&rsquo;s a tie between the timestamp, we define an arbitrary but deterministic ordering on the DCs, in our case  we just compare the name strings of the DCs. That&rsquo;s why we need to keep the identifier of the DC where a bid was registered  for every <code>Bid</code>.</li>
</ul>
<p>If the new bid was higher, we keep this one as the new highest and keep the amount of the former highest as the <code>highestCounterOffer</code>. If the new bid was lower, we just update the <code>highestCounterOffer</code> if necessary.</p>
<p>Using those rules, the order of incoming does not matter. Replicas in all DCs should eventually converge to the same result.</p>
<h4><a href="#open-questions" name="open-questions" class="anchor"><span class="anchor-link"></span></a>Open questions</h4>
<p>The auction example shows basic features of an auction. There are a few additional considerations</p>
<ul>
  <li>Replica only eventually converge to the same result. That might lead to surprising results because highest bids from other replicas than  the local one might only turn up with a delay. Another surprising result might be that two bids with the same amount issued each to different  replicas in quick succession might be ordered differently due clock differences between replicas. In a real bidding system, it needs to be made sure  that no replica has a competitive advantage over another one.</li>
</ul>
<h4><a href="#complete-example-source-code" name="complete-example-source-code" class="anchor"><span class="anchor-link"></span></a>Complete example source code</h4>
<p>For reference here&rsquo;s the complete example, including imports and tests:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">/**
 * Copyright (C) 2017 Lightbend Inc. &lt;http://www.lightbend.com&gt;
 */
package akka.persistence.multidc.scaladsl

//#full-example
import java.time.Instant
import scala.concurrent.duration._

import com.typesafe.config.ConfigFactory

import akka.actor.{ ActorRef, ActorSystem, Props }
import akka.persistence.multidc.PersistenceMultiDcSettings

import org.scalatest.BeforeAndAfterAll
import org.scalatest.Matchers
import org.scalatest.WordSpecLike
import org.scalatest.BeforeAndAfter
import akka.persistence.multidc.testkit._
//#disable-replication
import akka.persistence.multidc.testkit.PersistenceMultiDcTestKit._

//#disable-replication

import akka.testkit.ImplicitSender
import akka.testkit.TestKit

object AuctionExampleSpec {
  //#full-example
  type MoneyAmount = Int

  //#auction-commands
  case class Bid(bidder: String, offer: MoneyAmount, timestamp: Instant, originDc: String)

  // commands
  sealed trait AuctionCommand
  case class OfferBid(bidder: String, offer: MoneyAmount) extends AuctionCommand
  case object Finish extends AuctionCommand // A timer needs to schedule this event at each replica
  case object GetHighestBid extends AuctionCommand
  case object IsClosed extends AuctionCommand
  private case object Close extends AuctionCommand // Internal, should not be sent from the outside
  //#auction-commands

  //#auction-events
  // events
  sealed trait AuctionEvent
  case class BidRegistered(bid: Bid) extends AuctionEvent
  case class AuctionFinished(atDc: String) extends AuctionEvent
  case class WinnerDecided(atDc: String, winningBid: Bid, highestCounterOffer: MoneyAmount) extends AuctionEvent
  //#auction-events

  def auctionProps(pid: String, auctionSetup: AuctionSetup, settings: PersistenceMultiDcSettings): Props =
    ReplicatedEntity.props(&quot;auction&quot;, pid, () =&gt; new AuctionEntity(auctionSetup), settings)

  /**
   * The auction passes through several workflow phases.
   * First, in `Running` `OfferBid` commands are accepted.
   *
   * `AuctionEntity` instances in all DCs schedule a `Finish` command
   * at a given time. That persists the `AuctionFinished` event and the
   * phase is in `Closing` until the auction is finished in all DCs.
   *
   * When the auction has been finished no more `OfferBid` commands are accepted.
   *
   * The auction is also finished immediately if `AuctionFinished` event from another
   * DC is seen before the scheduled `Finish` command. In that way the auction is finished
   * as quickly as possible in all DCs even though there might be some clock skew.
   *
   * One DC is responsible for finally deciding the winner and publishing the result.
   * All events must be collected from all DC before that can happen.
   * When the responsible DC has seen all `AuctionFinished` events from other DCs
   * all other events have also been propagated and it can persist `WinnerDecided` and
   * the auction is finally `Closed`.
   *
   */
  sealed trait AuctionPhase
  case object Running extends AuctionPhase
  case class Closing(finishedAtDc: Set[String]) extends AuctionPhase
  case object Closed extends AuctionPhase

  //#auction-state

  private val FinishTimer = &quot;FinishTimer&quot;

  case class AuctionState(
    phase:               AuctionPhase,
    highestBid:          Bid,
    highestCounterOffer: MoneyAmount // in ebay style auctions, we need to keep track of current highest counter offer
  ) {

    def applyEvent(event: AuctionEvent): AuctionState =
      event match {
        case BidRegistered(b) =&gt;
          if (isHigherBid(b, highestBid)) withNewHighestBid(b)
          else withTooLowBid(b)
        case AuctionFinished(atDc) =&gt;
          phase match {
            case Running =&gt;
              copy(phase = Closing(Set(atDc)))
            case Closing(alreadyFinishedDcs) =&gt;
              copy(phase = Closing(alreadyFinishedDcs + atDc))
            case _ =&gt;
              this
          }
        case _: WinnerDecided =&gt;
          copy(phase = Closed)
      }

    def withNewHighestBid(bid: Bid): AuctionState = {
      require(phase != Closed)
      require(isHigherBid(bid, highestBid))
      copy(
        highestBid = bid,
        highestCounterOffer = highestBid.offer // keep last highest bid around
      )
    }
    def withTooLowBid(bid: Bid): AuctionState = {
      require(phase != Closed)
      require(isHigherBid(highestBid, bid))
      copy(highestCounterOffer = highestCounterOffer.max(bid.offer)) // update highest counter offer
    }

    def isHigherBid(first: Bid, second: Bid): Boolean =
      first.offer &gt; second.offer ||
        (first.offer == second.offer &amp;&amp; first.timestamp.isBefore(second.timestamp)) || // if equal, first one wins
        // If timestamps are equal, choose by dc where the offer was submitted
        // In real auctions, this last comparison should be deterministic but unpredictable, so that submitting to a
        // particular DC would not be an advantage.
        (first.offer == second.offer &amp;&amp; first.timestamp.equals(second.timestamp) &amp;&amp; first.originDc.compareTo(second.originDc) &lt; 0)
  }
  //#auction-state

  //#auction-actor
  case class AuctionSetup(
    name:                  String,
    initialBid:            Bid, // the initial bid is basically the minimum price bidden at start time by the owner
    closingAt:             Instant,
    responsibleForClosing: Boolean)

  class AuctionEntity(auctionSetup: AuctionSetup)
    extends ReplicatedEntity[AuctionCommand, AuctionEvent, AuctionState] {

    override def initialState: AuctionState =
      AuctionState(
        phase = Running,
        highestBid = auctionSetup.initialBid,
        highestCounterOffer = auctionSetup.initialBid.offer)

    override def commandHandler: CommandHandler = {
      CommandHandler.byState {
        case AuctionState(Running, _, _) =&gt; running
        case _                           =&gt; finished
      }
    }

    private val running: CommandHandler = {
      CommandHandler {
        case (_, _, OfferBid(bidder, offer)) =&gt;
          Effect.persist(BidRegistered(Bid(bidder, offer, Instant.ofEpochMilli(currentTimeMillis()), selfDc)))
        case (ctx, state, GetHighestBid) =&gt;
          ctx.sender() ! state.highestBid.copy(offer = state.highestCounterOffer)
          Effect.none
        case (_, _, Finish) =&gt;
          log.info(&quot;Finish&quot;)
          Effect.persist(AuctionFinished(selfDc))
        case (_, _, Close) =&gt;
          log.warning(&quot;Premature close&quot;)
          // Close should only be triggered when we have already finished
          Effect.unhandled
        case (ctx, _, IsClosed) =&gt;
          ctx.sender() ! false
          Effect.none
      }
    }

    private val finished: CommandHandler = {
      CommandHandler {
        case (ctx, state, GetHighestBid) =&gt;
          ctx.sender() ! state.highestBid
          Effect.none
        case (ctx, state, IsClosed) =&gt;
          ctx.sender() ! (state.phase == Closed)
          Effect.none
        case (ctx, _, Finish) =&gt;
          log.info(&quot;Finish&quot;)
          Effect.persist(AuctionFinished(selfDc))
        case (_, state, Close) =&gt;
          log.info(&quot;Close&quot;)
          require(shouldClose(state))
          // TODO send email (before or after persisting)
          Effect.persist(WinnerDecided(selfDc, state.highestBid, state.highestCounterOffer))
        case (_, _, _: OfferBid) =&gt;
          // auction finished, no more bids accepted
          Effect.unhandled
      }
    }

    override def eventHandler(state: AuctionState, event: AuctionEvent): AuctionState =
      state.applyEvent(event)

    private def shouldClose(state: AuctionState): Boolean = {
      auctionSetup.responsibleForClosing &amp;&amp; (state.phase match {
        case Closing(alreadyFinishedAtDc) =&gt; allDcs.diff(alreadyFinishedAtDc).isEmpty
        case _                            =&gt; false
      })
    }

    private def triggerCloseIfNeeded(ctx: ActorContext, state: AuctionState): Unit = {
      if (shouldClose(state)) ctx.self ! Close
    }

    override def eventTrigger(
      ctx:   EventTriggerContext,
      state: AuctionState, event: AuctionEvent): Effect[AuctionEvent, AuctionState] = {
      event match {
        case finished: AuctionFinished =&gt;
          state.phase match {
            case Closing(alreadyFinishedAtDc) =&gt;
              log.info(&quot;AuctionFinished at {}, already finished at [{}]&quot;, finished.atDc,
                alreadyFinishedAtDc.mkString(&quot;, &quot;))
              if (alreadyFinishedAtDc(selfDc)) {
                triggerCloseIfNeeded(ctx.actorContext, state)
              } else {
                log.info(&quot;Sending finish to self&quot;)
                ctx.actorContext.self ! Finish
              }

            case _ =&gt; // no trigger for this state
          }
        case _ =&gt; // no trigger for this event
      }
      Effect.none
    }

    override def recoveryCompleted(ctx: ActorContext, state: AuctionState): Effect[AuctionEvent, AuctionState] = {
      triggerCloseIfNeeded(ctx, state)

      val millisUntilClosing = auctionSetup.closingAt.toEpochMilli - currentTimeMillis()
      ctx.timers.startSingleTimer(FinishTimer, Finish, millisUntilClosing.millis)

      Effect.none
    }

  }
  //#auction-actor

  //#full-example
  val allDcs = Seq(&quot;DC-A&quot;, &quot;DC-B&quot;)

  val clusterConfig = ConfigFactory.parseString(&quot;&quot;&quot;
    akka.actor.provider = &quot;cluster&quot;
    akka.remote.netty.tcp.port = 0
    akka.remote.classic.netty.tcp.port = 0
    akka.remote.artery.canonical.port = 0
    akka.remote.artery.canonical.hostname = 127.0.0.1
    akka.cluster.jmx.multi-mbeans-in-same-jvm = on

    # avoid eager init in tests
    akka.persistence.multi-data-center.hot-standby.enabled = off

    # FIXME when using Akka 2.6 we should use Jackson or JavaSerializable
    akka.actor.allow-java-serialization = on
    akka.actor.warn-about-java-serializer-usage = off

    # speed up joining and such
    akka.cluster.gossip-interval = 500 ms
  &quot;&quot;&quot;)

  def createSystem(dc: String = allDcs.head) =
    ActorSystem(
      &quot;AuctionExampleSpec&quot;,
      clusterConfig
        .withFallback(CassandraLifecycle.config)
        //#disable-replication
        // Include persistenceMultiDcTestSettings in your ActorSystem configuration
        // to allow suspending replication through PersistenceMultiDcTestKit
        .withFallback(persistenceMultiDcTestSettings(&quot;AuctionExampleSpec&quot;, dc, allDcs)))

  //#disable-replication

}

class AuctionExampleSpec extends TestKit(AuctionExampleSpec.createSystem())
  with ImplicitSender
  with WordSpecLike
  with Matchers
  with BeforeAndAfterAll
  with BeforeAndAfter
  with CassandraLifecycleScalatest {
  import AuctionExampleSpec._

  val systemName = &quot;AuctionExampleSpec&quot;
  val settings = PersistenceMultiDcSettings(system)

  val otherSystem = createSystem(allDcs(1))
  val otherSettings = PersistenceMultiDcSettings(otherSystem)

  val allSystems = Seq(system, otherSystem)

  class TestSetup(testName: String) {
    val minimumBid = 12
    val auctionSetupA = AuctionSetup(&quot;bicycle&quot;, Bid(&quot;me&quot;, minimumBid, Instant.now(), &quot;&quot;),
      closingAt = Instant.now().plusSeconds(60), responsibleForClosing = true)
    val auctionSetupB = auctionSetupA.copy(responsibleForClosing = false)

    val nodeA = system.actorOf(auctionProps(s&quot;bikeAuction-$testName&quot;, auctionSetupA, settings), s&quot;auction-A-$testName&quot;)
    val nodeB = otherSystem.actorOf(auctionProps(s&quot;bikeAuction-$testName&quot;, auctionSetupB, otherSettings), s&quot;auction-B-$testName&quot;)

    def expectHighestBid(node: ActorRef): Bid = {
      node ! GetHighestBid
      expectMsgType[Bid]
    }
    def expectHighestBid(node: ActorRef, bidder: String, expected: MoneyAmount): Unit = {
      val bid = expectHighestBid(node)
      bid.offer shouldEqual expected
      bid.bidder shouldEqual bidder
    }
    def expectClosed(node: ActorRef): Unit = {
      node ! IsClosed
      expectMsg(true)
    }
  }

  &quot;AuctionExample&quot; should {
    &quot;propagate highest bid to replicated actor&quot; in new TestSetup(&quot;test1&quot;) {
      // simple bidding
      nodeA ! OfferBid(&quot;Mary&quot;, 42)
      expectHighestBid(nodeA, &quot;Mary&quot;, minimumBid) // ebay style, still the minimum offer

      nodeA ! OfferBid(&quot;Paul&quot;, 41)
      expectHighestBid(nodeA, &quot;Mary&quot;, 41) // ebay style, now updated to the highest counter offer

      awaitAssert {
        // check that results have propagated to b
        expectHighestBid(nodeB, &quot;Mary&quot;, 41) // ebay style, now updated to the highest counter offer
      }

      // make sure that first bidder still keeps the crown
      nodeB ! OfferBid(&quot;c&quot;, 42)
      expectHighestBid(nodeB, &quot;Mary&quot;, 42)
    }

    &quot;eventually resolve conflicting bids during auction if bids are highest (but different) in each dc&quot; in new TestSetup(&quot;test2&quot;) {
      // highest bid comes first
      nodeA ! OfferBid(&quot;Mary&quot;, 42)
      nodeB ! OfferBid(&quot;Paul&quot;, 41)

      awaitAssert {
        expectHighestBid(nodeA, &quot;Mary&quot;, 41)
        expectHighestBid(nodeB, &quot;Mary&quot;, 41)
      }

      // highest bid comes second
      nodeA ! OfferBid(&quot;Paul&quot;, 50)
      nodeB ! OfferBid(&quot;Kat&quot;, 60)

      awaitAssert {
        expectHighestBid(nodeA, &quot;Kat&quot;, 50)
        expectHighestBid(nodeB, &quot;Kat&quot;, 50)
      }
    }
    &quot;eventually resolve conflicting bids during auction if bids are highest and equal (but different time) in each dc&quot; in
      new TestSetup(&quot;test3&quot;) {
        nodeA ! OfferBid(&quot;Mary&quot;, 15)
        expectHighestBid(nodeA, &quot;Mary&quot;, 12)

        nodeB ! OfferBid(&quot;Paul&quot;, 15)

        awaitAssert {
          expectHighestBid(nodeA, &quot;Mary&quot;, 15)
          expectHighestBid(nodeB, &quot;Mary&quot;, 15)
        }
      }

    &quot;eventually come to a consistent final result&quot; in
      new TestSetup(&quot;test4&quot;) {
        nodeA ! OfferBid(&quot;Mary&quot;, 42)
        nodeB ! OfferBid(&quot;Paul&quot;, 43)
        Thread.sleep(3000)

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeA ! Finish

        awaitAssert {
          expectClosed(nodeA)
          expectClosed(nodeB)
        }

        expectHighestBid(nodeA, &quot;Paul&quot;, 43)
        expectHighestBid(nodeB, &quot;Paul&quot;, 43)
      }

    &quot;eventually come to a consistent final result when finishing is initiated on node B&quot; in
      new TestSetup(&quot;test5&quot;) {
        nodeA ! OfferBid(&quot;Mary&quot;, 42)
        nodeB ! OfferBid(&quot;Paul&quot;, 43)
        Thread.sleep(3000)

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeB ! Finish

        awaitAssert {
          expectClosed(nodeA)
          expectClosed(nodeB)
        }

        expectHighestBid(nodeA, &quot;Paul&quot;, 43)
        expectHighestBid(nodeB, &quot;Paul&quot;, 43)
      }

    //#disable-replication
    &quot;correctly resolve concurrent writes when replication is temporarily suspended&quot; in
      new TestSetup(&quot;test6&quot;) {
        disableReplication(otherSystem, system)

        nodeA ! OfferBid(&quot;Mary&quot;, 42)
        nodeB ! OfferBid(&quot;Paul&quot;, 43)

        expectHighestBid(nodeA, &quot;Mary&quot;, 12)

        enableReplication(otherSystem, system)

        awaitAssert {
          expectHighestBid(nodeA, &quot;Paul&quot;, 42)
        }
      }
    //#disable-replication
  }

  after {
    allSystems.foreach { sys =&gt;
      enableAllReplicationTo(sys)
    }
  }

  override protected def afterAll(): Unit = {
    allSystems.foreach(sys =&gt; shutdown(sys))
    super.afterAll()
  }
}
//#full-example</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">/*
 * Copyright (C) 2009-2017 Lightbend Inc. &lt;http://www.lightbend.com&gt;
 */
package akka.persistence.multidc.javadsl;

//#full-example
import java.io.Serializable;
import java.time.Instant;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;

import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import akka.japi.JAPI;
import akka.persistence.cassandra.testkit.CassandraLauncher;
import akka.persistence.multidc.PersistenceMultiDcSettings;
import akka.testkit.javadsl.TestKit;

//#cassandra-hook
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.scalatest.junit.JUnitSuite;

import akka.persistence.multidc.testkit.CassandraLifecycle;
//#disable-replication
import akka.persistence.multidc.testkit.PersistenceMultiDcTestKit;

//#disable-replication

//#cassandra-hook
import scala.concurrent.duration.Duration;

import static org.junit.Assert.assertEquals;

//#cassandra-hook
public class AuctionExampleTest extends JUnitSuite {
//#cassandra-hook

  //#auction-commands
  static class Bid implements Serializable {
    final String bidder;
    final int offer;
    final Instant timestamp;
    final String originDc;

    Bid(String bidder, int offer, Instant timestamp, String originDc) {
      this.bidder = bidder;
      this.offer = offer;
      this.timestamp = timestamp;
      this.originDc = originDc;
    }

    Bid withOffer(int offer) {
      return new Bid(bidder, offer, timestamp, originDc);
    }
  }


  // commands
  interface AuctionCommand extends Serializable {}
  static class OfferBid implements AuctionCommand {
    final String bidder;
    final int offer;
    public OfferBid(String bidder, int offer) {
      this.bidder = bidder;
      this.offer = offer;
    }
  }
  // An auction coordinator needs to schedule this event to each replica
  static class Finish implements AuctionCommand {
    static final Finish INSTANCE = new Finish();
    private Finish() {}
  }
  static class GetHighestBid implements AuctionCommand {
    static final GetHighestBid INSTANCE = new GetHighestBid();
    private GetHighestBid() {}
  }
  static class IsClosed implements AuctionCommand {
    static final IsClosed INSTANCE = new IsClosed();
    private IsClosed() {}
  }
  // Internal, should not be sent from the outside
  private static class Close implements AuctionCommand {
    static final Close INSTANCE = new Close();
    private Close() {}
  }
  //#auction-commands

  //#auction-events
  // events
  interface AuctionEvent extends Serializable {}
  static class BidRegistered implements AuctionEvent {
    final Bid bid;
    public BidRegistered(Bid bid) {
      this.bid = bid;
    }
  }
  static class AuctionFinished implements AuctionEvent {
    final String atDc;
    public AuctionFinished(String atDc) {
      this.atDc = atDc;
    }
  }
  static class WinnerDecided implements AuctionEvent {
    final String atDc;
    final Bid winningBid;
    final int highestCounterOffer;
    public WinnerDecided(String atDc, Bid winningBid, int highestCounterOffer) {
      this.atDc = atDc;
      this.winningBid = winningBid;
      this.highestCounterOffer = highestCounterOffer;
    }
  }
  //#auction-events


  //#auction-state
  static class AuctionState {

    final boolean stillRunning;
    final Bid highestBid;
    // in ebay style auctions, we need to keep track of current highest counter offer
    final int highestCounterOffer;
    final Set&lt;String&gt; finishedAtDc;

    AuctionState(boolean stillRunning, Bid highestBid, int highestCounterOffer, Set&lt;String&gt; finishedAtDc) {
      this.stillRunning = stillRunning;
      this.highestBid = highestBid;
      this.highestCounterOffer = highestCounterOffer;
      this.finishedAtDc = finishedAtDc;
    }

    AuctionState withNewHighestBid(Bid bid) {
      assert(stillRunning);
      assert(isHigherBid(bid, highestBid));
      return new AuctionState(stillRunning, bid, highestBid.offer, finishedAtDc); // keep last highest bid around
    }


    AuctionState withTooLowBid(Bid bid) {
      assert(stillRunning);
      assert(isHigherBid(highestBid, bid));
      return new AuctionState(stillRunning, highestBid, Math.max(highestCounterOffer, bid.offer), finishedAtDc);
    }

    static Boolean isHigherBid(Bid first, Bid second) {
      return first.offer &gt; second.offer ||
        (first.offer == second.offer &amp;&amp; first.timestamp.isBefore(second.timestamp)) || // if equal, first one wins
        // If timestamps are equal, choose by dc where the offer was submitted
        // In real auctions, this last comparison should be deterministic but unpredictable, so that submitting to a
        // particular DC would not be an advantage.
        (first.offer == second.offer &amp;&amp; first.timestamp.equals(second.timestamp) &amp;&amp; first.originDc.compareTo(second.originDc) &lt; 0);
    }

    AuctionState addFinishedAtDc(String dc) {
      Set&lt;String&gt; s = new HashSet&lt;&gt;(finishedAtDc);
      s.add(dc);
      return new AuctionState(false, highestBid, highestCounterOffer, Collections.unmodifiableSet(s));
    }

    public AuctionState close() {
      return new AuctionState(
          false,
          highestBid,
          highestCounterOffer,
          Collections.emptySet()
      );
    }

    public boolean isClosed() {
      return !stillRunning &amp;&amp; finishedAtDc.isEmpty();
    }
  }
  //#auction-state

  private static final String FINISH_TIMER = &quot;FinishTimer&quot;;

  //#auction-actor
  static class AuctionSetup {
    final String name;
    final Bid initialBid; // the initial bid is basically the minimum price bidden at start time by the owner
    final Instant closingAt;
    final boolean responsibleForClosing;
    public AuctionSetup(String name, Bid initialBid, Instant closingAt, boolean responsibleForClosing) {
      this.name = name;
      this.initialBid = initialBid;
      this.closingAt = closingAt;
      this.responsibleForClosing = responsibleForClosing;
    }
  }

  static class AuctionEntity extends ReplicatedEntity&lt;AuctionCommand, AuctionEvent, AuctionState&gt; {

    final AuctionSetup auctionSetup;

    public AuctionEntity(AuctionSetup auctionSetup) {
      this.auctionSetup = auctionSetup;
    }

    @Override
    public AuctionState initialState() {
      return new AuctionState(
          true,
          auctionSetup.initialBid,
          auctionSetup.initialBid.offer,
          Collections.emptySet());
    }

    @Override
    public CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; commandHandler() {
      return byStateCommandHandlerBuilder(AuctionState.class)
          .matchState(state -&gt; state.stillRunning, running())
          .matchAny(finished());
    }

    private CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; running() {
      return commandHandlerBuilder(AuctionCommand.class)
          .matchCommand(OfferBid.class, (ctx, state, offerBid) -&gt; {
            return Effect().persist(new BidRegistered(new Bid(offerBid.bidder, offerBid.offer,
                Instant.ofEpochMilli(currentTimeMillis()), selfDc())));
          }).matchExactCommand(GetHighestBid.INSTANCE, (ctx, state, query) -&gt; {
            ctx.getSender().tell(state.highestBid.withOffer(state.highestCounterOffer), getSelf());
            return Effect().none();
          }).matchExactCommand(Finish.INSTANCE, (ctx, state, finish) -&gt; {
            log().info(&quot;Finish&quot;);
            return Effect().persist(new AuctionFinished(selfDc()));
          }).matchExactCommand(Close.INSTANCE, (ctx, state, close) -&gt; {
            log().warning(&quot;Premature close&quot;);
            // Close should only be triggered when we have already finished
            return Effect().unhandled();
          }).matchExactCommand(IsClosed.INSTANCE, (ctx, state, query) -&gt; {
            ctx.getSender().tell(false, getSelf());
            return Effect().none();
          }).build();
    }

    private CommandHandler&lt;AuctionCommand, AuctionEvent, AuctionState&gt; finished() {
      return commandHandlerBuilder(AuctionCommand.class)
          .matchCommand(OfferBid.class, (ctx, state, offerBid) -&gt; {
            // auction finished, no more bids accepted
            return Effect().unhandled();
          }).matchExactCommand(GetHighestBid.INSTANCE, (ctx, state, query) -&gt; {
            ctx.getSender().tell(state.highestBid, getSelf());
            return Effect().none();
          }).matchExactCommand(Finish.INSTANCE, (ctx, state, finish) -&gt; {
            log().info(&quot;Finish&quot;);
            return Effect().persist(new AuctionFinished(selfDc()));
          }).matchExactCommand(Close.INSTANCE, (ctx, state, close) -&gt; {
            log().info(&quot;Close&quot;);
            // TODO send email (before or after persisting)
            return Effect().persist(new WinnerDecided(selfDc(), state.highestBid, state.highestCounterOffer));
          }).matchExactCommand(IsClosed.INSTANCE, (ctx, state, query) -&gt; {
              ctx.getSender().tell(state.isClosed(), getSelf());
              return Effect().none();
          }).build();
    }

    @Override
    public EventHandler&lt;AuctionEvent, AuctionState&gt; eventHandler() {
      return eventHandlerBuilder(AuctionEvent.class)
          .matchEvent(BidRegistered.class, (state, event) -&gt; {
            if (AuctionState.isHigherBid(event.bid, state.highestBid)) {
              return state.withNewHighestBid(event.bid);
            } else {
              return state.withTooLowBid(event.bid);
            }
          }).matchEvent(AuctionFinished.class, (state, event) -&gt; {
            if (state.isClosed())
              return state; // already closed
            else
              return state.addFinishedAtDc(event.atDc);
          }).matchEvent(WinnerDecided.class, (state, event) -&gt; {
            return state.close();
          })
          .build();
    }

    private boolean shouldClose(AuctionState state) {
      return auctionSetup.responsibleForClosing &amp;&amp; !state.isClosed() &amp;&amp;
          getAllDcs().equals(state.finishedAtDc);
    }

    private void triggerCloseIfNeeded(ActorContext ctx, AuctionState state) {
      if (shouldClose(state))
        ctx.getSelf().tell(Close.INSTANCE, ctx.getSelf());
    }


    @Override
    public Effect&lt;AuctionEvent, AuctionState&gt; eventTrigger(EventTriggerContext ctx,
                              AuctionState state, AuctionEvent event) {
      if (event instanceof AuctionFinished &amp;&amp; !state.isClosed()) {
        AuctionFinished finished = (AuctionFinished) event;
        log().info(&quot;AuctionFinished at {}, already finished at [{}]&quot;,
            finished.atDc, state.finishedAtDc);
        ActorContext actorCtx = ctx.actorContext();
        if (state.finishedAtDc.contains(getSelfDc())) {
          triggerCloseIfNeeded(actorCtx, state);
        } else {
          log().info(&quot;Sending finish to self&quot;);
          actorCtx.getSelf().tell(Finish.INSTANCE, actorCtx.getSelf());
        }
      }

      return Effect().none();
    }

    @Override
    public Effect&lt;AuctionEvent, AuctionState&gt; recoveryCompleted(ActorContext ctx, AuctionState state) {
      triggerCloseIfNeeded(ctx, state);

      long millisUntilClosing = auctionSetup.closingAt.toEpochMilli() - currentTimeMillis();
      ctx.getTimers().startSingleTimer(FINISH_TIMER, Finish.INSTANCE,
          Duration.create(millisUntilClosing, TimeUnit.MILLISECONDS));
      return Effect().none();
    }

  }
  //#auction-actor

  static Props auctionProps(String pid, AuctionSetup auctionSetup, PersistenceMultiDcSettings settings) {
    return ReplicatedEntity.props(
        AuctionCommand.class,
        &quot;auction&quot;,
        pid,
        () -&gt; new AuctionEntity(auctionSetup),
        settings);
  }


  static private class TestSetup extends TestKit {
    final String testName;
    final int minimumBid = 12;
    final AuctionSetup auctionSetupA;
    final AuctionSetup auctionSetupB;
    final ActorRef nodeA;
    final ActorRef nodeB;

    TestSetup(String testName) {
      super(system);
      this.testName = testName;
      auctionSetupA = new AuctionSetup(&quot;bicycle&quot;, new Bid(&quot;me&quot;, minimumBid, Instant.now(),
          &quot;&quot;), Instant.now().plusSeconds(60), true);
      auctionSetupB = new AuctionSetup(&quot;bicycle&quot;, new Bid(&quot;me&quot;, minimumBid, Instant.now(),
          &quot;&quot;), Instant.now().plusSeconds(60), false);

      PersistenceMultiDcSettings settings = PersistenceMultiDcSettings.create(system);
      PersistenceMultiDcSettings otherSettings = PersistenceMultiDcSettings.create(otherSystem);

      nodeA = system.actorOf(auctionProps(&quot;bikeAuction-&quot; + testName, auctionSetupA, settings), &quot;auction-A-&quot; + testName);
      nodeB = otherSystem.actorOf(auctionProps(&quot;bikeAuction-&quot; + testName, auctionSetupB, otherSettings), &quot;auction-B-&quot; + testName);
    }

    Bid expectHighestBid(ActorRef node) {
        node.tell(GetHighestBid.INSTANCE, getTestActor());
        return expectMsgClass(Bid.class);
    }

    void expectHighestBid(ActorRef node, String bidder, int expected) {
        Bid bid = expectHighestBid(node);
        assertEquals(expected, bid.offer);
        assertEquals(bidder, bid.bidder);
    }

    void expectClosed(ActorRef node) {
      node.tell(IsClosed.INSTANCE, getTestActor());
      expectMsg(true);
    }

  }

  private static Config clusterConfig = ConfigFactory.parseString(String.join(&quot;\n&quot;,
    &quot;akka.actor.provider = \&quot;cluster\&quot;&quot;,
    &quot;akka.remote.netty.tcp.port = 0&quot;,
    &quot;akka.remote.classic.netty.tcp.port = 0&quot;,
    &quot;akka.remote.artery.canonical.port = 0&quot;,
    &quot;akka.remote.artery.canonical.hostname = 127.0.0.1&quot;,
    &quot;akka.cluster.jmx.multi-mbeans-in-same-jvm = on&quot;,
    // avoid eager init in tests
    &quot;akka.persistence.multi-data-center.hot-standby.enabled = off&quot;,
    // FIXME when using Akka 2.6 we should use Jackson or JavaSerializable
    &quot;akka.actor.allow-java-serialization = on&quot;,
    &quot;akka.actor.warn-about-java-serializer-usage = off&quot;,
    // speed up joining and such
    &quot;akka.cluster.gossip-interval = 500 ms&quot;));

  private static ActorSystem createSystem(String dc) {
    return ActorSystem.create(
      &quot;auctionTest&quot;,
      clusterConfig
        .withFallback(CassandraLifecycle.config())
        //#disable-replication
        // Include persistenceMultiDcTestSettings in your ActorSystem configuration
        // to allow suspending replication through PersistenceMultiDcTestKit
        .withFallback(PersistenceMultiDcTestKit.persistenceMultiDcTestSettings(&quot;auctionTest&quot;, dc, JAPI.seq(&quot;DC-A&quot;, &quot;DC-B&quot;))));

        //#disable-replication
  }

  //#cassandra-hook
  private static ActorSystem system;
  private static ActorSystem otherSystem;

  @BeforeClass
  public static void setupSystems() {
    system = createSystem(&quot;DC-A&quot;);
    CassandraLifecycle.startCassandra(system.name(), CassandraLauncher.DefaultTestConfigResource());
    CassandraLifecycle.awaitPersistenceInit(system);

    otherSystem = createSystem(&quot;DC-B&quot;);
    CassandraLifecycle.awaitPersistenceInit(otherSystem);
  }

  @AfterClass
  public static void tearDownSystems() {
    TestKit.shutdownActorSystem(system, true);
    TestKit.shutdownActorSystem(otherSystem, true);
    CassandraLifecycle.stopCassandra();
  }
  //#cassandra-hook

  @Test
  public void propagateHighestBidToReplicatedActor() {
    new TestSetup(&quot;test-1&quot;) {
      {
        // simple bidding
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        expectHighestBid(nodeA, &quot;Mary&quot;, minimumBid); // ebay style, still the minimum offer

        nodeA.tell(new OfferBid(&quot;Paul&quot;, 41), ActorRef.noSender());
        expectHighestBid(nodeA, &quot;Mary&quot;, 41); // ebay style, now updated to the highest counter offer

        awaitAssert(
            () -&gt; {
              expectHighestBid(nodeB, &quot;Mary&quot;, 41);
              return null;
            });

        awaitAssert(
            () -&gt; {
              // check that results have propagated to b
              expectHighestBid(nodeB, &quot;Mary&quot;, 41); // ebay style, now updated to the highest counter offer
              return null;
            }
        );

        // make sure that first bidder still keeps the crown
        nodeB.tell(new OfferBid(&quot;c&quot;, 42), ActorRef.noSender());
        expectHighestBid(nodeB, &quot;Mary&quot;, 42);
      }
    };
  }


  @Test
  public void eventuallyResolveConflictingBidsDuringAuctionIfBidsAreHighestButDifferentInEachDc() {
    new TestSetup(&quot;test-2&quot;) {
      {
        // highest bid comes first
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 41), ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectHighestBid(nodeA, &quot;Mary&quot;, 41);
          expectHighestBid(nodeB, &quot;Mary&quot;, 41);
          return null;
        });


        // highest bid comes second
        nodeA.tell(new OfferBid(&quot;Paul&quot;, 50), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Kat&quot;, 60), ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectHighestBid(nodeA, &quot;Kat&quot;, 50);
          expectHighestBid(nodeB, &quot;Kat&quot;, 50);
          return null;
        });
      }
    };
  }

  @Test
  public void eventuallyResolveConflictingBidsDuringAuctionIfBidsAreHighestAndEqualButDifferentTimeInEachDc() {
    new TestSetup(&quot;test3&quot;) {
      {
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 15), ActorRef.noSender());
        expectHighestBid(nodeA, &quot;Mary&quot;, 12);

        nodeB.tell(new OfferBid(&quot;Paul&quot;, 15), ActorRef.noSender());

        awaitAssert(() -&gt; {
            expectHighestBid(nodeA, &quot;Mary&quot;, 15);
            expectHighestBid(nodeB, &quot;Mary&quot;, 15);
            return null;
        });
      }
    };
  }

  @Test
  public void eventuallyComeToAConsistentFinalResult() throws Exception {
    new TestSetup(&quot;test4&quot;) {
      {
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 43), ActorRef.noSender());
        Thread.sleep(3000);

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeA.tell(Finish.INSTANCE, ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectClosed(nodeA);
          expectClosed(nodeB);
          return null;
        });

        expectHighestBid(nodeA, &quot;Paul&quot;, 43);
        expectHighestBid(nodeB, &quot;Paul&quot;, 43);
      }
    };
  }

  @Test
  public void eventuallyComeToAConsistentFinalResultWhenFinishingIsInitiatedOnNodeB() throws Exception {
    new TestSetup(&quot;test5&quot;) {
      {
        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 43), ActorRef.noSender());
        Thread.sleep(3000);

        // Finish is scheduled by the AuctionEntity, but we can do it earlier from the test
        nodeB.tell(Finish.INSTANCE, ActorRef.noSender());

        awaitAssert(() -&gt; {
          expectClosed(nodeA);
          expectClosed(nodeB);
          return null;
        });

        expectHighestBid(nodeA, &quot;Paul&quot;, 43);
        expectHighestBid(nodeB, &quot;Paul&quot;, 43);
      }
    };
  }

  //#disable-replication
  @Test
  public void correctlyResolveConcurrentWritesWhenReplicationIsTemporarilySuspended() throws Exception {
    new TestSetup(&quot;test6&quot;) {
      {
        PersistenceMultiDcTestKit.disableReplication(otherSystem, system);

        nodeA.tell(new OfferBid(&quot;Mary&quot;, 42), ActorRef.noSender());
        nodeB.tell(new OfferBid(&quot;Paul&quot;, 43), ActorRef.noSender());

        expectHighestBid(nodeA, &quot;Mary&quot;, 12);

        PersistenceMultiDcTestKit.enableReplication(otherSystem, system);

        awaitAssert(() -&gt; {
          expectHighestBid(nodeA, &quot;Paul&quot;, 42);
          return null;
        });

      }
    };
  }
  //#disable-replication
//#cassandra-hook
}
//#cassandra-hook
//#full-example</code></pre></dd>
</dl>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../persistence-dc/examples.html"><i class="icon-prev"></i> <span class="link-prev">Additional Examples</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../persistence-dc/shopping-cart-example.html">Shopping Cart Example <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<!-- no source links for private github repository -->

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<p class="legal">
&copy; 2011-2020 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- hook for including project specific javascript into the generated docs -->

</body>
</html>
