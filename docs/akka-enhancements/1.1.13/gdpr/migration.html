<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Migrating existing data &bull; Akka Enhancements</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka Enhancements is a suite of useful components that complement Akka."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka-enhancements/current/gdpr/migration.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-7.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-1.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_setDomainName', '']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="../images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="../images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="../images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="../images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="../images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="../images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="../images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Enhancements</a></h1>
</div>
<div class="nav-header-version">
Version 1.1.13
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../akka-resilience-enhancements.html" class="page">Akka Resilience Enhancements</a></li>
  <li><a href="../akka-persistence-enhancements.html" class="page">Akka Persistence Enhancements</a>
  <ul>
    <li><a href="../persistence-dc/index.html" class="page">Akka Multi-DC Persistence</a></li>
    <li><a href="../gdpr/index.html" class="page">GDPR for Akka Persistence</a>
    <ul>
      <li><a href="../gdpr/index.html#introduction" class="header">Introduction</a></li>
      <li><a href="../gdpr/data-subject-id.html" class="page">Subject identifiers</a></li>
      <li><a href="../gdpr/shredding.html" class="page">Shred or delete?</a></li>
      <li><a href="../gdpr/using.html" class="page">Using akka-gdpr</a></li>
      <li><a href="../gdpr/encryption.html" class="page">Encrypting data</a></li>
      <li><a href="../gdpr/migration.html#migrating-existing-data" class="active page">Migrating existing data</a>
      <ul>
        <li><a href="../gdpr/migration.html#dependencies" class="header">Dependencies</a></li>
        <li><a href="../gdpr/migration.html#using-journalupdater-to-encrypt-data-for-a-given-persistenceid" class="header">Using <code>JournalUpdater</code> to encrypt data for a given persistenceId</a></li>
        <li><a href="../gdpr/migration.html#migrating-snapshots" class="header">Migrating snapshots</a></li>
      </ul></li>
      <li><a href="../gdpr/lagom.html" class="page">Lagom specifics</a></li>
      <li><a href="../gdpr/other-storage.html" class="page">Other data storage</a></li>
    </ul></li>
    <li><a href="../akka-persistence-enhancements-release-notes.html" class="page">Akka Persistence Enhancements Release Notes</a></li>
  </ul></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Enhancements</a></h1>
</div>
<div class="nav-header-version">
Version 1.1.13
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../akka-resilience-enhancements.html" class="page">Akka Resilience Enhancements</a></li>
  <li><a href="../akka-persistence-enhancements.html" class="page">Akka Persistence Enhancements</a>
  <ul>
    <li><a href="../persistence-dc/index.html" class="page">Akka Multi-DC Persistence</a></li>
    <li><a href="../gdpr/index.html" class="page">GDPR for Akka Persistence</a>
    <ul>
      <li><a href="../gdpr/index.html#introduction" class="header">Introduction</a></li>
      <li><a href="../gdpr/data-subject-id.html" class="page">Subject identifiers</a></li>
      <li><a href="../gdpr/shredding.html" class="page">Shred or delete?</a></li>
      <li><a href="../gdpr/using.html" class="page">Using akka-gdpr</a></li>
      <li><a href="../gdpr/encryption.html" class="page">Encrypting data</a></li>
      <li><a href="../gdpr/migration.html#migrating-existing-data" class="active page">Migrating existing data</a>
      <ul>
        <li><a href="../gdpr/migration.html#dependencies" class="header">Dependencies</a></li>
        <li><a href="../gdpr/migration.html#using-journalupdater-to-encrypt-data-for-a-given-persistenceid" class="header">Using <code>JournalUpdater</code> to encrypt data for a given persistenceId</a></li>
        <li><a href="../gdpr/migration.html#migrating-snapshots" class="header">Migrating snapshots</a></li>
      </ul></li>
      <li><a href="../gdpr/lagom.html" class="page">Lagom specifics</a></li>
      <li><a href="../gdpr/other-storage.html" class="page">Other data storage</a></li>
    </ul></li>
    <li><a href="../akka-persistence-enhancements-release-notes.html" class="page">Akka Persistence Enhancements Release Notes</a></li>
  </ul></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#migrating-existing-data" name="migrating-existing-data" class="anchor"><span class="anchor-link"></span></a>Migrating existing data</h1>
<p>First, read <a href="shredding.html">Shred or delete?</a> and <a href="encryption.html">Encrypting data</a> to understand which existing events you might want to modify. Remember that in general, when using event sourcing, it is not recommended to modify events&mdash;they are meant to be immutable.</p>
<p>However, if you have an existing application that you want to move to use data encryption for payloads, and eventually also make use of <a href="shredding.html">data shredding</a>, you can use <code>akka-persistence-update</code> to <em>update</em> (modify, in place) events that have been stored using Akka Persistence or Lagom&rsquo;s Persistent Entities.</p>
<h2><a href="#dependencies" name="dependencies" class="anchor"><span class="anchor-link"></span></a>Dependencies</h2>
<p>To create such a migration you will want to depend on the <code>akka-persistence-update</code> module in addition to the <code>akka-gdpr</code> module, since we will be using its encryption capabilities:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.lightbend.akka" %% "akka-persistence-update" % "1.1.13"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.lightbend.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-persistence-update_2.12&lt;/artifactId&gt;
  &lt;version&gt;1.1.13&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.lightbend.akka', name: 'akka-persistence-update_2.12', version: '1.1.13'
}</code></pre></dd></dl><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.lightbend.akka" %% "akka-gdpr" % "1.1.13"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.lightbend.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-gdpr_2.12&lt;/artifactId&gt;
  &lt;version&gt;1.1.13&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.lightbend.akka', name: 'akka-gdpr_2.12', version: '1.1.13'
}</code></pre></dd></dl>
<h2><a href="#using-journalupdater-to-encrypt-data-for-a-given-persistenceid" name="using-journalupdater-to-encrypt-data-for-a-given-persistenceid" class="anchor"><span class="anchor-link"></span></a>Using <code>JournalUpdater</code> to encrypt data for a given persistenceId</h2>
<p>The <code>JournalUpdater</code> API can perform sweeping changes to events in-place.These APIs are intended to be used for offline migrations of data. Specifically in this case, for GDPR compliance, you may want to encrypt events using GDPR for Akka Persistence. The <code>akka-gdpr</code> module automatically encrypts events that are wrapped using <code>akka.persistence.gdpr.WithDataSubjectId</code>. See <a href="using.html#wrapping-data-in-withdatasubjectid">Wrapping data in WithDataSubjectId</a> for more information.</p>
<p>In order to encrypt all persisted events you may use the <code>transformAllPersistenceIds</code> operation and replace the existing payload with the payload wrapped in an <code>WithDataSubjectId</code>. GDPR for Akka Persistence will handle the key lookup and encryption of such wrapped event transparently for you from there on.</p>
<p>When using Lagom it&rsquo;s recommended to use the <code>WithDataSubjectId</code> inside the events rather than wrapping the events with <code>WithDataSubjectId</code> as described in the section <a href="lagom.html#lagom-persistententity">Lagom PersistentEntity</a>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Note that for the updater to be able to perform its duties, the underlying Akka Persistence Journal has to implement such update operations. Currently only the Cassandra and JDBC journals implement this feature.</p>
<p>The <a href="https://github.com/akka/akka-persistence-cassandra">Cassandra journal</a> must be version 0.85 or later. That version is not used by default by Lagom but it is possible and existing applications can be <a href="https://github.com/akka/akka-persistence-cassandra#migrations-to-080-and-later">migrated</a>. Contact <a href="http://support.lightbend.com/">Lightbend Support</a> for detailed instructions and help with updating the Cassandra journal version with Lagom.</p>
<p>The <a href="https://github.com/dnvriend/akka-persistence-jdbc">JDBC journal</a> must be version 3.4.0 or later, and that is the version that Lagom 1.4.6 is using.</p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import java.security.MessageDigest

import akka.Done
import akka.stream.scaladsl.Sink


import akka.persistence.cassandra.query.scaladsl.CassandraReadJournal
import akka.persistence.query.PersistenceQuery


import akka.actor.ActorSystem
import akka.persistence.gdpr.WithDataSubjectId
import akka.persistence.update.JournaledEvent
import akka.persistence.update.cassandra.scaladsl.CassandraJournalTransformer
import akka.persistence.update.scaladsl.{ JournalTransformer, JournalUpdater }
import akka.stream.ActorMaterializer

import scala.concurrent.Future

class GdprMigrationExamples {

  implicit val system = ActorSystem()
  implicit val ec = system.dispatcher
  implicit val mat = ActorMaterializer()

  val identifier: String = CassandraJournalTransformer.Identifier
  // or, for JDBC, the following:
  //  val identifier: String = JdbcJournalTransformer.Identifier

  val transformer: JournalTransformer = JournalUpdater(system)
    .journalUpdaterFor[JournalTransformer](identifier)

  def run(): Unit = {
    transformer.transformAllPersistenceIds(updateEvent)
  }

  private def updateEvent(event: JournaledEvent): Future[JournaledEvent] = {
    // determine the encryption key for given event:
    val encryptiondataSubjectId = determineEncryptionKey(event)

    encryptiondataSubjectId match {
      case Some(key) =&gt;
        // TODO this cast is needed since the Any type of payload, yet if we change it, we break other places... ideas?
        val withSubjectId = event.withPayload(WithDataSubjectId[AnyRef](key, event.payload.asInstanceOf[AnyRef]))
        Future.successful(withSubjectId)

      case None =&gt;
        // not encrypting this event:
        Future.successful(event)
    }
  }


  // only share the instance when using parallelism = 1
  private val sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;)

  /**
   * Implement your logic for determining a stable data subject id for each event here.
   *
   * For example, it could be based on masking a known user identifier that exists in all
   * events related to a given user. Or it could be *based on* the persistenceId of the event passed in,
   * which is a simple and effective solution.
   */
  private def determineEncryptionKey(event: JournaledEvent): Option[String] = {
    if (event.persistenceId startsWith &quot;user&quot;) {
      try {
        sha1.update(&quot;my-app-secrets&quot;.getBytes)
        sha1.update(event.persistenceId.getBytes)

        Some(new String(sha1.digest()))
      } finally {
        sha1.reset()
      }
    } else {
      None
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import akka.Done;
import akka.actor.ActorSystem;
import akka.persistence.cassandra.query.javadsl.CassandraReadJournal;
import akka.persistence.gdpr.WithDataSubjectId;
import akka.persistence.query.PersistenceQuery;
import akka.persistence.update.JournaledEvent;
import akka.persistence.update.cassandra.javadsl.CassandraJournalTransformer;
import akka.persistence.update.javadsl.JournalTransformer;
import akka.persistence.update.javadsl.JournalUpdater;
import akka.stream.ActorMaterializer;
import akka.stream.Materializer;
import akka.stream.javadsl.Sink;
import scala.concurrent.ExecutionContext;
import scala.concurrent.ExecutionContextExecutor;

import java.security.MessageDigest;

import java.security.NoSuchAlgorithmException;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

public class GdprMigration {

  final ActorSystem system;
  final Materializer materializer;

  final MessageDigest SHA1; // only share the instance when using parallelism = 1


  String identifier = CassandraJournalTransformer.Identifier();
  // or, for JDBC, the following:
  //  String identifier = JdbcJournalTransformer.Identifier();

  final JournalTransformer transformer;

  public GdprMigration() {
    system = ActorSystem.create();
    materializer = ActorMaterializer.create(system);
    transformer = JournalUpdater.get(system)
      .getJournalUpdaterFor(JournalTransformer.class, identifier);

    try {
      SHA1 = MessageDigest.getInstance(&quot;SHA-1&quot;);
    } catch (NoSuchAlgorithmException ex) {
      throw new RuntimeException(ex); // should not happen
    }
  }

  public static void main(String... args) throws Exception {
    new GdprMigration().run();
  }

  private void run() {
    transformer.transformAllPersistenceIds(this::updateEvent);
  }

  private CompletionStage&lt;JournaledEvent&gt; updateEvent(JournaledEvent event) {
    // determine the encryption key for given event:
    Optional&lt;String&gt; encryptiondataSubjectId = determineEncryptionKey(event);

    if (encryptiondataSubjectId.isPresent()) {
      String key = encryptiondataSubjectId.get();
      JournaledEvent withSubjectId = event.withPayload(WithDataSubjectId.create(key, event.payload()));
      return CompletableFuture.completedFuture(withSubjectId);

    } else {
      return CompletableFuture.completedFuture(event);
    }
  }

  /**
   * Implement your logic for determining a stable data subject id for each event here.
   *
   * For example, it could be based on masking a known user identifier that exists in all
   * events related to a given user. Or it could be *based on* the persistenceId of the event passed in,
   * which is a simple and effective solution.
   */
  private Optional&lt;String&gt; determineEncryptionKey(JournaledEvent event) {
    if (event.persistenceId().startsWith(&quot;user&quot;)) {
      try {
        SHA1.update(&quot;my-app-secrets&quot;.getBytes());
        SHA1.update(event.persistenceId().getBytes());
        return Optional.of(new String(SHA1.digest()));
      } catch (Exception ex) {
        return  Optional.empty();
      } finally {
        SHA1.reset();
      }
    } else {
      return Optional.empty();
    }
  }
}</code></pre></dd>
</dl>
<p>You can use the snippet above to create a runnable migration app that you can execute against your systems. We recommend first doing so on a staging environment to be sure that the key assignment logic is sound and that replays of such migrated system continue to work properly.</p>
<p>You can also selectively run migrations on a specific <code>persistenceId</code> like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">def runSingle(persistenceId: String): Future[Done] = {
  transformer.transformPersistenceId(persistenceId, updateEvent)
}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">private CompletionStage&lt;Done&gt; runSingle(String persistenceId) {
  return transformer.transformPersistenceId(persistenceId, this::updateEvent);
}
</code></pre></dd>
</dl>
<p>Finally, you can run the migration id-by-id, rather than scanning through all events, which does not guarantee ordering of events being ordered by persistence id. This approach may be more useful if you needed to abort a migration and have a number of known-to-be-already-migrated events or if you know which persistenceIds need to be migrated to the encrypted format:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import akka.persistence.cassandra.query.scaladsl.CassandraReadJournal
import akka.persistence.query.PersistenceQuery

val queryJournal: CassandraReadJournal =
  PersistenceQuery(system)
    .readJournalFor[CassandraReadJournal](CassandraReadJournal.Identifier)

def runIdById(): Future[Done] = {
  // obtain all persistence Ids (you could implement &quot;skip known already migrated ids&quot; here by filtering)
  queryJournal.persistenceIds().mapAsync(parallelism = 1) { id =&gt;
    // for each of the ids perform an one-off per-id migration:
    transformer.transformPersistenceId(id, updateEvent)
  }.log(&quot;completion&quot;)
    .runWith(Sink.ignore)
}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">  final CassandraReadJournal queryJournal =
      PersistenceQuery.get(system)
          .getReadJournalFor(CassandraReadJournal.class, CassandraReadJournal.Identifier());

public CompletionStage&lt;Done&gt; runIdById(CassandraReadJournal queryJournal) {
  int parallelism = 1; // since we reuse the SHA1 instance, we have to do 1 here
  return queryJournal.persistenceIds().mapAsync(parallelism, persistenceId -&gt;
      transformer.transformPersistenceId(persistenceId, this::updateEvent)
  ).log(&quot;completion&quot;)
  .runWith(Sink.ignore(), materializer);
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>See also discussion about <a href="data-subject-id.html">Data Subject Id</a> and how to treat them.</p></div>
<h2><a href="#migrating-snapshots" name="migrating-snapshots" class="anchor"><span class="anchor-link"></span></a>Migrating snapshots</h2>
<p>In addition you may want to delete or migrate to their encrypted forms any snapshots a persistent actor has created. The following sections discuss:</p>
<ul>
  <li><a href="migration.html#deleting-snapshots">Deleting snapshots</a></li>
  <li><a href="migration.html#replacing-with-a-new-encrypted-snapshot">Replacing with a new encrypted snapshot</a></li>
</ul>
<h3><a href="#deleting-snapshots" name="deleting-snapshots" class="anchor"><span class="anchor-link"></span></a>Deleting snapshots</h3>
<p>Note that snapshots in general are a performance optimization, and unlike events, it is fine to drop them all up-front when deciding to move to encrypted payloads in the snapshot store. During normal operations the system will then continue as usual, and any snapshot that is going to be persisted wrapped in an <code>akka.persistence.gdpr.WithDataSubjectId</code> will be encrypted with the proper key then as well. This will in turn enable you to use the <a href="shredding.html">data shredding</a> technique instead of deleting snapshots for any future removal deletion requests. </p>
<!-- There is no consistent API outside of the PersistentActor itself to perform a delete on snapshots, so we recommend that -->
<!-- In general it seels like the Updater should also be able to do this, but perhaps we're ok with just such docs here. -->
<p>Here is a sample app that you can use to delete snapshots for all, or a subset of (by filtering the all persistence ids stream) your persistent actors. </p>
<p>First we prepare an actor that is designed only to delete snapshots, and ignore all existing events: </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object SnapshotDeleter {
  final case object DeleteSnapshots
  final case class SnapshotsDeleted(criteria: SnapshotSelectionCriteria)
}
class SnapshotDeleter(val persistenceId: String) extends PersistentActor with ActorLogging {
  import SnapshotDeleter._

  private var notifyOnceSnapshotsDeleted: Option[ActorRef] = None

  override def recovery: Recovery = Recovery()

  override def receiveRecover: Receive = {
    // snapshot offer
    case SnapshotOffer(meta, snap) =&gt;
    // ignore actual snapshot, we

    // events
    case event                     =&gt;
    // ignore all events ...
  }

  override def receiveCommand: Receive = {
    case DeleteSnapshots =&gt;
      notifyOnceSnapshotsDeleted = Some(sender())
      deleteSnapshots(SnapshotSelectionCriteria())

    // handle snapshot deletion response
    case DeleteSnapshotsSuccess(criteria) =&gt;
      notifyOnceSnapshotsDeleted foreach { _ ! SnapshotsDeleted(criteria) }
      context stop self

    case DeleteSnapshotsFailure(criteria, cause) =&gt;
      // replying with a failure will terminate the outer stream
      log.error(cause, &quot;Failed to delete snapshot for {} {}&quot;, persistenceId, criteria)
      notifyOnceSnapshotsDeleted foreach { _ ! Failure(cause) }
      context stop self
  }
}
</code></pre></dd>
</dl>
<p>And then we make use of it by executing it for all existing persistence ids:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">implicit val system = ActorSystem()
implicit val ec = system.dispatcher
implicit val mat = ActorMaterializer()
val log = system.log

val queryJournal: CassandraReadJournal =
  PersistenceQuery(system)
    .readJournalFor[CassandraReadJournal](CassandraReadJournal.Identifier)


def deleteAllSnapshots(): Future[Done] = {
  import akka.pattern.ask
  implicit val timeout: Timeout = Timeout(60.seconds)

  // obtain all persistence Ids (you could implement &quot;skip known already migrated ids&quot; here by filtering)
  queryJournal.persistenceIds()
    .mapAsync(parallelism = 1) { id =&gt;
      val deleter = system.actorOf(Props(new SnapshotDeleter(id)), s&quot;delete-snapshots-$id&quot;)
      val deleted = (deleter ? SnapshotDeleter.DeleteSnapshots).mapTo[SnapshotDeleter.SnapshotsDeleted]
      deleted.map { d =&gt; log.info(&quot;Deleted snapshots for {} {}&quot;, id, d.criteria) }
    }.log(&quot;completion&quot;)
    .runWith(Sink.ignore)
}</code></pre></dd>
</dl>
<h3><a href="#replacing-with-a-new-encrypted-snapshot" name="replacing-with-a-new-encrypted-snapshot" class="anchor"><span class="anchor-link"></span></a>Replacing with a new encrypted snapshot</h3>
<p>Other than deleting all snapshots and rely on the running application after doing so to recover the snapshots in normal operation, you may want to proactively make all actors create new snapshots using GDPR for Akka Persistence encryption so that they can be subject to <a href="shredding.html">data shredding</a>.</p>
<p>Do to this you can use the following pattern, and instead of the example Actor here use your actual actors. You would have to make sure to start the right type of actor for the specific persistence id though.</p>
<p>Note that the persistent actor performs an actual replay and recovery of its state, unlike in the &ldquo;only delete the snapshots&rdquo; application. It does so since once it has completed recovery, it will persist a snapshot yet wrap it using the <code>WithDataSubjectId</code> same as we were doing for events previously. GDPR for Akka Persistence will take care of properly encrypting the payload with the right key associated to the given subject id transparently. Once this has complete successfully, you can issue a <code>deleteSnapshots</code> similar to how this was done in the &ldquo;deleting snapshots&rdquo; section, however this time we want to delete all-but-the-last snapshot &ndash; since that one is already encrypted and we want to keep it for future use.</p>
<p>When using this technique do remember to make sure to start the right kind of actor for each of the ids, as otherwise you would accidentally attempt replaying and recovering state using wrong logic (that would not align with the data persisted for the given persistence id).</p>
<p>Also note that some actors may use the name of the actor and for those you must use the correct name when starting the actor from a stream rather than in the normal application. Persistent actors running in Cluster Sharding may use the actor name as the entity identifier. That is also the case for Lagom <code>PersistentEntity</code>. Typically such name can be derived from the <code>persistenceId</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object DeleteSnapshotAndSnapNewEncryptedOne {
  final case object AwaitCompletion
  final case class SnapshotUpdateComplete(criteria: SnapshotSelectionCriteria, newSnapshotSeqNr: Long)

  // example state, this would be your application state (like &quot;wallet state&quot; etc)
  final case class ExampleState(data: Int)
  final case class ExampleEvent(update: Int)
}
class DeleteSnapshotAndSnapNewEncryptedOne(val persistenceId: String) extends PersistentActor with ActorLogging {
  import DeleteSnapshotAndSnapNewEncryptedOne._

  private var state: ExampleState = ExampleState(0)
  private var snapshotUpdated = false
  private var notifyOnceDone: Option[ActorRef] = None

  override def recovery: Recovery = Recovery()

  override def receiveRecover: Receive = {
    // snapshot offer
    case SnapshotOffer(meta, snap: ExampleState) =&gt;
      state = snap // we do use the previous snapshot

    // events, we process them all since we will want to store a new snapshot
    case ExampleEvent(update) =&gt;
      state = updateState(update)

    // time to store our new snapshot!
    case RecoveryCompleted =&gt;
      saveSnapshot(WithDataSubjectId(s&quot;MY_SPECIAL_ID_$persistenceId&quot;, state))
  }

  // this is only an example; your usual business logic updating the state would be here
  private def updateState(update: Int): ExampleState = {
    state.copy(state.data + update)
  }

  override def receiveCommand: Receive = {
    case AwaitCompletion =&gt;
      notifyOnceDone = Some(sender())

    // handle snapshot update result (the new, encrypted one)
    case SaveSnapshotSuccess(criteria) =&gt;
      // delete all except the previous snapshot
      deleteSnapshots(SnapshotSelectionCriteria().copy(maxSequenceNr = snapshotSequenceNr - 1))

    case SaveSnapshotFailure(criteria, cause) =&gt;
      // replying with a failure will terminate the outer stream
      log.error(cause, &quot;Failed to delete snapshot for {} {}&quot;, persistenceId, criteria)
      notifyOnceDone foreach { _ ! Failure(cause) }
      context stop self

    // handle snapshot deletion response
    case DeleteSnapshotsSuccess(criteria) =&gt;
      if (snapshotUpdated) {
        notifyOnceDone foreach { _ ! SnapshotUpdateComplete(criteria, snapshotSequenceNr) }
        context stop self
      }

    case DeleteSnapshotsFailure(criteria, cause) =&gt;
      // replying with a failure will terminate the outer stream
      log.error(cause, &quot;Failed to delete snapshot for {} {}&quot;, persistenceId, criteria)
      notifyOnceDone foreach { _ ! Failure(cause) }
      context stop self
  }
}
</code></pre></dd>
</dl>
<p>Running the application is similar to what we did previously, we start the &ldquo;updater&rdquo; actor for each of the ids and wait for it to reply that it has completed its task by using the ask pattern:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object DeleteSnapshotAndSnapNewEncryptedOne {
  final case object AwaitCompletion
  final case class SnapshotUpdateComplete(criteria: SnapshotSelectionCriteria, newSnapshotSeqNr: Long)

  // example state, this would be your application state (like &quot;wallet state&quot; etc)
  final case class ExampleState(data: Int)
  final case class ExampleEvent(update: Int)
}
class DeleteSnapshotAndSnapNewEncryptedOne(val persistenceId: String) extends PersistentActor with ActorLogging {
  import DeleteSnapshotAndSnapNewEncryptedOne._

  private var state: ExampleState = ExampleState(0)
  private var snapshotUpdated = false
  private var notifyOnceDone: Option[ActorRef] = None

  override def recovery: Recovery = Recovery()

  override def receiveRecover: Receive = {
    // snapshot offer
    case SnapshotOffer(meta, snap: ExampleState) =&gt;
      state = snap // we do use the previous snapshot

    // events, we process them all since we will want to store a new snapshot
    case ExampleEvent(update) =&gt;
      state = updateState(update)

    // time to store our new snapshot!
    case RecoveryCompleted =&gt;
      saveSnapshot(WithDataSubjectId(s&quot;MY_SPECIAL_ID_$persistenceId&quot;, state))
  }

  // this is only an example; your usual business logic updating the state would be here
  private def updateState(update: Int): ExampleState = {
    state.copy(state.data + update)
  }

  override def receiveCommand: Receive = {
    case AwaitCompletion =&gt;
      notifyOnceDone = Some(sender())

    // handle snapshot update result (the new, encrypted one)
    case SaveSnapshotSuccess(criteria) =&gt;
      // delete all except the previous snapshot
      deleteSnapshots(SnapshotSelectionCriteria().copy(maxSequenceNr = snapshotSequenceNr - 1))

    case SaveSnapshotFailure(criteria, cause) =&gt;
      // replying with a failure will terminate the outer stream
      log.error(cause, &quot;Failed to delete snapshot for {} {}&quot;, persistenceId, criteria)
      notifyOnceDone foreach { _ ! Failure(cause) }
      context stop self

    // handle snapshot deletion response
    case DeleteSnapshotsSuccess(criteria) =&gt;
      if (snapshotUpdated) {
        notifyOnceDone foreach { _ ! SnapshotUpdateComplete(criteria, snapshotSequenceNr) }
        context stop self
      }

    case DeleteSnapshotsFailure(criteria, cause) =&gt;
      // replying with a failure will terminate the outer stream
      log.error(cause, &quot;Failed to delete snapshot for {} {}&quot;, persistenceId, criteria)
      notifyOnceDone foreach { _ ! Failure(cause) }
      context stop self
  }
}
</code></pre></dd>
</dl>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../gdpr/encryption.html"><i class="icon-prev"></i> <span class="link-prev">Encrypting data</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../gdpr/lagom.html">Lagom specifics <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<!-- no source links for private github repository -->

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<p class="legal">
&copy; 2011-2020 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- hook for including project specific javascript into the generated docs -->

</body>
</html>
