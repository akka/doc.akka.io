<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>JMS &bull; Alpakka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Alpakka is a Reactive Enterprise Integration library for Java and Scala, based on Reactive Streams and Akka."/><link rel="canonical" href="https://doc.akka.io/docs/alpakka/current/jms.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_setDomainName', '']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-alpakka-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Alpakka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 1.0-M1
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="overview.html" class="page">Overview</a></li>
  <li><a href="data-transformations/index.html" class="page">Data Transformations</a></li>
  <li><a href="amqp.html" class="page">AMQP</a></li>
  <li><a href="external/apache-camel.html" class="page">Apache Camel</a></li>
  <li><a href="cassandra.html" class="page">Apache Cassandra</a></li>
  <li><a href="geode.html" class="page">Apache Geode</a></li>
  <li><a href="kafka.html" class="page">Apache Kafka</a></li>
  <li><a href="kudu.html" class="page">Apache Kudu</a></li>
  <li><a href="solr.html" class="page">Apache Solr</a></li>
  <li><a href="avroparquet.html" class="page">Avro Parquet</a></li>
  <li><a href="dynamodb.html" class="page">AWS DynamoDB</a></li>
  <li><a href="kinesis.html" class="page">AWS Kinesis</a></li>
  <li><a href="awslambda.html" class="page">AWS Lambda</a></li>
  <li><a href="s3.html" class="page">AWS S3</a></li>
  <li><a href="sns.html" class="page">AWS SNS</a></li>
  <li><a href="sqs.html" class="page">AWS SQS</a></li>
  <li><a href="external/azure-event-hubs.html" class="page">Azure Event Hubs</a></li>
  <li><a href="external/azure-iot-hub.html" class="page">Azure IoT Hub</a></li>
  <li><a href="azure-storage-queue.html" class="page">Azure Storage Queue</a></li>
  <li><a href="external/couchbase.html" class="page">Couchbase</a></li>
  <li><a href="elasticsearch.html" class="page">Elasticsearch</a></li>
  <li><a href="external/eventuate.html" class="page">Eventuate</a></li>
  <li><a href="file.html" class="page">Files</a></li>
  <li><a href="external/fs2.html" class="page">FS2</a></li>
  <li><a href="ftp.html" class="page">FTP</a></li>
  <li><a href="google-cloud-pub-sub.html" class="page">Google Cloud Pub/Sub</a></li>
  <li><a href="google-cloud-pub-sub-grpc.html" class="page">Google Cloud Pub/Sub gRPC</a></li>
  <li><a href="google-fcm.html" class="page">Google Firebase Cloud Messaging</a></li>
  <li><a href="external/grpc.html" class="page">gRPC</a></li>
  <li><a href="hdfs.html" class="page">Hadoop Distributed File System - HDFS</a></li>
  <li><a href="hbase.html" class="page">HBase</a></li>
  <li><a href="external/http.html" class="page">HTTP</a></li>
  <li><a href="ironmq.html" class="page">IronMQ</a></li>
  <li><a href="jms.html#jms" class="active page">JMS</a>
  <ul>
    <li><a href="jms.html#reported-issues" class="header">Reported issues</a></li>
    <li><a href="jms.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="jms.html#usage" class="header">Usage</a></li>
    <li><a href="jms.html#sending-messages-to-a-jms-provider" class="header">Sending messages to a JMS provider</a></li>
    <li><a href="jms.html#receiving-messages-from-a-jms-provider" class="header">Receiving messages from a JMS provider</a></li>
    <li><a href="jms.html#connection-retries" class="header">Connection Retries</a></li>
    <li><a href="jms.html#using-ibm-mq" class="header">Using IBM MQ</a></li>
  </ul></li>
  <li><a href="mongodb.html" class="page">MongoDB</a></li>
  <li><a href="mqtt.html" class="page">MQTT</a></li>
  <li><a href="orientdb.html" class="page">OrientDB</a></li>
  <li><a href="external/pulsar.html" class="page">Pulsar</a></li>
  <li><a href="sse.html" class="page">Server-sent Events (SSE)</a></li>
  <li><a href="slick.html" class="page">Slick (JDBC)</a></li>
  <li><a href="spring-web.html" class="page">Spring Web</a></li>
  <li><a href="external/tcp.html" class="page">TCP</a></li>
  <li><a href="udp.html" class="page">UDP</a></li>
  <li><a href="unix-domain-socket.html" class="page">Unix Domain Socket</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Alpakka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 1.0-M1
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="overview.html" class="page">Overview</a></li>
  <li><a href="data-transformations/index.html" class="page">Data Transformations</a></li>
  <li><a href="amqp.html" class="page">AMQP</a></li>
  <li><a href="external/apache-camel.html" class="page">Apache Camel</a></li>
  <li><a href="cassandra.html" class="page">Apache Cassandra</a></li>
  <li><a href="geode.html" class="page">Apache Geode</a></li>
  <li><a href="kafka.html" class="page">Apache Kafka</a></li>
  <li><a href="kudu.html" class="page">Apache Kudu</a></li>
  <li><a href="solr.html" class="page">Apache Solr</a></li>
  <li><a href="avroparquet.html" class="page">Avro Parquet</a></li>
  <li><a href="dynamodb.html" class="page">AWS DynamoDB</a></li>
  <li><a href="kinesis.html" class="page">AWS Kinesis</a></li>
  <li><a href="awslambda.html" class="page">AWS Lambda</a></li>
  <li><a href="s3.html" class="page">AWS S3</a></li>
  <li><a href="sns.html" class="page">AWS SNS</a></li>
  <li><a href="sqs.html" class="page">AWS SQS</a></li>
  <li><a href="external/azure-event-hubs.html" class="page">Azure Event Hubs</a></li>
  <li><a href="external/azure-iot-hub.html" class="page">Azure IoT Hub</a></li>
  <li><a href="azure-storage-queue.html" class="page">Azure Storage Queue</a></li>
  <li><a href="external/couchbase.html" class="page">Couchbase</a></li>
  <li><a href="elasticsearch.html" class="page">Elasticsearch</a></li>
  <li><a href="external/eventuate.html" class="page">Eventuate</a></li>
  <li><a href="file.html" class="page">Files</a></li>
  <li><a href="external/fs2.html" class="page">FS2</a></li>
  <li><a href="ftp.html" class="page">FTP</a></li>
  <li><a href="google-cloud-pub-sub.html" class="page">Google Cloud Pub/Sub</a></li>
  <li><a href="google-cloud-pub-sub-grpc.html" class="page">Google Cloud Pub/Sub gRPC</a></li>
  <li><a href="google-fcm.html" class="page">Google Firebase Cloud Messaging</a></li>
  <li><a href="external/grpc.html" class="page">gRPC</a></li>
  <li><a href="hdfs.html" class="page">Hadoop Distributed File System - HDFS</a></li>
  <li><a href="hbase.html" class="page">HBase</a></li>
  <li><a href="external/http.html" class="page">HTTP</a></li>
  <li><a href="ironmq.html" class="page">IronMQ</a></li>
  <li><a href="jms.html#jms" class="active page">JMS</a>
  <ul>
    <li><a href="jms.html#reported-issues" class="header">Reported issues</a></li>
    <li><a href="jms.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="jms.html#usage" class="header">Usage</a></li>
    <li><a href="jms.html#sending-messages-to-a-jms-provider" class="header">Sending messages to a JMS provider</a></li>
    <li><a href="jms.html#receiving-messages-from-a-jms-provider" class="header">Receiving messages from a JMS provider</a></li>
    <li><a href="jms.html#connection-retries" class="header">Connection Retries</a></li>
    <li><a href="jms.html#using-ibm-mq" class="header">Using IBM MQ</a></li>
  </ul></li>
  <li><a href="mongodb.html" class="page">MongoDB</a></li>
  <li><a href="mqtt.html" class="page">MQTT</a></li>
  <li><a href="orientdb.html" class="page">OrientDB</a></li>
  <li><a href="external/pulsar.html" class="page">Pulsar</a></li>
  <li><a href="sse.html" class="page">Server-sent Events (SSE)</a></li>
  <li><a href="slick.html" class="page">Slick (JDBC)</a></li>
  <li><a href="spring-web.html" class="page">Spring Web</a></li>
  <li><a href="external/tcp.html" class="page">TCP</a></li>
  <li><a href="udp.html" class="page">UDP</a></li>
  <li><a href="unix-domain-socket.html" class="page">Unix Domain Socket</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-alpakka-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#jms" name="jms" class="anchor"><span class="anchor-link"></span></a>JMS</h1>
<p>The JMS connector provides Akka Stream sources and sinks to connect to JMS providers.</p>
<h3><a href="#reported-issues" name="reported-issues" class="anchor"><span class="anchor-link"></span></a>Reported issues</h3>
<p><a href="https://github.com/akka/alpakka/labels/p%3Ajms">Tagged issues at Github</a></p>
<h2><a href="#artifacts" name="artifacts" class="anchor"><span class="anchor-link"></span></a>Artifacts</h2>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;com.lightbend.akka&quot; %% &quot;akka-stream-alpakka-jms&quot; % &quot;1.0-M1&quot;
libraryDependencies += &quot;javax.jms&quot; % &quot;jms&quot; % &quot;1.1&quot;
</code></pre></dd>
  <dt>Maven</dt>
  <dd>
  <pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.lightbend.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-stream-alpakka-jms_2.12&lt;/artifactId&gt;
  &lt;version&gt;1.0-M1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javax.jms&lt;/groupId&gt;
  &lt;artifactId&gt;jms&lt;/artifactId&gt;
  &lt;version&gt;1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></dd>
  <dt>Gradle</dt>
  <dd>
  <pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: &quot;com.lightbend.akka&quot;, name: &quot;akka-stream-alpakka-jms_2.12&quot;, version: &quot;1.0-M1&quot;
  compile group: &#39;javax.jms&#39;, name: &#39;jms&#39;, version: &#39;1.1&#39;
}
</code></pre></dd>
</dl>
<h2><a href="#usage" name="usage" class="anchor"><span class="anchor-link"></span></a>Usage</h2>
<p>The JMS message model supports several types of message body (see <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a>) and Alpakka currently supports messages with a body containing a <a href="https://docs.oracle.com/javase/8/docs/api/?java/lang/String.html">String</a>, a <a href="https://docs.oracle.com/javase/8/docs/api/?java/io/Serializable.html">Serializable</a> object, a <a href="https://docs.oracle.com/javase/8/docs/api/?java/util/Map.html">Map</a> or a byte array.</p>
<p>First define a <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/ConnectionFactory.html">javax.jms.ConnectionFactory</a> depending on the implementation you&rsquo;re using. Here we&rsquo;re using Active MQ.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val connectionFactory: javax.jms.ConnectionFactory = new ActiveMQConnectionFactory(ctx.url)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L39" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">javax.jms.ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ctx.url);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L102" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The created <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/ConnectionFactory.html">ConnectionFactory</a> is then used for the creation of the different jms sinks or sources (see below).</p>
<h2><a href="#sending-messages-to-a-jms-provider" name="sending-messages-to-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Sending messages to a JMS provider</h2>
<p>Use a case class with the subtype of <a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/JmsMessage$.html">JmsMessage</a> to wrap the messages you want to send and optionally set their properties. <span class="group-java"><a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/javadsl/JmsProducer$.html">JmsProducer</a></span><span class="group-scala"><a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/scaladsl/JmsProducer$.html">JmsProducer</a></span> contains factory methods to facilitate the creation of sinks according to the message type (see below for an example).</p>
<h3><a href="#sending-text-messages-to-a-jms-provider" name="sending-text-messages-to-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Sending text messages to a JMS provider</h3>
<p>Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/JmsTextMessage$.html">JmsTextMessage</a>s to the JMS provider:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSink: Sink[String, Future[Done]] = JmsProducer.textSink(
  JmsProducerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L43-L45" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Sink&lt;String, CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.textSink(JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L106-L107" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Last step is to <a href="https://doc.akka.io/docs/akka/2.5.16/scala/stream/stream-flows-and-basics">materialize</a> and run the sink(s) we have created.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val in = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;)
Source(in).runWith(jmsSink)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L49-L50" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">List&lt;String&gt; in = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;);
CompletionStage&lt;Done&gt; finished = Source.from(in).runWith(jmsSink, materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L111-L112" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#sending-byte-messages-to-a-jms-provider" name="sending-byte-messages-to-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Sending byte messages to a JMS provider</h3>
<p>Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/JmsByteMessage$.html">JmsByteMessage</a>s to the JMS provider.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSink: Sink[Array[Byte], Future[Done]] = JmsProducer.bytesSink(
  JmsProducerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L101-L103" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Sink&lt;byte[], CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.bytesSink(
        JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L176-L178" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Last step is to <a href="https://doc.akka.io/docs/akka/2.5.16/scala/stream/stream-flows-and-basics">materialize</a> and run the sink(s) we have created.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val in = &quot;ThisIsATest&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;))
Source.single(in).runWith(jmsSink)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L107-L108" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">byte[] in = &quot;ThisIsATest&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;));
CompletionStage&lt;Done&gt; finished = Source.single(in).runWith(jmsSink, materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L182-L183" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#sending-map-messages-to-a-jms-provider" name="sending-map-messages-to-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Sending map messages to a JMS provider</h3>
<p>Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/JmsMapMessage$.html">JmsMapMessage</a>s to the JMS provider:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSink: Sink[Map[String, Any], Future[Done]] = JmsProducer.mapSink(
  JmsProducerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L128-L130" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Sink&lt;Map&lt;String, Object&gt;, CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.mapSink(JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L208-L209" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Last step is to <a href="https://doc.akka.io/docs/akka/2.5.16/scala/stream/stream-flows-and-basics">materialize</a> and run the sink(s) we have created.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val input = List(
  Map[String, Any](
    &quot;string&quot; -&gt; &quot;value&quot;,
    &quot;int value&quot; -&gt; 42,
    &quot;double value&quot; -&gt; 43.toDouble,
    &quot;short value&quot; -&gt; 7.toShort,
    &quot;boolean value&quot; -&gt; true,
    &quot;long value&quot; -&gt; 7.toLong,
    &quot;bytearray&quot; -&gt; &quot;AStringAsByteArray&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;)),
    &quot;byte&quot; -&gt; 1.toByte
  )
)

Source(input).runWith(jmsSink)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L134-L147" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Map&lt;String, Object&gt; in = new HashMap&lt;&gt;();
in.put(&quot;string value&quot;, &quot;value&quot;);
in.put(&quot;int value&quot;, 42);
in.put(&quot;double value&quot;, 43.0);
in.put(&quot;short value&quot;, (short) 7);
in.put(&quot;boolean value&quot;, true);
in.put(&quot;long value&quot;, 7L);
in.put(&quot;bytearray&quot;, &quot;AStringAsByteArray&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;)));
in.put(&quot;byte&quot;, (byte) 1);

CompletionStage&lt;Done&gt; finished = Source.single(in).runWith(jmsSink, materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L213-L223" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#sending-object-messages-to-a-jms-provider" name="sending-object-messages-to-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Sending object messages to a JMS provider</h3>
<p>Create and configure ActiveMQ connection factory to support serialization. See <a href="http://activemq.apache.org/objectmessage.html">ActiveMQ Security</a> for more information on this.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val connectionFactory = new ActiveMQConnectionFactory(ctx.url)
connectionFactory.setTrustedPackages(List(classOf[DummyObject].getPackage.getName).asJava)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L68-L69" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ctx.url);
connectionFactory.setTrustedPackages(
    Arrays.asList(DummyJavaTests.class.getPackage().getName()));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L137-L139" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/JmsObjectMessage$.html">JmsObjectMessage</a>s to the JMS provider:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSink: Sink[Serializable, Future[Done]] = JmsProducer.objectSink(
  JmsProducerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L73-L75" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Sink&lt;java.io.Serializable, CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.objectSink(
        JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L143-L145" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Last step is to <a href="https://doc.akka.io/docs/akka/2.5.16/scala/stream/stream-flows-and-basics">materialize</a> and run the sink(s) we have created.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>val in = DummyObject(&quot;ThisIsATest&quot;)
Source.single(in).runWith(jmsSink)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L79-L81" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">java.io.Serializable in = new DummyJavaTests(&quot;javaTest&quot;);
CompletionStage&lt;Done&gt; finished = Source.single(in).runWith(jmsSink, materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L149-L150" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#sending-messages-with-properties-to-a-jms-provider" name="sending-messages-with-properties-to-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Sending messages with properties to a JMS provider</h3>
<p>For every <a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/JmsMessage$.html">JmsMessage</a> you can set jms properties.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val msgsIn = (1 to 10).toList.map { n =&gt;
  JmsTextMessage(n.toString)
    .withProperty(&quot;Number&quot;, n)
    .withProperty(&quot;IsOdd&quot;, n % 2 == 1)
    .withProperty(&quot;IsEven&quot;, n % 2 == 0)
}</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L183-L188" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">JmsTextMessage message =
    JmsTextMessage.create(n.toString())
        .withProperty(&quot;Number&quot;, n)
        .withProperty(&quot;IsOdd&quot;, n % 2 == 1)
        .withProperty(&quot;IsEven&quot;, n % 2 == 0);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L84-L88" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#sending-messages-with-header-to-a-jms-provider" name="sending-messages-with-header-to-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Sending messages with header to a JMS provider</h3>
<p>For every <a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/JmsMessage$.html">JmsMessage</a> you can set also jms headers.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val msgsIn = (1 to 10).toList.map { n =&gt;
  JmsTextMessage(n.toString)
    .withHeader(JmsType(&quot;type&quot;))
    .withHeader(JmsCorrelationId(&quot;correlationId&quot;))
    .withHeader(JmsReplyTo.queue(&quot;test-reply&quot;))
    .withHeader(JmsTimeToLive(FiniteDuration(999, TimeUnit.SECONDS)))
    .withHeader(JmsPriority(2))
    .withHeader(JmsDeliveryMode(DeliveryMode.NON_PERSISTENT))
}</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L222-L230" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">List&lt;JmsTextMessage&gt; msgsIn =
    createTestMessageList()
        .stream()
        .map(
            jmsTextMessage -&gt;
                jmsTextMessage
                    .withHeader(JmsType.create(&quot;type&quot;))
                    .withHeader(JmsCorrelationId.create(&quot;correlationId&quot;))
                    .withHeader(JmsReplyTo.queue(&quot;test-reply&quot;))
                    .withHeader(JmsTimeToLive.create(999, TimeUnit.SECONDS))
                    .withHeader(JmsPriority.create(2))
                    .withHeader(JmsDeliveryMode.create(DeliveryMode.NON_PERSISTENT)))
        .collect(Collectors.toList());</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L310-L322" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#sending-messages-as-a-flow" name="sending-messages-as-a-flow" class="anchor"><span class="anchor-link"></span></a>Sending messages as a Flow</h3>
<p>The producer can also act as a flow, in order to publish messages in the middle of stream processing. For example, you can ensure that a message is persisted to the queue before subsequent processing.</p>
<p>Create a flow:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val flowSink: Flow[JmsMessage, JmsMessage, NotUsed] = JmsProducer.flow(
  JmsProducerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L806-L808" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Flow&lt;JmsTextMessage, JmsTextMessage, NotUsed&gt; flowSink =
    JmsProducer.flow(JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L690-L691" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Run the flow:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val input = (1 to 100).map(i =&gt; JmsTextMessage(i.toString))

val result = Source(input)
  .via(flowSink)
  .runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L812-L816" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">List&lt;JmsTextMessage&gt; input = createTestMessageList();

CompletionStage&lt;List&lt;JmsTextMessage&gt;&gt; result =
    Source.from(input).via(flowSink).runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L695-L698" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#sending-messages-with-per-message-destinations" name="sending-messages-with-per-message-destinations" class="anchor"><span class="anchor-link"></span></a>Sending messages with per-message destinations</h3>
<p>It is also possible to define message destinations per message:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val flowSink: Flow[JmsMessage, JmsMessage, NotUsed] =
  JmsProducer.flow(
    JmsProducerSettings(connectionFactory).withQueue(&quot;test&quot;)
  )

val input = (1 to 100).map { i =&gt;
  val queueName = if (i % 2 == 0) &quot;even&quot; else &quot;odd&quot;
  JmsTextMessage(i.toString).toQueue(queueName)
}
Source(input).via(flowSink).runWith(Sink.ignore)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L826-L835" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Flow&lt;JmsTextMessage, JmsTextMessage, NotUsed&gt; flowSink =
    JmsProducer.flow(JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));

List&lt;JmsTextMessage&gt; input = new ArrayList&lt;&gt;();
for (Integer n : Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) {
  String queueName = (n % 2 == 0) ? &quot;even&quot; : &quot;odd&quot;;
  input.add(JmsTextMessage.create(n.toString()).toQueue(queueName));
}

Source.from(input).via(flowSink).runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L712-L721" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>When no destination is defined on the message, the destination given in the producer settings is used.</p>
<h3><a href="#passing-context-through-the-producer" name="passing-context-through-the-producer" class="anchor"><span class="anchor-link"></span></a>Passing context through the producer</h3>
<p>In some use cases, it is useful to pass through context information when producing (e.g. for acknowledging or committing messages after sending to Jms). For this, the <code>JmsProducer.flexiFlow</code> accepts implementations of <code>JmsProducerEnvelope</code>, which it will pass through.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsProducer = JmsProducer.flexiFlow[JmsTextMessage, String](
  JmsProducerSettings(connectionFactory).withQueue(&quot;test&quot;)
)

val data = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;)
val in = data.map(t =&gt; JmsProducerMessage.Message(JmsTextMessage(t), t))

val result = Source(in).via(jmsProducer).map(_.passThrough).runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L1134-L1141" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Flow&lt;Envelope&lt;JmsTextMessage, String&gt;, Envelope&lt;JmsTextMessage, String&gt;, NotUsed&gt;
    jmsProducer =
        JmsProducer.flexiFlow(
            JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));

List&lt;String&gt; data = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;);
List&lt;Envelope&lt;JmsTextMessage, String&gt;&gt; input = new ArrayList&lt;&gt;();
for (String s : data) {
  input.add(JmsProducerMessage.message(JmsTextMessage.create(s), s));
}

CompletionStage&lt;List&lt;String&gt;&gt; result =
    Source.from(input)
        .via(jmsProducer)
        .map(Envelope::passThrough)
        .runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L790-L805" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>There are two implementations: One envelope type containing a messages to send to Jms, and one envelope type containing only values to pass through. This allows messages to flow without producing any new messages to Jms. This is primarily useful when committing offsets back to Kakfa, or when acknowledging Jms messages after sending the outcome of processing them back to Jms.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsProducer = JmsProducer.flexiFlow[JmsTextMessage, String](
  JmsProducerSettings(connectionFactory).withQueue(&quot;topic&quot;)
)

val data = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;)
val in = data.map(t =&gt; JmsProducerMessage.PassThroughMessage(t))

val result = Source(in).via(jmsProducer).map(_.passThrough).runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L1168-L1175" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Flow&lt;Envelope&lt;JmsTextMessage, String&gt;, Envelope&lt;JmsTextMessage, String&gt;, NotUsed&gt;
    jmsProducer =
        JmsProducer.flexiFlow(
            JmsProducerSettings.create(connectionFactory).withQueue(&quot;test&quot;));

List&lt;String&gt; data = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;);
List&lt;Envelope&lt;JmsTextMessage, String&gt;&gt; input = new ArrayList&lt;&gt;();
for (String s : data) {
  input.add(JmsProducerMessage.passThroughMessage(s));
}

CompletionStage&lt;List&lt;String&gt;&gt; result =
    Source.from(input)
        .via(jmsProducer)
        .map(Envelope::passThrough)
        .runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L826-L841" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#configuring-the-producer" name="configuring-the-producer" class="anchor"><span class="anchor-link"></span></a>Configuring the Producer</h3>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val settings = JmsProducerSettings(new ActiveMQConnectionFactory(&quot;broker-url&quot;))
  .withTopic(&quot;target-topic&quot;)
  .withCredential(Credentials(&quot;username&quot;, &quot;password&quot;))
  .withConnectionRetrySettings(retrySettings)
  .withSessionCount(10)
  .withTimeToLive(1.hour)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsSettingsSpec.scala#L28-L33" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">JmsProducerSettings settings =
    JmsProducerSettings.create(new ActiveMQConnectionFactory(&quot;broker-url&quot;))
        .withTopic(&quot;target-topic&quot;)
        .withCredential(new Credentials(&quot;username&quot;, &quot;password&quot;))
        .withConnectionRetrySettings(retrySettings)
        .withSessionCount(10)
        .withTimeToLive(Duration.ofHours(1));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsSettingsTest.java#L32-L38" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The producer can be configured with the following settings.</p>
<ul>
  <li><code>connectionFactory</code> (mandatory) the factory to use for creating Jms connections.</li>
  <li><code>destination</code> (mandatory) the destination (queue or topic) to send Jms messgages to.</li>
  <li><code>credentials</code> (optional) username and password to use for authentication to the Jms broker .</li>
  <li><code>connectionRetrySettings</code> (optional) retry characteristics if the connection failed to be established or taking a long time. Please see default values under <a href="#connection-retries">Connection Retries</a>. Note that producers cannot re-establish the connection if it fails mid-stream at this time.</li>
  <li><code>sessionCount</code> (defaults to 1) the number of parallel sessions to use for sending Jms messages. Increasing the  number of parallel sessions increases throughput at the cost of message ordering. While the messages may arrive  out of order at the Jms broker, the producer flow outputs messages in the order they are received.</li>
  <li><code>timeToLive</code> (optional) the time messages should be kept on the Jms broker. This setting can be overridden on  individual messages. If not set, messages will never expire.</li>
</ul>
<h2><a href="#receiving-messages-from-a-jms-provider" name="receiving-messages-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Receiving messages from a JMS provider</h2>
<p><span class="group-java"><a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/javadsl/JmsConsumer$.html">JmsConsumer</a></span><span class="group-scala"><a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/scaladsl/JmsConsumer$.html">JmsConsumer</a></span> contains factory methods to facilitate the creation of sinks according to the message type (see below for an example).</p>
<h3><a href="#receiving-messages-from-a-jms-provider" name="receiving-messages-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Receiving <a href="https://docs.oracle.com/javase/8/docs/api/?java/lang/String.html">String</a> messages from a JMS provider</h3>
<p>Create a source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[String, KillSwitch] = JmsConsumer.textSource(
  JmsConsumerSettings(connectionFactory).withBufferSize(10).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L54-L56" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;String, KillSwitch&gt; jmsSource =
    JmsConsumer.textSource(
        JmsConsumerSettings.create(connectionFactory)
            .withQueue(&quot;test&quot;)
            .withBufferSize(10));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L116-L120" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>bufferSize</code> parameter controls the maximum number of messages to prefetch before applying backpressure.</p>
<p>Run the source and take the same amount of messages as we previously sent to it.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = jmsSource.take(in.size).runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L60" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;List&lt;String&gt;&gt; result =
    jmsSource.take(in.size()).runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L124-L125" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#receiving-byte-array-messages-from-a-jms-provider" name="receiving-byte-array-messages-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Receiving byte array messages from a JMS provider</h3>
<p>Create a source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[Array[Byte], KillSwitch] = JmsConsumer.bytesSource(
  JmsConsumerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L112-L114" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;byte[], KillSwitch&gt; jmsSource =
    JmsConsumer.bytesSource(
        JmsConsumerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L187-L189" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>bufferSize</code> parameter controls the maximum number of messages to prefetch before applying backpressure.</p>
<p>Run the source and take the same amount of messages as we previously sent to it.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = jmsSource.take(1).runWith(Sink.head)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L118" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;byte[]&gt; result = jmsSource.take(1).runWith(Sink.head(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L193" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#receiving-object-messages-from-a-jms-provider" name="receiving-object-messages-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Receiving <a href="https://docs.oracle.com/javase/8/docs/api/?java/io/Serializable.html">Serializable</a> object messages from a JMS provider</h3>
<p>Create and configure ActiveMQ connection factory to support serialization. See <a href="http://activemq.apache.org/objectmessage.html">ActiveMQ Security</a> for more information on this.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val connectionFactory = new ActiveMQConnectionFactory(ctx.url)
connectionFactory.setTrustedPackages(List(classOf[DummyObject].getPackage.getName).asJava)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L68-L69" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ctx.url);
connectionFactory.setTrustedPackages(
    Arrays.asList(DummyJavaTests.class.getPackage().getName()));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L137-L139" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Create a source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[java.io.Serializable, KillSwitch] = JmsConsumer.objectSource(
  JmsConsumerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L85-L87" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;java.io.Serializable, KillSwitch&gt; jmsSource =
    JmsConsumer.objectSource(
        JmsConsumerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L154-L156" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>bufferSize</code> parameter controls the maximum number of messages to prefetch before applying backpressure.</p>
<p>Run the source and take the same amount of messages as we previously sent to it.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = jmsSource.take(1).runWith(Sink.head)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L91" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;java.io.Serializable&gt; result =
    jmsSource.take(1).runWith(Sink.head(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L160-L161" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#receiving-messages-from-a-jms-provider" name="receiving-messages-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Receiving <a href="https://docs.oracle.com/javase/8/docs/api/?java/util/Map.html">Map</a> messages from a JMS provider</h3>
<p>Create a source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[Map[String, Any], KillSwitch] = JmsConsumer.mapSource(
  JmsConsumerSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L151-L153" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;Map&lt;String, Object&gt;, KillSwitch&gt; jmsSource =
    JmsConsumer.mapSource(
        JmsConsumerSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L227-L229" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>bufferSize</code> parameter controls the maximum number of messages to prefetch before applying backpressure.</p>
<p>Run the source and take the same amount of messages as we previously sent to it.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = jmsSource.take(1).runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L157" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;Map&lt;String, Object&gt;&gt; resultStage =
    jmsSource.take(1).runWith(Sink.head(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L233-L234" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#receiving-s-from-a-jms-provider" name="receiving-s-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Receiving <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a>s from a JMS provider</h3>
<p>Create a source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[Message, KillSwitch] = JmsConsumer(
  JmsConsumerSettings(connectionFactory).withBufferSize(10).withQueue(&quot;numbers&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L194-L196" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;Message, KillSwitch&gt; jmsSource =
    JmsConsumer.create(
        JmsConsumerSettings.create(connectionFactory)
            .withQueue(&quot;test&quot;)
            .withBufferSize(10));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L271-L275" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>bufferSize</code> parameter controls the maximum number of messages to prefetch before applying backpressure.</p>
<p>Run the source and specify the amount of messages to take:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result: Future[Seq[Message]] = jmsSource.take(msgsIn.size).runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L200" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;List&lt;Message&gt;&gt; result =
    jmsSource.take(msgsIn.size()).runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L279-L280" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p><strong>Notes:</strong></p>
<ul>
  <li>The default <code>AcknowledgeMode</code> is <code>AutoAcknowledge</code> but can be overridden to custom <code>AcknowledgeMode</code>s, even implementation-specific ones by setting the <code>AcknowledgeMode</code> in the <code>JmsConsumerSettings</code> when creating the stream.</li>
</ul>
<h3><a href="#receiving-s-messages-from-a-jms-provider-with-client-acknowledgement" name="receiving-s-messages-from-a-jms-provider-with-client-acknowledgement" class="anchor"><span class="anchor-link"></span></a>Receiving <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a>s messages from a JMS provider with Client Acknowledgement</h3>
<p>Create a <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a> source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[Message, KillSwitch] = JmsConsumer(
  JmsConsumerSettings(connectionFactory)
    .withQueue(&quot;numbers&quot;)
    .withAcknowledgeMode(AcknowledgeMode.ClientAcknowledge)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L470-L474" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;Message, KillSwitch&gt; jmsSource =
    JmsConsumer.create(
        JmsConsumerSettings.create(connectionFactory)
            .withQueue(&quot;test&quot;)
            .withAcknowledgeMode(AcknowledgeMode.ClientAcknowledge()));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L490-L494" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>acknowledgeMode</code> (<a href="https://doc.akka.io/api/alpakka/1.0-M1/akka/stream/alpakka/jms/AcknowledgeMode$.html">AcknowledgeMode</a>) parameter controls the JMS acknowledge mode parameter, see <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Connection.html#createSession-boolean-int-">javax.jms.Connection.createSession</a>.</p>
<p>Run the source and take the same amount of messages as we previously sent to it acknowledging them.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = jmsSource
  .map {
    case textMessage: TextMessage =&gt;
      val text = textMessage.getText
      textMessage.acknowledge()
      text
  }
  .take(msgsIn.size)
  .runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L478-L486" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;List&lt;String&gt;&gt; result =
    jmsSource
        .map(
            message -&gt; {
              String text = ((ActiveMQTextMessage) message).getText();
              message.acknowledge();
              return text;
            })
        .take(msgsIn.size())
        .runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L498-L507" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#receiving-s-from-a-jms-provider-with-a-selector" name="receiving-s-from-a-jms-provider-with-a-selector" class="anchor"><span class="anchor-link"></span></a>Receiving <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a>s from a JMS provider with a selector</h3>
<p>Create a <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a> source specifying a <a href="https://docs.oracle.com/cd/E19798-01/821-1841/bncer/index.html">JMS selector expression</a>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource = JmsConsumer(
  JmsConsumerSettings(connectionFactory).withBufferSize(10).withQueue(&quot;numbers&quot;).withSelector(&quot;IsOdd = TRUE&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L309-L311" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;Message, KillSwitch&gt; jmsSource =
    JmsConsumer.create(
        JmsConsumerSettings.create(connectionFactory)
            .withQueue(&quot;test&quot;)
            .withBufferSize(10)
            .withSelector(&quot;IsOdd = TRUE&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L374-L379" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Verify that we are only receiving messages according to the selector:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val oddMsgsIn = msgsIn.filter(msg =&gt; msg.body.toInt % 2 == 1)
val result = jmsSource.take(oddMsgsIn.size).runWith(Sink.seq)
// We should have only received the odd numbers in the list
result.futureValue.zip(oddMsgsIn).foreach {
  case (out, in) =&gt;
    out.getIntProperty(&quot;Number&quot;) shouldEqual in.properties(&quot;Number&quot;)
    out.getBooleanProperty(&quot;IsOdd&quot;) shouldEqual in.properties(&quot;IsOdd&quot;)
    out.getBooleanProperty(&quot;IsEven&quot;) shouldEqual in.properties(&quot;IsEven&quot;)
    // Make sure we are only receiving odd numbers
    out.getIntProperty(&quot;Number&quot;) % 2 shouldEqual 1
}</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L315-L325" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">List&lt;JmsTextMessage&gt; oddMsgsIn =
    msgsIn
        .stream()
        .filter(msg -&gt; Integer.valueOf(msg.body()) % 2 == 1)
        .collect(Collectors.toList());
assertEquals(5, oddMsgsIn.size());

CompletionStage&lt;List&lt;Message&gt;&gt; result =
    jmsSource.take(oddMsgsIn.size()).runWith(Sink.seq(), materializer);

List&lt;Message&gt; outMessages = result.toCompletableFuture().get(4, TimeUnit.SECONDS);
int msgIdx = 0;
for (Message outMsg : outMessages) {
  assertEquals(
      outMsg.getIntProperty(&quot;Number&quot;),
      oddMsgsIn.get(msgIdx).properties().get(&quot;Number&quot;).get());
  assertEquals(
      outMsg.getBooleanProperty(&quot;IsOdd&quot;),
      oddMsgsIn.get(msgIdx).properties().get(&quot;IsOdd&quot;).get());
  assertEquals(
      outMsg.getBooleanProperty(&quot;IsEven&quot;),
      (oddMsgsIn.get(msgIdx).properties().get(&quot;IsEven&quot;).get()));
  assertEquals(1, outMsg.getIntProperty(&quot;Number&quot;) % 2);
  msgIdx++;
}</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L383-L407" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#receiving-and-explicitly-acknowledging-s-from-a-jms-provider" name="receiving-and-explicitly-acknowledging-s-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Receiving and explicitly acknowledging <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a>s from a JMS provider</h3>
<p>Create a <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a> source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[AckEnvelope, KillSwitch] = JmsConsumer.ackSource(
  JmsConsumerSettings(connectionFactory).withSessionCount(5).withBufferSize(5).withQueue(&quot;numbers&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsBufferedAckConnectorsSpec.scala#L68-L70" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;AckEnvelope, KillSwitch&gt; jmsSource =
    JmsConsumer.ackSource(
        JmsConsumerSettings.create(connectionFactory)
            .withSessionCount(5)
            .withBufferSize(5)
            .withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsBufferedAckConnectorsTest.java#L103-L108" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>sessionCount</code> parameter controls the number of JMS sessions to run in parallel.</p>
<p>The <code>bufferSize</code> parameter controls the maximum number of messages each JMS session will prefetch and awaiting acknowledgement before applying backpressure.</p>
<p>Run the source and specify the amount of messages to take:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = jmsSource
  .take(msgsIn.size)
  .map { env =&gt;
    env.acknowledge()
    env.message
  }
  .runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsBufferedAckConnectorsSpec.scala#L74-L80" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;List&lt;Message&gt;&gt; result =
    jmsSource
        .take(msgsIn.size())
        .map(
            env -&gt; {
              env.acknowledge();
              return env.message();
            })
        .runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsBufferedAckConnectorsTest.java#L112-L120" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p><strong>Notes:</strong></p>
<ul>
  <li>Using multiple sessions increases throughput, especially if a acknowledging message by message is desired.</li>
  <li>Messages may arrive out of order if <code>sessionCount</code> is larger than 1.</li>
  <li>Message-by-message acknowledgement can be achieved by setting <code>bufferSize</code> to 0, thus disabling buffering. The outstanding messages before backpressure will be the <code>sessionCount</code>.</li>
  <li>The default <code>AcknowledgeMode</code> is <code>ClientAcknowledge</code> but can be overridden to custom <code>AcknowledgeMode</code>s, even implementation-specific ones by setting the <code>AcknowledgeMode</code> in the <code>JmsConsumerSettings</code> when creating the stream.</li>
</ul>
<h3><a href="#transactionally-receiving-s-from-a-jms-provider" name="transactionally-receiving-s-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Transactionally receiving <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a>s from a JMS provider</h3>
<p>Create a <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a> source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsSource: Source[TxEnvelope, KillSwitch] = JmsConsumer.txSource(
  JmsConsumerSettings(connectionFactory)
    .withSessionCount(5)
    .withAckTimeout(1.second)
    .withQueue(&quot;numbers&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsTxConnectorsSpec.scala#L68-L73" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;TxEnvelope, KillSwitch&gt; jmsSource =
    JmsConsumer.txSource(
        JmsConsumerSettings.create(connectionFactory)
            .withSessionCount(5)
            .withAckTimeout(1, TimeUnit.SECONDS)
            .withQueue(&quot;test&quot;));
Source&lt;TxEnvelope, KillSwitch&gt; jmsSource =
    JmsConsumer.txSource(
        JmsConsumerSettings.create(connectionFactory)
            .withSessionCount(5)
            .withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsTxConnectorsTest.java#L122-L201" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>sessionCount</code> parameter controls the number of JMS sessions to run in parallel.</p>
<p>The <code>ackTimeout</code> parameter controls the maximum time given to a message to be committed or rolled back. If the message times out it will automatically be rolled back. This is to prevent stream from starvation if the application fails to commit or rollback a message, or if the message errors out and the stream is resumed by a <code>decider</code>.</p>
<p>Run the source and specify the amount of messages to take:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = jmsSource
  .take(msgsIn.size)
  .map { env =&gt;
    env.commit()
    env.message
  }
  .runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsTxConnectorsSpec.scala#L77-L83" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;List&lt;Message&gt;&gt; result =
    jmsSource
        .take(msgsIn.size())
        .map(
            env -&gt; {
              env.commit();
              return env.message();
            })
        .runWith(Sink.seq(), materializer);
CompletionStage&lt;List&lt;Message&gt;&gt; result =
    jmsSource
        .take(msgsIn.size())
        .map(
            env -&gt; {
              env.commit();
              return env.message();
            })
        .runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsTxConnectorsTest.java#L131-L213" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p><strong>Notes:</strong></p>
<ul>
  <li>Higher throughput is achieved by increasing the <code>sessionCount</code>.</li>
  <li>Messages will arrive out of order if <code>sessionCount</code> is larger than 1.</li>
  <li>Buffering is not supported in transaction mode. The <code>bufferSize</code> is ignored.</li>
  <li>The default <code>AcknowledgeMode</code> is <code>SessionTransacted</code> but can be overridden to custom <code>AcknowledgeMode</code>s, even implementation-specific ones by setting the <code>AcknowledgeMode</code> in the <code>JmsConsumerSettings</code> when creating the stream.</li>
</ul>
<h3><a href="#browsing-messages-from-a-jms-provider" name="browsing-messages-from-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Browsing messages from a JMS provider</h3>
<p>The browse source will stream the messages in a queue without consuming them.</p>
<p>Create a source:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val browseSource: Source[Message, NotUsed] = JmsConsumer.browse(
  JmsBrowseSettings(connectionFactory).withQueue(&quot;test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L779-L781" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;Message, NotUsed&gt; browseSource =
    JmsConsumer.browse(JmsBrowseSettings.create(connectionFactory).withQueue(&quot;test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L619-L620" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>The <code>messageSelector</code> parameter can be used to filter the messages. Otherwise it will browse the entire content of the queue.</p>
<p>Unlike the other sources, the browse source will complete after browsing all the messages:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val result = browseSource.runWith(Sink.seq)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L785" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletionStage&lt;List&lt;Message&gt;&gt; result = browseSource.runWith(Sink.seq(), materializer);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L624" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p><strong>Notes:</strong></p>
<ul>
  <li>Messages may be arriving and expiring while the scan is done.</li>
  <li>The JMS API does not require the content of an enumeration to be a static snapshot of queue content. Whether these changes are visible or not depends on the JMS provider.</li>
  <li>A message must not be returned by a QueueBrowser before its delivery time has been reached.</li>
</ul>
<h3><a href="#using-topic-with-an-jms-provider" name="using-topic-with-an-jms-provider" class="anchor"><span class="anchor-link"></span></a>Using Topic with an JMS provider</h3>
<p>You can use JMS topic in a very similar way.</p>
<p>For the Sink :</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsTopicSink: Sink[String, Future[Done]] = JmsProducer.textSink(
  JmsProducerSettings(connectionFactory).withTopic(&quot;topic&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L417-L419" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Sink&lt;String, CompletionStage&lt;Done&gt;&gt; jmsTopicSink =
    JmsProducer.textSink(
        JmsProducerSettings.create(connectionFactory).withTopic(&quot;topic&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L423-L425" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>For the source :</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsTopicSource: Source[String, KillSwitch] = JmsConsumer.textSource(
  JmsConsumerSettings(connectionFactory).withBufferSize(10).withTopic(&quot;topic&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L429-L431" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;String, KillSwitch&gt; jmsTopicSource =
    JmsConsumer.textSource(
        JmsConsumerSettings.create(connectionFactory)
            .withTopic(&quot;topic&quot;)
            .withBufferSize(10));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L432-L436" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>Such sink and source can be started the same way as in the previous example.</p>
<p><strong>Notes:</strong></p>
<ul>
  <li>Explicit acknowledgement sources and transactional sources work with topics the same way they work with queues.</li>
  <li><strong>DO NOT</strong> set the <code>sessionCount</code> greater than 1 for topics. Doing so will result in duplicate messages being delivered. Each topic message is delivered to each JMS session and all the messages feed to the same <code>Source</code>. JMS 2.0 created shared consumers to solve this problem and multiple sessions without duplication may be supported in the future.</li>
</ul>
<h3><a href="#using-a-durable-topic-subscription-with-a-jms-provider" name="using-a-durable-topic-subscription-with-a-jms-provider" class="anchor"><span class="anchor-link"></span></a>Using a durable Topic subscription with a JMS provider</h3>
<p>Using a durable topic subscription works mostly like a normal topic source.</p>
<p>You need to specify a client ID for the connection factory you use to create the consumer with, however:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val consumerConnectionFactory = new ActiveMQConnectionFactory(ctx.url)
consumerConnectionFactory.setClientID(getClass.getSimpleName)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L1188-L1189" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">ConnectionFactory consumerConnectionFactory = new ActiveMQConnectionFactory(ctx.url);
((ActiveMQConnectionFactory) consumerConnectionFactory)
    .setClientID(getClass().getSimpleName());</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L652-L654" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<p>In addition, use <code>withDurableTopic</code> and specify a name for the durable subscriber:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val jmsTopicSource = JmsConsumer.textSource(
  JmsConsumerSettings(consumerConnectionFactory)
    .withDurableTopic(&quot;topic&quot;, &quot;durable-test&quot;)
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorsSpec.scala#L1199-L1202" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Source&lt;String, KillSwitch&gt; jmsTopicSource =
    JmsConsumer.textSource(
        JmsConsumerSettings.create(consumerConnectionFactory)
            .withDurableTopic(&quot;topic&quot;, &quot;durable-test&quot;));</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsConnectorsTest.java#L664-L667" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h3><a href="#running-the-example-code" name="running-the-example-code" class="anchor"><span class="anchor-link"></span></a>Running the example code</h3>
<p>The code in this guide is part of runnable tests of this project. You are welcome to edit the code and run it in sbt.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre><code>sbt
&gt; jms/testOnly *.JmsConnectorsSpec
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre><code>sbt
&gt; jms/testOnly *.JmsConnectorsTest
</code></pre></dd>
</dl>
<h3><a href="#stopping-a-jms-source" name="stopping-a-jms-source" class="anchor"><span class="anchor-link"></span></a>Stopping a JMS Source</h3>
<p>All JMS sources materialize to a <code>KillSwitch</code> to allow safely stopping consumption without message loss for transactional and acknowledged messages, and with minimal message loss for the simple JMS source.</p>
<p>To stop consumption safely, call <code>shutdown()</code> on the <code>KillSwitch</code> that is the materialized value of the source. To abruptly abort consumption (without concerns for message loss), call <code>abort(Throwable)</code> on the <code>KillSwitch</code>.</p>
<h2><a href="#connection-retries" name="connection-retries" class="anchor"><span class="anchor-link"></span></a>Connection Retries</h2>
<p>When a connection to a broker cannot be established and errors out, or is timing out being established or started, the connection can be retried. All JMS publishers, consumers, and browsers are configured with a connection retry settings as follows:</p>
<table>
  <thead>
    <tr>
      <th>Setting </th>
      <th>Description </th>
      <th>Default Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>connectTimeout </td>
      <td>Time allowed to establish and start a connection </td>
      <td>10 s</td>
    </tr>
    <tr>
      <td>initialRetry </td>
      <td>Wait time before retrying the first time </td>
      <td>100 ms</td>
    </tr>
    <tr>
      <td>backoffFactor </td>
      <td>Back-off factor for subsequent retries </td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>maxBackoff </td>
      <td>Maximum back-off time allowed, after which all retries will happen after this delay </td>
      <td>1 minute</td>
    </tr>
    <tr>
      <td>maxRetries </td>
      <td>Maximim number of retries allowed (negative value is infinite) </td>
      <td>10</td>
    </tr>
  </tbody>
</table>
<p>The retry time is calculated by:</p>
<p><em>initialRetry * retryNumber<sup>backoffFactor</sup></em></p>
<p>With the default settings, we&rsquo;ll see retries after 100ms, 400ms, 900ms pauses, until the pauses reach 1 minute and will stay with 1 minute intervals for any subsequent retries.</p>
<p>Consumers and browsers try to reconnect with the same retry characteristics if a connection fails mid-stream. Publishers do not reconnect at this point in time.</p>
<p>All JMS settings support setting the <code>connectionRetrySettings</code> field using <code>.withConnectionRetrySettings(retrySettings)</code> on the given settings. The followings show how to create the <code>ConnectionRetrySettings</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val retrySettings = ConnectionRetrySettings(
  connectTimeout = 3.seconds,
  initialRetry = 1.second,
  backoffFactor = 1.5,
  maxBackoff = 30.seconds,
  maxRetries = -1
)</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/scala/akka/stream/alpakka/jms/scaladsl/JmsSettingsSpec.scala#L18-L24" class="snippet-full-source github">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">ConnectionRetrySettings retrySettings =
    ConnectionRetrySettings.create()
        .withConnectTimeout(3, TimeUnit.SECONDS)
        .withInitialRetry(1, TimeUnit.SECONDS)
        .withBackoffFactor(1.5)
        .withMaxBackoff(30, TimeUnit.SECONDS)
        .withMaxRetries(-1);</code></pre><a href="https://github.com/akka/alpakka/tree/v1.0-M1/jms/src/test/java/akka/stream/alpakka/jms/javadsl/JmsSettingsTest.java#L22-L28" class="snippet-full-source github">Full source at GitHub</a></dd>
</dl>
<h2><a href="#using-ibm-mq" name="using-ibm-mq" class="anchor"><span class="anchor-link"></span></a>Using IBM MQ</h2>
<p>You can use IBM MQ like any other JMS Provider by creating a <code>QueueConnectionFactory</code> or a <code>TopicConnectionFactory</code> and creating a <code>JmsConsumerSettings</code> or <code>JmsProducerSettings</code> from it. The below snippets have been tested with a default IBM MQ docker image which contains queues and topics for testing. The following command starts MQ 9 using docker:</p>
<pre><code>docker run --env LICENSE=accept --env MQ_QMGR_NAME=QM1 --publish 1414:1414 --publish 9443:9443 ibmcom/mq:9
</code></pre>
<p>MQ settings for this image are shown here: <a href="https://github.com/ibm-messaging/mq-docker#mq-developer-defaults">https://github.com/ibm-messaging/mq-docker#mq-developer-defaults</a></p>
<h3><a href="#create-a-jmsconsumer-to-an-ibm-mq-queue" name="create-a-jmsconsumer-to-an-ibm-mq-queue" class="anchor"><span class="anchor-link"></span></a>Create a JmsConsumer to an IBM MQ Queue</h3>
<p>The <code>MQQueueConnectionFactory</code> needs a queue manager name and a channel name, the docker command used in the previous section sets up a <code>QM1</code> queue manager and a <code>DEV.APP.SVRCONN</code> channel. The IBM MQ client makes it possible to connect to the MQ server over TCP/IP or natively through JNI (when the client and server run on the same machine). In the examples below we have chosen to use TCP/IP, which is done by setting the transport type to <code>CommonConstants.WMQ_CM_CLIENT</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>&#9;
    <pre class="prettyprint"><code class="language-scala">import com.ibm.mq.jms.MQQueueConnectionFactory
import com.ibm.msg.client.wmq.common.CommonConstants

val QueueManagerName = &quot;QM1&quot;
val TestChannelName = &quot;DEV.APP.SVRCONN&quot;

// Create the IBM MQ QueueConnectionFactory
val queueConnectionFactory = new MQQueueConnectionFactory()
queueConnectionFactory.setQueueManager(QueueManagerName)
queueConnectionFactory.setChannel(TestChannelName)

// Connect to IBM MQ over TCP/IP
queueConnectionFactory.setTransportType(CommonConstants.WMQ_CM_CLIENT)
val TestQueueName = &quot;DEV.QUEUE.1&quot;

// Option1: create Source using default factory with just name
val jmsSource: Source[String, NotUsed] = JmsConsumer.textSource(
  JmsConsumerSettings(queueConnectionFactory).withQueue(TestQueueName)
)

// Option2: create Source using custom factory
private def createMqQueue(destinationName: String): Session =&gt; MQQueue = { session =&gt;
   ...
}

val jmsSource: Source[String, NotUsed] = JmsConsumer.textSource(
  JmsConsumerSettings(queueConnectionFactory)
    .withDestination(CustomDestination(TestQueueName, createMqQueue(TestQueueName)))
)
</code></pre>
  </dd>
  <dt>Java</dt>
  <dd>&#9;
    <pre class="prettyprint"><code class="language-java">import com.ibm.mq.jms.MQQueueConnectionFactory;
import com.ibm.msg.client.wmq.common.CommonConstants;

String queueManagerName = &quot;QM1&quot;;
String testChannelName = &quot;DEV.APP.SVRCONN&quot;;

// Create the IBM MQ QueueConnectionFactory
MQQueueConnectionFactory queueConnectionFactory = new MQQueueConnectionFactory();
queueConnectionFactory.setQueueManager(queueManagerName);
queueConnectionFactory.setChannel(testChannelName);

// Connect to IBM MQ over TCP/IP
queueConnectionFactory.setTransportType(CommonConstants.WMQ_CM_CLIENT);
String testQueueName = &quot;DEV.QUEUE.1&quot;;

// Option1: create Source using default factory with just name
Source&lt;String, NotUsed&gt; jmsSource = JmsConsumer.textSource(
  JmsConsumerSettings
    .create(queueConnectionFactory)
    .withQueue(testQueueName)
);

// Option2: create Source using custom factory
private Function1&lt;Session, Destination&gt; createMqQueue(String destinationName) {
    return (session) -&gt; {
        ...
    };
}

Source&lt;String, NotUsed&gt; jmsSource = JmsConsumer.textSource(
  JmsConsumerSettings
    .create(queueConnectionFactory)
    .withDestination(new CustomDestination(testQueueName,createMqQueue(testQueueName)))
);
</code></pre>
  </dd>
</dl>
<h3><a href="#create-a-jmsproducer-to-an-ibm-mq-topic" name="create-a-jmsproducer-to-an-ibm-mq-topic" class="anchor"><span class="anchor-link"></span></a>Create a JmsProducer to an IBM MQ Topic</h3>
<p>The IBM MQ docker container sets up a <code>dev/</code> topic, which is used in the example below.</p>
<dl>
  <dt>Scala</dt>
  <dd>&#9;
    <pre class="prettyprint"><code class="language-scala">import com.ibm.mq.jms.MQTopicConnectionFactory
import com.ibm.msg.client.wmq.common.CommonConstants

val QueueManagerName = &quot;QM1&quot;
val TestChannelName = &quot;DEV.APP.SVRCONN&quot;

// Create the IBM MQ TopicConnectionFactory
val topicConnectionFactory = new MQTopicConnectionFactory()
topicConnectionFactory.setQueueManager(QueueManagerName)
topicConnectionFactory.setChannel(TestChannelName)

// Connect to IBM MQ over TCP/IP
topicConnectionFactory.setTransportType(CommonConstants.WMQ_CM_CLIENT)
val TestTopicName = &quot;dev/&quot;

// Option1: create Sink using default factory with just name
val jmsTopicSink: Sink[String, NotUsed] = JmsProducer(
  JmsProducerSettings(topicConnectionFactory).withTopic(TestTopicName)
)

// Option2: create Sink using custom factory
private def createMqTopic(destinationName: String): Session =&gt; MQTopic = { session =&gt;
    ...
}    

val jmsTopicSink: Sink[String, NotUsed] = JmsProducer(
  JmsProducerSettings(topicConnectionFactory)
    .withDestination(CustomDestination(TestTopicName, createMqTopic(TestTopicName)))
)    
</code></pre>
  </dd>
  <dt>Java</dt>
  <dd>&#9;
    <pre class="prettyprint"><code class="language-java">import com.ibm.mq.jms.MQTopicConnectionFactory;
import com.ibm.msg.client.wmq.common.CommonConstants;

String queueManagerName = &quot;QM1&quot;;
String testChannelName = &quot;DEV.APP.SVRCONN&quot;;

// Create the IBM MQ TopicConnectionFactory
val topicConnectionFactory = new MQTopicConnectionFactory();
topicConnectionFactory.setQueueManager(queueManagerName);
topicConnectionFactory.setChannel(testChannelName);

// Connect to IBM MQ over TCP/IP
topicConnectionFactory.setTransportType(CommonConstants.WMQ_CM_CLIENT);
String testTopicName = &quot;dev/&quot;;

// Option1: create Source using default factory with just name
Sink&lt;String, NotUsed&gt; jmsTopicSink = JmsProducer.textSink(
  JmsProducerSettings
    .create(topicConnectionFactory)
    .withTopic(testTopicName)
);

// Option2: create Source using custom factory
private Function1&lt;Session, Destination&gt; createMqTopic(String destinationName) {
    return (session) -&gt; {
        ...
    };
}

Sink&lt;String, NotUsed&gt; jmsTopicSink = JmsProducer.textSink(
  JmsProducerSettings
    .create(queueConnectionFactory)
    .withDestination(new CustomDestination(testTopicName, createMqTopic(testTopicName)))
);    
</code></pre>
  </dd>
</dl>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="ironmq.html"><i class="icon-prev"></i> <span class="link-prev">IronMQ</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="mongodb.html">MongoDB <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/alpakka/tree/v1.0-M1/docs/src/main/paradox/jms.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Alpakka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<script type="text/javascript" src="assets/js/warnOldVersion.js"></script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '1.0-M1', 'https://doc.akka.io/docs/alpakka/current/')});</script>


</body>
</html>
