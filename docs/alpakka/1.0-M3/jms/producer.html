<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Producer &bull; Alpakka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Alpakka is a Reactive Enterprise Integration library for Java and Scala, based on Reactive Streams and Akka."/>
<link rel="canonical" href="https://doc.akka.io/docs/alpakka/current/jms/producer.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_setDomainName', '']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-alpakka-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Alpakka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 1.0-M3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../overview.html" class="page">Overview</a></li>
  <li><a href="../data-transformations/index.html" class="page">Data Transformations</a></li>
  <li><a href="../amqp.html" class="page">AMQP</a></li>
  <li><a href="../external/apache-camel.html" class="page">Apache Camel</a></li>
  <li><a href="../cassandra.html" class="page">Apache Cassandra</a></li>
  <li><a href="../geode.html" class="page">Apache Geode</a></li>
  <li><a href="../kafka.html" class="page">Apache Kafka</a></li>
  <li><a href="../kudu.html" class="page">Apache Kudu</a></li>
  <li><a href="../solr.html" class="page">Apache Solr</a></li>
  <li><a href="../avroparquet.html" class="page">Avro Parquet</a></li>
  <li><a href="../dynamodb.html" class="page">AWS DynamoDB</a></li>
  <li><a href="../kinesis.html" class="page">AWS Kinesis</a></li>
  <li><a href="../awslambda.html" class="page">AWS Lambda</a></li>
  <li><a href="../s3.html" class="page">AWS S3</a></li>
  <li><a href="../sns.html" class="page">AWS SNS</a></li>
  <li><a href="../sqs.html" class="page">AWS SQS</a></li>
  <li><a href="../external/azure-event-hubs.html" class="page">Azure Event Hubs</a></li>
  <li><a href="../external/azure-iot-hub.html" class="page">Azure IoT Hub</a></li>
  <li><a href="../azure-storage-queue.html" class="page">Azure Storage Queue</a></li>
  <li><a href="../couchbase.html" class="page">Couchbase</a></li>
  <li><a href="../elasticsearch.html" class="page">Elasticsearch</a></li>
  <li><a href="../external/eventuate.html" class="page">Eventuate</a></li>
  <li><a href="../file.html" class="page">File</a></li>
  <li><a href="../external/fs2.html" class="page">FS2</a></li>
  <li><a href="../ftp.html" class="page">FTP</a></li>
  <li><a href="../google-cloud-pub-sub.html" class="page">Google Cloud Pub/Sub</a></li>
  <li><a href="../google-cloud-pub-sub-grpc.html" class="page">Google Cloud Pub/Sub gRPC</a></li>
  <li><a href="../google-fcm.html" class="page">Google FCM</a></li>
  <li><a href="../external/grpc.html" class="page">gRPC</a></li>
  <li><a href="../hdfs.html" class="page">Hadoop Distributed File System - HDFS</a></li>
  <li><a href="../hbase.html" class="page">HBase</a></li>
  <li><a href="../external/http.html" class="page">HTTP</a></li>
  <li><a href="../bluemix-cos.html" class="page">IBM Bluemix Cloud Object Storage</a></li>
  <li><a href="../external/db2-event-store.html" class="page">IBM Db2 Event Store</a></li>
  <li><a href="../ironmq.html" class="page">IronMQ</a></li>
  <li><a href="../jms/index.html" class="page">JMS</a>
  <ul>
    <li><a href="../jms/index.html#reported-issues" class="header">Reported issues</a></li>
    <li><a href="../jms/index.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="../jms/producer.html#producer" class="active page">Producer</a>
    <ul>
      <li><a href="../jms/producer.html#configure-jms-producers" class="header">Configure JMS producers</a></li>
      <li><a href="../jms/producer.html#a-jmsmessage-sub-type-sink" class="header">A <code>JmsMessage</code> sub-type sink</a></li>
      <li><a href="../jms/producer.html#raw-jvm-type-sinks" class="header">Raw JVM type sinks</a></li>
      <li><a href="../jms/producer.html#sending-messages-as-a-flow" class="header">Sending messages as a Flow</a></li>
      <li><a href="../jms/producer.html#sending-messages-with-per-message-destinations" class="header">Sending messages with per-message destinations</a></li>
      <li><a href="../jms/producer.html#passing-context-through-the-producer" class="header">Passing context through the producer</a></li>
      <li><a href="../jms/producer.html#producer-settings" class="header">Producer Settings</a></li>
      <li><a href="../jms/producer.html#connection-retries" class="header">Connection Retries</a></li>
      <li><a href="../jms/producer.html#send-retries" class="header">Send Retries</a></li>
    </ul></li>
    <li><a href="../jms/consumer.html" class="page">Consumer</a></li>
    <li><a href="../jms/browse.html" class="page">Browse</a></li>
    <li><a href="../jms/ibm-mq.html" class="page">Using IBM MQ</a></li>
  </ul></li>
  <li><a href="../mongodb.html" class="page">MongoDB</a></li>
  <li><a href="../mqtt.html" class="page">MQTT</a></li>
  <li><a href="../mqtt-streaming.html" class="page">MQTT Streaming</a></li>
  <li><a href="../orientdb.html" class="page">OrientDB</a></li>
  <li><a href="../external/pulsar.html" class="page">Pulsar</a></li>
  <li><a href="../sse.html" class="page">Server-sent Events (SSE)</a></li>
  <li><a href="../slick.html" class="page">Slick (JDBC)</a></li>
  <li><a href="../spring-web.html" class="page">Spring Web</a></li>
  <li><a href="../external/tcp.html" class="page">TCP</a></li>
  <li><a href="../udp.html" class="page">UDP</a></li>
  <li><a href="../unix-domain-socket.html" class="page">Unix Domain Socket</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Alpakka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 1.0-M3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../overview.html" class="page">Overview</a></li>
  <li><a href="../data-transformations/index.html" class="page">Data Transformations</a></li>
  <li><a href="../amqp.html" class="page">AMQP</a></li>
  <li><a href="../external/apache-camel.html" class="page">Apache Camel</a></li>
  <li><a href="../cassandra.html" class="page">Apache Cassandra</a></li>
  <li><a href="../geode.html" class="page">Apache Geode</a></li>
  <li><a href="../kafka.html" class="page">Apache Kafka</a></li>
  <li><a href="../kudu.html" class="page">Apache Kudu</a></li>
  <li><a href="../solr.html" class="page">Apache Solr</a></li>
  <li><a href="../avroparquet.html" class="page">Avro Parquet</a></li>
  <li><a href="../dynamodb.html" class="page">AWS DynamoDB</a></li>
  <li><a href="../kinesis.html" class="page">AWS Kinesis</a></li>
  <li><a href="../awslambda.html" class="page">AWS Lambda</a></li>
  <li><a href="../s3.html" class="page">AWS S3</a></li>
  <li><a href="../sns.html" class="page">AWS SNS</a></li>
  <li><a href="../sqs.html" class="page">AWS SQS</a></li>
  <li><a href="../external/azure-event-hubs.html" class="page">Azure Event Hubs</a></li>
  <li><a href="../external/azure-iot-hub.html" class="page">Azure IoT Hub</a></li>
  <li><a href="../azure-storage-queue.html" class="page">Azure Storage Queue</a></li>
  <li><a href="../couchbase.html" class="page">Couchbase</a></li>
  <li><a href="../elasticsearch.html" class="page">Elasticsearch</a></li>
  <li><a href="../external/eventuate.html" class="page">Eventuate</a></li>
  <li><a href="../file.html" class="page">File</a></li>
  <li><a href="../external/fs2.html" class="page">FS2</a></li>
  <li><a href="../ftp.html" class="page">FTP</a></li>
  <li><a href="../google-cloud-pub-sub.html" class="page">Google Cloud Pub/Sub</a></li>
  <li><a href="../google-cloud-pub-sub-grpc.html" class="page">Google Cloud Pub/Sub gRPC</a></li>
  <li><a href="../google-fcm.html" class="page">Google FCM</a></li>
  <li><a href="../external/grpc.html" class="page">gRPC</a></li>
  <li><a href="../hdfs.html" class="page">Hadoop Distributed File System - HDFS</a></li>
  <li><a href="../hbase.html" class="page">HBase</a></li>
  <li><a href="../external/http.html" class="page">HTTP</a></li>
  <li><a href="../bluemix-cos.html" class="page">IBM Bluemix Cloud Object Storage</a></li>
  <li><a href="../external/db2-event-store.html" class="page">IBM Db2 Event Store</a></li>
  <li><a href="../ironmq.html" class="page">IronMQ</a></li>
  <li><a href="../jms/index.html" class="page">JMS</a>
  <ul>
    <li><a href="../jms/index.html#reported-issues" class="header">Reported issues</a></li>
    <li><a href="../jms/index.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="../jms/producer.html#producer" class="active page">Producer</a>
    <ul>
      <li><a href="../jms/producer.html#configure-jms-producers" class="header">Configure JMS producers</a></li>
      <li><a href="../jms/producer.html#a-jmsmessage-sub-type-sink" class="header">A <code>JmsMessage</code> sub-type sink</a></li>
      <li><a href="../jms/producer.html#raw-jvm-type-sinks" class="header">Raw JVM type sinks</a></li>
      <li><a href="../jms/producer.html#sending-messages-as-a-flow" class="header">Sending messages as a Flow</a></li>
      <li><a href="../jms/producer.html#sending-messages-with-per-message-destinations" class="header">Sending messages with per-message destinations</a></li>
      <li><a href="../jms/producer.html#passing-context-through-the-producer" class="header">Passing context through the producer</a></li>
      <li><a href="../jms/producer.html#producer-settings" class="header">Producer Settings</a></li>
      <li><a href="../jms/producer.html#connection-retries" class="header">Connection Retries</a></li>
      <li><a href="../jms/producer.html#send-retries" class="header">Send Retries</a></li>
    </ul></li>
    <li><a href="../jms/consumer.html" class="page">Consumer</a></li>
    <li><a href="../jms/browse.html" class="page">Browse</a></li>
    <li><a href="../jms/ibm-mq.html" class="page">Using IBM MQ</a></li>
  </ul></li>
  <li><a href="../mongodb.html" class="page">MongoDB</a></li>
  <li><a href="../mqtt.html" class="page">MQTT</a></li>
  <li><a href="../mqtt-streaming.html" class="page">MQTT Streaming</a></li>
  <li><a href="../orientdb.html" class="page">OrientDB</a></li>
  <li><a href="../external/pulsar.html" class="page">Pulsar</a></li>
  <li><a href="../sse.html" class="page">Server-sent Events (SSE)</a></li>
  <li><a href="../slick.html" class="page">Slick (JDBC)</a></li>
  <li><a href="../spring-web.html" class="page">Spring Web</a></li>
  <li><a href="../external/tcp.html" class="page">TCP</a></li>
  <li><a href="../udp.html" class="page">UDP</a></li>
  <li><a href="../unix-domain-socket.html" class="page">Unix Domain Socket</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-alpakka-reverse.svg"/></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#producer" name="producer" class="anchor"><span class="anchor-link"></span></a>Producer</h1>
<p>The Alpakka JMS connector offers producing JMS messages to topics or queues in three ways</p>
<ul>
  <li>JVM types to an Akka Streams Sink</li>
  <li><code>JmsMessage</code> sub-types to a Akka Streams Sink or Flow (using <code>JmsProducer.sink</code> or <code>JmsProducer.flow</code>)</li>
  <li><code>JmsEnvelope</code> sub-types to a Akka Streams Flow (using <code>JmsProducer.flexiFlow</code>) to support pass-throughs</li>
</ul>
<p>The JMS message model supports several types of message bodies in (see <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/Message.html">javax.jms.Message</a>), which may be created directly from the Akka Stream elements, or in wrappers to access more advanced features.</p>
<table>
  <thead>
    <tr>
      <th>Stream element type </th>
      <th>Alpakka producer </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>String </td>
      <td><a href="#text-sinks"><code>JmsProducer.textSink</code></a> </td>
    </tr>
    <tr>
      <td><span class="group-scala">Array[Byte]</span><span class="group-java">byte[</span>] </td>
      <td><a href="#byte-array-sinks"><code>JmsProducer.bytesSink</code></a> </td>
    </tr>
    <tr>
      <td><span class="group-scala">Map[String, AnyRef]</span><span class="group-java">Map&lt;String, Object&gt;</span> </td>
      <td><a href="#map-messages-sinks"><code>JmsProducer.mapSink</code></a> </td>
    </tr>
    <tr>
      <td>Object (<code>java.io.Serializable</code>) </td>
      <td><a href="#object-sinks"><code>JmsProducer.objectSink</code></a> </td>
    </tr>
    <tr>
      <td><code>JmsTextMessage</code> </td>
      <td><a href="#a-jmsmessage-sub-type-sink"><code>JmsProducer.sink</code></a> or <a href="#sending-messages-as-a-flow"><code>JmsProducer.flow</code></a> </td>
    </tr>
    <tr>
      <td><code>JmsByteMessage</code> </td>
      <td><a href="#a-jmsmessage-sub-type-sink"><code>JmsProducer.sink</code></a> or <a href="#sending-messages-as-a-flow"><code>JmsProducer.flow</code></a> </td>
    </tr>
    <tr>
      <td><code>JmsByteStringMessage</code> </td>
      <td><a href="#a-jmsmessage-sub-type-sink"><code>JmsProducer.sink</code></a> or <a href="#sending-messages-as-a-flow"><code>JmsProducer.flow</code></a> </td>
    </tr>
    <tr>
      <td><code>JmsMapMessage</code> </td>
      <td><a href="#a-jmsmessage-sub-type-sink"><code>JmsProducer.sink</code></a> or <a href="#sending-messages-as-a-flow"><code>JmsProducer.flow</code></a> </td>
    </tr>
    <tr>
      <td><code>JmsObjectMessage</code> </td>
      <td><a href="#a-jmsmessage-sub-type-sink"><code>JmsProducer.sink</code></a> or <a href="#sending-messages-as-a-flow"><code>JmsProducer.flow</code></a> </td>
    </tr>
    <tr>
      <td><span class="group-scala"><code>JmsEnvelope[PassThrough]</code></span><span class="group-java"><code>JmsEnvelope&lt;PassThrough&gt;</code></span> with instances <code>JmsPassThrough</code>, <code>JmsTextMessagePassThrough</code>, <code>JmsByteMessagePassThrough</code>, <code>JmsByteStringMessagePassThrough</code>, <code>JmsMapMessagePassThrough</code>, <code>JmsObjectMessagePassThrough</code> </td>
      <td><a href="#passing-context-through-the-producer"><code>JmsProducer.flexiFlow</code></a> </td>
    </tr>
  </tbody>
</table>
<h3><a href="#configure-jms-producers" name="configure-jms-producers" class="anchor"><span class="anchor-link"></span></a>Configure JMS producers</h3>
<p>To connect to the JMS broker, first define an appropriate <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/ConnectionFactory.html">javax.jms.ConnectionFactory</a>. Here we&rsquo;re using Active MQ.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L43" target="_blank" title="Go to snippet source"></a><code class="language-scala">val connectionFactory: javax.jms.ConnectionFactory = new org.apache.activemq.ActiveMQConnectionFactory(url)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L124" target="_blank" title="Go to snippet source"></a><code class="language-java">javax.jms.ConnectionFactory connectionFactory = server.createConnectionFactory();</code></pre></dd>
</dl>
<p>The created <a href="https://docs.oracle.com/javaee/7/api/?javax/jms/ConnectionFactory.html">ConnectionFactory</a> is then used for the creation of the different JMS sinks or sources (see below).</p>
<h3><a href="#a-jmsmessage-sub-type-sink" name="a-jmsmessage-sub-type-sink" class="anchor"><span class="anchor-link"></span></a>A <code>JmsMessage</code> sub-type sink</h3>
<p>Use a case class with the subtype of <a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/JmsMessage.html">JmsMessage</a> to wrap the messages you want to send and optionally set message specific properties or headers. <span class="group-java"><a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/javadsl/JmsProducer$.html">JmsProducer</a></span><span class="group-scala"><a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/scaladsl/JmsProducer$.html">JmsProducer</a></span> contains factory methods to facilitate the creation of sinks according to the message type.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L233-L240" target="_blank" title="Go to snippet source"></a><code class="language-scala">val jmsSink: Sink[JmsTextMessage, Future[Done]] = JmsProducer.sink(
  JmsProducerSettings(producerConfig, connectionFactory).withQueue(&quot;numbers&quot;)
)

val finished: Future[Done] =
  Source(immutable.Seq(&quot;Message A&quot;, &quot;Message B&quot;))
    .map(JmsTextMessage(_))
    .runWith(jmsSink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L286-L293" target="_blank" title="Go to snippet source"></a><code class="language-java">Sink&lt;JmsTextMessage, CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.sink(
        JmsProducerSettings.create(producerConfig, connectionFactory).withQueue(&quot;test&quot;));

CompletionStage&lt;Done&gt; finished =
    Source.from(Arrays.asList(&quot;Message A&quot;, &quot;Message B&quot;))
        .map(JmsTextMessage::create)
        .runWith(jmsSink, materializer);</code></pre></dd>
</dl>
<h4><a href="#setting-jms-message-properties" name="setting-jms-message-properties" class="anchor"><span class="anchor-link"></span></a>Setting JMS message properties</h4>
<p>For every <a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/JmsMessage.html">JmsMessage</a> you can set JMS message properties.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L197-L203" target="_blank" title="Go to snippet source"></a><code class="language-scala">val msgsIn = (1 to 10).toList.map { n =&gt;
  akka.stream.alpakka.jms
    .JmsTextMessage(n.toString)
    .withProperty(&quot;Number&quot;, n)
    .withProperty(&quot;IsOdd&quot;, n % 2 == 1)
    .withProperty(&quot;IsEven&quot;, n % 2 == 0)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L105-L109" target="_blank" title="Go to snippet source"></a><code class="language-java">JmsTextMessage message =
    akka.stream.alpakka.jms.JmsTextMessage.create(n.toString())
        .withProperty(&quot;Number&quot;, n)
        .withProperty(&quot;IsOdd&quot;, n % 2 == 1)
        .withProperty(&quot;IsEven&quot;, n % 2 == 0);</code></pre></dd>
</dl>
<h4><a href="#setting-jms-message-header-attributes" name="setting-jms-message-header-attributes" class="anchor"><span class="anchor-link"></span></a>Setting JMS message header attributes</h4>
<p>For every <a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/JmsMessage.html">JmsMessage</a> you can set also JMS message headers.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L264-L272" target="_blank" title="Go to snippet source"></a><code class="language-scala">val msgsIn = (1 to 10).toList.map { n =&gt;
  JmsTextMessage(n.toString)
    .withHeader(JmsType(&quot;type&quot;))
    .withHeader(JmsCorrelationId(&quot;correlationId&quot;))
    .withHeader(JmsReplyTo.queue(&quot;test-reply&quot;))
    .withHeader(JmsTimeToLive(FiniteDuration(999, TimeUnit.SECONDS)))
    .withHeader(JmsPriority(2))
    .withHeader(JmsDeliveryMode(DeliveryMode.NON_PERSISTENT))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L338-L350" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;JmsTextMessage&gt; msgsIn =
    createTestMessageList()
        .stream()
        .map(
            jmsTextMessage -&gt;
                jmsTextMessage
                    .withHeader(JmsType.create(&quot;type&quot;))
                    .withHeader(JmsCorrelationId.create(&quot;correlationId&quot;))
                    .withHeader(JmsReplyTo.queue(&quot;test-reply&quot;))
                    .withHeader(JmsTimeToLive.create(999, TimeUnit.SECONDS))
                    .withHeader(JmsPriority.create(2))
                    .withHeader(JmsDeliveryMode.create(DeliveryMode.NON_PERSISTENT)))
        .collect(Collectors.toList());</code></pre></dd>
</dl>
<h3><a href="#raw-jvm-type-sinks" name="raw-jvm-type-sinks" class="anchor"><span class="anchor-link"></span></a>Raw JVM type sinks</h3>
<h4><a href="#text-sinks" name="text-sinks" class="anchor"><span class="anchor-link"></span></a>Text sinks</h4>
<p>Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/JmsTextMessage$.html">JmsTextMessage</a>s to the JMS provider:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L43-L56" target="_blank" title="Go to snippet source"></a><code class="language-scala">val connectionFactory: javax.jms.ConnectionFactory = new org.apache.activemq.ActiveMQConnectionFactory(url)

val jmsSink: Sink[String, Future[Done]] = JmsProducer.textSink(
  JmsProducerSettings(system, connectionFactory).withQueue(&quot;test&quot;)
)

val in = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;)
val streamCompletion: Future[Done] =
  Source(in)
    .runWith(jmsSink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L124-L135" target="_blank" title="Go to snippet source"></a><code class="language-java">javax.jms.ConnectionFactory connectionFactory = server.createConnectionFactory();

Sink&lt;String, CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.textSink(
        JmsProducerSettings.create(system, connectionFactory).withQueue(&quot;test&quot;));

List&lt;String&gt; in = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;);
CompletionStage&lt;Done&gt; finished = Source.from(in).runWith(jmsSink, materializer);</code></pre></dd>
</dl>
<h4><a href="#byte-array-sinks" name="byte-array-sinks" class="anchor"><span class="anchor-link"></span></a>Byte array sinks</h4>
<p>Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/JmsByteMessage$.html">JmsByteMessage</a>s to the JMS provider.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L108-L115" target="_blank" title="Go to snippet source"></a><code class="language-scala">val jmsSink: Sink[Array[Byte], Future[Done]] = JmsProducer.bytesSink(
  JmsProducerSettings(system, connectionFactory).withQueue(&quot;test&quot;)
)
val in: Array[Byte] = &quot;ThisIsATest&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;))
val streamCompletion: Future[Done] =
  Source
    .single(in)
    .runWith(jmsSink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L195-L205" target="_blank" title="Go to snippet source"></a><code class="language-java">ConnectionFactory connectionFactory = server.createConnectionFactory();

Sink&lt;byte[], CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.bytesSink(
        JmsProducerSettings.create(producerConfig, connectionFactory).withQueue(&quot;test&quot;));

byte[] in = &quot;ThisIsATest&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;));
CompletionStage&lt;Done&gt; finished = Source.single(in).runWith(jmsSink, materializer);</code></pre></dd>
</dl>
<h4><a href="#map-message-sink" name="map-message-sink" class="anchor"><span class="anchor-link"></span></a>Map message sink</h4>
<p>Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/JmsMapMessage$.html">JmsMapMessage</a>s to the JMS provider:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L138-L157" target="_blank" title="Go to snippet source"></a><code class="language-scala">val jmsSink: Sink[Map[String, Any], Future[Done]] = JmsProducer.mapSink(
  JmsProducerSettings(system, connectionFactory).withQueue(&quot;test&quot;)
)

val input = List(
  Map[String, Any](
    &quot;string&quot; -&gt; &quot;value&quot;,
    &quot;int value&quot; -&gt; 42,
    &quot;double value&quot; -&gt; 43.toDouble,
    &quot;short value&quot; -&gt; 7.toShort,
    &quot;boolean value&quot; -&gt; true,
    &quot;long value&quot; -&gt; 7.toLong,
    &quot;bytearray&quot; -&gt; &quot;AStringAsByteArray&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;)),
    &quot;byte&quot; -&gt; 1.toByte
  )
)

val streamCompletion: Future[Done] =
  Source(input)
    .runWith(jmsSink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L227-L245" target="_blank" title="Go to snippet source"></a><code class="language-java">ConnectionFactory connectionFactory = server.createConnectionFactory();

Sink&lt;Map&lt;String, Object&gt;, CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.mapSink(
        JmsProducerSettings.create(system, connectionFactory).withQueue(&quot;test&quot;));

Map&lt;String, Object&gt; in = new HashMap&lt;&gt;();
in.put(&quot;string value&quot;, &quot;value&quot;);
in.put(&quot;int value&quot;, 42);
in.put(&quot;double value&quot;, 43.0);
in.put(&quot;short value&quot;, (short) 7);
in.put(&quot;boolean value&quot;, true);
in.put(&quot;long value&quot;, 7L);
in.put(&quot;bytearray&quot;, &quot;AStringAsByteArray&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;)));
in.put(&quot;byte&quot;, (byte) 1);

CompletionStage&lt;Done&gt; finished = Source.single(in).runWith(jmsSink, materializer);</code></pre></dd>
</dl>
<h4><a href="#object-sinks" name="object-sinks" class="anchor"><span class="anchor-link"></span></a>Object sinks</h4>
<p>Create and configure ActiveMQ connection factory to support serialization. See <a href="http://activemq.apache.org/objectmessage.html">ActiveMQ Security</a> for more information on this. Create a sink, that accepts and forwards <a href="https://doc.akka.io/api/alpakka/1.0-M3/akka/stream/alpakka/jms/JmsObjectMessage$.html">JmsObjectMessage</a>s to the JMS provider:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L73-L86" target="_blank" title="Go to snippet source"></a><code class="language-scala">val connectionFactory = connFactory.asInstanceOf[ActiveMQConnectionFactory]
connectionFactory.setTrustedPackages(List(classOf[DummyObject].getPackage.getName).asJava)

val jmsSink: Sink[Serializable, Future[Done]] = JmsProducer.objectSink(
  JmsProducerSettings(system, connectionFactory).withQueue(&quot;test&quot;)
)
val in = DummyObject(&quot;ThisIsATest&quot;)
val streamCompletion: Future[Done] =
  Source
    .single(in)
    .runWith(jmsSink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L158-L172" target="_blank" title="Go to snippet source"></a><code class="language-java">ActiveMQConnectionFactory connectionFactory =
    (ActiveMQConnectionFactory) server.createConnectionFactory();
connectionFactory.setTrustedPackages(
    Arrays.asList(DummyJavaTests.class.getPackage().getName()));

Sink&lt;java.io.Serializable, CompletionStage&lt;Done&gt;&gt; jmsSink =
    JmsProducer.objectSink(
        JmsProducerSettings.create(system, connectionFactory).withQueue(&quot;test&quot;));

java.io.Serializable in = new DummyJavaTests(&quot;javaTest&quot;);
CompletionStage&lt;Done&gt; finished = Source.single(in).runWith(jmsSink, materializer);</code></pre></dd>
</dl>
<h3><a href="#sending-messages-as-a-flow" name="sending-messages-as-a-flow" class="anchor"><span class="anchor-link"></span></a>Sending messages as a Flow</h3>
<p>The producer can also act as a flow, in order to publish messages in the middle of stream processing. For example, you can ensure that a message is persisted to the queue before subsequent processing.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L801-L813" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>val flow: Flow[JmsMessage, JmsMessage, JmsProducerStatus] =
  JmsProducer.flow(
    JmsProducerSettings(system, connectionFactory)
      .withQueue(&quot;test&quot;)
  )

val input: immutable.Seq[JmsTextMessage] =
  (1 to 100).map(i =&gt; JmsTextMessage(i.toString))

val result: Future[Seq[JmsMessage]] = Source(input)
  .via(flow)
  .runWith(Sink.seq)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L712-L721" target="_blank" title="Go to snippet source"></a><code class="language-java">ConnectionFactory connectionFactory = server.createConnectionFactory();

Flow&lt;JmsTextMessage, JmsTextMessage, JmsProducerStatus&gt; flow =
    JmsProducer.flow(
        JmsProducerSettings.create(system, connectionFactory).withQueue(&quot;test&quot;));

List&lt;JmsTextMessage&gt; input = createTestMessageList();

CompletionStage&lt;List&lt;JmsTextMessage&gt;&gt; result =
    Source.from(input).via(flow).runWith(Sink.seq(), materializer);</code></pre></dd>
</dl>
<h3><a href="#sending-messages-with-per-message-destinations" name="sending-messages-with-per-message-destinations" class="anchor"><span class="anchor-link"></span></a>Sending messages with per-message destinations</h3>
<p>It is also possible to define message destinations per message:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L821-L830" target="_blank" title="Go to snippet source"></a><code class="language-scala">val flowSink: Flow[JmsMessage, JmsMessage, JmsProducerStatus] =
  JmsProducer.flow(
    JmsProducerSettings(system, connectionFactory).withQueue(&quot;test&quot;)
  )

val input = (1 to 100).map { i =&gt;
  val queueName = if (i % 2 == 0) &quot;even&quot; else &quot;odd&quot;
  JmsTextMessage(i.toString).toQueue(queueName)
}
Source(input).via(flowSink).runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L735-L745" target="_blank" title="Go to snippet source"></a><code class="language-java">Flow&lt;JmsTextMessage, JmsTextMessage, JmsProducerStatus&gt; flowSink =
    JmsProducer.flow(
        JmsProducerSettings.create(system, connectionFactory).withQueue(&quot;test&quot;));

List&lt;JmsTextMessage&gt; input = new ArrayList&lt;&gt;();
for (Integer n : Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) {
  String queueName = (n % 2 == 0) ? &quot;even&quot; : &quot;odd&quot;;
  input.add(JmsTextMessage.create(n.toString()).toQueue(queueName));
}

Source.from(input).via(flowSink).runWith(Sink.seq(), materializer);</code></pre></dd>
</dl>
<p>When no destination is defined on the message, the destination given in the producer settings is used.</p>
<h3><a href="#passing-context-through-the-producer" name="passing-context-through-the-producer" class="anchor"><span class="anchor-link"></span></a>Passing context through the producer</h3>
<p>In some use cases, it is useful to pass through context information when producing (e.g. for acknowledging or committing messages after sending to Jms). For this, the <code>JmsProducer.flexiFlow</code> accepts implementations of <code>JmsEnvelope</code>, which it will pass through:</p>
<ul>
  <li><code>JmsPassThrough</code></li>
  <li><code>JmsTextMessagePassThrough</code></li>
  <li><code>JmsByteMessagePassThrough</code></li>
  <li><code>JmsByteStringMessagePassThrough</code></li>
  <li><code>JmsMapMessagePassThrough</code></li>
  <li><code>JmsObjectMessagePassThrough</code></li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L1121-L1133" target="_blank" title="Go to snippet source"></a><code class="language-scala">val jmsProducer: Flow[JmsEnvelope[String], JmsEnvelope[String], JmsProducerStatus] =
  JmsProducer.flexiFlow[String](
    JmsProducerSettings(system, connectionFactory).withQueue(&quot;test&quot;)
  )

val data = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;)
val in: immutable.Seq[JmsTextMessagePassThrough[String]] =
  data.map(t =&gt; JmsTextMessage(t).withPassThrough(t))

val result = Source(in)
  .via(jmsProducer)
  .map(_.passThrough) // extract the value passed through
  .runWith(Sink.seq)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L810-L825" target="_blank" title="Go to snippet source"></a><code class="language-java">Flow&lt;JmsEnvelope&lt;String&gt;, JmsEnvelope&lt;String&gt;, JmsProducerStatus&gt; jmsProducer =
    JmsProducer.flexiFlow(
        JmsProducerSettings.create(producerConfig, connectionFactory).withQueue(&quot;test&quot;));

List&lt;String&gt; data = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;);
List&lt;JmsEnvelope&lt;String&gt;&gt; input = new ArrayList&lt;&gt;();
for (String s : data) {
  String passThrough = s;
  input.add(JmsTextMessage.create(s, passThrough));
}

CompletionStage&lt;List&lt;String&gt;&gt; result =
    Source.from(input)
        .via(jmsProducer)
        .map(JmsEnvelope::passThrough)
        .runWith(Sink.seq(), materializer);</code></pre></dd>
</dl>
<p>There are two implementations: One envelope type containing a messages to send to Jms, and one envelope type containing only values to pass through. This allows messages to flow without producing any new messages to Jms. This is primarily useful when committing offsets back to Kakfa, or when acknowledging Jms messages after sending the outcome of processing them back to Jms.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsConnectorsSpec.scala#L1160-L1167" target="_blank" title="Go to snippet source"></a><code class="language-scala">val jmsProducer = JmsProducer.flexiFlow[String](
  JmsProducerSettings(producerConfig, connectionFactory).withQueue(&quot;topic&quot;)
)

val data = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;)
val in = data.map(t =&gt; JmsPassThrough(t))

val result = Source(in).via(jmsProducer).map(_.passThrough).runWith(Sink.seq)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsConnectorsTest.java#L844-L859" target="_blank" title="Go to snippet source"></a><code class="language-java">Flow&lt;JmsEnvelope&lt;String&gt;, JmsEnvelope&lt;String&gt;, JmsProducerStatus&gt; jmsProducer =
    JmsProducer.flexiFlow(
        JmsProducerSettings.create(producerConfig, connectionFactory).withQueue(&quot;test&quot;));

List&lt;String&gt; data = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;);
List&lt;JmsEnvelope&lt;String&gt;&gt; input = new ArrayList&lt;&gt;();
for (String s : data) {
  String passThrough = s;
  input.add(JmsPassThrough.create(passThrough));
}

CompletionStage&lt;List&lt;String&gt;&gt; result =
    Source.from(input)
        .via(jmsProducer)
        .map(JmsEnvelope::passThrough)
        .runWith(Sink.seq(), materializer);</code></pre></dd>
</dl>
<h2><a href="#producer-settings" name="producer-settings" class="anchor"><span class="anchor-link"></span></a>Producer Settings</h2>
<p>The Alpakka JMS producer is configured via default settings in the <a href="https://github.com/lightbend/config#using-hocon-the-json-superset">HOCON</a> config file section <code>alpakka.jms.producer</code> in your <code>application.conf</code>, and settings may be tweaked in the code using the <code>withXyz</code> methods.</p>
<p>The <code>JmsProducerSettings</code> factories allow for passing the actor system to read from the default <code>alpakka.jms.producer</code> section, or you may pass a <code>Config</code> instance which is resolved to a section of the same structure. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsSettingsSpec.scala#L41-L45" target="_blank" title="Go to snippet source"></a><code class="language-scala">val producerConfig: Config = system.settings.config.getConfig(JmsProducerSettings.configPath)
val settings = JmsProducerSettings(producerConfig, connectionFactory)
  .withTopic(&quot;target-topic&quot;)
  .withCredentials(Credentials(&quot;username&quot;, &quot;password&quot;))
  .withSessionCount(1)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsSettingsTest.java#L59-L67" target="_blank" title="Go to snippet source"></a><code class="language-java">Config producerConfig = config.getConfig(JmsProducerSettings.configPath());
JmsProducerSettings settings =
    JmsProducerSettings.create(producerConfig, new ActiveMQConnectionFactory(&quot;broker-url&quot;))
        .withTopic(&quot;target-topic&quot;)
        .withCredential(Credentials.create(&quot;username&quot;, &quot;password&quot;))
        .withConnectionRetrySettings(retrySettings)
        .withSendRetrySettings(sendRetrySettings)
        .withSessionCount(10)
        .withTimeToLive(Duration.ofHours(1));</code></pre></dd>
</dl>
<p>The producer can be configured with the following settings. On the second tab, the section from <code>reference.conf</code> shows the structure to use for configuring multiple set-ups.</p>
<dl>
  <dt>Table</dt>
  <dd>
  <table>
    <thead>
      <tr>
        <th>Setting </th>
        <th>Defaults </th>
        <th>Description </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>connectionFactory </td>
        <td>mandatory </td>
        <td>Factory to use for creating JMS connections </td>
      </tr>
      <tr>
        <td>destination </td>
        <td>mandatory </td>
        <td>Destination (queue or topic) to send JMS messages to </td>
      </tr>
      <tr>
        <td>credentials </td>
        <td>optional </td>
        <td>JMS broker credentials </td>
      </tr>
      <tr>
        <td>connectionRetrySettings </td>
        <td>default settings </td>
        <td>Retry characteristics if the connection failed to be established or taking a long time. Please see default values under <a href="#connection-retries">Connection Retries</a> </td>
      </tr>
      <tr>
        <td>sendRetrySettings </td>
        <td>default settings </td>
        <td>Retry characteristics if message sending failed. Please see default values under <a href="#send-retries">Send Retries</a> </td>
      </tr>
      <tr>
        <td>sessionCount </td>
        <td>defaults to <code>1</code> </td>
        <td>Number of parallel sessions to use for sending JMS messages. Increasing the number of parallel sessions increases throughput at the cost of message ordering. While the messages may arrive out of order on the JMS broker, the producer flow outputs messages in the order they are received </td>
      </tr>
      <tr>
        <td>timeToLive </td>
        <td>optional </td>
        <td>Time messages should be kept on the Jms broker. This setting can be overridden on individual messages. If not set, messages will never expire </td>
      </tr>
    </tbody>
  </table></dd>
  <dt>reference.conf
  </dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/main/resources/reference.conf#L73-L96" target="_blank" title="Go to snippet source"></a><code class="language-conf"># Jms Producer Settings
# sets default values
producer {
  # Configure connection retrying by providing settings for ConnectionRetrySettings.
  connection-retry = ${alpakka.jms.connection-retry}
  # Configure re-sending by providing settings for SendRetrySettings.
  send-retry = ${alpakka.jms.send-retry}
  # Credentials to connect to the JMS broker.
  # credentials {
  #   username = &quot;some text&quot;
  #   password = &quot;some text&quot;
  # }
  # &quot;off&quot; to not use any credentials.
  credentials = off
  # Number of parallel sessions to use for sending JMS messages.
  # Increasing the number of parallel sessions increases throughput at the cost of message ordering.
  # While the messages may arrive out of order on the JMS broker, the producer flow outputs messages
  # in the order they are received.
  session-count = 1
  # Time messages should be kept on the JMS broker.
  # This setting can be overridden on individual messages.
  # &quot;off&quot; to not let messages expire.
  time-to-live = off
}</code></pre></dd>
</dl>
<h2><a href="#connection-retries" name="connection-retries" class="anchor"><span class="anchor-link"></span></a>Connection Retries</h2>
<p>When a connection to a broker cannot be established and errors out, or is timing out being established or started, the connection can be retried. All JMS publishers, consumers, and browsers are configured with connection retry settings. On the second tab the section from <code>reference.conf</code> shows the structure to use for configuring multiple set-ups.</p>
<dl>
  <dt>Table</dt>
  <dd>
  <table>
    <thead>
      <tr>
        <th>Setting </th>
        <th>Description </th>
        <th>Default Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>connectTimeout </td>
        <td>Time allowed to establish and start a connection </td>
        <td>10 s</td>
      </tr>
      <tr>
        <td>initialRetry </td>
        <td>Wait time before retrying the first time </td>
        <td>100 ms</td>
      </tr>
      <tr>
        <td>backoffFactor </td>
        <td>Back-off factor for subsequent retries </td>
        <td>2.0</td>
      </tr>
      <tr>
        <td>maxBackoff </td>
        <td>Maximum back-off time allowed, after which all retries will happen after this delay </td>
        <td>1 minute</td>
      </tr>
      <tr>
        <td>maxRetries </td>
        <td>Maximum number of retries allowed (negative value is infinite) </td>
        <td>10</td>
      </tr>
    </tbody>
  </table></dd>
  <dt>reference.conf
  </dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/main/resources/reference.conf#L5-L20" target="_blank" title="Go to snippet source"></a><code class="language-conf"># Connection Retry Settings
# these set the defaults for Consumer, Producer, and Browse settings
connection-retry {
  # Time allowed to establish and start a connection.
  connect-timeout = 10 seconds
  # Wait time before retrying the connection the first time.
  initial-retry = 100 millis
  # Back-off factor for subsequent retries.
  backoff-factor = 2
  # Back-off factor for subsequent retries.
  max-backoff = 1 minute
  # Maximum number of retries allowed.
  # &quot;infinite&quot;, or positive integer
  max-retries = 10
}
</code></pre></dd>
</dl>
<p>The retry time is calculated by:</p>
<p><em>initialRetry * retryNumber<sup>backoffFactor</sup></em></p>
<p>With the default settings, we&rsquo;ll see retries after 100ms, 400ms, 900ms pauses, until the pauses reach 1 minute and will stay with 1 minute intervals for any subsequent retries.</p>
<p>Consumers, producers and browsers try to reconnect with the same retry characteristics if a connection fails mid-stream.</p>
<p>All JMS settings support setting the <code>connectionRetrySettings</code> field using <code>.withConnectionRetrySettings(retrySettings)</code> on the given settings. The followings show how to create <code>ConnectionRetrySettings</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsSettingsSpec.scala#L22-L28" target="_blank" title="Go to snippet source"></a><code class="language-scala">// reiterating defaults from reference.conf
val retrySettings = ConnectionRetrySettings(system)
  .withConnectTimeout(10.seconds)
  .withInitialRetry(100.millis)
  .withBackoffFactor(2.0d)
  .withMaxBackoff(1.minute)
  .withMaxRetries(10)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsSettingsTest.java#L19-L39" target="_blank" title="Go to snippet source"></a><code class="language-java">import com.typesafe.config.Config;
import scala.Option;

Config connectionRetryConfig = config.getConfig(&quot;alpakka.jms.connection-retry&quot;);
// reiterating the values from reference.conf
ConnectionRetrySettings retrySettings =
    ConnectionRetrySettings.create(connectionRetryConfig)
        .withConnectTimeout(Duration.ofSeconds(10))
        .withInitialRetry(Duration.ofMillis(100))
        .withBackoffFactor(2.0)
        .withMaxBackoff(Duration.ofMinutes(1))
        .withMaxRetries(10);</code></pre></dd>
</dl>
<h2><a href="#send-retries" name="send-retries" class="anchor"><span class="anchor-link"></span></a>Send Retries</h2>
<p>When a connection to a broker starts failing, sending JMS messages will also fail. Those failed messages can be retried at the cost of potentially duplicating the failed messages. Send retries can be configured as follows:</p>
<dl>
  <dt>Table</dt>
  <dd>
  <table>
    <thead>
      <tr>
        <th>Setting </th>
        <th>Description </th>
        <th>Default Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>initialRetry </td>
        <td>Wait time before retrying the first time </td>
        <td>20 ms</td>
      </tr>
      <tr>
        <td>backoffFactor </td>
        <td>Back-off factor for subsequent retries </td>
        <td>1.5</td>
      </tr>
      <tr>
        <td>maxBackoff </td>
        <td>Maximum back-off time allowed, after which all retries will happen after this delay </td>
        <td>500 ms</td>
      </tr>
      <tr>
        <td>maxRetries </td>
        <td>Maximum number of retries allowed (negative value is infinite) </td>
        <td>10</td>
      </tr>
    </tbody>
  </table></dd>
  <dt>reference.conf
  </dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/main/resources/reference.conf#L57-L69" target="_blank" title="Go to snippet source"></a><code class="language-conf"># Send Retry Settings
# these set the defaults for Producer settings
send-retry {
  # Wait time before retrying the first time.
  initial-retry = 20 millis
  # Back-off factor for subsequent retries.
  backoff-factor = 1.5
  # Maximum back-off time allowed, after which all retries will happen after this delay.
  max-backoff = 500 millis
  # Maximum number of retries allowed.
  # &quot;infinite&quot;, or positive integer
  max-retries = 10
}</code></pre></dd>
</dl>
<p>The retry time is calculated by:</p>
<p><em>initialRetry * retryNumber<sup>backoffFactor</sup></em></p>
<p>With the default settings, we&rsquo;ll see retries after 20ms, 57ms, 104ms pauses, until the pauses reach 500 ms and will stay with 500 ms intervals for any subsequent retries.</p>
<p>JMS producer settings support configuring retries by using <code>.withSendRetrySettings(retrySettings)</code>. The followings show how to create <code>SendRetrySettings</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/scala/docs/scaladsl/JmsSettingsSpec.scala#L32-L37" target="_blank" title="Go to snippet source"></a><code class="language-scala">// reiterating defaults from reference.conf
val sendRetrySettings = SendRetrySettings(system)
  .withInitialRetry(20.millis)
  .withBackoffFactor(1.5d)
  .withMaxBackoff(500.millis)
  .withMaxRetries(10)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/alpakka/tree/v1.0-M3/jms/src/test/java/docs/javadsl/JmsSettingsTest.java#L19-L53" target="_blank" title="Go to snippet source"></a><code class="language-java">import com.typesafe.config.Config;
import scala.Option;

Config sendRetryConfig = config.getConfig(&quot;alpakka.jms.send-retry&quot;);
// reiterating the values from reference.conf
SendRetrySettings sendRetrySettings =
    SendRetrySettings.create(sendRetryConfig)
        .withInitialRetry(Duration.ofMillis(20))
        .withBackoffFactor(1.5d)
        .withMaxBackoff(Duration.ofMillis(500))
        .withMaxRetries(10);</code></pre></dd>
</dl>
<p>If a send operation finally fails, the stage also fails unless a different supervision strategy is applied. The producer stage honours stream supervision.</p>
<h3><a href="#observing-connectivity-and-state-of-a-jms-producer" name="observing-connectivity-and-state-of-a-jms-producer" class="anchor"><span class="anchor-link"></span></a>Observing connectivity and state of a JMS producer</h3>
<p>All JMS producer&rsquo;s materialized values are of type <code>JmsProducerStatus</code>. This provides a <code>connectorState</code> method returning a <code>Source</code> of <code>JmsConnectorState</code> updates that publishes connection attempts, disconnections, completions and failures. The source is completed after the JMS producer completes or fails.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../jms/index.html"><i class="icon-prev"></i> <span class="link-prev">JMS</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../jms/consumer.html">Consumer <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/alpakka/tree/v1.0-M3/docs/src/main/paradox/jms/producer.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg"/>
<section class="copyright">
<div>Alpakka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<script type="text/javascript" src="../assets/js/warnOldVersion.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(jq){initOldVersionWarnings(jq, '1.0-M3', 'https://doc.akka.io/docs/alpakka/current/')});
//]]></script>


</body>
</html>
