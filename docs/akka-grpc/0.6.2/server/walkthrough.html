<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Walkthrough &bull; Akka gRPC</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka gRPC - Support for building streaming gRPC servers and clients on top of Akka Streams."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka-grpc/current/server/walkthrough.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_setDomainName', '']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka gRPC</a></h1>
</div>
<div class="nav-header-version">
Version 0.6.2
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
<select class="supergroup" name="Buildtool"><option class="group" value="group-sbt">sbt</option><option class="group" value="group-gradle">Gradle</option><option class="group" value="group-maven">Maven</option></select>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../overview.html" class="page">Overview</a></li>
  <li><a href="../whygrpc.html" class="page">Why gRPC?</a></li>
  <li><a href="../proto.html" class="page">Protobuf Service Descriptors</a></li>
  <li><a href="../server/index.html" class="page">Providing Services (Server)</a>
  <ul>
    <li><a href="../server/walkthrough.html#walkthrough" class="active page">Walkthrough</a>
    <ul>
      <li><a href="../server/walkthrough.html#setting-up" class="header">Setting up</a></li>
      <li><a href="../server/walkthrough.html#writing-a-service-definition" class="header">Writing a service definition</a></li>
      <li><a href="../server/walkthrough.html#generating-interfaces-and-stubs" class="header">Generating interfaces and stubs</a></li>
      <li><a href="../server/walkthrough.html#implementing-the-service" class="header">Implementing the service</a></li>
      <li><a href="../server/walkthrough.html#serving-the-service-with-akka-http" class="header">Serving the service with Akka HTTP</a></li>
      <li><a href="../server/walkthrough.html#serving-multiple-services" class="header">Serving multiple services</a></li>
      <li><a href="../server/walkthrough.html#running-the-server" class="header">Running the server</a></li>
      <li><a href="../server/walkthrough.html#stateful-services" class="header">Stateful services</a></li>
      <li><a href="../server/walkthrough.html#accessing-request-metadata" class="header">Accessing request metadata</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../client/index.html" class="page">Consuming Services (Client)</a></li>
  <li><a href="../buildtools/index.html" class="page">Build Tool Support</a></li>
  <li><a href="../apidesign.html" class="page">API Design</a></li>
  <li><a href="../deploy.html" class="page">Deployment</a></li>
  <li><a href="../troubleshooting.html" class="page">Troubleshooting</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka gRPC</a></h1>
</div>
<div class="nav-header-version">
Version 0.6.2
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-java">Java</option><option class="group" value="group-scala">Scala</option></select>
<select class="supergroup" name="Buildtool"><option class="group" value="group-sbt">sbt</option><option class="group" value="group-gradle">Gradle</option><option class="group" value="group-maven">Maven</option></select>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../overview.html" class="page">Overview</a></li>
  <li><a href="../whygrpc.html" class="page">Why gRPC?</a></li>
  <li><a href="../proto.html" class="page">Protobuf Service Descriptors</a></li>
  <li><a href="../server/index.html" class="page">Providing Services (Server)</a>
  <ul>
    <li><a href="../server/walkthrough.html#walkthrough" class="active page">Walkthrough</a>
    <ul>
      <li><a href="../server/walkthrough.html#setting-up" class="header">Setting up</a></li>
      <li><a href="../server/walkthrough.html#writing-a-service-definition" class="header">Writing a service definition</a></li>
      <li><a href="../server/walkthrough.html#generating-interfaces-and-stubs" class="header">Generating interfaces and stubs</a></li>
      <li><a href="../server/walkthrough.html#implementing-the-service" class="header">Implementing the service</a></li>
      <li><a href="../server/walkthrough.html#serving-the-service-with-akka-http" class="header">Serving the service with Akka HTTP</a></li>
      <li><a href="../server/walkthrough.html#serving-multiple-services" class="header">Serving multiple services</a></li>
      <li><a href="../server/walkthrough.html#running-the-server" class="header">Running the server</a></li>
      <li><a href="../server/walkthrough.html#stateful-services" class="header">Stateful services</a></li>
      <li><a href="../server/walkthrough.html#accessing-request-metadata" class="header">Accessing request metadata</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../client/index.html" class="page">Consuming Services (Client)</a></li>
  <li><a href="../buildtools/index.html" class="page">Build Tool Support</a></li>
  <li><a href="../apidesign.html" class="page">API Design</a></li>
  <li><a href="../deploy.html" class="page">Deployment</a></li>
  <li><a href="../troubleshooting.html" class="page">Troubleshooting</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#walkthrough" name="walkthrough" class="anchor"><span class="anchor-link"></span></a>Walkthrough</h1>
<h2><a href="#setting-up" name="setting-up" class="anchor"><span class="anchor-link"></span></a>Setting up</h2>
<p>To get started, you must obtain or write the <a href="../proto.html"><code>.proto</code></a> file(s) that describe the interface you want to implement and add those files to your project. Add <code>.proto</code> files to your project&rsquo;s <span class="group-sbt"><code>src/main/protobuf</code></span><span class="group-gradle"><code>src/main/proto</code></span><span class="group-maven"><code>src/main/proto</code></span> directory. (See the detailed chapters on <a href="../buildtools/sbt.html">sbt</a>, <a href="../buildtools/gradle.html">Gradle</a> and <a href="../buildtools/maven.html">Maven</a> for information on taking .proto definitions from dependencies)</p>
<p>Then add the Akka gRPC plugin to your build:</p>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// in project/plugins.sbt:
addSbtPlugin(&quot;com.lightbend.akka.grpc&quot; % &quot;sbt-akka-grpc&quot; % &quot;0.6.2&quot;)
addSbtPlugin(&quot;com.lightbend.sbt&quot; % &quot;sbt-javaagent&quot; % &quot;0.1.4&quot;) // ALPN agent
//
// in build.sbt:
enablePlugins(AkkaGrpcPlugin)
// ALPN agent
enablePlugins(JavaAgent)
javaAgents += &quot;org.mortbay.jetty.alpn&quot; % &quot;jetty-alpn-agent&quot; % &quot;2.0.9&quot; % &quot;runtime;test&quot;
</code></pre></dd>
  <dt>Gradle</dt>
  <dd>
  <pre class="prettyprint"><code class="language-gradle">buildscript {
  repositories {
    mavenLocal()
    gradlePluginPortal()
  }
  dependencies {
    // see https://plugins.gradle.org/plugin/com.lightbend.akka.grpc.gradle
    // for the currently latest version.
    classpath &#39;gradle.plugin.com.lightbend.akka.grpc:akka-grpc-gradle-plugin:0.6.2&#39;
  }
}
plugins {
  id &#39;java&#39;
  id &#39;application&#39;
}
apply plugin: &#39;com.lightbend.akka.grpc.gradle&#39;
repositories {
  mavenLocal()
  mavenCentral()
}
</code></pre></dd>
  <dt>Maven</dt>
  <dd>
  <pre class="prettyprint"><code class="language-xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;name&gt;Project name&lt;/name&gt;
  &lt;groupId&gt;com.example&lt;/groupId&gt;
  &lt;artifactId&gt;my-grpc-app&lt;/artifactId&gt;
  &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;akka.grpc.version&gt;0.6.2&lt;/akka.grpc.version&gt;
    &lt;grpc.version&gt;1.20.0&lt;/grpc.version&gt;
    &lt;project.encoding&gt;UTF-8&lt;/project.encoding&gt;
  &lt;/properties&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.lightbend.akka.grpc&lt;/groupId&gt;
      &lt;artifactId&gt;akka-grpc-runtime_2.12&lt;/artifactId&gt;
      &lt;version&gt;${akka.grpc.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;com.lightbend.akka.grpc&lt;/groupId&gt;
        &lt;artifactId&gt;akka-grpc-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;${akka.grpc.version}&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;generate&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre></dd>
</dl>
<p>For a complete overview of the configuration options see the chapter for your build tool, <a href="../buildtools/sbt.html">sbt</a>, <a href="../buildtools/gradle.html">Gradle</a> or <a href="../buildtools/maven.html">Maven</a>.</p>
<h2><a href="#writing-a-service-definition" name="writing-a-service-definition" class="anchor"><span class="anchor-link"></span></a>Writing a service definition</h2>
<p>Define the interfaces you want to implement in your project&rsquo;s <span class="group-sbt"><code>src/main/protobuf</code></span><span class="group-gradle"><code>src/main/proto</code></span><span class="group-maven"><code>src/main/proto</code></span> file(s).</p>
<p>For example, this is the definition of a Hello World service:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/src/main/protobuf/helloworld.proto" target="_blank" title="Go to snippet source"></a><code class="language-proto">syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;example.myapp.helloworld.grpc&quot;;
option java_outer_classname = &quot;HelloWorldProto&quot;;

package helloworld;

// The greeting service definition.
service GreeterService {
    // Sends a greeting
    rpc SayHello (HelloRequest) returns (HelloReply) {}

    rpc ItKeepsTalking (stream HelloRequest) returns (HelloReply) {}

    rpc ItKeepsReplying (HelloRequest) returns (stream HelloReply) {}

    rpc StreamHellos (stream HelloRequest) returns (stream HelloReply) {}
}

// The request message containing the user&#39;s name.
message HelloRequest {
    string name = 1;
}

// The response message containing the greetings
message HelloReply {
    string message = 1;
}</code></pre>
<h2><a href="#generating-interfaces-and-stubs" name="generating-interfaces-and-stubs" class="anchor"><span class="anchor-link"></span></a>Generating interfaces and stubs</h2>
<p>Start by generating code from the <code>.proto</code> definition with:</p>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre><code>sbt compile
</code></pre></dd>
  <dt>Gradle</dt>
  <dd>
  <pre><code>./gradlew build
</code></pre></dd>
  <dt>Maven</dt>
  <dd>
  <pre><code>mvn akka-grpc:generate
</code></pre></dd>
</dl>
<p>From the above definition, Akka gRPC generates interfaces that look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/target/scala-2.12/src_managed/main/example/myapp/helloworld/grpc/GreeterService.scala" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>// Generated by Akka gRPC. DO NOT EDIT.
package example.myapp.helloworld.grpc

trait GreeterService {
  
  def sayHello(in: example.myapp.helloworld.grpc.HelloRequest): scala.concurrent.Future[example.myapp.helloworld.grpc.HelloReply]
  
  def itKeepsTalking(in: akka.stream.scaladsl.Source[example.myapp.helloworld.grpc.HelloRequest, akka.NotUsed]): scala.concurrent.Future[example.myapp.helloworld.grpc.HelloReply]
  
  def itKeepsReplying(in: example.myapp.helloworld.grpc.HelloRequest): akka.stream.scaladsl.Source[example.myapp.helloworld.grpc.HelloReply, akka.NotUsed]
  
  def streamHellos(in: akka.stream.scaladsl.Source[example.myapp.helloworld.grpc.HelloRequest, akka.NotUsed]): akka.stream.scaladsl.Source[example.myapp.helloworld.grpc.HelloReply, akka.NotUsed]
  
}

object GreeterService {
  val name = &quot;helloworld.GreeterService&quot;

  object Serializers {
    import akka.grpc.scaladsl.ScalapbProtobufSerializer
    
    val HelloRequestSerializer = new ScalapbProtobufSerializer(example.myapp.helloworld.grpc.HelloRequest.messageCompanion)
    
    val HelloReplySerializer = new ScalapbProtobufSerializer(example.myapp.helloworld.grpc.HelloReply.messageCompanion)
    
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-java/target/scala-2.12/src_managed/main/example/myapp/helloworld/grpc/GreeterService.java" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>// Generated by Akka gRPC. DO NOT EDIT.
package example.myapp.helloworld.grpc;

import akka.grpc.ProtobufSerializer;
import akka.grpc.javadsl.GoogleProtobufSerializer;

public interface GreeterService {
  
  java.util.concurrent.CompletionStage&lt;example.myapp.helloworld.grpc.HelloReply&gt; sayHello(example.myapp.helloworld.grpc.HelloRequest in);
  
  java.util.concurrent.CompletionStage&lt;example.myapp.helloworld.grpc.HelloReply&gt; itKeepsTalking(akka.stream.javadsl.Source&lt;example.myapp.helloworld.grpc.HelloRequest, akka.NotUsed&gt; in);
  
  akka.stream.javadsl.Source&lt;example.myapp.helloworld.grpc.HelloReply, akka.NotUsed&gt; itKeepsReplying(example.myapp.helloworld.grpc.HelloRequest in);
  
  akka.stream.javadsl.Source&lt;example.myapp.helloworld.grpc.HelloReply, akka.NotUsed&gt; streamHellos(akka.stream.javadsl.Source&lt;example.myapp.helloworld.grpc.HelloRequest, akka.NotUsed&gt; in);
  

  static String name = &quot;helloworld.GreeterService&quot;;

  public static class Serializers {
    
      public static ProtobufSerializer&lt;example.myapp.helloworld.grpc.HelloRequest&gt; HelloRequestSerializer = new GoogleProtobufSerializer&lt;&gt;(example.myapp.helloworld.grpc.HelloRequest.class);
    
      public static ProtobufSerializer&lt;example.myapp.helloworld.grpc.HelloReply&gt; HelloReplySerializer = new GoogleProtobufSerializer&lt;&gt;(example.myapp.helloworld.grpc.HelloReply.class);
    
  }
}</code></pre></dd>
</dl>
<p>and model <span class="group-scala">case </span>classes for <code>HelloRequest</code> and <code>HelloResponse</code>.</p>
<p>The service interface is the same for the client and the server side. On the server side, the service implements the interface, on the client side the Akka gRPC infrastructure implements a stub that will connect to the remote service when called.</p>
<p>There are 4 different types of calls:</p>
<ul>
  <li><strong>unary call</strong> - single request that returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> with a single response,  see <code>sayHello</code> in above example</li>
  <li><strong>client streaming call</strong> - <code>Source</code> (stream) of requests from the client that returns a  <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> with a single response,  see <code>itKeepsTalking</code> in above example</li>
  <li><strong>server streaming call</strong> - single request that returns a <code>Source</code> (stream) of responses,  see <code>itKeepsReplying</code> in above example</li>
  <li><strong>client and server streaming call</strong> - <code>Source</code> (stream) of requests from the client that returns a  <code>Source</code> (stream) of responses,  see <code>streamHellos</code> in above example</li>
</ul>
<h2><a href="#implementing-the-service" name="implementing-the-service" class="anchor"><span class="anchor-link"></span></a>Implementing the service</h2>
<p>Let&rsquo;s implement these 4 calls in a new class:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/src/main/scala/example/myapp/helloworld/GreeterServiceImpl.scala#L6-L42" target="_blank" title="Go to snippet source"></a><code class="language-scala">package example.myapp.helloworld

import scala.concurrent.Future

import akka.NotUsed
import akka.stream.Materializer
import akka.stream.scaladsl.Sink
import akka.stream.scaladsl.Source

import example.myapp.helloworld.grpc._

class GreeterServiceImpl(implicit mat: Materializer) extends GreeterService {
  import mat.executionContext

  override def sayHello(in: HelloRequest): Future[HelloReply] = {
    println(s&quot;sayHello to ${in.name}&quot;)
    Future.successful(HelloReply(s&quot;Hello, ${in.name}&quot;))
  }

  override def itKeepsTalking(in: Source[HelloRequest, NotUsed]): Future[HelloReply] = {
    println(s&quot;sayHello to in stream...&quot;)
    in.runWith(Sink.seq)
      .map(elements =&gt; HelloReply(s&quot;Hello, ${elements.map(_.name).mkString(&quot;, &quot;)}&quot;))
  }

  override def itKeepsReplying(in: HelloRequest): Source[HelloReply, NotUsed] = {
    println(s&quot;sayHello to ${in.name} with stream of chars...&quot;)
    Source(s&quot;Hello, ${in.name}&quot;.toList)
      .map(character =&gt; HelloReply(character.toString))
  }

  override def streamHellos(in: Source[HelloRequest, NotUsed]): Source[HelloReply, NotUsed] = {
    println(s&quot;sayHello to stream...&quot;)
    in.map(request =&gt; HelloReply(s&quot;Hello, ${request.name}&quot;))
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-java/src/main/java/example/myapp/helloworld/GreeterServiceImpl.java#L6-L61" target="_blank" title="Go to snippet source"></a><code class="language-java">package example.myapp.helloworld;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.stream.Collectors;

import akka.NotUsed;
import akka.stream.Materializer;
import akka.stream.javadsl.Sink;
import akka.stream.javadsl.Source;

import example.myapp.helloworld.grpc.*;

public class GreeterServiceImpl implements GreeterService {
  private final Materializer mat;

  public GreeterServiceImpl(Materializer mat) {
   this.mat = mat;
  }

  @Override
  public CompletionStage&lt;HelloReply&gt; sayHello(HelloRequest in) {
    System.out.println(&quot;sayHello to &quot; + in.getName());
    HelloReply reply = HelloReply.newBuilder().setMessage(&quot;Hello, &quot; + in.getName()).build();
    return CompletableFuture.completedFuture(reply);
  }

  @Override
  public CompletionStage&lt;HelloReply&gt; itKeepsTalking(Source&lt;HelloRequest, NotUsed&gt; in) {
    System.out.println(&quot;sayHello to in stream...&quot;);
    return in.runWith(Sink.seq(), mat)
      .thenApply(elements -&gt; {
        String elementsStr = elements.stream().map(elem -&gt; elem.getName())
            .collect(Collectors.toList()).toString();
        return HelloReply.newBuilder().setMessage(&quot;Hello, &quot; + elementsStr).build();
      });
  }

  @Override
  public Source&lt;HelloReply, NotUsed&gt; itKeepsReplying(HelloRequest in) {
    System.out.println(&quot;sayHello to &quot; + in.getName() + &quot; with stream of chars&quot;);
    List&lt;Character&gt; characters = (&quot;Hello, &quot; + in.getName())
        .chars().mapToObj(c -&gt; (char) c).collect(Collectors.toList());
    return Source.from(characters)
      .map(character -&gt; {
        return HelloReply.newBuilder().setMessage(String.valueOf(character)).build();
      });
  }

  @Override
  public Source&lt;HelloReply, NotUsed&gt; streamHellos(Source&lt;HelloRequest, NotUsed&gt; in) {
    System.out.println(&quot;sayHello to stream...&quot;);
    return in.map(request -&gt; HelloReply.newBuilder().setMessage(&quot;Hello, &quot; + request.getName()).build());
  }
}</code></pre></dd>
</dl>
<h2><a href="#serving-the-service-with-akka-http" name="serving-the-service-with-akka-http" class="anchor"><span class="anchor-link"></span></a>Serving the service with Akka HTTP</h2>
<p>Note, how the implementation we just wrote is free from any gRPC related boilerplate. It only uses the generated model and interfaces from your domain and basic Akka streams classes. We now need to connect this implementation class to the web server to offer it to clients.</p>
<p>Akka gRPC servers are implemented with Akka HTTP. In addition to the above <code>GreeterService</code>, a <span class="group-scala"><code>GreeterServiceHandler</code></span><span class="group-java"><code>GreeterServiceHandlerFactory</code></span> was generated that wraps the implementation with the gRPC functionality to be plugged into an existing Akka HTTP server app.</p>
<p>You create the request handler by calling <span class="group-scala"><code>GreeterServiceHandler(yourImpl)</code></span><span class="group-java"><code>GreeterServiceHandlerFactory.create(yourImpl, ...)</code></span>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>The server will reuse the given instance of the implementation, which means that it is shared between (potentially concurrent) requests. Make sure that the implementation is thread-safe. In the sample above there is no mutable state, so it is safe. For more information about safely implementing servers with state see the advice about <a href="#stateful-services">stateful</a> below.</p></div>
<p>A complete main program that starts an Akka HTTP server with the <code>GreeterService</code> looks like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/src/main/scala/example/myapp/helloworld/GreeterServer.scala#L6-L58" target="_blank" title="Go to snippet source"></a><code class="language-scala">package example.myapp.helloworld

import akka.actor.ActorSystem
import akka.http.scaladsl.UseHttp2.Always
import akka.http.scaladsl.model.{ HttpRequest, HttpResponse }
import akka.http.scaladsl.{ Http, HttpConnectionContext }
import akka.stream.{ ActorMaterializer, Materializer }
import com.typesafe.config.ConfigFactory
import example.myapp.helloworld.grpc._

import scala.concurrent.{ ExecutionContext, Future }

object GreeterServer {

  def main(args: Array[String]): Unit = {
    // Important: enable HTTP/2 in ActorSystem&#39;s config
    // We do it here programmatically, but you can also set it in the application.conf
    val conf = ConfigFactory.parseString(&quot;akka.http.server.preview.enable-http2 = on&quot;)
      .withFallback(ConfigFactory.defaultApplication())
    val system = ActorSystem(&quot;HelloWorld&quot;, conf)
    new GreeterServer(system).run()
    // ActorSystem threads will keep the app alive until `system.terminate()` is called
  }
}

class GreeterServer(system: ActorSystem) {

  def run(): Future[Http.ServerBinding] = {
    // Akka boot up code
    implicit val sys: ActorSystem = system
    implicit val mat: Materializer = ActorMaterializer()
    implicit val ec: ExecutionContext = sys.dispatcher

    // Create service handlers
    val service: HttpRequest =&gt; Future[HttpResponse] =
      GreeterServiceHandler(new GreeterServiceImpl())

    // Bind service handler servers to localhost:8080/8081
    val binding = Http().bindAndHandleAsync(
      service,
      interface = &quot;127.0.0.1&quot;,
      port = 8080,
      connectionContext = HttpConnectionContext(http2 = Always))

    // report successful binding
    binding.foreach { binding =&gt;
      println(s&quot;gRPC server bound to: ${binding.localAddress}&quot;)
    }

    binding
  }
}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-java/src/main/java/example/myapp/helloworld/GreeterServer.java#L6-L46" target="_blank" title="Go to snippet source"></a><code class="language-java">package example.myapp.helloworld;

import akka.actor.ActorSystem;
import akka.http.javadsl.*;
import akka.stream.ActorMaterializer;
import akka.stream.Materializer;
import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;

import example.myapp.helloworld.grpc.*;

import java.util.concurrent.CompletionStage;

class GreeterServer {
  public static void main(String[] args) throws Exception {
    // important to enable HTTP/2 in ActorSystem&#39;s config
    Config conf = ConfigFactory.parseString(&quot;akka.http.server.preview.enable-http2 = on&quot;)
            .withFallback(ConfigFactory.defaultApplication());

    // Akka ActorSystem Boot
    ActorSystem sys = ActorSystem.create(&quot;HelloWorld&quot;, conf);

    run(sys).thenAccept(binding -&gt; {
      System.out.println(&quot;gRPC server bound to: &quot; + binding.localAddress());
    });

    // ActorSystem threads will keep the app alive until `system.terminate()` is called
  }

  public static CompletionStage&lt;ServerBinding&gt; run(ActorSystem sys) throws Exception {
    Materializer mat = ActorMaterializer.create(sys);

    // Instantiate implementation
    GreeterService impl = new GreeterServiceImpl(mat);

    return Http.get(sys).bindAndHandleAsync(
      GreeterServiceHandlerFactory.create(impl, mat, sys),
      ConnectHttp.toHost(&quot;127.0.0.1&quot;, 8080, UseHttp2.always()),
      mat);
  }
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>It&rsquo;s important to enable HTTP/2 in Akka HTTP in the configuration of the <code>ActorSystem</code> by setting</p>
<pre><code>akka.http.server.preview.enable-http2 = on
</code></pre>
<p>In the example this was done from the <code>main</code> method, but you could also do this from within your <code>application.conf</code>.</p></div>
<p>The above example does not use TLS and is configured to only serve HTTP/2. To allow HTTP and HTTP/2 and gRPC on the same port TLS must be used. That means that you need to configure your server with TLS information to provide certificates.</p>
<p>TODO Document how to configure TLS (<a href="https://github.com/akka/akka-grpc/issues/352">#352</a>)</p>
<h2><a href="#serving-multiple-services" name="serving-multiple-services" class="anchor"><span class="anchor-link"></span></a>Serving multiple services</h2>
<p>When a server handles several services the handlers must be combined with <span class="group-scala"><code>akka.grpc.scaladsl.ServiceHandler.concatOrNotFound</code></span><span class="group-java"><code>akka.grpc.javadsl.ServiceHandler.concatOrNotFound</code></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/src/main/scala/example/myapp/CombinedServer.scala#L38-L66" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.grpc.scaladsl.ServiceHandler

// explicit types not needed but included in example for clarity
val greeterService: PartialFunction[HttpRequest, Future[HttpResponse]] =
  example.myapp.helloworld.grpc.GreeterServiceHandler.partial(new GreeterServiceImpl())
val echoService: PartialFunction[HttpRequest, Future[HttpResponse]] =
  EchoServiceHandler.partial(new EchoServiceImpl)
val serviceHandlers: HttpRequest =&gt; Future[HttpResponse] =
  ServiceHandler.concatOrNotFound(greeterService, echoService)

Http().bindAndHandleAsync(
  serviceHandlers,
  interface = &quot;127.0.0.1&quot;,
  port = 8080,
  connectionContext = HttpConnectionContext(http2 = Always)
)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-java/src/main/java/example/myapp/CombinedServer.java#L34-L38" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.grpc.javadsl.ServiceHandler;
import akka.http.javadsl.model.HttpRequest;
import akka.http.javadsl.model.HttpResponse;
import akka.japi.Function;

Function&lt;HttpRequest, CompletionStage&lt;HttpResponse&gt;&gt; greeterService =
    GreeterServiceHandlerFactory.create(new GreeterServiceImpl(mat), mat, sys);
Function&lt;HttpRequest, CompletionStage&lt;HttpResponse&gt;&gt; echoService =
  EchoServiceHandlerFactory.create(new EchoServiceImpl(), mat, sys);
Function&lt;HttpRequest, CompletionStage&lt;HttpResponse&gt;&gt; serviceHandlers =
  ServiceHandler.concatOrNotFound(greeterService, echoService);

Http.get(sys).bindAndHandleAsync(
    serviceHandlers,
    ConnectHttp.toHost(&quot;127.0.0.1&quot;, 8080, UseHttp2.always()),
    mat)</code></pre></dd>
</dl>
<p><span class="group-scala">Note that <code>GreeterServiceHandler.partial</code> and <code>EchoServiceHandler.partial</code> are used instead of <code>apply</code> methods to create partial functions that are combined by <code>concatOrNotFound</code>.</span></p>
<h2><a href="#running-the-server" name="running-the-server" class="anchor"><span class="anchor-link"></span></a>Running the server</h2>
<p>To run the server with HTTP/2 enabled correctly, you will likely have to configure the Jetty ALPN agent as described <a href="https://doc.akka.io/docs/akka-http/10.1.8/server-side/http2.html#application-layer-protocol-negotiation-alpn-">in the Akka HTTP documentation</a>:</p>
<p>See the detailed chapters on <a href="../buildtools/sbt.html#starting-your-akka-grpc-server-from-sbt">sbt</a>, <a href="../buildtools/gradle.html#starting-your-akka-grpc-server-from-gradle">Gradle</a> and <a href="../buildtools/maven.html#starting-your-akka-grpc-server-from-maven">Maven</a> for details on adding the agent.</p>
<h2><a href="#stateful-services" name="stateful-services" class="anchor"><span class="anchor-link"></span></a>Stateful services</h2>
<p>More often than not, the whole point of the implementing a service is to keep state. Since the service implementation is shared between concurrent incoming requests any state must be thread safe.</p>
<p>There are two recommended ways to deal with this:</p>
<ul>
  <li>Put the mutable state inside an actor and interact with it through <code>ask</code> from unary methods or <code>Flow.ask</code> from streams.</li>
  <li>Keep the state in a thread-safe place. For example, a CRUD application that is backed by a database is thread-safe  when access to the backing database is (which until recently was THE way that applications dealt with request  concurrency).</li>
</ul>
<p>This is an example based on the Hello World above, but allowing users to change the greeting through a unary call:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/src/main/scala/example/myapp/statefulhelloworld/GreeterServiceImpl.scala#L18-L35" target="_blank" title="Go to snippet source"></a><code class="language-scala">class GreeterServiceImpl(system: ActorSystem) extends GreeterService {

  val greeterActor = system.actorOf(GreeterActor.props(&quot;Hello&quot;), &quot;greeter&quot;)

  def sayHello(in: HelloRequest): Future[HelloReply] = {
    // timeout and execution context for ask
    implicit val timeout: Timeout = 3.seconds
    import system.dispatcher

    (greeterActor ? GreeterActor.GetGreeting).mapTo[GreeterActor.Greeting]
      .map(message =&gt; HelloReply(s&quot;${message.greeting}, ${in.name}&quot;))
  }

  def changeGreeting(in: ChangeRequest): Future[ChangeResponse] = {
    greeterActor ! GreeterActor.ChangeGreeting(in.newGreeting)
    Future.successful(ChangeResponse())
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-java/src/main/java/example/myapp/statefulhelloworld/GreeterServiceImpl.java#L19-L44" target="_blank" title="Go to snippet source"></a><code class="language-java">public final class GreeterServiceImpl implements GreeterService {

  private final ActorSystem system;
  private final ActorRef greeterActor;
  private final Timeout timeout = Timeout.create(Duration.ofSeconds(5));

  public GreeterServiceImpl(ActorSystem system) {
    this.system = system;
    this.greeterActor = system.actorOf(GreeterActor.props(&quot;Hello&quot;), &quot;greeter&quot;);
  }

  public CompletionStage&lt;HelloReply&gt; sayHello(HelloRequest in) {
    return ask(greeterActor, GreeterActor.GET_GREETING, timeout)
        .thenApply(message -&gt;
          HelloReply.newBuilder()
            .setMessage(((GreeterActor.Greeting) message).greeting)
            .build()
        );
  }

  public CompletionStage&lt;ChangeResponse&gt; changeGreeting(ChangeRequest in) {
    greeterActor.tell(new GreeterActor.ChangeGreeting(in.getNewGreeting()), ActorRef.noSender());
    return CompletableFuture.completedFuture(ChangeResponse.newBuilder().build());
  }

}</code></pre></dd>
</dl>
<p>The <code>GreeterActor</code> is implemented like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/src/main/scala/example/myapp/statefulhelloworld/GreeterActor.scala#L11-L30" target="_blank" title="Go to snippet source"></a><code class="language-scala">object GreeterActor {
  case class ChangeGreeting(newGreeting: String)

  case object GetGreeting
  case class Greeting(greeting: String)

  def props(initialGreeting: String) = Props(new GreeterActor(initialGreeting))
}

class GreeterActor(initialGreeting: String) extends Actor {
  import GreeterActor._

  var greeting = Greeting(initialGreeting)

  def receive = {
    case GetGreeting =&gt; sender() ! greeting
    case ChangeGreeting(newGreeting) =&gt;
      greeting = Greeting(newGreeting)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-java/src/main/java/example/myapp/statefulhelloworld/GreeterActor.java#L11-L53" target="_blank" title="Go to snippet source"></a><code class="language-java">public class GreeterActor extends AbstractActor {

  public static class ChangeGreeting {
    public final String newGreeting;
    public ChangeGreeting(String newGreeting) {
      this.newGreeting = newGreeting;
    }
  }
  public static class GetGreeting {}
  public static GetGreeting GET_GREETING = new GetGreeting();

  public static class Greeting {
    public final String greeting;
    public Greeting(String greeting) {
      this.greeting = greeting;
    }
  }

  public static Props props(final String initialGreeting) {
    return Props.create(() -&gt; new GreeterActor(initialGreeting));
  }

  private Greeting greeting;

  public GreeterActor(String initialGreeting) {
    greeting = new Greeting(initialGreeting);
  }

  public AbstractActor.Receive createReceive() {
    return receiveBuilder()
        .match(GetGreeting.class, this::onGetGreeting)
        .match(ChangeGreeting.class, this::onChangeGreeting)
        .build();
  }

  private void onGetGreeting(GetGreeting get) {
    getSender().tell(greeting, getSelf());
  }

  private void onChangeGreeting(ChangeGreeting change) {
    greeting = new Greeting(change.newGreeting);
  }
}</code></pre></dd>
</dl>
<p>Now the actor mailbox is used to synchronize accesses to the mutable state.</p>
<h2><a href="#accessing-request-metadata" name="accessing-request-metadata" class="anchor"><span class="anchor-link"></span></a>Accessing request metadata</h2>
<p>By default the generated service interfaces don&rsquo;t provide access to the request metadata, only to the request body (via the rpc method input parameter). If your methods require access to the request metadata, you can tell akka-grpc to generate server &ldquo;power APIs&rdquo; that extend the base service interfaces to provide an additional request metadata parameter to each service method. See the detailed chapters on <a href="../buildtools/sbt.html">sbt</a>, <a href="../buildtools/gradle.html">Gradle</a> and <a href="../buildtools/maven.html">Maven</a> for how to set this build option. Note that this option doesn&rsquo;t effect the generated client stubs.</p>
<p>Here&rsquo;s an example implementation of these server power APIs:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-scala/src/main/scala/example/myapp/helloworld/PowerGreeterServiceImpl.scala#L6-L53" target="_blank" title="Go to snippet source"></a><code class="language-scala">package example.myapp.helloworld

import akka.NotUsed
import akka.grpc.scaladsl.Metadata
import akka.stream.Materializer
import akka.stream.scaladsl.{ Sink, Source }
import example.myapp.helloworld.grpc._

import scala.concurrent.Future

class PowerGreeterServiceImpl(materializer: Materializer) extends GreeterServicePowerApi {
  import materializer.executionContext
  private implicit val mat: Materializer = materializer

  override def sayHello(in: HelloRequest, metadata: Metadata): Future[HelloReply] = {
    val greetee = authTaggedName(in, metadata)
    println(s&quot;sayHello to $greetee&quot;)
    Future.successful(HelloReply(s&quot;Hello, $greetee&quot;))
  }

  override def itKeepsTalking(in: Source[HelloRequest, NotUsed], metadata: Metadata): Future[HelloReply] = {
    println(s&quot;sayHello to in stream...&quot;)
    in.runWith(Sink.seq)
      .map(elements =&gt; HelloReply(s&quot;Hello, ${elements.map(authTaggedName(_, metadata)).mkString(&quot;, &quot;)}&quot;))
  }

  override def itKeepsReplying(in: HelloRequest, metadata: Metadata): Source[HelloReply, NotUsed] = {
    val greetee = authTaggedName(in, metadata)
    println(s&quot;sayHello to $greetee with stream of chars...&quot;)
    Source(s&quot;Hello, $greetee&quot;.toList)
      .map(character =&gt; HelloReply(character.toString))
  }

  override def streamHellos(in: Source[HelloRequest, NotUsed], metadata: Metadata): Source[HelloReply, NotUsed] = {
    println(s&quot;sayHello to stream...&quot;)
    in.map(request =&gt; HelloReply(s&quot;Hello, ${authTaggedName(request, metadata)}&quot;))
  }

  // Bare-bones just for GRPC metadata demonstration purposes
  private def isAuthenticated(metadata: Metadata): Boolean = {
    metadata.getText(&quot;authorization&quot;).nonEmpty
  }

  private def authTaggedName(in: HelloRequest, metadata: Metadata): String = {
    val authenticated = isAuthenticated(metadata)
    s&quot;${in.name} (${if (!authenticated) &quot;not &quot; else &quot;&quot;}authenticated)&quot;
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka-grpc/tree/v0.6.2/plugin-tester-java/src/main/java/example/myapp/helloworld/GreeterServicePowerApiImpl.java#L6-L76" target="_blank" title="Go to snippet source"></a><code class="language-java">package example.myapp.helloworld;

import akka.NotUsed;
import akka.grpc.javadsl.Metadata;
import akka.stream.Materializer;
import akka.stream.javadsl.Sink;
import akka.stream.javadsl.Source;
import example.myapp.helloworld.grpc.GreeterService;
import example.myapp.helloworld.grpc.GreeterServicePowerApi;
import example.myapp.helloworld.grpc.HelloReply;
import example.myapp.helloworld.grpc.HelloRequest;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.stream.Collectors;

public class GreeterServicePowerApiImpl implements GreeterServicePowerApi {
  private final Materializer mat;

  public GreeterServicePowerApiImpl(Materializer mat) {
   this.mat = mat;
  }

  @Override
  public CompletionStage&lt;HelloReply&gt; sayHello(HelloRequest in, Metadata metadata) {
    String greetee = authTaggedName(in, metadata);
    System.out.println(&quot;sayHello to &quot; + greetee);
    HelloReply reply = HelloReply.newBuilder().setMessage(&quot;Hello, &quot; + greetee).build();
    return CompletableFuture.completedFuture(reply);
  }

  @Override
  public CompletionStage&lt;HelloReply&gt; itKeepsTalking(Source&lt;HelloRequest, NotUsed&gt; in, Metadata metadata) {
    System.out.println(&quot;sayHello to in stream...&quot;);
    return in.runWith(Sink.seq(), mat)
      .thenApply(elements -&gt; {
        String elementsStr = elements.stream().map(elem -&gt; authTaggedName(elem, metadata))
            .collect(Collectors.toList()).toString();
        return HelloReply.newBuilder().setMessage(&quot;Hello, &quot; + elementsStr).build();
      });
  }

  @Override
  public Source&lt;HelloReply, NotUsed&gt; itKeepsReplying(HelloRequest in, Metadata metadata) {
    String greetee = authTaggedName(in, metadata);
    System.out.println(&quot;sayHello to &quot; + greetee + &quot; with stream of chars&quot;);
    List&lt;Character&gt; characters = (&quot;Hello, &quot; + greetee)
        .chars().mapToObj(c -&gt; (char) c).collect(Collectors.toList());
    return Source.from(characters)
      .map(character -&gt; {
        return HelloReply.newBuilder().setMessage(String.valueOf(character)).build();
      });
  }

  @Override
  public Source&lt;HelloReply, NotUsed&gt; streamHellos(Source&lt;HelloRequest, NotUsed&gt; in, Metadata metadata) {
    System.out.println(&quot;sayHello to stream...&quot;);
    return in.map(request -&gt; HelloReply.newBuilder().setMessage(&quot;Hello, &quot; + authTaggedName(request, metadata)).build());
  }

  // Bare-bones just for GRPC metadata demonstration purposes
  private boolean isAuthenticated(Metadata metadata) {
    return metadata.getText(&quot;authorization&quot;).isPresent();
  }

  private String authTaggedName(HelloRequest in, Metadata metadata) {
    boolean authenticated = isAuthenticated(metadata);
    return String.format(&quot;%s (%sauthenticated)&quot;, in.getName(), isAuthenticated(metadata) ? &quot;&quot; : &quot;not &quot;);
  }
}</code></pre></dd>
</dl>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../server/index.html"><i class="icon-prev"></i> <span class="link-prev">Providing Services (Server)</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../client/index.html">Consuming Services (Client) <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka-grpc/tree/v0.6.2/docs/src/main/paradox/server/walkthrough.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg"/>
<section class="copyright">
<div>Akka gRPC is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<script type="text/javascript" src="../assets/js/warnOldVersion.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(jq){initOldVersionWarnings(jq, '0.6.2', 'https://doc.akka.io/docs/akka-grpc/current/')});
//]]></script>


</body>
</html>
