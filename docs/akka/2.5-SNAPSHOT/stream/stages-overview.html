<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Overview of built-in stages and their semantics &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/stream/stages-overview.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/stream-integrations.html" class="page">Integration</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stages-overview.html#overview-of-built-in-stages-and-their-semantics" class="active page">Overview of built-in stages and their semantics</a>
    <ul>
      <li><a href="../stream/stages-overview.html#source-stages" class="header">Source stages</a></li>
      <li><a href="../stream/stages-overview.html#sink-stages" class="header">Sink stages</a></li>
      <li><a href="../stream/stages-overview.html#additional-sink-and-source-converters" class="header">Additional Sink and Source converters</a></li>
      <li><a href="../stream/stages-overview.html#file-io-sinks-and-sources" class="header">File IO Sinks and Sources</a></li>
      <li><a href="../stream/stages-overview.html#flow-stages" class="header">Flow stages</a></li>
      <li><a href="../stream/stages-overview.html#simple-processing-stages" class="header">Simple processing stages</a></li>
      <li><a href="../stream/stages-overview.html#flow-stages-composed-of-sinks-and-sources" class="header">Flow stages composed of Sinks and Sources</a></li>
      <li><a href="../stream/stages-overview.html#asynchronous-processing-stages" class="header">Asynchronous processing stages</a></li>
      <li><a href="../stream/stages-overview.html#timer-driven-stages" class="header">Timer driven stages</a></li>
      <li><a href="../stream/stages-overview.html#backpressure-aware-stages" class="header">Backpressure aware stages</a></li>
      <li><a href="../stream/stages-overview.html#nesting-and-flattening-stages" class="header">Nesting and flattening stages</a></li>
      <li><a href="../stream/stages-overview.html#time-aware-stages" class="header">Time aware stages</a></li>
      <li><a href="../stream/stages-overview.html#fan-in-stages" class="header">Fan-in stages</a></li>
      <li><a href="../stream/stages-overview.html#fan-out-stages" class="header">Fan-out stages</a></li>
      <li><a href="../stream/stages-overview.html#watching-status-stages" class="header">Watching status stages</a></li>
    </ul></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
  </ul></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/stream-integrations.html" class="page">Integration</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stages-overview.html#overview-of-built-in-stages-and-their-semantics" class="active page">Overview of built-in stages and their semantics</a>
    <ul>
      <li><a href="../stream/stages-overview.html#source-stages" class="header">Source stages</a></li>
      <li><a href="../stream/stages-overview.html#sink-stages" class="header">Sink stages</a></li>
      <li><a href="../stream/stages-overview.html#additional-sink-and-source-converters" class="header">Additional Sink and Source converters</a></li>
      <li><a href="../stream/stages-overview.html#file-io-sinks-and-sources" class="header">File IO Sinks and Sources</a></li>
      <li><a href="../stream/stages-overview.html#flow-stages" class="header">Flow stages</a></li>
      <li><a href="../stream/stages-overview.html#simple-processing-stages" class="header">Simple processing stages</a></li>
      <li><a href="../stream/stages-overview.html#flow-stages-composed-of-sinks-and-sources" class="header">Flow stages composed of Sinks and Sources</a></li>
      <li><a href="../stream/stages-overview.html#asynchronous-processing-stages" class="header">Asynchronous processing stages</a></li>
      <li><a href="../stream/stages-overview.html#timer-driven-stages" class="header">Timer driven stages</a></li>
      <li><a href="../stream/stages-overview.html#backpressure-aware-stages" class="header">Backpressure aware stages</a></li>
      <li><a href="../stream/stages-overview.html#nesting-and-flattening-stages" class="header">Nesting and flattening stages</a></li>
      <li><a href="../stream/stages-overview.html#time-aware-stages" class="header">Time aware stages</a></li>
      <li><a href="../stream/stages-overview.html#fan-in-stages" class="header">Fan-in stages</a></li>
      <li><a href="../stream/stages-overview.html#fan-out-stages" class="header">Fan-out stages</a></li>
      <li><a href="../stream/stages-overview.html#watching-status-stages" class="header">Watching status stages</a></li>
    </ul></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
  </ul></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#overview-of-built-in-stages-and-their-semantics" name="overview-of-built-in-stages-and-their-semantics" class="anchor"><span class="anchor-link"></span></a>Overview of built-in stages and their semantics</h1>
<br/>
<h2><a href="#source-stages" name="source-stages" class="anchor"><span class="anchor-link"></span></a>Source stages</h2>
<p>These built-in sources are available from <span class="group-scala"><code>akka.stream.scaladsl.Source</code></span> <span class="group-java"><code>akka.stream.javadsl.Source</code></span>:</p>
<hr/>
<h3><a href="#fromiterator" name="fromiterator" class="anchor"><span class="anchor-link"></span></a>fromIterator</h3>
<p>Stream the values from an <code>Iterator</code>, requesting the next value when there is demand. The iterator will be created anew for each materialization, which is the reason the <span class="group-scala"><code>method</code></span> <span class="group-java"><code>factory</code></span> takes a <span class="group-scala"><code>function</code></span> <span class="group-java"><code>Creator</code></span> rather than an <code>Iterator</code> directly.</p>
<p>If the iterator perform blocking operations, make sure to run it on a separate dispatcher.</p>
<p><strong>emits</strong> the next value returned from the iterator</p>
<p><strong>completes</strong> when the iterator reaches its end</p>
<hr/><div class="group-scala">
<h3><a href="#apply" name="apply" class="anchor"><span class="anchor-link"></span></a>apply</h3>
<p>Stream the values of an <code>immutable.Seq</code>.</p>
<p><strong>emits</strong> the next value of the seq</p>
<p><strong>completes</strong> when the last element of the seq has been emitted</p></div><div class="group-java">
<h3><a href="#from" name="from" class="anchor"><span class="anchor-link"></span></a>from</h3>
<p>Stream the values of an <code>Iterable</code>. Make sure the <code>Iterable</code> is immutable or at least not modified after being used as a source.</p></div>
<hr/>
<h3><a href="#single" name="single" class="anchor"><span class="anchor-link"></span></a>single</h3>
<p>Stream a single object</p>
<p><strong>emits</strong> the value once</p>
<p><strong>completes</strong> when the single value has been emitted</p>
<hr/>
<h3><a href="#repeat" name="repeat" class="anchor"><span class="anchor-link"></span></a>repeat</h3>
<p>Stream a single object repeatedly</p>
<p><strong>emits</strong> the same value repeatedly when there is demand</p>
<p><strong>completes</strong> never</p>
<hr/>
<h3><a href="#cycle" name="cycle" class="anchor"><span class="anchor-link"></span></a>cycle</h3>
<p>Stream iterator in cycled manner. Internally new iterator is being created to cycle the one provided via argument meaning when original iterator runs out of elements process will start all over again from the beginning of the iterator provided by the evaluation of provided parameter. If method argument provides empty iterator stream will be terminated with exception.</p>
<p><strong>emits</strong> the next value returned from cycled iterator</p>
<p><strong>completes</strong> never</p>
<hr/>
<h3><a href="#tick" name="tick" class="anchor"><span class="anchor-link"></span></a>tick</h3>
<p>A periodical repetition of an arbitrary object. Delay of first tick is specified separately from interval of the following ticks.</p>
<p><strong>emits</strong> periodically, if there is downstream backpressure ticks are skipped</p>
<p><strong>completes</strong> never</p>
<hr/>
<h3><a href="#fromfuture" name="fromfuture" class="anchor"><span class="anchor-link"></span></a>fromFuture</h3>
<p>Send the single value of the <code>Future</code> when it completes and there is demand. If the future fails the stream is failed with that exception.</p>
<p><strong>emits</strong> the future completes</p>
<p><strong>completes</strong> after the future has completed</p>
<hr/>
<h3><a href="#fromcompletionstage" name="fromcompletionstage" class="anchor"><span class="anchor-link"></span></a>fromCompletionStage</h3>
<p>Send the single value of the <code>CompletionStage</code> when it completes and there is demand. If the future fails the stream is failed with that exception.</p>
<p><strong>emits</strong> the future completes</p>
<p><strong>completes</strong> after the future has completed</p>
<hr/>
<h3><a href="#fromfuturesource" name="fromfuturesource" class="anchor"><span class="anchor-link"></span></a>fromFutureSource</h3>
<p>Streams the elements of the given future source once it successfully completes. If the future fails the stream is failed.</p>
<p><strong>emits</strong> the next value from the <em>future</em> source, once it has completed</p>
<p><strong>completes</strong> after the <em>future</em> source completes</p>
<hr/>
<h3><a href="#fromsourcecompletionstage" name="fromsourcecompletionstage" class="anchor"><span class="anchor-link"></span></a>fromSourceCompletionStage</h3>
<p>Streams the elements of an asynchronous source once its given <em>completion</em> stage completes. If the <em>completion</em> fails the stream is failed with that exception.</p>
<p><strong>emits</strong> the next value from the asynchronous source, once its <em>completion stage</em> has completed</p>
<p><strong>completes</strong> after the asynchronous source completes</p>
<hr/>
<h3><a href="#unfold" name="unfold" class="anchor"><span class="anchor-link"></span></a>unfold</h3>
<p>Stream the result of a function as long as it returns a <span class="group-scala"><code>Some</code></span> <span class="group-java"><code>Optional</code></span>, the value inside the option consists of a <span class="group-scala">tuple</span> <span class="group-java">pair</span> where the first value is a state passed back into the next call to the function allowing to pass a state. The first invocation of the provided fold function will receive the <code>zero</code> state.</p>
<p>Can be used to implement many stateful sources without having to touch the more low level <code>GraphStage</code> API.</p>
<p><strong>emits</strong> when there is demand and the unfold function over the previous state returns non empty value</p>
<p><strong>completes</strong> when the unfold function returns an empty value</p>
<hr/>
<h3><a href="#unfoldasync" name="unfoldasync" class="anchor"><span class="anchor-link"></span></a>unfoldAsync</h3>
<p>Just like <code>unfold</code> but the fold function returns a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> which will cause the source to complete or emit when it completes.</p>
<p>Can be used to implement many stateful sources without having to touch the more low level <code>GraphStage</code> API.</p>
<p><strong>emits</strong> when there is demand and unfold state returned future completes with some value</p>
<p><strong>completes</strong> when the <span class="group-scala">future</span> <span class="group-java">CompletionStage</span> returned by the unfold function completes with an empty value</p>
<hr/>
<h3><a href="#empty" name="empty" class="anchor"><span class="anchor-link"></span></a>empty</h3>
<p>Complete right away without ever emitting any elements. Useful when you have to provide a source to an API but there are no elements to emit.</p>
<p><strong>emits</strong> never</p>
<p><strong>completes</strong> directly</p>
<hr/>
<h3><a href="#maybe" name="maybe" class="anchor"><span class="anchor-link"></span></a>maybe</h3>
<p>Materialize a <span class="group-scala"><code>Promise[Option[T]]</code></span> <span class="group-java"><code>CompletionStage</code></span> that if completed with a <span class="group-scala"><code>Some[T]</code></span> <span class="group-java"><code>Optional</code></span> will emit that <em>T</em> and then complete the stream, or if completed with <span class="group-scala"><code>None</code></span> <span class="group-java"><code>empty Optional</code></span> complete the stream right away.</p>
<p><strong>emits</strong> when the returned promise is completed with some value</p>
<p><strong>completes</strong> after emitting some value, or directly if the promise is completed with no value</p>
<hr/>
<h3><a href="#failed" name="failed" class="anchor"><span class="anchor-link"></span></a>failed</h3>
<p>Fail directly with a user specified exception.</p>
<p><strong>emits</strong> never</p>
<p><strong>completes</strong> fails the stream directly with the given exception</p>
<hr/>
<h3><a href="#lazily" name="lazily" class="anchor"><span class="anchor-link"></span></a>lazily</h3>
<p>Defers creation and materialization of a <code>Source</code> until there is demand.</p>
<p><strong>emits</strong> depends on the wrapped <code>Source</code></p>
<p><strong>completes</strong> depends on the wrapped <code>Source</code></p>
<hr/>
<h3><a href="#actorpublisher" name="actorpublisher" class="anchor"><span class="anchor-link"></span></a>actorPublisher</h3>
<p>Wrap an actor extending <code>ActorPublisher</code> as a source.</p>
<p><strong>emits</strong> depends on the actor implementation</p>
<p><strong>completes</strong> when the actor stops</p>
<hr/>
<h3><a href="#actorref" name="actorref" class="anchor"><span class="anchor-link"></span></a>actorRef</h3>
<p>Materialize an <code>ActorRef</code>, sending messages to it will emit them on the stream. The actor contain a buffer but since communication is one way, there is no back pressure. Handling overflow is done by either dropping elements or failing the stream, the strategy is chosen by the user.</p>
<p><strong>emits</strong> when there is demand and there are messages in the buffer or a message is sent to the actorref</p>
<p><strong>completes</strong> when the <code>ActorRef</code> is sent <code>akka.actor.Status.Success</code> or <code>PoisonPill</code></p>
<hr/>
<h3><a href="#range" name="range" class="anchor"><span class="anchor-link"></span></a>range</h3>
<p>Emit each integer in a range, with an option to take bigger steps than 1.</p>
<p><strong>emits</strong> when there is demand, the next value</p>
<p><strong>completes</strong> when the end of the range has been reached</p>
<hr/>
<h3><a href="#combine" name="combine" class="anchor"><span class="anchor-link"></span></a>combine</h3>
<p>Combine several sources, using a given strategy such as merge or concat, into one source.</p>
<p><strong>emits</strong> when there is demand, but depending on the strategy</p>
<p><strong>completes</strong> when all sources has completed</p>
<hr/>
<h3><a href="#unfoldresource" name="unfoldresource" class="anchor"><span class="anchor-link"></span></a>unfoldResource</h3>
<p>Wrap any resource that can be opened, queried for next element (in a blocking way) and closed using three distinct functions into a source.</p>
<p><strong>emits</strong> when there is demand and read <span class="group-scala">function</span> <span class="group-java">method</span> returns value</p>
<p><strong>completes</strong> when read function returns <code>None</code></p>
<hr/>
<h3><a href="#unfoldresourceasync" name="unfoldresourceasync" class="anchor"><span class="anchor-link"></span></a>unfoldResourceAsync</h3>
<p>Wrap any resource that can be opened, queried for next element (in a blocking way) and closed using three distinct functions into a source. Functions return <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> to achieve asynchronous processing</p>
<p><strong>emits</strong> when there is demand and <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> from read function returns value</p>
<p><strong>completes</strong> when <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> from read function returns <code>None</code></p>
<hr/>
<h3><a href="#queue" name="queue" class="anchor"><span class="anchor-link"></span></a>queue</h3>
<p>Materialize a <code>SourceQueue</code> onto which elements can be pushed for emitting from the source. The queue contains a buffer, if elements are pushed onto the queue faster than the source is consumed the overflow will be handled with a strategy specified by the user. Functionality for tracking when an element has been emitted is available through <code>SourceQueue.offer</code>.</p>
<p><strong>emits</strong> when there is demand and the queue contains elements</p>
<p><strong>completes</strong> when downstream completes</p>
<hr/>
<h3><a href="#assubscriber" name="assubscriber" class="anchor"><span class="anchor-link"></span></a>asSubscriber</h3>
<p>Integration with Reactive Streams, materializes into a <code>org.reactivestreams.Subscriber</code>.</p>
<hr/>
<h3><a href="#frompublisher" name="frompublisher" class="anchor"><span class="anchor-link"></span></a>fromPublisher</h3>
<p>Integration with Reactive Streams, subscribes to a <code>org.reactivestreams.Publisher</code>.</p>
<hr/>
<h3><a href="#zipn" name="zipn" class="anchor"><span class="anchor-link"></span></a>zipN</h3>
<p>Combine the elements of multiple streams into a stream of sequences.</p>
<p><strong>emits</strong> when all of the inputs has an element available</p>
<p><strong>completes</strong> when any upstream completes</p>
<hr/>
<h3><a href="#zipwithn" name="zipwithn" class="anchor"><span class="anchor-link"></span></a>zipWithN</h3>
<p>Combine the elements of multiple streams into a stream of sequences using a combiner function.</p>
<p><strong>emits</strong> when all of the inputs has an element available</p>
<p><strong>completes</strong> when any upstream completes</p>
<hr/>
<br/>
<h2><a href="#sink-stages" name="sink-stages" class="anchor"><span class="anchor-link"></span></a>Sink stages</h2>
<p>These built-in sinks are available from <span class="group-scala"><code>akka.stream.scaladsl.Sink</code></span> <span class="group-java"><code>akka.stream.javadsl.Sink</code></span>:</p>
<hr/>
<h3><a href="#head" name="head" class="anchor"><span class="anchor-link"></span></a>head</h3>
<p>Materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> which completes with the first value arriving, after this the stream is canceled. If no element is emitted, the <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> is failed.</p>
<p><strong>cancels</strong> after receiving one element</p>
<p><strong>backpressures</strong> never</p>
<hr/>
<h3><a href="#headoption" name="headoption" class="anchor"><span class="anchor-link"></span></a>headOption</h3>
<p>Materializes into a <span class="group-scala"><code>Future[Option[T]]</code></span> <span class="group-java"><code>CompletionStage&lt;Optional&lt;T&gt;&gt;</code></span> which completes with the first value arriving wrapped in <span class="group-scala"><code>Some</code></span> <span class="group-java"><code>Optional</code></span>, or <span class="group-scala">a <code>None</code></span> <span class="group-java">an empty Optional</span> if the stream completes without any elements emitted.</p>
<p><strong>cancels</strong> after receiving one element</p>
<p><strong>backpressures</strong> never</p>
<hr/>
<h3><a href="#last" name="last" class="anchor"><span class="anchor-link"></span></a>last</h3>
<p>Materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> which will complete with the last value emitted when the stream completes. If the stream completes with no elements the <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> is failed.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> never</p>
<hr/>
<h3><a href="#lastoption" name="lastoption" class="anchor"><span class="anchor-link"></span></a>lastOption</h3>
<p>Materialize a <span class="group-scala"><code>Future[Option[T]]</code></span> <span class="group-java"><code>CompletionStage&lt;Optional&lt;T&gt;&gt;</code></span> which completes with the last value emitted wrapped in an <span class="group-scala"><code>Some</code></span> <span class="group-java"><code>Optional</code></span> when the stream completes. if the stream completes with no elements the <code>CompletionStage</code> is completed with <span class="group-scala"><code>None</code></span> <span class="group-java">an empty <code>Optional</code></span>.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> never</p>
<hr/>
<h3><a href="#ignore" name="ignore" class="anchor"><span class="anchor-link"></span></a>ignore</h3>
<p>Consume all elements but discards them. Useful when a stream has to be consumed but there is no use to actually do anything with the elements.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> never</p>
<hr/>
<h3><a href="#cancelled" name="cancelled" class="anchor"><span class="anchor-link"></span></a>cancelled</h3>
<p>Immediately cancel the stream</p>
<p><strong>cancels</strong> immediately</p>
<hr/>
<h3><a href="#seq" name="seq" class="anchor"><span class="anchor-link"></span></a>seq</h3>
<p>Collect values emitted from the stream into a collection, the collection is available through a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> or which completes when the stream completes. Note that the collection is bounded to <span class="group-scala"><code>Int.MaxValue</code></span> <span class="group-java"><code>Integer.MAX_VALUE</code></span>, if more element are emitted the sink will cancel the stream</p>
<p><strong>cancels</strong> If too many values are collected</p>
<hr/>
<h3><a href="#foreach" name="foreach" class="anchor"><span class="anchor-link"></span></a>foreach</h3>
<p>Invoke a given procedure for each element received. Note that it is not safe to mutate shared state from the procedure.</p>
<p>The sink materializes into a <span class="group-scala"><code>Future[Option[Done]]</code></span> <span class="group-java"><code>CompletionStage&lt;Optional&lt;Done&gt;</code></span> which completes when the stream completes, or fails if the stream fails.</p>
<p>Note that it is not safe to mutate state from the procedure.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> when the previous procedure invocation has not yet completed</p>
<hr/>
<h3><a href="#foreachparallel" name="foreachparallel" class="anchor"><span class="anchor-link"></span></a>foreachParallel</h3>
<p>Like <code>foreach</code> but allows up to <code>parallellism</code> procedure calls to happen in parallel.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> when the previous parallel procedure invocations has not yet completed</p>
<hr/>
<h3><a href="#oncomplete" name="oncomplete" class="anchor"><span class="anchor-link"></span></a>onComplete</h3>
<p>Invoke a callback when the stream has completed or failed.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> never</p>
<hr/>
<h3><a href="#lazyinit" name="lazyinit" class="anchor"><span class="anchor-link"></span></a>lazyInit</h3>
<p>Invoke sinkFactory function to create a real sink upon receiving the first element. Internal <code>Sink</code> will not be created if there are no elements, because of completion or error. <em>fallback</em> will be invoked if there was no elements and completed is received from upstream.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> when initialized and when created sink backpressures</p>
<hr/>
<h3><a href="#queue" name="queue" class="anchor"><span class="anchor-link"></span></a>queue</h3>
<p>Materialize a <code>SinkQueue</code> that can be pulled to trigger demand through the sink. The queue contains a buffer in case stream emitting elements faster than queue pulling them.</p>
<p><strong>cancels</strong> when <code>SinkQueue.cancel</code> is called</p>
<p><strong>backpressures</strong> when buffer has some space</p>
<hr/>
<h3><a href="#fold" name="fold" class="anchor"><span class="anchor-link"></span></a>fold</h3>
<p>Fold over emitted element with a function, where each invocation will get the new element and the result from the previous fold invocation. The first invocation will be provided the <code>zero</code> value.</p>
<p>Materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> that will complete with the last state when the stream has completed.</p>
<p>This stage allows combining values into a result without a global mutable state by instead passing the state along between invocations.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> when the previous fold function invocation has not yet completed</p>
<hr/>
<h3><a href="#reduce" name="reduce" class="anchor"><span class="anchor-link"></span></a>reduce</h3>
<p>Apply a reduction function on the incoming elements and pass the result to the next invocation. The first invocation receives the two first elements of the flow.</p>
<p>Materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> that will be completed by the last result of the reduction function.</p>
<p><strong>cancels</strong> never</p>
<p><strong>backpressures</strong> when the previous reduction function invocation has not yet completed</p>
<hr/>
<h3><a href="#combine" name="combine" class="anchor"><span class="anchor-link"></span></a>combine</h3>
<p>Combine several sinks into one using a user specified strategy</p>
<p><strong>cancels</strong> depends on the strategy</p>
<p><strong>backpressures</strong> depends on the strategy</p>
<hr/>
<h3><a href="#actorref" name="actorref" class="anchor"><span class="anchor-link"></span></a>actorRef</h3>
<p>Send the elements from the stream to an <code>ActorRef</code>. No backpressure so care must be taken to not overflow the inbox.</p>
<p><strong>cancels</strong> when the actor terminates</p>
<p><strong>backpressures</strong> never</p>
<hr/>
<h3><a href="#actorrefwithack" name="actorrefwithack" class="anchor"><span class="anchor-link"></span></a>actorRefWithAck</h3>
<p>Send the elements from the stream to an <code>ActorRef</code> which must then acknowledge reception after completing a message, to provide back pressure onto the sink.</p>
<p><strong>cancels</strong> when the actor terminates</p>
<p><strong>backpressures</strong> when the actor acknowledgement has not arrived</p>
<hr/>
<h3><a href="#actorsubscriber" name="actorsubscriber" class="anchor"><span class="anchor-link"></span></a>actorSubscriber</h3>
<p>Create an actor from a <code>Props</code> upon materialization, where the actor implements <code>ActorSubscriber</code>, which will receive the elements from the stream.</p>
<p>Materializes into an <code>ActorRef</code> to the created actor.</p>
<p><strong>cancels</strong> when the actor terminates</p>
<p><strong>backpressures</strong> depends on the actor implementation</p>
<hr/>
<h3><a href="#aspublisher" name="aspublisher" class="anchor"><span class="anchor-link"></span></a>asPublisher</h3>
<p>Integration with Reactive Streams, materializes into a <code>org.reactivestreams.Publisher</code>.</p>
<hr/>
<h3><a href="#fromsubscriber" name="fromsubscriber" class="anchor"><span class="anchor-link"></span></a>fromSubscriber</h3>
<p>Integration with Reactive Streams, wraps a <code>org.reactivestreams.Subscriber</code> as a sink</p>
<hr/>
<br/>
<h2><a href="#additional-sink-and-source-converters" name="additional-sink-and-source-converters" class="anchor"><span class="anchor-link"></span></a>Additional Sink and Source converters</h2>
<p>Sources and sinks for integrating with <code>java.io.InputStream</code> and <code>java.io.OutputStream</code> can be found on <code>StreamConverters</code>. As they are blocking APIs the implementations of these stages are run on a separate dispatcher configured through the <code>akka.stream.blocking-io-dispatcher</code>.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Be aware that <code>asInputStream</code> and <code>asOutputStream</code> materialize <code>InputStream</code> and <code>OutputStream</code> respectively as blocking API implementation. They will block tread until data will be available from upstream. Because of blocking nature these objects cannot be used in <code>mapMaterializeValue</code> section as it causes deadlock of the stream materialization process. For example, following snippet will fall with timeout exception:</p>
<pre class="prettyprint"><code class="language-scala">...
.toMat(StreamConverters.asInputStream().mapMaterializedValue { inputStream ⇒
        inputStream.read()  // this could block forever
        ...
}).run()
</code></pre></div>
<hr/>
<h3><a href="#fromoutputstream" name="fromoutputstream" class="anchor"><span class="anchor-link"></span></a>fromOutputStream</h3>
<p>Create a sink that wraps an <code>OutputStream</code>. Takes a function that produces an <code>OutputStream</code>, when the sink is materialized the function will be called and bytes sent to the sink will be written to the returned <code>OutputStream</code>.</p>
<p>Materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> which will complete with a <code>IOResult</code> when the stream completes.</p>
<p>Note that a flow can be materialized multiple times, so the function producing the <code>OutputStream</code> must be able to handle multiple invocations.</p>
<p>The <code>OutputStream</code> will be closed when the stream that flows into the <code>Sink</code> is completed, and the <code>Sink</code> will cancel its inflow when the <code>OutputStream</code> is no longer writable.</p>
<hr/>
<h3><a href="#asinputstream" name="asinputstream" class="anchor"><span class="anchor-link"></span></a>asInputStream</h3>
<p>Create a sink which materializes into an <code>InputStream</code> that can be read to trigger demand through the sink. Bytes emitted through the stream will be available for reading through the <code>InputStream</code></p>
<p>The <code>InputStream</code> will be ended when the stream flowing into this <code>Sink</code> completes, and the closing the <code>InputStream</code> will cancel the inflow of this <code>Sink</code>.</p>
<hr/>
<h3><a href="#frominputstream" name="frominputstream" class="anchor"><span class="anchor-link"></span></a>fromInputStream</h3>
<p>Create a source that wraps an <code>InputStream</code>. Takes a function that produces an <code>InputStream</code>, when the source is materialized the function will be called and bytes from the <code>InputStream</code> will be emitted into the stream.</p>
<p>Materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> which will complete with a <code>IOResult</code> when the stream completes.</p>
<p>Note that a flow can be materialized multiple times, so the function producing the <code>InputStream</code> must be able to handle multiple invocations.</p>
<p>The <code>InputStream</code> will be closed when the <code>Source</code> is canceled from its downstream, and reaching the end of the <code>InputStream</code> will complete the <code>Source</code>.</p>
<hr/>
<h3><a href="#asoutputstream" name="asoutputstream" class="anchor"><span class="anchor-link"></span></a>asOutputStream</h3>
<p>Create a source that materializes into an <code>OutputStream</code>. When bytes are written to the <code>OutputStream</code> they are emitted from the source.</p>
<p>The <code>OutputStream</code> will no longer be writable when the <code>Source</code> has been canceled from its downstream, and closing the <code>OutputStream</code> will complete the <code>Source</code>.</p>
<hr/>
<h3><a href="#asjavastream" name="asjavastream" class="anchor"><span class="anchor-link"></span></a>asJavaStream</h3>
<p>Create a sink which materializes into Java 8 <code>Stream</code> that can be run to trigger demand through the sink. Elements emitted through the stream will be available for reading through the Java 8 <code>Stream</code>.</p>
<p>The Java 8 <code>Stream</code> will be ended when the stream flowing into this <code>Sink</code> completes, and closing the Java <code>Stream</code> will cancel the inflow of this <code>Sink</code>. Java <code>Stream</code> throws exception in case reactive stream failed.</p>
<p>Be aware that Java <code>Stream</code> blocks current thread while waiting on next element from downstream.</p>
<hr/>
<h3><a href="#fromjavastream" name="fromjavastream" class="anchor"><span class="anchor-link"></span></a>fromJavaStream</h3>
<p>Create a source that wraps a Java 8 <code>Stream</code>. <code>Source</code> uses a stream iterator to get all its elements and send them downstream on demand.</p>
<hr/>
<h3><a href="#javacollector" name="javacollector" class="anchor"><span class="anchor-link"></span></a>javaCollector</h3>
<p>Create a sink which materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> which will be completed with a result of the Java 8 <code>Collector</code> transformation and reduction operations. This allows usage of Java 8 streams transformations for reactive streams. The <code>Collector</code> will trigger demand downstream. Elements emitted through the stream will be accumulated into a mutable result container, optionally transformed into a final representation after all input elements have been processed. The <code>Collector</code> can also do reduction at the end. Reduction processing is performed sequentially</p>
<p>Note that a flow can be materialized multiple times, so the function producing the <code>Collector</code> must be able to handle multiple invocations.</p>
<hr/>
<h3><a href="#javacollectorparallelunordered" name="javacollectorparallelunordered" class="anchor"><span class="anchor-link"></span></a>javaCollectorParallelUnordered</h3>
<p>Create a sink which materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> which will be completed with a result of the Java 8 <code>Collector</code> transformation and reduction operations. This allows usage of Java 8 streams transformations for reactive streams. The <code>Collector</code> is triggering demand downstream. Elements emitted through the stream will be accumulated into a mutable result container, optionally transformed into a final representation after all input elements have been processed. The <code>Collector</code> can also do reduction at the end. Reduction processing is performed in parallel based on graph <code>Balance</code>.</p>
<p>Note that a flow can be materialized multiple times, so the function producing the <code>Collector</code> must be able to handle multiple invocations.</p>
<hr/>
<br/>
<h2><a href="#file-io-sinks-and-sources" name="file-io-sinks-and-sources" class="anchor"><span class="anchor-link"></span></a>File IO Sinks and Sources</h2>
<p>Sources and sinks for reading and writing files can be found on <code>FileIO</code>.</p>
<hr/>
<h3><a href="#frompath" name="frompath" class="anchor"><span class="anchor-link"></span></a>fromPath</h3>
<p>Emit the contents of a file, as <code>ByteString</code> s, materializes into a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span><code>which will be completed with
a</code>IOResult` upon reaching the end of the file or if there is a failure.</p>
<hr/>
<h3><a href="#topath" name="topath" class="anchor"><span class="anchor-link"></span></a>toPath</h3>
<p>Create a sink which will write incoming <code>ByteString</code> s to a given file path.</p>
<hr/>
<br/>
<h2><a href="#flow-stages" name="flow-stages" class="anchor"><span class="anchor-link"></span></a>Flow stages</h2>
<p>All flows by default backpressure if the computation they encapsulate is not fast enough to keep up with the rate of incoming elements from the preceding stage. There are differences though how the different stages handle when some of their downstream stages backpressure them.</p>
<p>Most stages stop and propagate the failure downstream as soon as any of their upstreams emit a failure. This happens to ensure reliable teardown of streams and cleanup when failures happen. Failures are meant to be to model unrecoverable conditions, therefore they are always eagerly propagated. For in-band error handling of normal errors (dropping elements if a map fails for example) you should use the supervision support, or explicitly wrap your element types in a proper container that can express error or success states (for example <code>Try</code> in Scala).</p>
<br/>
<h2><a href="#simple-processing-stages" name="simple-processing-stages" class="anchor"><span class="anchor-link"></span></a>Simple processing stages</h2>
<p>These stages can transform the rate of incoming elements since there are stages that emit multiple elements for a single input (e.g. <code>mapConcat</code>) or consume multiple elements before emitting one output (e.g. <code>filter</code>). However, these rate transformations are data-driven, i.e. it is the incoming elements that define how the rate is affected. This is in contrast with <a href="#backpressure-aware-stages">detached stages</a> which can change their processing behavior depending on being backpressured by downstream or not.</p>
<hr/>
<h3><a href="#alsoto" name="alsoto" class="anchor"><span class="anchor-link"></span></a>alsoTo</h3>
<p>Attaches the given <code>Sink</code> to this <code>Flow</code>, meaning that elements that passes through will also be sent to the <code>Sink</code>.</p>
<p><strong>emits</strong> when an element is available and demand exists both from the Sink and the downstream</p>
<p><strong>backpressures</strong> when downstream or Sink backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#map" name="map" class="anchor"><span class="anchor-link"></span></a>map</h3>
<p>Transform each element in the stream by calling a mapping function with it and passing the returned value downstream.</p>
<p><strong>emits</strong> when the mapping function returns an element</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#mapconcat" name="mapconcat" class="anchor"><span class="anchor-link"></span></a>mapConcat</h3>
<p>Transform each element into zero or more elements that are individually passed downstream.</p>
<p><strong>emits</strong> when the mapping function returns an element or there are still remaining elements from the previously calculated collection</p>
<p><strong>backpressures</strong> when downstream backpressures or there are still available elements from the previously calculated collection</p>
<p><strong>completes</strong> when upstream completes and all remaining elements has been emitted</p>
<hr/>
<h3><a href="#statefulmapconcat" name="statefulmapconcat" class="anchor"><span class="anchor-link"></span></a>statefulMapConcat</h3>
<p>Transform each element into zero or more elements that are individually passed downstream. The difference to <code>mapConcat</code> is that the transformation function is created from a factory for every materialization of the flow.</p>
<p><strong>emits</strong> when the mapping function returns an element or there are still remaining elements from the previously calculated collection</p>
<p><strong>backpressures</strong> when downstream backpressures or there are still available elements from the previously calculated collection</p>
<p><strong>completes</strong> when upstream completes and all remaining elements has been emitted</p>
<hr/>
<h3><a href="#filter" name="filter" class="anchor"><span class="anchor-link"></span></a>filter</h3>
<p>Filter the incoming elements using a predicate. If the predicate returns true the element is passed downstream, if it returns false the element is discarded.</p>
<p><strong>emits</strong> when the given predicate returns true for the element</p>
<p><strong>backpressures</strong> when the given predicate returns true for the element and downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#filternot" name="filternot" class="anchor"><span class="anchor-link"></span></a>filterNot</h3>
<p>Filter the incoming elements using a predicate. If the predicate returns false the element is passed downstream, if it returns true the element is discarded.</p>
<p><strong>emits</strong> when the given predicate returns false for the element</p>
<p><strong>backpressures</strong> when the given predicate returns false for the element and downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#collect" name="collect" class="anchor"><span class="anchor-link"></span></a>collect</h3>
<p>Apply a partial function to each incoming element, if the partial function is defined for a value the returned value is passed downstream. Can often replace <code>filter</code> followed by <code>map</code> to achieve the same in one single stage.</p>
<p><strong>emits</strong> when the provided partial function is defined for the element</p>
<p><strong>backpressures</strong> the partial function is defined for the element and downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#grouped" name="grouped" class="anchor"><span class="anchor-link"></span></a>grouped</h3>
<p>Accumulate incoming events until the specified number of elements have been accumulated and then pass the collection of elements downstream.</p>
<p><strong>emits</strong> when the specified number of elements has been accumulated or upstream completed</p>
<p><strong>backpressures</strong> when a group has been assembled and downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#sliding" name="sliding" class="anchor"><span class="anchor-link"></span></a>sliding</h3>
<p>Provide a sliding window over the incoming stream and pass the windows as groups of elements downstream.</p>
<p>Note: the last window might be smaller than the requested size due to end of stream.</p>
<p><strong>emits</strong> the specified number of elements has been accumulated or upstream completed</p>
<p><strong>backpressures</strong> when a group has been assembled and downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#scan" name="scan" class="anchor"><span class="anchor-link"></span></a>scan</h3>
<p>Emit its current value which starts at <code>zero</code> and then applies the current and next value to the given function emitting the next current value.</p>
<p>Note that this means that scan emits one element downstream before and upstream elements will not be requested until the second element is required from downstream.</p>
<p><strong>emits</strong> when the function scanning the element returns a new element</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#scanasync" name="scanasync" class="anchor"><span class="anchor-link"></span></a>scanAsync</h3>
<p>Just like <code>scan</code> but receiving a function that results in a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> to the next value.</p>
<p><strong>emits</strong> when the <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> resulting from the function scanning the element resolves to the next value</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and the last <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> is resolved</p>
<hr/>
<h3><a href="#fold" name="fold" class="anchor"><span class="anchor-link"></span></a>fold</h3>
<p>Start with current value <code>zero</code> and then apply the current and next value to the given function, when upstream complete the current value is emitted downstream.</p>
<p><strong>emits</strong> when upstream completes</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#foldasync" name="foldasync" class="anchor"><span class="anchor-link"></span></a>foldAsync</h3>
<p>Just like <code>fold</code> but receiving a function that results in a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> to the next value.</p>
<p><strong>emits</strong> when upstream completes and the last <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> is resolved</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and the last <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> is resolved</p>
<hr/>
<h3><a href="#reduce" name="reduce" class="anchor"><span class="anchor-link"></span></a>reduce</h3>
<p>Start with first element and then apply the current and next value to the given function, when upstream complete the current value is emitted downstream. Similar to <code>fold</code>.</p>
<p><strong>emits</strong> when upstream completes</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#drop" name="drop" class="anchor"><span class="anchor-link"></span></a>drop</h3>
<p>Drop <code>n</code> elements and then pass any subsequent element downstream.</p>
<p><strong>emits</strong> when the specified number of elements has been dropped already</p>
<p><strong>backpressures</strong> when the specified number of elements has been dropped and downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#take" name="take" class="anchor"><span class="anchor-link"></span></a>take</h3>
<p>Pass <code>n</code> incoming elements downstream and then complete</p>
<p><strong>emits</strong> while the specified number of elements to take has not yet been reached</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when the defined number of elements has been taken or upstream completes</p>
<hr/>
<h3><a href="#takewhile" name="takewhile" class="anchor"><span class="anchor-link"></span></a>takeWhile</h3>
<p>Pass elements downstream as long as a predicate function return true for the element include the element when the predicate first return false and then complete.</p>
<p><strong>emits</strong> while the predicate is true and until the first false result</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when predicate returned false or upstream completes</p>
<hr/>
<h3><a href="#dropwhile" name="dropwhile" class="anchor"><span class="anchor-link"></span></a>dropWhile</h3>
<p>Drop elements as long as a predicate function return true for the element</p>
<p><strong>emits</strong> when the predicate returned false and for all following stream elements</p>
<p><strong>backpressures</strong> predicate returned false and downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#recover" name="recover" class="anchor"><span class="anchor-link"></span></a>recover</h3>
<p>Allow sending of one last element downstream when a failure has happened upstream.</p>
<p>Throwing an exception inside <code>recover</code> <em>will</em> be logged on ERROR level automatically.</p>
<p><strong>emits</strong> when the element is available from the upstream or upstream is failed and pf returns an element</p>
<p><strong>backpressures</strong> when downstream backpressures, not when failure happened</p>
<p><strong>completes</strong> when upstream completes or upstream failed with exception pf can handle</p>
<hr/>
<h3><a href="#recoverwith" name="recoverwith" class="anchor"><span class="anchor-link"></span></a>recoverWith</h3>
<p>Allow switching to alternative Source when a failure has happened upstream.</p>
<p>Throwing an exception inside <code>recoverWith</code> <em>will</em> be logged on ERROR level automatically.</p>
<p><strong>emits</strong> the element is available from the upstream or upstream is failed and pf returns alternative Source</p>
<p><strong>backpressures</strong> downstream backpressures, after failure happened it backprssures to alternative Source</p>
<p><strong>completes</strong> upstream completes or upstream failed with exception pf can handle</p>
<hr/>
<h3><a href="#recoverwithretries" name="recoverwithretries" class="anchor"><span class="anchor-link"></span></a>recoverWithRetries</h3>
<p>RecoverWithRetries allows to switch to alternative Source on flow failure. It will stay in effect after a failure has been recovered up to <em>attempts</em> number of times so that each time there is a failure it is fed into the <em>pf</em> and a new Source may be materialized. Note that if you pass in 0, this won&rsquo;t attempt to recover at all. A negative <code>attempts</code> number is interpreted as &ldquo;infinite&rdquo;, which results in the exact same behavior as <code>recoverWith</code>.</p>
<p>Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements. This stage can recover the failure signal, but not the skipped elements, which will be dropped.</p>
<p><strong>emits</strong> when element is available from the upstream or upstream is failed and element is available from alternative Source</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes or upstream failed with exception pf can handle</p>
<hr/>
<h3><a href="#maperror" name="maperror" class="anchor"><span class="anchor-link"></span></a>mapError</h3>
<p>While similar to <code>recover</code> this stage can be used to transform an error signal to a different one <em>without</em> logging it as an error in the process. So in that sense it is NOT exactly equivalent to <code>recover(t =&gt; throw t2)</code> since recover would log the <code>t2</code> error.</p>
<p>Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements. This stage can recover the failure signal, but not the skipped elements, which will be dropped.</p>
<p>Similarily to <code>recover</code> throwing an exception inside <code>mapError</code> <em>will</em> be logged on ERROR level automatically.</p>
<p><strong>emits</strong> when element is available from the upstream or upstream is failed and pf returns an element <strong>backpressures</strong> when downstream backpressures <strong>completes</strong> when upstream completes or upstream failed with exception pf can handle</p>
<hr/>
<h3><a href="#detach" name="detach" class="anchor"><span class="anchor-link"></span></a>detach</h3>
<p>Detach upstream demand from downstream demand without detaching the stream rates.</p>
<p><strong>emits</strong> when the upstream stage has emitted and there is demand</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#throttle" name="throttle" class="anchor"><span class="anchor-link"></span></a>throttle</h3>
<p>Limit the throughput to a specific number of elements per time unit, or a specific total cost per time unit, where a function has to be provided to calculate the individual cost of each element.</p>
<p><strong>emits</strong> when upstream emits an element and configured time per each element elapsed</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#intersperse" name="intersperse" class="anchor"><span class="anchor-link"></span></a>intersperse</h3>
<p>Intersperse stream with provided element similar to <code>List.mkString</code>. It can inject start and end marker elements to stream.</p>
<p><strong>emits</strong> when upstream emits an element or before with the <em>start</em> element if provided</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#limit" name="limit" class="anchor"><span class="anchor-link"></span></a>limit</h3>
<p>Limit number of element from upstream to given <code>max</code> number.</p>
<p><strong>emits</strong> when upstream emits and the number of emitted elements has not reached max</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and the number of emitted elements has not reached max</p>
<hr/>
<h3><a href="#limitweighted" name="limitweighted" class="anchor"><span class="anchor-link"></span></a>limitWeighted</h3>
<p>Ensure stream boundedness by evaluating the cost of incoming elements using a cost function. Evaluated cost of each element defines how many elements will be allowed to travel downstream.</p>
<p><strong>emits</strong> when upstream emits and the number of emitted elements has not reached max</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and the number of emitted elements has not reached max</p>
<hr/>
<h3><a href="#log" name="log" class="anchor"><span class="anchor-link"></span></a>log</h3>
<p>Log elements flowing through the stream as well as completion and erroring. By default element and completion signals are logged on debug level, and errors are logged on Error level. This can be changed by calling <span class="group-scala"><code>Attributes.logLevels(...)</code></span> <span class="group-java"><code>Attributes.createLogLevels(...)</code></span> on the given Flow.</p>
<p><strong>emits</strong> when upstream emits</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<br/>
<h2><a href="#flow-stages-composed-of-sinks-and-sources" name="flow-stages-composed-of-sinks-and-sources" class="anchor"><span class="anchor-link"></span></a>Flow stages composed of Sinks and Sources</h2>
<hr/>
<h3><a href="#flow-fromsinkandsource" name="flow-fromsinkandsource" class="anchor"><span class="anchor-link"></span></a>Flow.fromSinkAndSource</h3>
<p>Creates a <code>Flow</code> from a <code>Sink</code> and a <code>Source</code> where the Flow&rsquo;s input will be sent to the <code>Sink</code> and the <code>Flow</code> &rsquo;s output will come from the Source.</p>
<p>Note that termination events, like completion and cancelation is not automatically propagated through to the &ldquo;other-side&rdquo; of the such-composed Flow. Use <code>Flow.fromSinkAndSourceCoupled</code> if you want to couple termination of both of the ends, for example most useful in handling websocket connections.</p>
<hr/>
<h3><a href="#flow-fromsinkandsourcecoupled" name="flow-fromsinkandsourcecoupled" class="anchor"><span class="anchor-link"></span></a>Flow.fromSinkAndSourceCoupled</h3>
<p>Allows coupling termination (cancellation, completion, erroring) of Sinks and Sources while creating a Flow them them. Similar to <code>Flow.fromSinkAndSource</code> however couples the termination of these two stages.</p>
<p>E.g. if the emitted <code>Flow</code> gets a cancellation, the <code>Source</code> of course is cancelled, however the Sink will also be completed. The table below illustrates the effects in detail:</p>
<table>
  <thead>
    <tr>
      <th>Returned Flow </th>
      <th>Sink (in) </th>
      <th>Source (out) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cause: upstream (sink-side) receives completion </td>
      <td>effect: receives completion </td>
      <td>effect: receives cancel </td>
    </tr>
    <tr>
      <td>cause: upstream (sink-side) receives error </td>
      <td>effect: receives error </td>
      <td>effect: receives cancel </td>
    </tr>
    <tr>
      <td>cause: downstream (source-side) receives cancel </td>
      <td>effect: completes </td>
      <td>effect: receives cancel </td>
    </tr>
    <tr>
      <td>effect: cancels upstream, completes downstream </td>
      <td>effect: completes </td>
      <td>cause: signals complete </td>
    </tr>
    <tr>
      <td>effect: cancels upstream, errors downstream </td>
      <td>effect: receives error </td>
      <td>cause: signals error or throws </td>
    </tr>
    <tr>
      <td>effect: cancels upstream, completes downstream </td>
      <td>cause: cancels </td>
      <td>effect: receives cancel </td>
    </tr>
  </tbody>
</table>
<p>The order in which the <em>in</em> and <em>out</em> sides receive their respective completion signals is not defined, do not rely on its ordering.</p>
<hr/>
<br/>
<h2><a href="#asynchronous-processing-stages" name="asynchronous-processing-stages" class="anchor"><span class="anchor-link"></span></a>Asynchronous processing stages</h2>
<p>These stages encapsulate an asynchronous computation, properly handling backpressure while taking care of the asynchronous operation at the same time (usually handling the completion of a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span>).</p>
<hr/>
<h3><a href="#mapasync" name="mapasync" class="anchor"><span class="anchor-link"></span></a>mapAsync</h3>
<p>Pass incoming elements to a function that return a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> result. When the <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> arrives the result is passed downstream. Up to <code>n</code> elements can be processed concurrently, but regardless of their completion time the incoming order will be kept when results complete. For use cases where order does not matter <code>mapAsyncUnordered</code> can be used.</p>
<p>If a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> fails, the stream also fails (unless a different supervision strategy is applied)</p>
<p><strong>emits</strong> when the <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> returned by the provided function finishes for the next element in sequence</p>
<p><strong>backpressures</strong> when the number of <span class="group-scala"><code>Future</code> s</span> <span class="group-java"><code>CompletionStage</code> s</span> reaches the configured parallelism and the downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and all <span class="group-scala"><code>Future</code> s</span> <span class="group-java"><code>CompletionStage</code> s</span> has been completed and all elements has been emitted</p>
<hr/>
<h3><a href="#mapasyncunordered" name="mapasyncunordered" class="anchor"><span class="anchor-link"></span></a>mapAsyncUnordered</h3>
<p>Like <code>mapAsync</code> but <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> results are passed downstream as they arrive regardless of the order of the elements that triggered them.</p>
<p>If a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> fails, the stream also fails (unless a different supervision strategy is applied)</p>
<p><strong>emits</strong> any of the <span class="group-scala"><code>Future</code> s</span> <span class="group-java"><code>CompletionStage</code> s</span> returned by the provided function complete</p>
<p><strong>backpressures</strong> when the number of <span class="group-scala"><code>Future</code> s</span> <span class="group-java"><code>CompletionStage</code> s</span> reaches the configured parallelism and the downstream backpressures</p>
<p><strong>completes</strong> upstream completes and all <span class="group-scala"><code>Future</code> s</span> <span class="group-java"><code>CompletionStage</code> s</span> has been completed and all elements has been emitted</p>
<hr/>
<br/>
<h2><a href="#timer-driven-stages" name="timer-driven-stages" class="anchor"><span class="anchor-link"></span></a>Timer driven stages</h2>
<p>These stages process elements using timers, delaying, dropping or grouping elements for certain time durations.</p>
<hr/>
<h3><a href="#takewithin" name="takewithin" class="anchor"><span class="anchor-link"></span></a>takeWithin</h3>
<p>Pass elements downstream within a timeout and then complete.</p>
<p><strong>emits</strong> when an upstream element arrives</p>
<p><strong>backpressures</strong> downstream backpressures</p>
<p><strong>completes</strong> upstream completes or timer fires</p>
<hr/>
<h3><a href="#dropwithin" name="dropwithin" class="anchor"><span class="anchor-link"></span></a>dropWithin</h3>
<p>Drop elements until a timeout has fired</p>
<p><strong>emits</strong> after the timer fired and a new upstream element arrives</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> upstream completes</p>
<hr/>
<h3><a href="#groupedwithin" name="groupedwithin" class="anchor"><span class="anchor-link"></span></a>groupedWithin</h3>
<p>Chunk up this stream into groups of elements received within a time window, or limited by the number of the elements, whatever happens first. Empty groups will not be emitted if no elements are received from upstream. The last group before end-of-stream will contain the buffered elements since the previously emitted group.</p>
<p><strong>emits</strong> when the configured time elapses since the last group has been emitted, but not if no elements has been grouped (i.e: no empty groups), or when limit has been reached.</p>
<p><strong>backpressures</strong> downstream backpressures, and there are <em>n+1</em> buffered elements</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#groupedweightedwithin" name="groupedweightedwithin" class="anchor"><span class="anchor-link"></span></a>groupedWeightedWithin</h3>
<p>Chunk up this stream into groups of elements received within a time window, or limited by the weight of the elements, whatever happens first. Empty groups will not be emitted if no elements are received from upstream. The last group before end-of-stream will contain the buffered elements since the previously emitted group.</p>
<p><strong>emits</strong> when the configured time elapses since the last group has been emitted, but not if no elements has been grouped (i.e: no empty groups), or when weight limit has been reached.</p>
<p><strong>backpressures</strong> downstream backpressures, and buffered group (+ pending element) weighs more than <em>maxWeight</em></p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#initialdelay" name="initialdelay" class="anchor"><span class="anchor-link"></span></a>initialDelay</h3>
<p>Delay the initial element by a user specified duration from stream materialization.</p>
<p><strong>emits</strong> upstream emits an element if the initial delay already elapsed</p>
<p><strong>backpressures</strong> downstream backpressures or initial delay not yet elapsed</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#delay" name="delay" class="anchor"><span class="anchor-link"></span></a>delay</h3>
<p>Delay every element passed through with a specific duration.</p>
<p><strong>emits</strong> there is a pending element in the buffer and configured time for this element elapsed</p>
<p><strong>backpressures</strong> differs, depends on <code>OverflowStrategy</code> set</p>
<p><strong>completes</strong> when upstream completes and buffered elements has been drained</p>
<hr/>
<br/>
<h2><a href="#backpressure-aware-stages" name="backpressure-aware-stages" class="anchor"><span class="anchor-link"></span></a>Backpressure aware stages</h2>
<p>These stages are aware of the backpressure provided by their downstreams and able to adapt their behavior to that signal.</p>
<hr/>
<h3><a href="#conflate" name="conflate" class="anchor"><span class="anchor-link"></span></a>conflate</h3>
<p>Allow for a slower downstream by passing incoming elements and a summary into an aggregate function as long as there is backpressure. The summary value must be of the same type as the incoming elements, for example the sum or average of incoming numbers, if aggregation should lead to a different type <code>conflateWithSeed</code> can be used:</p>
<p><strong>emits</strong> when downstream stops backpressuring and there is a conflated element available</p>
<p><strong>backpressures</strong> when the aggregate function cannot keep up with incoming elements</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#conflatewithseed" name="conflatewithseed" class="anchor"><span class="anchor-link"></span></a>conflateWithSeed</h3>
<p>Allow for a slower downstream by passing incoming elements and a summary into an aggregate function as long as there is backpressure. When backpressure starts or there is no backpressure element is passed into a <code>seed</code> function to transform it to the summary type.</p>
<p><strong>emits</strong> when downstream stops backpressuring and there is a conflated element available</p>
<p><strong>backpressures</strong> when the aggregate or seed functions cannot keep up with incoming elements</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#batch" name="batch" class="anchor"><span class="anchor-link"></span></a>batch</h3>
<p>Allow for a slower downstream by passing incoming elements and a summary into an aggregate function as long as there is backpressure and a maximum number of batched elements is not yet reached. When the maximum number is reached and downstream still backpressures batch will also backpressure.</p>
<p>When backpressure starts or there is no backpressure element is passed into a <code>seed</code> function to transform it to the summary type.</p>
<p>Will eagerly pull elements, this behavior may result in a single pending (i.e. buffered) element which cannot be aggregated to the batched value.</p>
<p><strong>emits</strong> when downstream stops backpressuring and there is a batched element available</p>
<p><strong>backpressures</strong> when batched elements reached the max limit of allowed batched elements &amp; downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and a &ldquo;possibly pending&rdquo; element was drained</p>
<hr/>
<h3><a href="#batchweighted" name="batchweighted" class="anchor"><span class="anchor-link"></span></a>batchWeighted</h3>
<p>Allow for a slower downstream by passing incoming elements and a summary into an aggregate function as long as there is backpressure and a maximum weight batched elements is not yet reached. The weight of each element is determined by applying <code>costFn</code>. When the maximum total weight is reached and downstream still backpressures batch will also backpressure.</p>
<p>Will eagerly pull elements, this behavior may result in a single pending (i.e. buffered) element which cannot be aggregated to the batched value.</p>
<p><strong>emits</strong> downstream stops backpressuring and there is a batched element available</p>
<p><strong>backpressures</strong> batched elements reached the max weight limit of allowed batched elements &amp; downstream backpressures</p>
<p><strong>completes</strong> upstream completes and a &ldquo;possibly pending&rdquo; element was drained</p>
<hr/>
<h3><a href="#expand" name="expand" class="anchor"><span class="anchor-link"></span></a>expand</h3>
<p>Allow for a faster downstream by expanding the last incoming element to an <code>Iterator</code>. For example <code>Iterator.continually(element)</code> to keep repeating the last incoming element.</p>
<p><strong>emits</strong> when downstream stops backpressuring</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#buffer-backpressure-" name="buffer-backpressure-" class="anchor"><span class="anchor-link"></span></a>buffer (Backpressure)</h3>
<p>Allow for a temporarily faster upstream events by buffering <code>size</code> elements. When the buffer is full backpressure is applied.</p>
<p><strong>emits</strong> when downstream stops backpressuring and there is a pending element in the buffer</p>
<p><strong>backpressures</strong> when buffer is full</p>
<p><strong>completes</strong> when upstream completes and buffered elements has been drained</p>
<hr/>
<h3><a href="#buffer-drop-" name="buffer-drop-" class="anchor"><span class="anchor-link"></span></a>buffer (Drop)</h3>
<p>Allow for a temporarily faster upstream events by buffering <code>size</code> elements. When the buffer is full elements are dropped according to the specified <code>OverflowStrategy</code>:</p>
<ul>
  <li><code>dropHead</code> drops the oldest element in the buffer to make space for the new element</li>
  <li><code>dropTail</code> drops the youngest element in the buffer to make space for the new element</li>
  <li><code>dropBuffer</code> drops the entire buffer and buffers the new element</li>
  <li><code>dropNew</code> drops the new element</li>
</ul>
<p><strong>emits</strong> when downstream stops backpressuring and there is a pending element in the buffer</p>
<p><strong>backpressures</strong> never (when dropping cannot keep up with incoming elements)</p>
<p><strong>completes</strong> upstream completes and buffered elements has been drained</p>
<hr/>
<h3><a href="#buffer-fail-" name="buffer-fail-" class="anchor"><span class="anchor-link"></span></a>buffer (Fail)</h3>
<p>Allow for a temporarily faster upstream events by buffering <code>size</code> elements. When the buffer is full the stage fails the flow with a <code>BufferOverflowException</code>.</p>
<p><strong>emits</strong> when downstream stops backpressuring and there is a pending element in the buffer</p>
<p><strong>backpressures</strong> never, fails the stream instead of backpressuring when buffer is full</p>
<p><strong>completes</strong> when upstream completes and buffered elements has been drained</p>
<hr/>
<br/>
<h2><a href="#nesting-and-flattening-stages" name="nesting-and-flattening-stages" class="anchor"><span class="anchor-link"></span></a>Nesting and flattening stages</h2>
<p>These stages either take a stream and turn it into a stream of streams (nesting) or they take a stream that contains nested streams and turn them into a stream of elements instead (flattening).</p>
<hr/>
<h3><a href="#prefixandtail" name="prefixandtail" class="anchor"><span class="anchor-link"></span></a>prefixAndTail</h3>
<p>Take up to <em>n</em> elements from the stream (less than <em>n</em> only if the upstream completes before emitting <em>n</em> elements) and returns a pair containing a strict sequence of the taken element and a stream representing the remaining elements.</p>
<p><strong>emits</strong> when the configured number of prefix elements are available. Emits this prefix, and the rest as a substream</p>
<p><strong>backpressures</strong> when downstream backpressures or substream backpressures</p>
<p><strong>completes</strong> when prefix elements has been consumed and substream has been consumed</p>
<hr/>
<h3><a href="#groupby" name="groupby" class="anchor"><span class="anchor-link"></span></a>groupBy</h3>
<p>Demultiplex the incoming stream into separate output streams.</p>
<p><strong>emits</strong> an element for which the grouping function returns a group that has not yet been created. Emits the new group there is an element pending for a group whose substream backpressures</p>
<p><strong>completes</strong> when upstream completes (Until the end of stream it is not possible to know whether new substreams will be needed or not)</p>
<hr/>
<h3><a href="#splitwhen" name="splitwhen" class="anchor"><span class="anchor-link"></span></a>splitWhen</h3>
<p>Split off elements into a new substream whenever a predicate function return <code>true</code>.</p>
<p><strong>emits</strong> an element for which the provided predicate is true, opening and emitting a new substream for subsequent elements</p>
<p><strong>backpressures</strong> when there is an element pending for the next substream, but the previous is not fully consumed yet, or the substream backpressures</p>
<p><strong>completes</strong> when upstream completes (Until the end of stream it is not possible to know whether new substreams will be needed or not)</p>
<hr/>
<h3><a href="#splitafter" name="splitafter" class="anchor"><span class="anchor-link"></span></a>splitAfter</h3>
<p>End the current substream whenever a predicate returns <code>true</code>, starting a new substream for the next element.</p>
<p><strong>emits</strong> when an element passes through. When the provided predicate is true it emits the element * and opens a new substream for subsequent element</p>
<p><strong>backpressures</strong> when there is an element pending for the next substream, but the previous is not fully consumed yet, or the substream backpressures</p>
<p><strong>completes</strong> when upstream completes (Until the end of stream it is not possible to know whether new substreams will be needed or not)</p>
<hr/>
<h3><a href="#flatmapconcat" name="flatmapconcat" class="anchor"><span class="anchor-link"></span></a>flatMapConcat</h3>
<p>Transform each input element into a <code>Source</code> whose elements are then flattened into the output stream through concatenation. This means each source is fully consumed before consumption of the next source starts.</p>
<p><strong>emits</strong> when the current consumed substream has an element available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and all consumed substreams complete</p>
<hr/>
<h3><a href="#flatmapmerge" name="flatmapmerge" class="anchor"><span class="anchor-link"></span></a>flatMapMerge</h3>
<p>Transform each input element into a <code>Source</code> whose elements are then flattened into the output stream through merging. The maximum number of merged sources has to be specified.</p>
<p><strong>emits</strong> when one of the currently consumed substreams has an element available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes and all consumed substreams complete</p>
<hr/>
<br/>
<h2><a href="#time-aware-stages" name="time-aware-stages" class="anchor"><span class="anchor-link"></span></a>Time aware stages</h2>
<p>Those stages operate taking time into consideration.</p>
<hr/>
<h3><a href="#initialtimeout" name="initialtimeout" class="anchor"><span class="anchor-link"></span></a>initialTimeout</h3>
<p>If the first element has not passed through this stage before the provided timeout, the stream is failed with a <code>TimeoutException</code>.</p>
<p><strong>emits</strong> when upstream emits an element</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes or fails if timeout elapses before first element arrives</p>
<p><strong>cancels</strong> when downstream cancels</p>
<hr/>
<h3><a href="#completiontimeout" name="completiontimeout" class="anchor"><span class="anchor-link"></span></a>completionTimeout</h3>
<p>If the completion of the stream does not happen until the provided timeout, the stream is failed with a <code>TimeoutException</code>.</p>
<p><strong>emits</strong> when upstream emits an element</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes or fails if timeout elapses before upstream completes</p>
<p><strong>cancels</strong> when downstream cancels</p>
<hr/>
<h3><a href="#idletimeout" name="idletimeout" class="anchor"><span class="anchor-link"></span></a>idleTimeout</h3>
<p>If the time between two processed elements exceeds the provided timeout, the stream is failed with a <code>TimeoutException</code>. The timeout is checked periodically, so the resolution of the check is one period (equals to timeout value).</p>
<p><strong>emits</strong> when upstream emits an element</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes or fails if timeout elapses between two emitted elements</p>
<p><strong>cancels</strong> when downstream cancels</p>
<hr/>
<h3><a href="#backpressuretimeout" name="backpressuretimeout" class="anchor"><span class="anchor-link"></span></a>backpressureTimeout</h3>
<p>If the time between the emission of an element and the following downstream demand exceeds the provided timeout, the stream is failed with a <code>TimeoutException</code>. The timeout is checked periodically, so the resolution of the check is one period (equals to timeout value).</p>
<p><strong>emits</strong> when upstream emits an element</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes or fails if timeout elapses between element emission and downstream demand.</p>
<p><strong>cancels</strong> when downstream cancels</p>
<hr/>
<h3><a href="#keepalive" name="keepalive" class="anchor"><span class="anchor-link"></span></a>keepAlive</h3>
<p>Injects additional (configured) elements if upstream does not emit for a configured amount of time.</p>
<p><strong>emits</strong> when upstream emits an element or if the upstream was idle for the configured period</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<p><strong>cancels</strong> when downstream cancels</p>
<hr/>
<h3><a href="#initialdelay" name="initialdelay" class="anchor"><span class="anchor-link"></span></a>initialDelay</h3>
<p>Delays the initial element by the specified duration.</p>
<p><strong>emits</strong> when upstream emits an element if the initial delay is already elapsed</p>
<p><strong>backpressures</strong> when downstream backpressures or initial delay is not yet elapsed</p>
<p><strong>completes</strong> when upstream completes</p>
<p><strong>cancels</strong> when downstream cancels</p>
<hr/>
<br/>
<h2><a href="#fan-in-stages" name="fan-in-stages" class="anchor"><span class="anchor-link"></span></a>Fan-in stages</h2>
<p>These stages take multiple streams as their input and provide a single output combining the elements from all of the inputs in different ways.</p>
<hr/>
<h3><a href="#merge" name="merge" class="anchor"><span class="anchor-link"></span></a>merge</h3>
<p>Merge multiple sources. Picks elements randomly if all sources has elements ready.</p>
<p><strong>emits</strong> when one of the inputs has an element available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when all upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)</p>
<hr/>
<h3><a href="#mergesorted" name="mergesorted" class="anchor"><span class="anchor-link"></span></a>mergeSorted</h3>
<p>Merge multiple sources. Waits for one element to be ready from each input stream and emits the smallest element.</p>
<p><strong>emits</strong> when all of the inputs have an element available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when all upstreams complete</p>
<hr/>
<h3><a href="#mergepreferred" name="mergepreferred" class="anchor"><span class="anchor-link"></span></a>mergePreferred</h3>
<p>Merge multiple sources. Prefer one source if all sources has elements ready.</p>
<p><strong>emits</strong> when one of the inputs has an element available, preferring a defined input if multiple have elements available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when all upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)</p>
<hr/>
<h3><a href="#mergeprioritized" name="mergeprioritized" class="anchor"><span class="anchor-link"></span></a>mergePrioritized</h3>
<p>Merge multiple sources. Prefer sources depending on priorities if all sources has elements ready. If a subset of all sources has elements ready the relative priorities for those sources are used to prioritise.</p>
<p><strong>emits</strong> when one of the inputs has an element available, preferring inputs based on their priorities if multiple have elements available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when all upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)</p>
<hr/>
<h3><a href="#zip" name="zip" class="anchor"><span class="anchor-link"></span></a>zip</h3>
<p>Combines elements from each of multiple sources into <span class="group-scala">tuples</span> <span class="group-java"><em>Pair</em></span> and passes the <span class="group-scala">tuples</span> <span class="group-java">pairs</span> downstream.</p>
<p><strong>emits</strong> when all of the inputs have an element available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when any upstream completes</p>
<hr/>
<h3><a href="#zipwith" name="zipwith" class="anchor"><span class="anchor-link"></span></a>zipWith</h3>
<p>Combines elements from multiple sources through a <code>combine</code> function and passes the returned value downstream.</p>
<p><strong>emits</strong> when all of the inputs have an element available</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when any upstream completes</p>
<hr/>
<h3><a href="#zipwithindex" name="zipwithindex" class="anchor"><span class="anchor-link"></span></a>zipWithIndex</h3>
<p>Zips elements of current flow with its indices.</p>
<p><strong>emits</strong> upstream emits an element and is paired with their index</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#concat" name="concat" class="anchor"><span class="anchor-link"></span></a>concat</h3>
<p>After completion of the original upstream the elements of the given source will be emitted.</p>
<p><strong>emits</strong> when the current stream has an element available; if the current input completes, it tries the next one</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when all upstreams complete</p>
<hr/>
<h3><a href="#" name="" class="anchor"><span class="anchor-link"></span></a>++</h3>
<p>Just a shorthand for concat</p>
<p><strong>emits</strong> when the current stream has an element available; if the current input completes, it tries the next one</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when all upstreams complete</p>
<hr/>
<h3><a href="#prepend" name="prepend" class="anchor"><span class="anchor-link"></span></a>prepend</h3>
<p>Prepends the given source to the flow, consuming it until completion before the original source is consumed.</p>
<p>If materialized values needs to be collected <code>prependMat</code> is available.</p>
<p><strong>emits</strong> when the given stream has an element available; if the given input completes, it tries the current one</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> when all upstreams complete</p>
<hr/>
<h3><a href="#orelse" name="orelse" class="anchor"><span class="anchor-link"></span></a>orElse</h3>
<p>If the primary source completes without emitting any elements, the elements from the secondary source are emitted. If the primary source emits any elements the secondary source is cancelled.</p>
<p>Note that both sources are materialized directly and the secondary source is backpressured until it becomes the source of elements or is cancelled.</p>
<p>Signal errors downstream, regardless which of the two sources emitted the error.</p>
<p><strong>emits</strong> when an element is available from first stream or first stream closed without emitting any elements and an element is available from the second stream</p>
<p><strong>backpressures</strong> when downstream backpressures</p>
<p><strong>completes</strong> the primary stream completes after emitting at least one element, when the primary stream completes without emitting and the secondary stream already has completed or when the secondary stream completes</p>
<hr/>
<h3><a href="#interleave" name="interleave" class="anchor"><span class="anchor-link"></span></a>interleave</h3>
<p>Emits a specifiable number of elements from the original source, then from the provided source and repeats. If one source completes the rest of the other stream will be emitted.</p>
<p><strong>emits</strong> when element is available from the currently consumed upstream</p>
<p><strong>backpressures</strong> when upstream backpressures</p>
<p><strong>completes</strong> when both upstreams have completed</p>
<hr/>
<br/>
<h2><a href="#fan-out-stages" name="fan-out-stages" class="anchor"><span class="anchor-link"></span></a>Fan-out stages</h2>
<p>These have one input and multiple outputs. They might route the elements between different outputs, or emit elements on multiple outputs at the same time.</p>
<hr/>
<h3><a href="#unzip" name="unzip" class="anchor"><span class="anchor-link"></span></a>unzip</h3>
<p>Takes a stream of two element tuples and unzips the two elements ino two different downstreams.</p>
<p><strong>emits</strong> when all of the outputs stops backpressuring and there is an input element available</p>
<p><strong>backpressures</strong> when any of the outputs backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#unzipwith" name="unzipwith" class="anchor"><span class="anchor-link"></span></a>unzipWith</h3>
<p>Splits each element of input into multiple downstreams using a function</p>
<p><strong>emits</strong> when all of the outputs stops backpressuring and there is an input element available</p>
<p><strong>backpressures</strong> when any of the outputs backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#broadcast" name="broadcast" class="anchor"><span class="anchor-link"></span></a>broadcast</h3>
<p>Emit each incoming element each of <code>n</code> outputs.</p>
<p><strong>emits</strong> when all of the outputs stops backpressuring and there is an input element available</p>
<p><strong>backpressures</strong> when any of the outputs backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#balance" name="balance" class="anchor"><span class="anchor-link"></span></a>balance</h3>
<p>Fan-out the stream to several streams. Each upstream element is emitted to the first available downstream consumer.</p>
<p><strong>emits</strong> when any of the outputs stops backpressuring; emits the element to the first available output</p>
<p><strong>backpressures</strong> when all of the outputs backpressure</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#partition" name="partition" class="anchor"><span class="anchor-link"></span></a>partition</h3>
<p>Fan-out the stream to several streams. Each upstream element is emitted to one downstream consumer according to the partitioner function applied to the element.</p>
<p><strong>emits</strong> when the chosen output stops backpressuring and there is an input element available</p>
<p><strong>backpressures</strong> when the chosen output backpressures</p>
<p><strong>completes</strong> when upstream completes and no output is pending</p>
<hr/>
<br/>
<h2><a href="#watching-status-stages" name="watching-status-stages" class="anchor"><span class="anchor-link"></span></a>Watching status stages</h2>
<hr/>
<h3><a href="#watchtermination" name="watchtermination" class="anchor"><span class="anchor-link"></span></a>watchTermination</h3>
<p>Materializes to a <span class="group-scala"><code>Future</code></span> <span class="group-java"><code>CompletionStage</code></span> that will be completed with Done or failed depending whether the upstream of the stage has been completed or failed. The stage otherwise passes through elements unchanged.</p>
<p><strong>emits</strong> when input has an element available</p>
<p><strong>backpressures</strong> when output backpressures</p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
<h3><a href="#monitor" name="monitor" class="anchor"><span class="anchor-link"></span></a>monitor</h3>
<p>Materializes to a <code>FlowMonitor</code> that monitors messages flowing through or completion of the stage. The stage otherwise passes through elements unchanged. Note that the <code>FlowMonitor</code> inserts a memory barrier every time it processes an event, and may therefore affect performance.</p>
<p><strong>emits</strong> when upstream emits an element</p>
<p><strong>backpressures</strong> when downstream <strong>backpressures</strong></p>
<p><strong>completes</strong> when upstream completes</p>
<hr/>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../stream/stream-testkit.html"><i class="icon-prev"></i> <span class="link-prev">Testing streams</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../stream/stream-cookbook.html">Streams Cookbook <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="http://github.com/akka/akka/tree/master/akka-docs/src/main/paradox/stream/stages-overview.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
