<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Persistence &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/persistence-typed.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="index-typed.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="actors-typed.html" class="page">Actors</a></li>
    <li><a href="coexisting.html" class="page">Coexistence</a></li>
    <li><a href="fault-tolerance-typed.html" class="page">Fault Tolerance</a></li>
    <li><a href="actor-discovery-typed.html" class="page">Actor discovery</a></li>
    <li><a href="cluster-typed.html" class="page">Cluster</a></li>
    <li><a href="cluster-sharding-typed.html" class="page">Sharding</a></li>
    <li><a href="persistence-typed.html#persistence" class="active page">Persistence</a>
    <ul>
      <li><a href="persistence-typed.html#command-handler" class="header">Command handler</a></li>
      <li><a href="persistence-typed.html#event-handler" class="header">Event handler</a></li>
      <li><a href="persistence-typed.html#basic-example" class="header">Basic example</a></li>
      <li><a href="persistence-typed.html#larger-example" class="header">Larger example</a></li>
      <li><a href="persistence-typed.html#serialization" class="header">Serialization</a></li>
      <li><a href="persistence-typed.html#recovery" class="header">Recovery</a></li>
      <li><a href="persistence-typed.html#current-limitations" class="header">Current limitations</a></li>
    </ul></li>
    <li><a href="testing-typed.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.9
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="index-typed.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="actors-typed.html" class="page">Actors</a></li>
    <li><a href="coexisting.html" class="page">Coexistence</a></li>
    <li><a href="fault-tolerance-typed.html" class="page">Fault Tolerance</a></li>
    <li><a href="actor-discovery-typed.html" class="page">Actor discovery</a></li>
    <li><a href="cluster-typed.html" class="page">Cluster</a></li>
    <li><a href="cluster-sharding-typed.html" class="page">Sharding</a></li>
    <li><a href="persistence-typed.html#persistence" class="active page">Persistence</a>
    <ul>
      <li><a href="persistence-typed.html#command-handler" class="header">Command handler</a></li>
      <li><a href="persistence-typed.html#event-handler" class="header">Event handler</a></li>
      <li><a href="persistence-typed.html#basic-example" class="header">Basic example</a></li>
      <li><a href="persistence-typed.html#larger-example" class="header">Larger example</a></li>
      <li><a href="persistence-typed.html#serialization" class="header">Serialization</a></li>
      <li><a href="persistence-typed.html#recovery" class="header">Recovery</a></li>
      <li><a href="persistence-typed.html#current-limitations" class="header">Current limitations</a></li>
    </ul></li>
    <li><a href="testing-typed.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#persistence" name="persistence" class="anchor"><span class="anchor-link"></span></a>Persistence</h1><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="common/may-change.html">may change</a> in the sense  of being the subject of active research. This means that API or semantics can  change without warning or deprecation period and it is not recommended to use  this module in production just yet—you have been warned.</p></div><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module only has a Scala DSL. See <a href="https://github.com/akka/akka/issues/24193">#24193</a> to track progress and to contribute to the Java DSL.</p></div>
<p>To use typed persistence add the following dependency:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" % "akka-persistence-typed_2.11" % "2.5.9"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-persistence-typed_2.11&lt;/artifactId&gt;
  &lt;version&gt;2.5.9&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-persistence-typed_2.11', version: '2.5.9'
}</code></pre></dd></dl>
<p>Akka Persistence is a library for building event sourced actors. For background about how it works see the <a href="persistence.html">untyped Akka Persistence section</a>. This documentation shows how the typed API for persistence works and assumes you know what is meant by <code>Command</code>, <code>Event</code> and <code>State</code>.</p>
<p>Let&rsquo;s start with a simple example. The minimum required for a <code>PersistentActor</code> is:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait Command
sealed trait Event
case class State()

val behavior: Behavior[Command] =
  PersistentActor.immutable[Command, Event, State](
    persistenceId = &quot;abc&quot;,
    initialState = State(),
    commandHandler = PersistentActor.CommandHandler { (ctx, state, cmd) ⇒ ??? },
    eventHandler = (state, evt) ⇒ ???)</code></pre></dd>
</dl>
<p>The first important thing to notice is the <code>Behavior</code> of a <code>PersistentActor</code> is typed to the type of the <code>Command</code> because this type of message a persistent actor should receive. In Akka Typed this is now enforced by the type system. The event and state are only used internally.</p>
<p>The parameters to <code>PersistentActor.immutable</code> are::</p>
<ul>
  <li><code>persistenceId</code> is the unique identifier for the persistent actor.</li>
  <li><code>initialState</code> defines the <code>State</code> when the entity is first created e.g. a Counter would start wiht 0 as state.</li>
  <li><code>commandHandler</code> defines how to handle command and optional functions for other signals, e.g. <code>Termination</code> messages if <code>watch</code> is used.</li>
  <li><code>eventHandler</code> updates the current state when an event has been persisted.</li>
</ul>
<p>Next we&rsquo;ll discuss each of these in detail.</p>
<h3><a href="#command-handler" name="command-handler" class="anchor"><span class="anchor-link"></span></a>Command handler</h3>
<p>The command handler is a function with 3 parameters for the <code>ActorContext</code>, current <code>State</code>, and <code>Command</code>.</p>
<p>A command handler returns an <code>Effect</code> directive that defines what event or events, if any, to persist.</p>
<ul>
  <li><code>Effect.persist</code> will persist one single event or several events atomically, i.e. all events  are stored or none of them are stored if there is an error</li>
  <li><code>Effect.none</code> no events are to be persisted, for example a read-only command</li>
  <li><code>Effect.unhandled</code> the command is unhandled (not supported) in current state</li>
</ul>
<p>External side effects can be performed after successful persist with the <code>andThen</code> function e.g <code>Effect.persist(..).andThen</code>. In the example below a reply is sent to the <code>replyTo</code> ActorRef. Note that the new state after applying the event is passed as parameter to the <code>andThen</code> function.</p>
<h3><a href="#event-handler" name="event-handler" class="anchor"><span class="anchor-link"></span></a>Event handler</h3>
<p>When an event has been persisted successfully the current state is updated by applying the event to the current state with the <code>eventHandler</code> function. </p>
<p>The event handler returns the new state, which must be immutable so you return a new instance of the state. The same event handler is also used when the entity is started up to recover its state from the stored events.</p>
<p>It is not recommended to perform side effects in the event handler, as those are also executed during recovery of an persistent actor</p>
<h2><a href="#basic-example" name="basic-example" class="anchor"><span class="anchor-link"></span></a>Basic example</h2>
<p>Command and event:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait SimpleCommand
case class Cmd(data: String) extends SimpleCommand

sealed trait SimpleEvent
case class Evt(data: String) extends SimpleEvent</code></pre></dd>
</dl>
<p>State is a List containing all the events:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">case class ExampleState(events: List[String] = Nil)</code></pre></dd>
</dl>
<p>The command handler just persists the <code>Cmd</code> payload in an <code>Evt</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val commandHandler: CommandHandler[SimpleCommand, SimpleEvent, ExampleState] =
  CommandHandler.command {
    case Cmd(data) ⇒ Effect.persist(Evt(data))
  }</code></pre></dd>
</dl>
<p>The event handler appends the event to the state. This is called after successfully persisting the event in the database:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventHandler: (ExampleState, SimpleEvent) ⇒ (ExampleState) = {
  case (state, Evt(data)) ⇒ state.copy(data :: state.events)
}</code></pre></dd>
</dl>
<p>These are used to create a <code>PersistentBehavior</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val simpleBehavior: PersistentBehavior[SimpleCommand, SimpleEvent, ExampleState] =
  PersistentActor.immutable[SimpleCommand, SimpleEvent, ExampleState](
    persistenceId = &quot;sample-id-1&quot;,
    initialState = ExampleState(Nil),
    commandHandler = commandHandler,
    eventHandler = eventHandler)</code></pre></dd>
</dl>
<p>The behavior can then be run as with any normal typed actor as described in <a href="actors-typed.md">typed actors documentation</a>.</p>
<h2><a href="#larger-example" name="larger-example" class="anchor"><span class="anchor-link"></span></a>Larger example</h2>
<p>After processing a message plain typed actors are able to return the <code>Behavior</code> that is used for next message. </p>
<p>As you can see in the above examples this is not supported by typed persistent actors. Instead, the state is returned by <code>eventHandler</code>. The reason a new behavior can&rsquo;t be returned is that behavior is part of the actor&rsquo;s state and must also carefully be reconstructed during recovery. If it would have been supported it would mean that the behavior must be restored when replaying events and also encoded in the state anyway when snapshots are used. That would be very prone to mistakes and thus not allowed in Typed Persistence.</p>
<p>For simple actors you can use the same set of command handlers independent of what state the entity is in, as shown in above example. For more complex actors it&rsquo;s useful to be able to change the behavior in the sense that different functions for processing commands may be defined depending on what state the actor is in. This is useful when implementing finite state machine (FSM) like entities. </p>
<p>The next example shows how to define different behavior based on the current <code>State</code>. It is an actor that represents the state of a blog post. Before a post is started the only command it can process is to <code>AddPost</code>. Once it is started then it we can look it up with <code>GetPost</code>, modify it with <code>ChangeBody</code> or publish it with <code>Publish</code>.</p>
<p>The state is captured by:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object BlogState {
  val empty = BlogState(None, published = false)
}

final case class BlogState(content: Option[PostContent], published: Boolean) {
  def withContent(newContent: PostContent): BlogState =
    copy(content = Some(newContent))
  def isEmpty: Boolean = content.isEmpty
  def postId: String = content match {
    case Some(c) ⇒ c.postId
    case None    ⇒ throw new IllegalStateException(&quot;postId unknown before post is created&quot;)
  }
}</code></pre></dd>
</dl>
<p>The commands (only a subset are valid depending on state):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait BlogCommand extends Serializable
final case class AddPost(content: PostContent, replyTo: ActorRef[AddPostDone]) extends BlogCommand
final case class AddPostDone(postId: String)
final case class GetPost(replyTo: ActorRef[PostContent]) extends BlogCommand
final case class ChangeBody(newBody: String, replyTo: ActorRef[Done]) extends BlogCommand
final case class Publish(replyTo: ActorRef[Done]) extends BlogCommand
final case object PassivatePost extends BlogCommand
final case class PostContent(postId: String, title: String, body: String)</code></pre></dd>
</dl>
<p>The command handler to process each command is decided by a <code>CommandHandler.byState</code> command handler, which is a function from <code>State =&gt; CommandHandler</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private def commandHandler: CommandHandler[BlogCommand, BlogEvent, BlogState] = CommandHandler.byState {
  case state if state.isEmpty  ⇒ initial
  case state if !state.isEmpty ⇒ postAdded
}</code></pre></dd>
</dl>
<p>This can refer to many other <code>CommandHandler</code>s e.g one for a post that hasn&rsquo;t been started:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private def initial: CommandHandler[BlogCommand, BlogEvent, BlogState] =
  CommandHandler { (ctx, state, cmd) ⇒
    cmd match {
      case AddPost(content, replyTo) ⇒
        val evt = PostAdded(content.postId, content)
        Effect.persist(evt).andThen { state2 ⇒
          // After persist is done additional side effects can be performed
          replyTo ! AddPostDone(content.postId)
        }
      case PassivatePost ⇒
        Effect.stop
      case _ ⇒
        Effect.unhandled
    }
  }</code></pre></dd>
</dl>
<p>And a different <code>CommandHandler</code> for after the post has been added:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private def postAdded: CommandHandler[BlogCommand, BlogEvent, BlogState] = {
  CommandHandler { (ctx, state, cmd) ⇒
    cmd match {
      case ChangeBody(newBody, replyTo) ⇒
        val evt = BodyChanged(state.postId, newBody)
        Effect.persist(evt).andThen { _ ⇒
          replyTo ! Done
        }
      case Publish(replyTo) ⇒
        Effect.persist(Published(state.postId)).andThen { _ ⇒
          println(s&quot;Blog post ${state.postId} was published&quot;)
          replyTo ! Done
        }
      case GetPost(replyTo) ⇒
        replyTo ! state.content.get
        Effect.none
      case _: AddPost ⇒
        Effect.unhandled
      case PassivatePost ⇒
        Effect.stop
    }
  }
}</code></pre></dd>
</dl>
<p>The event handler is always the same independent of state. The main reason for not making the event handler part of the <code>CommandHandler</code> is that all events must be handled and that is typically independent of what the current state is. The event handler can of course still decide what to do based on the state if that is needed.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private def eventHandler(state: BlogState, event: BlogEvent): BlogState =
  event match {
    case PostAdded(postId, content) ⇒
      state.withContent(content)

    case BodyChanged(_, newBody) ⇒
      state.content match {
        case Some(c) ⇒ state.copy(content = Some(c.copy(body = newBody)))
        case None    ⇒ state
      }

    case Published(_) ⇒
      state.copy(published = true)
  }</code></pre></dd>
</dl>
<p>And finally the behavior is created from the <code>byState</code> command handler:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">def behavior: Behavior[BlogCommand] =
  PersistentActor.immutable[BlogCommand, BlogEvent, BlogState](
    persistenceId = &quot;abc&quot;,
    initialState = BlogState.empty,
    commandHandler,
    eventHandler)</code></pre></dd>
</dl>
<h2><a href="#serialization" name="serialization" class="anchor"><span class="anchor-link"></span></a>Serialization</h2>
<p>The same <a href="serialization.html">serialization</a> mechanism as for untyped actors is also used in Akka Typed, also for persistent actors. When picking serialization solution for the events you should also consider that it must be possible read old events when the application has evolved. Strategies for that can be found in the <a href="persistence-schema-evolution.html">schema evolution</a>.</p>
<h2><a href="#recovery" name="recovery" class="anchor"><span class="anchor-link"></span></a>Recovery</h2>
<p>Since it is strongly discouraged to perform side effects in applyEvent , side effects should be performed once recovery has completed in the <code>onRecoveryCompleted</code> callback</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val recoveryBehavior: Behavior[Command] =
  PersistentActor.immutable[Command, Event, State](
    persistenceId = &quot;abc&quot;,
    initialState = State(),
    commandHandler = PersistentActor.CommandHandler { (ctx, state, cmd) ⇒ ??? },
    eventHandler = (state, evt) ⇒ ???)
    .onRecoveryCompleted { (ctx, state) ⇒
      ???
    }</code></pre></dd>
</dl>
<p>The <code>onRecoveryCompleted</code> takes on an <code>ActorContext</code> and the current <code>State</code>.</p>
<h2><a href="#current-limitations" name="current-limitations" class="anchor"><span class="anchor-link"></span></a>Current limitations</h2>
<ul>
  <li>The <code>PersistentBehavior</code> can&rsquo;t be wrapped in other behaviors, such as <code>Actor.deferred</code>. See <a href="https://github.com/akka/akka/issues/23694">#23694</a></li>
  <li>Can only tag events with event adapters. See <a href="https://github.com/akka/akka/issues/23817">#23817</a></li>
  <li>Missing Java DSL. See <a href="https://github.com/akka/akka/issues/24193">#24193</a></li>
  <li>Snapshot support. See <a href="https://github.com/akka/akka/issues/24196">#24196</a></li>
</ul>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="cluster-sharding-typed.html"><i class="icon-prev"></i> <span class="link-prev">Sharding</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="testing-typed.html">Testing <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/johanandren/akka/tree/master/akka-docs/src/main/paradox/persistence-typed.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2018 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
