


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Actors (Scala) &mdash; Akka Documentation</title>
    <link rel="stylesheet" href="../_static/akka.css" type="text/css" />
<link rel="stylesheet" href="https://doc.akka.io/docs/akka/1.1.3/_static/docs.css" type="text/css"/>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
<script type="text/javascript" src="https://doc.akka.io/docs/akka/1.1.3/_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Scala API" href="index.html" />
    <link rel="next" title="Typed Actors (Scala)" href="typed-actors.html" />
    <link rel="prev" title="Scala API" href="index.html" /> 
  </head>
  <body>
      <div class="header"><a href="../index.html"><img class="leftlogo" src="../_static/logo.png" alt="Logo"/></a><h1 class="heading"><a href="../index.html"><span>Akka Documentation</span></a></h1>
       <h2 class="heading"><a href="../index.html"><span>Version 1.1.3</span></a></h2>
       <h2 class="rightheading"><span><a href="https://akka.io/docs/akka/1.1.3/Akka.pdf">PDF</a></span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="index.html">Scala API</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="typed-actors.html">Typed Actors (Scala)</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="actors-scala">
<span id="id1"></span><h1>Actors (Scala)<a class="headerlink" href="#actors-scala" title="Permalink to this headline">¶</a></h1>
<div class="sidebar">
<p class="first sidebar-title">Contents</p>
<div class="contents local last topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#creating-actors" id="id3">Creating Actors</a><ul>
<li><a class="reference internal" href="#defining-an-actor-class" id="id4">Defining an Actor class</a></li>
<li><a class="reference internal" href="#id2" id="id5">Creating Actors</a></li>
<li><a class="reference internal" href="#creating-actors-with-non-default-constructor" id="id6">Creating Actors with non-default constructor</a></li>
<li><a class="reference internal" href="#running-a-block-of-code-asynchronously" id="id7">Running a block of code asynchronously</a></li>
</ul>
</li>
<li><a class="reference internal" href="#identifying-actors" id="id8">Identifying Actors</a></li>
<li><a class="reference internal" href="#messages-and-immutability" id="id9">Messages and immutability</a></li>
<li><a class="reference internal" href="#send-messages" id="id10">Send messages</a><ul>
<li><a class="reference internal" href="#fire-forget" id="id11">Fire-forget</a></li>
<li><a class="reference internal" href="#send-and-receive-eventually" id="id12">Send-And-Receive-Eventually</a></li>
<li><a class="reference internal" href="#send-and-receive-future" id="id13">Send-And-Receive-Future</a></li>
<li><a class="reference internal" href="#forward-message" id="id14">Forward message</a></li>
</ul>
</li>
<li><a class="reference internal" href="#receive-messages" id="id15">Receive messages</a></li>
<li><a class="reference internal" href="#actor-internal-api" id="id16">Actor internal API</a></li>
<li><a class="reference internal" href="#reply-to-messages" id="id17">Reply to messages</a><ul>
<li><a class="reference internal" href="#reply-using-the-channel" id="id18">Reply using the channel</a></li>
<li><a class="reference internal" href="#reply-using-the-reply-and-reply-methods" id="id19">Reply using the reply and reply_? methods</a></li>
<li><a class="reference internal" href="#reply-using-the-sender-reference" id="id20">Reply using the sender reference</a></li>
<li><a class="reference internal" href="#reply-using-the-sender-future" id="id21">Reply using the sender future</a></li>
<li><a class="reference internal" href="#summary-of-reply-semantics-and-options" id="id22">Summary of reply semantics and options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initial-receive-timeout" id="id23">Initial receive timeout</a></li>
<li><a class="reference internal" href="#starting-actors" id="id24">Starting actors</a></li>
<li><a class="reference internal" href="#stopping-actors" id="id25">Stopping actors</a></li>
<li><a class="reference internal" href="#poisonpill" id="id26">PoisonPill</a></li>
<li><a class="reference internal" href="#hotswap" id="id27">HotSwap</a><ul>
<li><a class="reference internal" href="#upgrade" id="id28">Upgrade</a></li>
</ul>
</li>
<li><a class="reference internal" href="#encoding-scala-actors-nested-receives-without-accidentally-leaking-memory-unnestedreceive" id="id29">Encoding Scala Actors nested receives without accidentally leaking memory: UnnestedReceive</a><ul>
<li><a class="reference internal" href="#downgrade" id="id30">Downgrade</a></li>
</ul>
</li>
<li><a class="reference internal" href="#killing-an-actor" id="id31">Killing an Actor</a></li>
<li><a class="reference internal" href="#actor-life-cycle" id="id32">Actor life-cycle</a></li>
<li><a class="reference internal" href="#extending-actors-using-partialfunction-chaining" id="id33">Extending Actors using PartialFunction chaining</a></li>
</ul>
</div>
</div>
<p>Module stability: <strong>SOLID</strong></p>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a> provides a higher level of abstraction for writing concurrent and distributed systems. It alleviates the developer from having to deal with explicit locking and thread management, making it easier to write correct concurrent and parallel systems. Actors were defined in the 1973 paper by Carl Hewitt but have been popularized by the Erlang language, and used for example at Ericsson with great success to build highly concurrent and reliable telecom systems.</p>
<p>The API of Akka’s Actors is similar to Scala Actors which has borrowed some of its syntax from Erlang.</p>
<p>The Akka 0.9 release introduced a new concept; ActorRef, which requires some refactoring. If you are new to Akka just read along, but if you have used Akka 0.6.x, 0.7.x and 0.8.x then you might be helped by the <a class="reference internal" href="../project/migration-guide-0.8.x-0.9.x.html"><em>0.8.x =&gt; 0.9.x migration guide</em></a></p>
<div class="section" id="creating-actors">
<h2><a class="toc-backref" href="#id3">Creating Actors</a><a class="headerlink" href="#creating-actors" title="Permalink to this headline">¶</a></h2>
<p>Actors can be created either by:</p>
<ul class="simple">
<li>Extending the Actor class and implementing the receive method.</li>
<li>Create an anonymous actor using one of the actor methods.</li>
</ul>
<div class="section" id="defining-an-actor-class">
<h3><a class="toc-backref" href="#id4">Defining an Actor class</a><a class="headerlink" href="#defining-an-actor-class" title="Permalink to this headline">¶</a></h3>
<p>Actor classes are implemented by extending the Actor class and implementing the <tt class="docutils literal"><span class="pre">receive</span></tt> method. The <tt class="docutils literal"><span class="pre">receive</span></tt> method should define a series of case statements (which has the type <tt class="docutils literal"><span class="pre">PartialFunction[Any,</span> <span class="pre">Unit]</span></tt>) that defines which messages your Actor can handle, using standard Scala pattern matching, along with the implementation of how the messages should be processed.</p>
<p>Here is an example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.event.EventHandler</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;test&quot;</span> <span class="k">=&gt;</span> <span class="nc">EventHandler</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;received test&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">EventHandler</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;received unknown message&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Please note that the Akka Actor <tt class="docutils literal"><span class="pre">receive</span></tt> message loop is exhaustive, which is different compared to Erlang and Scala Actors. This means that you need to provide a pattern match for all messages that it can accept and if you want to be able to handle unknown messages then you need to have a default case as in the example above.</p>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id5">Creating Actors</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="nc">Actor</span><span class="o">.</span><span class="n">actorOf</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">]</span>
<span class="n">myActor</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>
</pre></div>
</div>
<p>Normally you would want to import the <tt class="docutils literal"><span class="pre">actorOf</span></tt> method like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor._</span>

<span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">actorOf</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">]</span>
</pre></div>
</div>
<p>To avoid prefixing it with <tt class="docutils literal"><span class="pre">Actor</span></tt> every time you use it.</p>
<p>You can also start it in the same statement:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">actorOf</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">].</span><span class="n">start</span><span class="o">()</span>
</pre></div>
</div>
<p>The call to <tt class="docutils literal"><span class="pre">actorOf</span></tt> returns an instance of <tt class="docutils literal"><span class="pre">ActorRef</span></tt>. This is a handle to the <tt class="docutils literal"><span class="pre">Actor</span></tt> instance which you can use to interact with the <tt class="docutils literal"><span class="pre">Actor</span></tt>. The <tt class="docutils literal"><span class="pre">ActorRef</span></tt> is immutable and has a one to one relationship with the Actor it represents. The <tt class="docutils literal"><span class="pre">ActorRef</span></tt> is also serializable and network-aware. This means that you can serialize it, send it over the wire and use it on a remote host and it will still be representing the same Actor on the original node, across the network.</p>
</div>
<div class="section" id="creating-actors-with-non-default-constructor">
<h3><a class="toc-backref" href="#id6">Creating Actors with non-default constructor</a><a class="headerlink" href="#creating-actors-with-non-default-constructor" title="Permalink to this headline">¶</a></h3>
<p>If your Actor has a constructor that takes parameters then you can&#8217;t create it using <tt class="docutils literal"><span class="pre">actorOf[TYPE]</span></tt>. Instead you can use a variant of <tt class="docutils literal"><span class="pre">actorOf</span></tt> that takes a call-by-name block in which you can create the Actor in any way you like.</p>
<p>Here is an example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">actorOf</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyActor</span><span class="o">(..)).</span><span class="n">start</span><span class="o">()</span> <span class="c1">// allows passing in arguments into the MyActor constructor</span>
</pre></div>
</div>
</div>
<div class="section" id="running-a-block-of-code-asynchronously">
<h3><a class="toc-backref" href="#id7">Running a block of code asynchronously</a><a class="headerlink" href="#running-a-block-of-code-asynchronously" title="Permalink to this headline">¶</a></h3>
<p>Here we create a light-weight actor-based thread, that can be used to spawn off a task. Code blocks spawned up like this are always implicitly started, shut down and made eligible for garbage collection. The actor that is created &#8220;under the hood&#8221; is not reachable from the outside and there is no way of sending messages to it. It being an actor is only an implementation detail. It will only run the block in an event-based thread and exit once the block has run to completion.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">spawn</span> <span class="o">{</span>
  <span class="o">...</span> <span class="c1">// do stuff</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="identifying-actors">
<h2><a class="toc-backref" href="#id8">Identifying Actors</a><a class="headerlink" href="#identifying-actors" title="Permalink to this headline">¶</a></h2>
<p>Each Actor has two fields:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self.uuid</span></tt></li>
<li><tt class="docutils literal"><span class="pre">self.id</span></tt></li>
</ul>
<p>The difference is that the <tt class="docutils literal"><span class="pre">uuid</span></tt> is generated by the runtime, guaranteed to be unique and can&#8217;t be modified. While the <tt class="docutils literal"><span class="pre">id</span></tt> is modifiable by the user, and defaults to the Actor class name. You can retrieve Actors by both UUID and ID using the <tt class="docutils literal"><span class="pre">ActorRegistry</span></tt>, see the section further down for details.</p>
</div>
<div class="section" id="messages-and-immutability">
<h2><a class="toc-backref" href="#id9">Messages and immutability</a><a class="headerlink" href="#messages-and-immutability" title="Permalink to this headline">¶</a></h2>
<p><strong>IMPORTANT</strong>: Messages can be any kind of object but have to be immutable. Scala can’t enforce immutability (yet) so this has to be by convention. Primitives like String, Int, Boolean are always immutable. Apart from these the recommended approach is to use Scala case classes which are immutable (if you don’t explicitly expose the state) and works great with pattern matching at the receiver side.</p>
<p>Here is an example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// define the case class</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Register</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span>

<span class="c1">// create a new case class message</span>
<span class="k">val</span> <span class="n">message</span> <span class="k">=</span> <span class="nc">Register</span><span class="o">(</span><span class="n">user</span><span class="o">)</span>
</pre></div>
</div>
<p>Other good messages types are <tt class="docutils literal"><span class="pre">scala.Tuple2</span></tt>, <tt class="docutils literal"><span class="pre">scala.List</span></tt>, <tt class="docutils literal"><span class="pre">scala.Map</span></tt> which are all immutable and great for pattern matching.</p>
</div>
<div class="section" id="send-messages">
<h2><a class="toc-backref" href="#id10">Send messages</a><a class="headerlink" href="#send-messages" title="Permalink to this headline">¶</a></h2>
<p>Messages are sent to an Actor through one of the “bang” methods.</p>
<ul class="simple">
<li>! means “fire-and-forget”, e.g. send a message asynchronously and return immediately.</li>
<li>!! means “send-and-reply-eventually”, e.g. send a message asynchronously and wait for a reply through aFuture. Here you can specify a timeout. Using timeouts is very important. If no timeout is specified then the actor’s default timeout (set by the this.timeout variable in the actor) is used. This method returns an <tt class="docutils literal"><span class="pre">Option[Any]</span></tt> which will be either <tt class="docutils literal"><span class="pre">Some(result)</span></tt> if returning successfully or None if the call timed out.</li>
<li>!!! sends a message asynchronously and returns a <tt class="docutils literal"><span class="pre">Future</span></tt>.</li>
</ul>
<p>You can check if an Actor can handle a specific message by invoking the <tt class="docutils literal"><span class="pre">isDefinedAt</span></tt> method:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">if</span> <span class="o">(</span><span class="n">actor</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="n">message</span><span class="o">))</span> <span class="n">actor</span> <span class="o">!</span> <span class="n">message</span>
<span class="k">else</span> <span class="o">...</span>
</pre></div>
</div>
<div class="section" id="fire-forget">
<h3><a class="toc-backref" href="#id11">Fire-forget</a><a class="headerlink" href="#fire-forget" title="Permalink to this headline">¶</a></h3>
<p>This is the preferred way of sending messages. No blocking waiting for a message. This gives the best concurrency and scalability characteristics.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">actor</span> <span class="o">!</span> <span class="s">&quot;Hello&quot;</span>
</pre></div>
</div>
<p>If invoked from within an Actor, then the sending actor reference will be implicitly passed along with the message and available to the receiving Actor in its <tt class="docutils literal"><span class="pre">sender:</span> <span class="pre">Option[AnyRef]</span></tt> member field. He can use this to reply to the original sender or use the <tt class="docutils literal"><span class="pre">reply(message:</span> <span class="pre">Any)</span></tt> method.</p>
<p>If invoked from an instance that is <strong>not</strong> an Actor there will be no implicit sender passed along the message and you will get an IllegalStateException if you call <tt class="docutils literal"><span class="pre">self.reply(..)</span></tt>.</p>
</div>
<div class="section" id="send-and-receive-eventually">
<h3><a class="toc-backref" href="#id12">Send-And-Receive-Eventually</a><a class="headerlink" href="#send-and-receive-eventually" title="Permalink to this headline">¶</a></h3>
<p>Using <tt class="docutils literal"><span class="pre">!!</span></tt> will send a message to the receiving Actor asynchronously but it will wait for a reply on a <tt class="docutils literal"><span class="pre">Future</span></tt>, blocking the sender Actor until either:</p>
<ul class="simple">
<li>A reply is received, or</li>
<li>The Future times out</li>
</ul>
<p>You can pass an explicit time-out to the <tt class="docutils literal"><span class="pre">!!</span></tt> method and if none is specified then the default time-out defined in the sender Actor will be used.</p>
<p>The <tt class="docutils literal"><span class="pre">!!</span></tt> method returns an <tt class="docutils literal"><span class="pre">Option[Any]</span></tt> which will be either <tt class="docutils literal"><span class="pre">Some(result)</span></tt> if returning successfully, or <tt class="xref docutils literal"><span class="pre">None</span></tt> if the call timed out.
Here are some examples:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">resultOption</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">!!</span> <span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>
<span class="k">if</span> <span class="o">(</span><span class="n">resultOption</span><span class="o">.</span><span class="n">isDefined</span><span class="o">)</span> <span class="o">...</span> <span class="c1">// handle reply</span>
<span class="k">else</span> <span class="o">...</span> <span class="c1">// handle timeout</span>

<span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">!!</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">resultOption</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">reply</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle reply</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>        <span class="o">...</span> <span class="c1">// handle timeout</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="o">(</span><span class="n">actor</span> <span class="o">!!</span> <span class="s">&quot;Hello&quot;</span><span class="o">).</span><span class="n">getOrElse</span><span class="o">(</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">&quot;TIMEOUT&quot;</span><span class="o">))</span>

<span class="o">(</span><span class="n">actor</span> <span class="o">!!</span> <span class="s">&quot;Hello&quot;</span><span class="o">).</span><span class="n">foreach</span><span class="o">(</span><span class="n">result</span> <span class="k">=&gt;</span> <span class="o">...)</span> <span class="c1">// handle result</span>
</pre></div>
</div>
</div>
<div class="section" id="send-and-receive-future">
<h3><a class="toc-backref" href="#id13">Send-And-Receive-Future</a><a class="headerlink" href="#send-and-receive-future" title="Permalink to this headline">¶</a></h3>
<p>Using <tt class="docutils literal"><span class="pre">!!!</span></tt> will send a message to the receiving Actor asynchronously and will return a &#8216;Future&#8217;:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">!!!</span> <span class="s">&quot;Hello&quot;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="futures.html#futures-scala"><em>Futures (Scala)</em></a> for more information.</p>
</div>
<div class="section" id="forward-message">
<h3><a class="toc-backref" href="#id14">Forward message</a><a class="headerlink" href="#forward-message" title="Permalink to this headline">¶</a></h3>
<p>You can forward a message from one actor to another. This means that the original sender address/reference is maintained even though the message is going through a &#8216;mediator&#8217;. This can be useful when writing actors that work as routers, load-balancers, replicators etc.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">actor</span><span class="o">.</span><span class="n">forward</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="receive-messages">
<h2><a class="toc-backref" href="#id15">Receive messages</a><a class="headerlink" href="#receive-messages" title="Permalink to this headline">¶</a></h2>
<p>An Actor has to implement the <tt class="docutils literal"><span class="pre">receive</span></tt> method to receive messages:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">protected</span> <span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Unit</span><span class="o">]</span>
</pre></div>
</div>
<p>Note: Akka has an alias to the <tt class="docutils literal"><span class="pre">PartialFunction[Any,</span> <span class="pre">Unit]</span></tt> type called <tt class="docutils literal"><span class="pre">Receive</span></tt> (<tt class="docutils literal"><span class="pre">akka.actor.Actor.Receive</span></tt>), so you can use this type instead for clarity. But most often you don&#8217;t need to spell it out.</p>
<p>This method should return a <tt class="docutils literal"><span class="pre">PartialFunction</span></tt>, e.g. a ‘match/case’ clause in which the message can be matched against the different case clauses using Scala pattern matching. Here is an example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;Hello&quot;</span> <span class="k">=&gt;</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Received &#39;Hello&#39;&quot;</span><span class="o">)</span>

    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">&quot;unknown message&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="actor-internal-api">
<h2><a class="toc-backref" href="#id16">Actor internal API</a><a class="headerlink" href="#actor-internal-api" title="Permalink to this headline">¶</a></h2>
<p>The Actor trait contains almost no member fields or methods to invoke, you just use the Actor trait to implement the:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">receive</span></tt> message handler</li>
<li>life-cycle callbacks:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>preStart</li>
<li>postStop</li>
<li>preRestart</li>
<li>postRestart</li>
</ol>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">Actor</span></tt> trait has one single member field (apart from the <tt class="docutils literal"><span class="pre">log</span></tt> field from the mixed in <tt class="docutils literal"><span class="pre">Logging</span></tt> trait):</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">self</span><span class="k">:</span> <span class="kt">ActorRef</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">self</span></tt> field holds a reference to its <tt class="docutils literal"><span class="pre">ActorRef</span></tt> and it is this reference you want to access the Actor&#8217;s API. Here, for example, you find methods to reply to messages, send yourself messages, define timeouts, fault tolerance etc., start and stop etc.</p>
<p>However, for convenience you can import these functions and fields like below, which will allow you do drop the <tt class="docutils literal"><span class="pre">self</span></tt> prefix:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">self._</span>
  <span class="n">id</span> <span class="k">=</span> <span class="o">...</span>
  <span class="n">dispatcher</span> <span class="k">=</span> <span class="o">...</span>
  <span class="n">start</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>But in this documentation we will always prefix the calls with <tt class="docutils literal"><span class="pre">self</span></tt> for clarity.</p>
<p>Let&#8217;s start by looking how we can reply to messages in a convenient way using this <tt class="docutils literal"><span class="pre">ActorRef</span></tt> API.</p>
</div>
<div class="section" id="reply-to-messages">
<h2><a class="toc-backref" href="#id17">Reply to messages</a><a class="headerlink" href="#reply-to-messages" title="Permalink to this headline">¶</a></h2>
<div class="section" id="reply-using-the-channel">
<h3><a class="toc-backref" href="#id18">Reply using the channel</a><a class="headerlink" href="#reply-using-the-channel" title="Permalink to this headline">¶</a></h3>
<p>If you want to have a handle to an object to whom you can reply to the message, you can use the <tt class="docutils literal"><span class="pre">Channel</span></tt> abstraction.
Simply call <tt class="docutils literal"><span class="pre">self.channel</span></tt> and then you can forward that to others, store it away or otherwise until you want to reply, which you do by <tt class="docutils literal"><span class="pre">Channel</span> <span class="pre">!</span> <span class="pre">response</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
    <span class="n">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">!</span> <span class="n">result</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
    <span class="n">friend</span> <span class="n">forward</span> <span class="n">self</span><span class="o">.</span><span class="n">channel</span>
</pre></div>
</div>
<p>We recommend that you as first choice use the channel abstraction instead of the other ways described in the following sections.</p>
</div>
<div class="section" id="reply-using-the-reply-and-reply-methods">
<h3><a class="toc-backref" href="#id19">Reply using the reply and reply_? methods</a><a class="headerlink" href="#reply-using-the-reply-and-reply-methods" title="Permalink to this headline">¶</a></h3>
<p>If you want to send a message back to the original sender of the message you just received then you can use the <tt class="docutils literal"><span class="pre">reply(..)</span></tt> method.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
  <span class="n">self</span><span class="o">.</span><span class="n">reply</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
</pre></div>
</div>
<p>In this case the <tt class="docutils literal"><span class="pre">result</span></tt> will be send back to the Actor that sent the <tt class="docutils literal"><span class="pre">request</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">reply</span></tt> method throws an <tt class="docutils literal"><span class="pre">IllegalStateException</span></tt> if unable to determine what to reply to, e.g. the sender is not an actor. You can also use the more forgiving <tt class="docutils literal"><span class="pre">reply_?</span></tt> method which returns <tt class="docutils literal"><span class="pre">true</span></tt> if reply was sent, and <tt class="docutils literal"><span class="pre">false</span></tt> if unable to determine what to reply to.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">self</span><span class="o">.</span><span class="n">reply_?</span><span class="o">(</span><span class="n">result</span><span class="o">))</span> <span class="o">...</span><span class="c1">// success</span>
  <span class="k">else</span> <span class="o">...</span> <span class="c1">// handle failure</span>
</pre></div>
</div>
</div>
<div class="section" id="reply-using-the-sender-reference">
<h3><a class="toc-backref" href="#id20">Reply using the sender reference</a><a class="headerlink" href="#reply-using-the-sender-reference" title="Permalink to this headline">¶</a></h3>
<p>If the sender is an Actor then its reference will be implicitly passed along together with the message and will end up in the <tt class="docutils literal"><span class="pre">sender:</span> <span class="pre">Option[ActorRef]</span></tt> member field in the <tt class="docutils literal"><span class="pre">ActorRef</span></tt>. This means that you can use this field to send a message back to the sender.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// receiver code</span>
<span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
  <span class="n">self</span><span class="o">.</span><span class="n">sender</span><span class="o">.</span><span class="n">get</span> <span class="o">!</span> <span class="n">result</span>
</pre></div>
</div>
<p>It&#8217;s important to know that <tt class="docutils literal"><span class="pre">sender.get</span></tt> will throw an exception if the <tt class="docutils literal"><span class="pre">sender</span></tt> is not defined, e.g. the <tt class="docutils literal"><span class="pre">Option</span></tt> is <tt class="xref docutils literal"><span class="pre">None</span></tt>. You can check if it is defined by invoking the <tt class="docutils literal"><span class="pre">sender.isDefined</span></tt> method, but a more elegant solution is to use <tt class="docutils literal"><span class="pre">foreach</span></tt> which will only be executed if the sender is defined in the <tt class="docutils literal"><span class="pre">sender</span></tt> member <tt class="docutils literal"><span class="pre">Option</span></tt> field. If it is not, then the operation in the <tt class="docutils literal"><span class="pre">foreach</span></tt> method is ignored.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// receiver code</span>
<span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
  <span class="n">self</span><span class="o">.</span><span class="n">sender</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="k">_</span> <span class="o">!</span> <span class="n">result</span><span class="o">)</span>
</pre></div>
</div>
<p>The same pattern holds for using the <tt class="docutils literal"><span class="pre">senderFuture</span></tt> in the section below.</p>
</div>
<div class="section" id="reply-using-the-sender-future">
<h3><a class="toc-backref" href="#id21">Reply using the sender future</a><a class="headerlink" href="#reply-using-the-sender-future" title="Permalink to this headline">¶</a></h3>
<p>If a message was sent with the <tt class="docutils literal"><span class="pre">!!</span></tt> or <tt class="docutils literal"><span class="pre">!!!</span></tt> methods, which both implements request-reply semantics using Future&#8217;s, then you either have the option of replying using the <tt class="docutils literal"><span class="pre">reply</span></tt> method as above. This method will then resolve the Future. But you can also get a reference to the Future directly and resolve it yourself or if you would like to store it away to resolve it later, or pass it on to some other Actor to resolve it.</p>
<p>The reference to the Future resides in the <tt class="docutils literal"><span class="pre">senderFuture:</span> <span class="pre">Option[CompletableFuture[_]]</span></tt> member field in the <tt class="docutils literal"><span class="pre">ActorRef</span></tt> class.</p>
<p>Here is an example of how it can be used:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
    <span class="n">self</span><span class="o">.</span><span class="n">senderFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">completeWithResult</span><span class="o">(</span><span class="n">result</span><span class="o">))</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">e</span> <span class="k">=&gt;</span>
      <span class="n">senderFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">completeWithException</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>
  <span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="summary-of-reply-semantics-and-options">
<h3><a class="toc-backref" href="#id22">Summary of reply semantics and options</a><a class="headerlink" href="#summary-of-reply-semantics-and-options" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self.reply(...)</span></tt> can be used to reply to an <tt class="docutils literal"><span class="pre">Actor</span></tt> or a <tt class="docutils literal"><span class="pre">Future</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">self.sender</span></tt> is a reference to the <tt class="docutils literal"><span class="pre">Actor</span></tt> you can reply to, if it exists</li>
<li><tt class="docutils literal"><span class="pre">self.senderFuture</span></tt> is a reference to the <tt class="docutils literal"><span class="pre">Future</span></tt> you can reply to, if it exists</li>
<li><tt class="docutils literal"><span class="pre">self.channel</span></tt> is a reference providing an abstraction to either <tt class="docutils literal"><span class="pre">self.sender</span></tt> or <tt class="docutils literal"><span class="pre">self.senderFuture</span></tt> if one is set, providing a single reference to store and reply to (the reference equivalent to the <tt class="docutils literal"><span class="pre">reply(...)</span></tt> method).</li>
<li><tt class="docutils literal"><span class="pre">self.sender</span></tt> and <tt class="docutils literal"><span class="pre">self.senderFuture</span></tt> will never be set at the same time, as there can only be one reference to accept a reply.</li>
</ul>
</div>
</div>
<div class="section" id="initial-receive-timeout">
<h2><a class="toc-backref" href="#id23">Initial receive timeout</a><a class="headerlink" href="#initial-receive-timeout" title="Permalink to this headline">¶</a></h2>
<p>A timeout mechanism can be used to receive a message when no initial message is received within a certain time. To receive this timeout you have to set the <tt class="docutils literal"><span class="pre">receiveTimeout</span></tt> property and declare a case handing the ReceiveTimeout object.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">self</span><span class="o">.</span><span class="n">receiveTimeout</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">30000L</span><span class="o">)</span> <span class="c1">// 30 seconds</span>

<span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;Hello&quot;</span> <span class="k">=&gt;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Received &#39;Hello&#39;&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">&quot;received timeout&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This mechanism also work for hotswapped receive functions. Every time a <tt class="docutils literal"><span class="pre">HotSwap</span></tt> is sent, the receive timeout is reset and rescheduled.</p>
</div>
<div class="section" id="starting-actors">
<h2><a class="toc-backref" href="#id24">Starting actors</a><a class="headerlink" href="#starting-actors" title="Permalink to this headline">¶</a></h2>
<p>Actors are started by invoking the <tt class="docutils literal"><span class="pre">start</span></tt> method.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">actor</span> <span class="k">=</span> <span class="n">actorOf</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">]</span>
<span class="n">actor</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>
</pre></div>
</div>
<p>You can create and start the <tt class="docutils literal"><span class="pre">Actor</span></tt> in a one liner like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">actor</span> <span class="k">=</span> <span class="n">actorOf</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">].</span><span class="n">start</span><span class="o">()</span>
</pre></div>
</div>
<p>When you start the <tt class="docutils literal"><span class="pre">Actor</span></tt> then it will automatically call the <tt class="docutils literal"><span class="pre">def</span> <span class="pre">preStart</span></tt> callback method on the <tt class="docutils literal"><span class="pre">Actor</span></tt> trait. This is an excellent place to add initialization code for the actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">...</span> <span class="c1">// initialization code</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stopping-actors">
<h2><a class="toc-backref" href="#id25">Stopping actors</a><a class="headerlink" href="#stopping-actors" title="Permalink to this headline">¶</a></h2>
<p>Actors are stopped by invoking the <tt class="docutils literal"><span class="pre">stop</span></tt> method.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">actor</span><span class="o">.</span><span class="n">stop</span><span class="o">()</span>
</pre></div>
</div>
<p>When stop is called then a call to the <tt class="docutils literal"><span class="pre">def</span> <span class="pre">postStop</span></tt> callback method will take place. The <tt class="docutils literal"><span class="pre">Actor</span></tt> can use this callback to implement shutdown behavior.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">...</span> <span class="c1">// clean up resources</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You can shut down all Actors in the system by invoking:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Actor</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">shutdownAll</span><span class="o">()</span>
</pre></div>
</div>
</div>
<div class="section" id="poisonpill">
<h2><a class="toc-backref" href="#id26">PoisonPill</a><a class="headerlink" href="#poisonpill" title="Permalink to this headline">¶</a></h2>
<p>You can also send an actor the <tt class="docutils literal"><span class="pre">akka.actor.PoisonPill</span></tt> message, which will stop the actor when the message is processed.</p>
<p>If the sender is a <tt class="docutils literal"><span class="pre">Future</span></tt> (e.g. the message is sent with <tt class="docutils literal"><span class="pre">!!</span></tt> or <tt class="docutils literal"><span class="pre">!!!</span></tt>), the <tt class="docutils literal"><span class="pre">Future</span></tt> will be completed with an <tt class="docutils literal"><span class="pre">akka.actor.ActorKilledException(&quot;PoisonPill&quot;)</span></tt>.</p>
</div>
<div class="section" id="hotswap">
<h2><a class="toc-backref" href="#id27">HotSwap</a><a class="headerlink" href="#hotswap" title="Permalink to this headline">¶</a></h2>
<div class="section" id="upgrade">
<h3><a class="toc-backref" href="#id28">Upgrade</a><a class="headerlink" href="#upgrade" title="Permalink to this headline">¶</a></h3>
<p>Akka supports hotswapping the Actor’s message loop (e.g. its implementation) at runtime. There are two ways you can do that:</p>
<ul class="simple">
<li>Send a <tt class="docutils literal"><span class="pre">HotSwap</span></tt> message to the Actor.</li>
<li>Invoke the <tt class="docutils literal"><span class="pre">become</span></tt> method from within the Actor.</li>
</ul>
<p>Both of these takes a <tt class="docutils literal"><span class="pre">ActorRef</span> <span class="pre">=&gt;</span> <span class="pre">PartialFunction[Any,</span> <span class="pre">Unit]</span></tt> that implements the new message handler. The hotswapped code is kept in a Stack which can be pushed and popped.</p>
<p>To hotswap the Actor body using the <tt class="docutils literal"><span class="pre">HotSwap</span></tt> message:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">actor</span> <span class="o">!</span> <span class="nc">HotSwap</span><span class="o">(</span> <span class="n">self</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">message</span> <span class="k">=&gt;</span> <span class="n">self</span><span class="o">.</span><span class="n">reply</span><span class="o">(</span><span class="s">&quot;hotswapped body&quot;</span><span class="o">)</span>
<span class="o">})</span>
</pre></div>
</div>
<p>Using the <tt class="docutils literal"><span class="pre">HotSwap</span></tt> message for hotswapping has its limitations. You can not replace it with any code that uses the Actor&#8217;s <tt class="docutils literal"><span class="pre">self</span></tt> reference. If you need to do that the the <tt class="docutils literal"><span class="pre">become</span></tt> method is better.</p>
<p>To hotswap the Actor using <tt class="docutils literal"><span class="pre">become</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">angry</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;foo&quot;</span> <span class="k">=&gt;</span> <span class="n">self</span> <span class="n">reply</span> <span class="s">&quot;I am already angry!!!&quot;</span>
  <span class="k">case</span> <span class="s">&quot;bar&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">happy</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">happy</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;bar&quot;</span> <span class="k">=&gt;</span> <span class="n">self</span> <span class="n">reply</span> <span class="s">&quot;I am already happy :-)&quot;</span>
  <span class="k">case</span> <span class="s">&quot;foo&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">angry</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;foo&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">angry</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">&quot;bar&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">happy</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">become</span></tt> method is useful for many different things, but a particular nice example of it is in example where it is used to implement a Finite State Machine (FSM): <a class="reference external" href="http://github.com/akka/akka/blob/master/akka-samples/akka-sample-fsm/src/main/scala/DiningHakkersOnBecome.scala">Dining Hakkers</a></p>
<p>Here is another little cute example of <tt class="docutils literal"><span class="pre">become</span></tt> and <tt class="docutils literal"><span class="pre">unbecome</span></tt> in action:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">object</span> <span class="nc">Swap</span>
<span class="k">class</span> <span class="nc">Swapper</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
 <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
   <span class="k">case</span> <span class="nc">Swap</span> <span class="k">=&gt;</span>
     <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hi&quot;</span><span class="o">)</span>
     <span class="n">become</span> <span class="o">{</span>
       <span class="k">case</span> <span class="nc">Swap</span> <span class="k">=&gt;</span>
         <span class="n">println</span><span class="o">(</span><span class="s">&quot;Ho&quot;</span><span class="o">)</span>
         <span class="n">unbecome</span><span class="o">()</span> <span class="c1">// resets the latest &#39;become&#39; (just for fun)</span>
     <span class="o">}</span>
 <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">swap</span> <span class="k">=</span> <span class="n">actorOf</span><span class="o">[</span><span class="kt">Swapper</span><span class="o">].</span><span class="n">start</span><span class="o">()</span>

<span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// prints Hi</span>
<span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// prints Ho</span>
<span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// prints Hi</span>
<span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// prints Ho</span>
<span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// prints Hi</span>
<span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// prints Ho</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="encoding-scala-actors-nested-receives-without-accidentally-leaking-memory-unnestedreceive">
<h2>Encoding Scala Actors nested receives without accidentally leaking memory: <a class="reference external" href="https://gist.github.com/797035">UnnestedReceive</a><a class="headerlink" href="#encoding-scala-actors-nested-receives-without-accidentally-leaking-memory-unnestedreceive" title="Permalink to this headline">¶</a></h2>
<div class="section" id="downgrade">
<h3><a class="toc-backref" href="#id30">Downgrade</a><a class="headerlink" href="#downgrade" title="Permalink to this headline">¶</a></h3>
<p>Since the hotswapped code is pushed to a Stack you can downgrade the code as well. There are two ways you can do that:</p>
<ul class="simple">
<li>Send the Actor a <tt class="docutils literal"><span class="pre">RevertHotswap</span></tt> message</li>
<li>Invoke the <tt class="docutils literal"><span class="pre">unbecome</span></tt> method from within the Actor.</li>
</ul>
<p>Both of these will pop the Stack and replace the Actor&#8217;s implementation with the <tt class="docutils literal"><span class="pre">PartialFunction[Any,</span> <span class="pre">Unit]</span></tt> that is at the top of the Stack.</p>
<p>Revert the Actor body using the <tt class="docutils literal"><span class="pre">RevertHotSwap</span></tt> message:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">actor</span> <span class="o">!</span> <span class="nc">RevertHotSwap</span>
</pre></div>
</div>
<p>Revert the Actor body using the <tt class="docutils literal"><span class="pre">unbecome</span></tt> method:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;revert&quot;</span> <span class="k">=&gt;</span> <span class="n">unbecome</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="killing-an-actor">
<h2><a class="toc-backref" href="#id31">Killing an Actor</a><a class="headerlink" href="#killing-an-actor" title="Permalink to this headline">¶</a></h2>
<p>You can kill an actor by sending a <tt class="docutils literal"><span class="pre">Kill</span></tt> message. This will restart the actor through regular supervisor semantics.</p>
<p>Use it like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// kill the actor called &#39;victim&#39;</span>
<span class="n">victim</span> <span class="o">!</span> <span class="nc">Kill</span>
</pre></div>
</div>
</div>
<div class="section" id="actor-life-cycle">
<h2><a class="toc-backref" href="#id32">Actor life-cycle</a><a class="headerlink" href="#actor-life-cycle" title="Permalink to this headline">¶</a></h2>
<p>The actor has a well-defined non-circular life-cycle.</p>
<div class="highlight-scala"><pre>NEW (newly created actor) - can't receive messages (yet)
    =&gt; STARTED (when 'start' is invoked) - can receive messages
        =&gt; SHUT DOWN (when 'exit' or 'stop' is invoked) - can't do anything</pre>
</div>
</div>
<div class="section" id="extending-actors-using-partialfunction-chaining">
<h2><a class="toc-backref" href="#id33">Extending Actors using PartialFunction chaining</a><a class="headerlink" href="#extending-actors-using-partialfunction-chaining" title="Permalink to this headline">¶</a></h2>
<p>A bit advanced but very useful way of defining a base message handler and then extend that, either through inheritance or delegation, is to use <tt class="docutils literal"><span class="pre">PartialFunction.orElse</span></tt> chaining.</p>
<p>In generic base Actor:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor.Receive</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">GenericActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="c1">// to be defined in subclassing actor</span>
  <span class="k">def</span> <span class="n">specificMessageHandler</span><span class="k">:</span> <span class="kt">Receive</span>

  <span class="c1">// generic message handler</span>
  <span class="k">def</span> <span class="n">genericMessageHandler</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="n">printf</span><span class="o">(</span><span class="s">&quot;generic: %s\n&quot;</span><span class="o">,</span> <span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">specificMessageHandler</span> <span class="n">orElse</span> <span class="n">genericMessageHandler</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In subclassing Actor:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SpecificActor</span> <span class="k">extends</span> <span class="nc">GenericActor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">specificMessageHandler</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span><span class="k">:</span> <span class="kt">MyMsg</span>  <span class="o">=&gt;</span> <span class="n">printf</span><span class="o">(</span><span class="s">&quot;specific: %s\n&quot;</span><span class="o">,</span> <span class="n">event</span><span class="o">.</span><span class="n">subject</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">MyMsg</span><span class="o">(</span><span class="n">subject</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="index.html">Scala API</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="typed-actors.html">Typed Actors (Scala)</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2011, Typesafe Inc.
      Last updated on Jun 29, 2011.
    </div>
  </body>
</html>