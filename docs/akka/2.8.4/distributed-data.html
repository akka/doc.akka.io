<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Classic Distributed Data &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/distributed-data.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page-8.css"/>
<link rel="stylesheet" type="text/css" href="css/banner-2.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png"/>
<link rel="manifest" href="images/manifest.json"/>
<meta name="msapplication-TileImage" content="images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"  type="text/javascript" charset="UTF-8" data-domain-script="28b912e7-09e9-43d5-91e4-3d1897044004" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics NOTE this will stop processing data July 1st 2023. At which point this embed code can be removed-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>

<!-- Google Tag Manager: Updated May 17th 2023 - Cookie Compliance checks have been moved into Google Tag Manager -->
<script type="text/javascript">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>

</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="oss-wrapper">
<div class="oss-brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com">
<img class="lightbend-logo" src="images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="oss-ad no-drop-down">
<nav id="lightbendRotator" class="lightbend-rotator">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Promo Rotator - Lightbend Changed its Software Licensing Model for Akka Technology. [License FAQ] - Akka Banner" href="https://www.lightbend.com/akka/license-faq">
<strong>Lightbend</strong> Changed its Software Licensing Model for Akka Technology. <span class="akka-btn">License FAQ</span>
</a>
</nav>
</div>
</div>
</div>

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.4
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a>
  <ul>
    <li><a href="index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="index-cluster.html" class="page">Classic Clustering</a>
    <ul>
      <li><a href="cluster-usage.html" class="page">Classic Cluster Usage</a></li>
      <li><a href="cluster-routing.html" class="page">Classic Cluster Aware Routers</a></li>
      <li><a href="cluster-singleton.html" class="page">Classic Cluster Singleton</a></li>
      <li><a href="distributed-pub-sub.html" class="page">Classic Distributed Publish Subscribe in Cluster</a></li>
      <li><a href="cluster-client.html" class="page">Classic Cluster Client</a></li>
      <li><a href="cluster-sharding.html" class="page">Classic Cluster Sharding</a></li>
      <li><a href="cluster-metrics.html" class="page">Classic Cluster Metrics Extension</a></li>
      <li><a href="distributed-data.html#classic-distributed-data" class="active page">Classic Distributed Data</a>
      <ul>
        <li><a href="distributed-data.html#dependency" class="header">Dependency</a></li>
        <li><a href="distributed-data.html#introduction" class="header">Introduction</a></li>
        <li><a href="distributed-data.html#using-the-replicator" class="header">Using the Replicator</a></li>
        <li><a href="distributed-data.html#replicated-data-types" class="header">Replicated data types</a></li>
        <li><a href="distributed-data.html#durable-storage" class="header">Durable Storage</a></li>
        <li><a href="distributed-data.html#limitations" class="header">Limitations</a></li>
        <li><a href="distributed-data.html#learn-more-about-crdts" class="header">Learn More about CRDTs</a></li>
        <li><a href="distributed-data.html#configuration" class="header">Configuration</a></li>
      </ul></li>
      <li><a href="cluster-dc.html" class="page">Classic Multi-DC Cluster</a></li>
      <li><a href="serialization-classic.html" class="page">Classic Serialization</a></li>
    </ul></li>
    <li><a href="index-network.html" class="page">Classic Networking</a></li>
    <li><a href="index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.4
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a>
  <ul>
    <li><a href="index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="index-cluster.html" class="page">Classic Clustering</a>
    <ul>
      <li><a href="cluster-usage.html" class="page">Classic Cluster Usage</a></li>
      <li><a href="cluster-routing.html" class="page">Classic Cluster Aware Routers</a></li>
      <li><a href="cluster-singleton.html" class="page">Classic Cluster Singleton</a></li>
      <li><a href="distributed-pub-sub.html" class="page">Classic Distributed Publish Subscribe in Cluster</a></li>
      <li><a href="cluster-client.html" class="page">Classic Cluster Client</a></li>
      <li><a href="cluster-sharding.html" class="page">Classic Cluster Sharding</a></li>
      <li><a href="cluster-metrics.html" class="page">Classic Cluster Metrics Extension</a></li>
      <li><a href="distributed-data.html#classic-distributed-data" class="active page">Classic Distributed Data</a>
      <ul>
        <li><a href="distributed-data.html#dependency" class="header">Dependency</a></li>
        <li><a href="distributed-data.html#introduction" class="header">Introduction</a></li>
        <li><a href="distributed-data.html#using-the-replicator" class="header">Using the Replicator</a></li>
        <li><a href="distributed-data.html#replicated-data-types" class="header">Replicated data types</a></li>
        <li><a href="distributed-data.html#durable-storage" class="header">Durable Storage</a></li>
        <li><a href="distributed-data.html#limitations" class="header">Limitations</a></li>
        <li><a href="distributed-data.html#learn-more-about-crdts" class="header">Learn More about CRDTs</a></li>
        <li><a href="distributed-data.html#configuration" class="header">Configuration</a></li>
      </ul></li>
      <li><a href="cluster-dc.html" class="page">Classic Multi-DC Cluster</a></li>
      <li><a href="serialization-classic.html" class="page">Classic Serialization</a></li>
    </ul></li>
    <li><a href="index-network.html" class="page">Classic Networking</a></li>
    <li><a href="index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#classic-distributed-data" name="classic-distributed-data" class="anchor"><span class="anchor-link"></span></a>Classic Distributed Data</h1><div class="callout note "><div class="callout-title">Note</div>
<p>Akka Classic pertains to the original Actor APIs, which have been improved by more type safe and guided Actor APIs. Akka Classic is still fully supported and existing applications can continue to use the classic APIs. It is also possible to use the new Actor APIs together with classic actors in the same ActorSystem, see <a href="typed/coexisting.html">coexistence</a>. For new projects we recommend using <a href="typed/actors.html">the new Actor API</a>.</p></div>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html">Distributed Data</a>.</p>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>The Akka dependencies are available from Akka&rsquo;s library repository. To access them there, you need to configure the URL for this repository.</p><dl class="repository"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">resolvers += "Akka library repository".at("https://repo.akka.io/maven")
</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;project&gt
  ...
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;akka-repository&lt;/id&gt;
      &lt;name>Akka library repository&lt;/name&gt;
      &lt;url>https://repo.akka.io/maven&lt;/url&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt
&lt;/project&gt;
</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">repositories {
    mavenCentral()
    maven {
        url "https://repo.akka.io/maven"
    }
}
</code></pre></dd></dl>
<p>To use Akka Distributed Data, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val AkkaVersion = "2.8.4"
libraryDependencies += "com.typesafe.akka" %% "akka-distributed-data" % AkkaVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
      &lt;artifactId&gt;akka-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.8.4&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
    &lt;artifactId&gt;akka-distributed-data_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("com.typesafe.akka:akka-bom_${versions.ScalaBinary}:2.8.4")

  implementation "com.typesafe.akka:akka-distributed-data_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#introduction">Distributed Data - Introduction</a>.</p>
<h2><a href="#using-the-replicator" name="using-the-replicator" class="anchor"><span class="anchor-link"></span></a>Using the Replicator</h2>
<p>The <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator.html" title="akka.cluster.ddata.Replicator"><code>Replicator</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.html" title="akka.cluster.ddata.Replicator"><code>Replicator</code></a></span> actor provides the API for interacting with the data. The <code>Replicator</code> actor must be started on each node in the cluster, or group of nodes tagged with a specific role. It communicates with other <code>Replicator</code> instances with the same path (without address) that are running on other nodes . For convenience it can be used with the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/DistributedData.html" title="akka.cluster.ddata.DistributedData"><code>DistributedData</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/DistributedData.html" title="akka.cluster.ddata.DistributedData"><code>DistributedData</code></a></span> extension but it can also be started as an ordinary actor using the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$.html#props(settings:akka.cluster.ddata.ReplicatorSettings):akka.actor.Props" title="akka.cluster.ddata.Replicator"><code>Replicator.props</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.html#props(akka.cluster.ddata.ReplicatorSettings)" title="akka.cluster.ddata.Replicator"><code>Replicator.props</code></a></span>. If it is started as an ordinary actor it is important that it is given the same name, started on same path, on all nodes.</p>
<p>Cluster members with status <a href="typed/cluster-membership.html#weakly-up">WeaklyUp</a>, will participate in Distributed Data. This means that the data will be replicated to the <code>WeaklyUp</code> nodes with the background gossip protocol. Note that it will not participate in any actions where the consistency mode is to read/write from all nodes or the majority of nodes. The <code>WeaklyUp</code> node is not counted as part of the cluster. So 3 nodes + 5 <code>WeaklyUp</code> is essentially a 3 node cluster as far as consistent actions are concerned.</p>
<p>Below is an example of an actor that schedules tick messages to itself and for each tick adds or removes elements from a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/ORSet.html" title="akka.cluster.ddata.ORSet"><code>ORSet</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/ORSet.html" title="akka.cluster.ddata.ORSet"><code>ORSet</code></a></span> (observed-remove set). It also subscribes to changes of this.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L48-L97" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import java.util.concurrent.ThreadLocalRandom
import akka.actor.Actor
import akka.actor.ActorLogging
import akka.cluster.Cluster
import akka.cluster.ddata.DistributedData
import akka.cluster.ddata.ORSet
import akka.cluster.ddata.ORSetKey
import akka.cluster.ddata.Replicator
import akka.cluster.ddata.Replicator._

object DataBot {
  private case object Tick
}

class DataBot extends Actor with ActorLogging {
  import DataBot._

  val replicator = DistributedData(context.system).replicator
  implicit val node: SelfUniqueAddress = DistributedData(context.system).selfUniqueAddress

  import context.dispatcher
  val tickTask = context.system.scheduler.scheduleWithFixedDelay(5.seconds, 5.seconds, self, Tick)

  val DataKey = ORSetKey[String](&quot;key&quot;)

  replicator ! Subscribe(DataKey, self)

  def receive = {
    case Tick =&gt;
      val s = ThreadLocalRandom.current().nextInt(97, 123).toChar.toString
      if (ThreadLocalRandom.current().nextBoolean()) {
        // add
        log.info(&quot;Adding: {}&quot;, s)
        replicator ! Update(DataKey, ORSet.empty[String], WriteLocal)(_ :+ s)
      } else {
        // remove
        log.info(&quot;Removing: {}&quot;, s)
        replicator ! Update(DataKey, ORSet.empty[String], WriteLocal)(_.remove(s))
      }

    case _: UpdateResponse[_] =&gt; // ignore

    case c @ Changed(DataKey) =&gt;
      val data = c.get(DataKey)
      log.info(&quot;Current elements: {}&quot;, data.elements)
  }

  override def postStop(): Unit = tickTask.cancel()

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DataBot.java#L8-L100" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.actor.AbstractActor;
import akka.actor.ActorRef;
import akka.actor.Cancellable;
import akka.cluster.ddata.DistributedData;
import akka.cluster.ddata.Key;
import akka.cluster.ddata.ORSet;
import akka.cluster.ddata.ORSetKey;
import akka.cluster.ddata.Replicator;
import akka.cluster.ddata.Replicator.Changed;
import akka.cluster.ddata.Replicator.Subscribe;
import akka.cluster.ddata.Replicator.Update;
import akka.cluster.ddata.Replicator.UpdateResponse;
import akka.cluster.ddata.SelfUniqueAddress;
import akka.event.Logging;
import akka.event.LoggingAdapter;
import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

public class DataBot extends AbstractActor {

  private static final String TICK = &quot;tick&quot;;

  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  private final ActorRef replicator = DistributedData.get(getContext().getSystem()).replicator();
  private final SelfUniqueAddress node =
      DistributedData.get(getContext().getSystem()).selfUniqueAddress();

  private final Cancellable tickTask =
      getContext()
          .getSystem()
          .scheduler()
          .scheduleWithFixedDelay(
              Duration.ofSeconds(5),
              Duration.ofSeconds(5),
              getSelf(),
              TICK,
              getContext().getDispatcher(),
              getSelf());

  private final Key&lt;ORSet&lt;String&gt;&gt; dataKey = ORSetKey.create(&quot;key&quot;);

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(String.class, a -&gt; a.equals(TICK), a -&gt; receiveTick())
        .match(
            Changed.class,
            c -&gt; c.key().equals(dataKey),
            c -&gt; receiveChanged((Changed&lt;ORSet&lt;String&gt;&gt;) c))
        .match(UpdateResponse.class, r -&gt; receiveUpdateResponse())
        .build();
  }

  private void receiveTick() {
    String s = String.valueOf((char) ThreadLocalRandom.current().nextInt(97, 123));
    if (ThreadLocalRandom.current().nextBoolean()) {
      // add
      log.info(&quot;Adding: {}&quot;, s);
      Update&lt;ORSet&lt;String&gt;&gt; update =
          new Update&lt;&gt;(dataKey, ORSet.create(), Replicator.writeLocal(), curr -&gt; curr.add(node, s));
      replicator.tell(update, getSelf());
    } else {
      // remove
      log.info(&quot;Removing: {}&quot;, s);
      Update&lt;ORSet&lt;String&gt;&gt; update =
          new Update&lt;&gt;(
              dataKey, ORSet.create(), Replicator.writeLocal(), curr -&gt; curr.remove(node, s));
      replicator.tell(update, getSelf());
    }
  }

  private void receiveChanged(Changed&lt;ORSet&lt;String&gt;&gt; c) {
    ORSet&lt;String&gt; data = c.dataValue();
    log.info(&quot;Current elements: {}&quot;, data.getElements());
  }

  private void receiveUpdateResponse() {
    // ignore
  }

  @Override
  public void preStart() {
    Subscribe&lt;ORSet&lt;String&gt;&gt; subscribe = new Subscribe&lt;&gt;(dataKey, getSelf());
    replicator.tell(subscribe, ActorRef.noSender());
  }

  @Override
  public void postStop() {
    tickTask.cancel();
  }
}</code></pre></dd>
</dl>
<a id="replicator-update"></a>
<h3><a href="#update" name="update" class="anchor"><span class="anchor-link"></span></a>Update</h3>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#update">Distributed Data - Update</a>.</p>
<p>To modify and replicate a data value you send a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Replicator.Update</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Replicator.Update</code></a></span> message to the local <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator.html" title="akka.cluster.ddata.Replicator"><code>Replicator</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.html" title="akka.cluster.ddata.Replicator"><code>Replicator</code></a></span>.</p>
<p>The current data value for the <code>key</code> of the <code>Update</code> is passed as parameter to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Update.html#modify:Option[A]=%3EA" title="akka.cluster.ddata.Replicator.Update"><code>modify</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Update.html#modify()" title="akka.cluster.ddata.Replicator.Update"><code>modify()</code></a></span> function of the <code>Update</code>. The function is supposed to return the new value of the data, which will then be replicated according to the given consistency level.</p>
<p>The <code>modify</code> function is called by the <code>Replicator</code> actor and must therefore be a pure function that only uses the data parameter and stable fields from enclosing scope. It must for example not access the sender (<span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/Actor.html#sender():akka.actor.ActorRef" title="akka.actor.Actor"><code>sender()</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/AbstractActor.html#getSender()" title="akka.actor.AbstractActor"><code>getSender()</code></a></span>) reference of an enclosing actor.</p>
<p><code>Update</code> is intended to only be sent from an actor running in same local <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span>  as the <code>Replicator</code>, because the <code>modify</code> function is typically not serializable.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L110-L127" target="_blank" title="Go to snippet source">source</a><code class="language-scala">implicit val node: SelfUniqueAddress = DistributedData(system).selfUniqueAddress
val replicator = DistributedData(system).replicator

val Counter1Key = PNCounterKey(&quot;counter1&quot;)
val Set1Key = GSetKey[String](&quot;set1&quot;)
val Set2Key = ORSetKey[String](&quot;set2&quot;)
val ActiveFlagKey = FlagKey(&quot;active&quot;)

replicator ! Update(Counter1Key, PNCounter(), WriteLocal)(_ :+ 1)

val writeTo3 = WriteTo(n = 3, timeout = 1.second)
replicator ! Update(Set1Key, GSet.empty[String], writeTo3)(_ + &quot;hello&quot;)

val writeMajority = WriteMajority(timeout = 5.seconds)
replicator ! Update(Set2Key, ORSet.empty[String], writeMajority)(_ :+ &quot;hello&quot;)

val writeAll = WriteAll(timeout = 5.seconds)
replicator ! Update(ActiveFlagKey, Flag.Disabled, writeAll)(_.switchOn)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L47-L119" target="_blank" title="Go to snippet source">source</a><code class="language-java">class DemonstrateUpdate extends AbstractActor {
  final SelfUniqueAddress node =
      DistributedData.get(getContext().getSystem()).selfUniqueAddress();
  final ActorRef replicator = DistributedData.get(getContext().getSystem()).replicator();

  final Key&lt;PNCounter&gt; counter1Key = PNCounterKey.create(&quot;counter1&quot;);
  final Key&lt;GSet&lt;String&gt;&gt; set1Key = GSetKey.create(&quot;set1&quot;);
  final Key&lt;ORSet&lt;String&gt;&gt; set2Key = ORSetKey.create(&quot;set2&quot;);
  final Key&lt;Flag&gt; activeFlagKey = FlagKey.create(&quot;active&quot;);

  @Override
  public Receive createReceive() {
    ReceiveBuilder b = receiveBuilder();

    b.matchEquals(
        &quot;demonstrate update&quot;,
        msg -&gt; {
          replicator.tell(
              new Replicator.Update&lt;PNCounter&gt;(
                  counter1Key,
                  PNCounter.create(),
                  Replicator.writeLocal(),
                  curr -&gt; curr.increment(node, 1)),
              getSelf());

          final WriteConsistency writeTo3 = new WriteTo(3, Duration.ofSeconds(1));
          replicator.tell(
              new Replicator.Update&lt;GSet&lt;String&gt;&gt;(
                  set1Key, GSet.create(), writeTo3, curr -&gt; curr.add(&quot;hello&quot;)),
              getSelf());

          final WriteConsistency writeMajority = new WriteMajority(Duration.ofSeconds(5));
          replicator.tell(
              new Replicator.Update&lt;ORSet&lt;String&gt;&gt;(
                  set2Key, ORSet.create(), writeMajority, curr -&gt; curr.add(node, &quot;hello&quot;)),
              getSelf());

          final WriteConsistency writeAll = new WriteAll(Duration.ofSeconds(5));
          replicator.tell(
              new Replicator.Update&lt;Flag&gt;(
                  activeFlagKey, Flag.create(), writeAll, curr -&gt; curr.switchOn()),
              getSelf());
        });
    return b.build();
  }
}</code></pre></dd>
</dl>
<p>As reply of the <code>Update</code> a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$UpdateSuccess.html" title="akka.cluster.ddata.Replicator.UpdateSuccess"><code>Replicator.UpdateSuccess</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.UpdateSuccess.html" title="akka.cluster.ddata.Replicator.UpdateSuccess"><code>Replicator.UpdateSuccess</code></a></span> is sent to the sender of the <code>Update</code> if the value was successfully replicated according to the supplied <a href="typed/distributed-data.html#write-consistency">write consistency level</a> within the supplied timeout. Otherwise a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$UpdateFailure.html" title="akka.cluster.ddata.Replicator.UpdateFailure"><code>Replicator.UpdateFailure</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.UpdateFailure.html" title="akka.cluster.ddata.Replicator.UpdateFailure"><code>Replicator.UpdateFailure</code></a></span> subclass is sent back. Note that a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$UpdateTimeout.html" title="akka.cluster.ddata.Replicator.UpdateTimeout"><code>Replicator.UpdateTimeout</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.UpdateTimeout.html" title="akka.cluster.ddata.Replicator.UpdateTimeout"><code>Replicator.UpdateTimeout</code></a></span> reply does not mean that the update completely failed or was rolled back. It may still have been replicated to some nodes, and will eventually be replicated to all nodes with the gossip protocol.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L132" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case UpdateSuccess(Counter1Key, req) =&gt; // ok</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L93-L98" target="_blank" title="Go to snippet source">source</a><code class="language-java">b.match(
    UpdateSuccess.class,
    a -&gt; a.key().equals(counter1Key),
    a -&gt; {
      // ok
    });</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L139-L141" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case UpdateSuccess(Set1Key, req) =&gt; // ok
case UpdateTimeout(Set1Key, req) =&gt;
// write to 3 nodes failed within 1.second</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L102-L113" target="_blank" title="Go to snippet source">source</a><code class="language-java">b.match(
        UpdateSuccess.class,
        a -&gt; a.key().equals(set1Key),
        a -&gt; {
          // ok
        })
    .match(
        UpdateTimeout.class,
        a -&gt; a.key().equals(set1Key),
        a -&gt; {
          // write to 3 nodes failed within 1.second
        });</code></pre></dd>
</dl>
<p>You will always see your own writes. For example if you send two <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span> messages changing the value of the same <code>key</code>, the <code>modify</code> function of the second message will see the change that was performed by the first <code>Update</code> message.</p>
<p>It is possible to abort the <code>Update</code> when inspecting the state parameter that is passed in to the <code>modify</code> function by throwing an exception. That happens before the update is performed and a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$ModifyFailure.html" title="akka.cluster.ddata.Replicator.ModifyFailure"><code>Replicator.ModifyFailure</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.ModifyFailure.html" title="akka.cluster.ddata.Replicator.ModifyFailure"><code>Replicator.ModifyFailure</code></a></span> is sent back as reply.</p>
<p>In the <code>Update</code> message you can pass an optional request context, which the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator.html" title="akka.cluster.ddata.Replicator"><code>Replicator</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.html" title="akka.cluster.ddata.Replicator"><code>Replicator</code></a></span> does not care about, but is included in the reply messages. This is a convenient way to pass contextual information (e.g. original sender) without having to use <code>ask</code> or maintain local correlation data structures.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L155-L170" target="_blank" title="Go to snippet source">source</a><code class="language-scala">implicit val node = DistributedData(system).selfUniqueAddress
val replicator = DistributedData(system).replicator
val writeTwo = WriteTo(n = 2, timeout = 3.second)
val Counter1Key = PNCounterKey(&quot;counter1&quot;)

def receive: Receive = {
  case &quot;increment&quot; =&gt;
    // incoming command to increase the counter
    val upd = Update(Counter1Key, PNCounter(), writeTwo, request = Some(sender()))(_ :+ 1)
    replicator ! upd

  case UpdateSuccess(Counter1Key, Some(replyTo: ActorRef)) =&gt;
    replyTo ! &quot;ack&quot;
  case UpdateTimeout(Counter1Key, Some(replyTo: ActorRef)) =&gt;
    replyTo ! &quot;nack&quot;
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L124-L165" target="_blank" title="Go to snippet source">source</a><code class="language-java">class DemonstrateUpdateWithRequestContext extends AbstractActor {
  final SelfUniqueAddress node = DistributedData.get(system).selfUniqueAddress();
  final ActorRef replicator = DistributedData.get(getContext().getSystem()).replicator();

  final WriteConsistency writeTwo = new WriteTo(2, Duration.ofSeconds(3));
  final Key&lt;PNCounter&gt; counter1Key = PNCounterKey.create(&quot;counter1&quot;);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            a -&gt; a.equals(&quot;increment&quot;),
            a -&gt; {
              // incoming command to increase the counter
              Optional&lt;Object&gt; reqContext = Optional.of(getSender());
              Replicator.Update&lt;PNCounter&gt; upd =
                  new Replicator.Update&lt;PNCounter&gt;(
                      counter1Key,
                      PNCounter.create(),
                      writeTwo,
                      reqContext,
                      curr -&gt; curr.increment(node, 1));
              replicator.tell(upd, getSelf());
            })
        .match(
            UpdateSuccess.class,
            a -&gt; a.key().equals(counter1Key),
            a -&gt; {
              ActorRef replyTo = (ActorRef) a.getRequest().get();
              replyTo.tell(&quot;ack&quot;, getSelf());
            })
        .match(
            UpdateTimeout.class,
            a -&gt; a.key().equals(counter1Key),
            a -&gt; {
              ActorRef replyTo = (ActorRef) a.getRequest().get();
              replyTo.tell(&quot;nack&quot;, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<a id="replicator-get"></a>
<h3><a href="#get" name="get" class="anchor"><span class="anchor-link"></span></a>Get</h3>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#get">Distributed Data - Get</a>.</p>
<p>To retrieve the current value of a data you send <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Get.html" title="akka.cluster.ddata.Replicator.Get"><code>Replicator.Get</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Get.html" title="akka.cluster.ddata.Replicator.Get"><code>Replicator.Get</code></a></span> message to the <code>Replicator</code>. You supply a consistency level which has the following meaning:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L179-L194" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val replicator = DistributedData(system).replicator
val Counter1Key = PNCounterKey(&quot;counter1&quot;)
val Set1Key = GSetKey[String](&quot;set1&quot;)
val Set2Key = ORSetKey[String](&quot;set2&quot;)
val ActiveFlagKey = FlagKey(&quot;active&quot;)

replicator ! Get(Counter1Key, ReadLocal)

val readFrom3 = ReadFrom(n = 3, timeout = 1.second)
replicator ! Get(Set1Key, readFrom3)

val readMajority = ReadMajority(timeout = 5.seconds)
replicator ! Get(Set2Key, readMajority)

val readAll = ReadAll(timeout = 5.seconds)
replicator ! Get(ActiveFlagKey, readAll)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L170-L240" target="_blank" title="Go to snippet source">source</a><code class="language-java">class DemonstrateGet extends AbstractActor {
  final ActorRef replicator = DistributedData.get(getContext().getSystem()).replicator();

  final Key&lt;PNCounter&gt; counter1Key = PNCounterKey.create(&quot;counter1&quot;);
  final Key&lt;GSet&lt;String&gt;&gt; set1Key = GSetKey.create(&quot;set1&quot;);
  final Key&lt;ORSet&lt;String&gt;&gt; set2Key = ORSetKey.create(&quot;set2&quot;);
  final Key&lt;Flag&gt; activeFlagKey = FlagKey.create(&quot;active&quot;);

  @Override
  public Receive createReceive() {
    ReceiveBuilder b = receiveBuilder();

    b.matchEquals(
        &quot;demonstrate get&quot;,
        msg -&gt; {
          replicator.tell(
              new Replicator.Get&lt;PNCounter&gt;(counter1Key, Replicator.readLocal()), getSelf());

          final ReadConsistency readFrom3 = new ReadFrom(3, Duration.ofSeconds(1));
          replicator.tell(new Replicator.Get&lt;GSet&lt;String&gt;&gt;(set1Key, readFrom3), getSelf());

          final ReadConsistency readMajority = new ReadMajority(Duration.ofSeconds(5));
          replicator.tell(new Replicator.Get&lt;ORSet&lt;String&gt;&gt;(set2Key, readMajority), getSelf());

          final ReadConsistency readAll = new ReadAll(Duration.ofSeconds(5));
          replicator.tell(new Replicator.Get&lt;Flag&gt;(activeFlagKey, readAll), getSelf());
        });
    return b.build();
  }
}</code></pre></dd>
</dl>
<p>As reply of the <code>Get</code> a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$GetSuccess.html" title="akka.cluster.ddata.Replicator.GetSuccess"><code>Replicator.GetSuccess</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.GetSuccess.html" title="akka.cluster.ddata.Replicator.GetSuccess"><code>Replicator.GetSuccess</code></a></span> is sent to the sender of the <code>Get</code> if the value was successfully retrieved according to the supplied <a href="typed/distributed-data.html#read-consistency">read consistency level</a> within the supplied timeout. Otherwise a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$GetFailure.html" title="akka.cluster.ddata.Replicator.GetFailure"><code>Replicator.GetFailure</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.GetFailure.html" title="akka.cluster.ddata.Replicator.GetFailure"><code>Replicator.GetFailure</code></a></span> is sent. If the key does not exist the reply will be <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$NotFound.html" title="akka.cluster.ddata.Replicator.NotFound"><code>Replicator.NotFound</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.NotFound.html" title="akka.cluster.ddata.Replicator.NotFound"><code>Replicator.NotFound</code></a></span>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L199-L201" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case g @ GetSuccess(Counter1Key, req) =&gt;
  val value = g.get(Counter1Key).value
case NotFound(Counter1Key, req) =&gt; // key counter1 does not exist</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L200-L212" target="_blank" title="Go to snippet source">source</a><code class="language-java">b.match(
        GetSuccess.class,
        a -&gt; a.key().equals(counter1Key),
        a -&gt; {
          GetSuccess&lt;PNCounter&gt; g = a;
          BigInteger value = g.dataValue().getValue();
        })
    .match(
        NotFound.class,
        a -&gt; a.key().equals(counter1Key),
        a -&gt; {
          // key counter1 does not exist
        });</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L208-L212" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case g @ GetSuccess(Set1Key, req) =&gt;
  val elements = g.get(Set1Key).elements
case GetFailure(Set1Key, req) =&gt;
// read from 3 nodes failed within 1.second
case NotFound(Set1Key, req) =&gt; // key set1 does not exist</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L216-L234" target="_blank" title="Go to snippet source">source</a><code class="language-java">b.match(
        GetSuccess.class,
        a -&gt; a.key().equals(set1Key),
        a -&gt; {
          GetSuccess&lt;GSet&lt;String&gt;&gt; g = a;
          Set&lt;String&gt; value = g.dataValue().getElements();
        })
    .match(
        GetFailure.class,
        a -&gt; a.key().equals(set1Key),
        a -&gt; {
          // read from 3 nodes failed within 1.second
        })
    .match(
        NotFound.class,
        a -&gt; a.key().equals(set1Key),
        a -&gt; {
          // key set1 does not exist
        });</code></pre></dd>
</dl>
<p>In the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Get.html" title="akka.cluster.ddata.Replicator.Get"><code>Get</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Get.html" title="akka.cluster.ddata.Replicator.Get"><code>Get</code></a></span> message you can pass an optional request context in the same way as for the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span> message, described above. For example the original sender can be passed and replied to after receiving and transforming <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$GetSuccess.html" title="akka.cluster.ddata.Replicator.GetSuccess"><code>GetSuccess</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.GetSuccess.html" title="akka.cluster.ddata.Replicator.GetSuccess"><code>GetSuccess</code></a></span>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L227-L244" target="_blank" title="Go to snippet source">source</a><code class="language-scala">implicit val node = DistributedData(system).selfUniqueAddress
val replicator = DistributedData(system).replicator
val readTwo = ReadFrom(n = 2, timeout = 3.second)
val Counter1Key = PNCounterKey(&quot;counter1&quot;)

def receive: Receive = {
  case &quot;get-count&quot; =&gt;
    // incoming request to retrieve current value of the counter
    replicator ! Get(Counter1Key, readTwo, request = Some(sender()))

  case g @ GetSuccess(Counter1Key, Some(replyTo: ActorRef)) =&gt;
    val value = g.get(Counter1Key).value.longValue
    replyTo ! value
  case GetFailure(Counter1Key, Some(replyTo: ActorRef)) =&gt;
    replyTo ! -1L
  case NotFound(Counter1Key, Some(replyTo: ActorRef)) =&gt;
    replyTo ! 0L
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L245-L287" target="_blank" title="Go to snippet source">source</a><code class="language-java">class DemonstrateGetWithRequestContext extends AbstractActor {
  final ActorRef replicator = DistributedData.get(getContext().getSystem()).replicator();

  final ReadConsistency readTwo = new ReadFrom(2, Duration.ofSeconds(3));
  final Key&lt;PNCounter&gt; counter1Key = PNCounterKey.create(&quot;counter1&quot;);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            a -&gt; a.equals(&quot;get-count&quot;),
            a -&gt; {
              // incoming request to retrieve current value of the counter
              Optional&lt;Object&gt; reqContext = Optional.of(getSender());
              replicator.tell(new Replicator.Get&lt;PNCounter&gt;(counter1Key, readTwo), getSelf());
            })
        .match(
            GetSuccess.class,
            a -&gt; a.key().equals(counter1Key),
            a -&gt; {
              ActorRef replyTo = (ActorRef) a.getRequest().get();
              GetSuccess&lt;PNCounter&gt; g = a;
              long value = g.dataValue().getValue().longValue();
              replyTo.tell(value, getSelf());
            })
        .match(
            GetFailure.class,
            a -&gt; a.key().equals(counter1Key),
            a -&gt; {
              ActorRef replyTo = (ActorRef) a.getRequest().get();
              replyTo.tell(-1L, getSelf());
            })
        .match(
            NotFound.class,
            a -&gt; a.key().equals(counter1Key),
            a -&gt; {
              ActorRef replyTo = (ActorRef) a.getRequest().get();
              replyTo.tell(0L, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<h3><a href="#subscribe" name="subscribe" class="anchor"><span class="anchor-link"></span></a>Subscribe</h3>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#subscribe">Distributed Data - Subscribe</a>.</p>
<p>You may also register interest in change notifications by sending <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Subscribe.html" title="akka.cluster.ddata.Replicator.Subscribe"><code>Replicator.Subscribe</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Subscribe.html" title="akka.cluster.ddata.Replicator.Subscribe"><code>Replicator.Subscribe</code></a></span> message to the <code>Replicator</code>. It will send <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Changed.html" title="akka.cluster.ddata.Replicator.Changed"><code>Replicator.Changed</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Changed.html" title="akka.cluster.ddata.Replicator.Changed"><code>Replicator.Changed</code></a></span> messages to the registered subscriber when the data for the subscribed key is updated. Subscribers will be notified periodically with the configured <code>notify-subscribers-interval</code>, and it is also possible to send an explicit <code>Replicator.FlushChanges</code> message to the <code>Replicator</code> to notify the subscribers immediately.</p>
<p>The subscriber is automatically removed if the subscriber is terminated. A subscriber can also be deregistered with the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Unsubscribe.html" title="akka.cluster.ddata.Replicator.Unsubscribe"><code>Replicator.Unsubscribe</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Unsubscribe.html" title="akka.cluster.ddata.Replicator.Unsubscribe"><code>Replicator.Unsubscribe</code></a></span> message.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L255-L267" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val replicator = DistributedData(system).replicator
val Counter1Key = PNCounterKey(&quot;counter1&quot;)
// subscribe to changes of the Counter1Key value
replicator ! Subscribe(Counter1Key, self)
var currentValue = BigInt(0)

def receive: Receive = {
  case c @ Changed(Counter1Key) =&gt;
    currentValue = c.get(Counter1Key).value
  case &quot;get-count&quot; =&gt;
    // incoming request to retrieve current value of the counter
    sender() ! currentValue
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L292-L323" target="_blank" title="Go to snippet source">source</a><code class="language-java">class DemonstrateSubscribe extends AbstractActor {
  final ActorRef replicator = DistributedData.get(getContext().getSystem()).replicator();
  final Key&lt;PNCounter&gt; counter1Key = PNCounterKey.create(&quot;counter1&quot;);

  BigInteger currentValue = BigInteger.valueOf(0);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            Changed.class,
            a -&gt; a.key().equals(counter1Key),
            a -&gt; {
              Changed&lt;PNCounter&gt; g = a;
              currentValue = g.dataValue().getValue();
            })
        .match(
            String.class,
            a -&gt; a.equals(&quot;get-count&quot;),
            a -&gt; {
              // incoming request to retrieve current value of the counter
              getSender().tell(currentValue, getSender());
            })
        .build();
  }

  @Override
  public void preStart() {
    // subscribe to changes of the Counter1Key value
    replicator.tell(new Subscribe&lt;PNCounter&gt;(counter1Key, getSelf()), ActorRef.noSender());
  }
}</code></pre></dd>
</dl>
<h3><a href="#consistency" name="consistency" class="anchor"><span class="anchor-link"></span></a>Consistency</h3>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#consistency">Distributed Data Consistency</a>.</p>
<p>Here is an example of using <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$WriteMajority.html" title="akka.cluster.ddata.Replicator.WriteMajority"><code>WriteMajority</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.WriteMajority.html" title="akka.cluster.ddata.Replicator.WriteMajority"><code>WriteMajority</code></a></span> and <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$ReadMajority.html" title="akka.cluster.ddata.Replicator.ReadMajority"><code>ReadMajority</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.ReadMajority.html" title="akka.cluster.ddata.Replicator.ReadMajority"><code>ReadMajority</code></a></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/ShoppingCart.scala#L30-L32" target="_blank" title="Go to snippet source">source</a><code class="language-scala">private val timeout = 3.seconds
private val readMajority = ReadMajority(timeout)
private val writeMajority = WriteMajority(timeout)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/ShoppingCart.java#L33-L34" target="_blank" title="Go to snippet source">source</a><code class="language-java">private final WriteConsistency writeMajority = new WriteMajority(Duration.ofSeconds(3));
private static final ReadConsistency readMajority = new ReadMajority(Duration.ofSeconds(3));</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/ShoppingCart.scala#L53-L68" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def receiveGetCart: Receive = {
  case GetCart =&gt;
    replicator ! Get(DataKey, readMajority, Some(sender()))

  case g @ GetSuccess(DataKey, Some(replyTo: ActorRef)) =&gt;
    val data = g.get(DataKey)
    val cart = Cart(data.entries.values.toSet)
    replyTo ! cart

  case NotFound(DataKey, Some(replyTo: ActorRef)) =&gt;
    replyTo ! Cart(Set.empty)

  case GetFailure(DataKey, Some(replyTo: ActorRef)) =&gt;
    // ReadMajority failure, try again with local read
    replicator ! Get(DataKey, ReadLocal, Some(replyTo))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/ShoppingCart.java#L137-L183" target="_blank" title="Go to snippet source">source</a><code class="language-java">private Receive matchGetCart() {
  return receiveBuilder()
      .matchEquals(GET_CART, s -&gt; receiveGetCart())
      .match(
          GetSuccess.class,
          this::isResponseToGetCart,
          g -&gt; receiveGetSuccess((GetSuccess&lt;LWWMap&lt;String, LineItem&gt;&gt;) g))
      .match(
          NotFound.class,
          this::isResponseToGetCart,
          n -&gt; receiveNotFound((NotFound&lt;LWWMap&lt;String, LineItem&gt;&gt;) n))
      .match(
          GetFailure.class,
          this::isResponseToGetCart,
          f -&gt; receiveGetFailure((GetFailure&lt;LWWMap&lt;String, LineItem&gt;&gt;) f))
      .build();
}

private void receiveGetCart() {
  Optional&lt;Object&gt; ctx = Optional.of(getSender());
  replicator.tell(
      new Replicator.Get&lt;LWWMap&lt;String, LineItem&gt;&gt;(dataKey, readMajority, ctx), getSelf());
}

private boolean isResponseToGetCart(GetResponse&lt;?&gt; response) {
  return response.key().equals(dataKey)
      &amp;&amp; (response.getRequest().orElse(null) instanceof ActorRef);
}

private void receiveGetSuccess(GetSuccess&lt;LWWMap&lt;String, LineItem&gt;&gt; g) {
  Set&lt;LineItem&gt; items = new HashSet&lt;&gt;(g.dataValue().getEntries().values());
  ActorRef replyTo = (ActorRef) g.getRequest().get();
  replyTo.tell(new Cart(items), getSelf());
}

private void receiveNotFound(NotFound&lt;LWWMap&lt;String, LineItem&gt;&gt; n) {
  ActorRef replyTo = (ActorRef) n.getRequest().get();
  replyTo.tell(new Cart(new HashSet&lt;&gt;()), getSelf());
}

private void receiveGetFailure(GetFailure&lt;LWWMap&lt;String, LineItem&gt;&gt; f) {
  // ReadMajority failure, try again with local read
  Optional&lt;Object&gt; ctx = Optional.of(getSender());
  replicator.tell(
      new Replicator.Get&lt;LWWMap&lt;String, LineItem&gt;&gt;(dataKey, Replicator.readLocal(), ctx),
      getSelf());
}</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/ShoppingCart.scala#L72-L78" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def receiveAddItem: Receive = {
  case cmd @ AddItem(item) =&gt;
    val update = Update(DataKey, LWWMap.empty[String, LineItem], writeMajority, Some(cmd)) { cart =&gt;
      updateCart(cart, item)
    }
    replicator ! update
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/ShoppingCart.java#L187-L196" target="_blank" title="Go to snippet source">source</a><code class="language-java">private Receive matchAddItem() {
  return receiveBuilder().match(AddItem.class, this::receiveAddItem).build();
}

private void receiveAddItem(AddItem add) {
  Update&lt;LWWMap&lt;String, LineItem&gt;&gt; update =
      new Update&lt;&gt;(dataKey, LWWMap.create(), writeMajority, cart -&gt; updateCart(cart, add.item));
  replicator.tell(update, getSelf());
}
</code></pre></dd>
</dl>
<p>In some rare cases, when performing an <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span> it is needed to first try to fetch latest data from other nodes. That can be done by first sending a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Get.html" title="akka.cluster.ddata.Replicator.Get"><code>Get</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Get.html" title="akka.cluster.ddata.Replicator.Get"><code>Get</code></a></span> with <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$ReadMajority.html" title="akka.cluster.ddata.Replicator.ReadMajority"><code>ReadMajority</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.ReadMajority.html" title="akka.cluster.ddata.Replicator.ReadMajority"><code>ReadMajority</code></a></span> and then continue with the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.Update.html" title="akka.cluster.ddata.Replicator.Update"><code>Update</code></a></span> when the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$GetSuccess.html" title="akka.cluster.ddata.Replicator.GetSuccess"><code>GetSuccess</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.GetSuccess.html" title="akka.cluster.ddata.Replicator.GetSuccess"><code>GetSuccess</code></a></span>, <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$GetFailure.html" title="akka.cluster.ddata.Replicator.GetFailure"><code>GetFailure</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.GetFailure.html" title="akka.cluster.ddata.Replicator.GetFailure"><code>GetFailure</code></a></span> or <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/Replicator$$NotFound.html" title="akka.cluster.ddata.Replicator.NotFound"><code>NotFound</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/Replicator.NotFound.html" title="akka.cluster.ddata.Replicator.NotFound"><code>NotFound</code></a></span> reply is received. This might be needed when you need to base a decision on latest information or when removing entries from an <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/ORSet.html" title="akka.cluster.ddata.ORSet"><code>ORSet</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/ORSet.html" title="akka.cluster.ddata.ORSet"><code>ORSet</code></a></span> or <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/ORMap.html" title="akka.cluster.ddata.ORMap"><code>ORMap</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/ORMap.html" title="akka.cluster.ddata.ORMap"><code>ORMap</code></a></span>. If an entry is added to an <code>ORSet</code> or <code>ORMap</code> from one node and removed from another node the entry will only be removed if the added entry is visible on the node where the removal is performed (hence the name observed-removed set).</p>
<p>The following example illustrates how to do that:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/ShoppingCart.scala#L89-L108" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def receiveRemoveItem: Receive = {
  case cmd @ RemoveItem(productId) =&gt;
    // Try to fetch latest from a majority of nodes first, since ORMap
    // remove must have seen the item to be able to remove it.
    replicator ! Get(DataKey, readMajority, Some(cmd))

  case GetSuccess(DataKey, Some(RemoveItem(productId))) =&gt;
    replicator ! Update(DataKey, LWWMap(), writeMajority, None) {
      _.remove(node, productId)
    }

  case GetFailure(DataKey, Some(RemoveItem(productId))) =&gt;
    // ReadMajority failed, fall back to best effort local value
    replicator ! Update(DataKey, LWWMap(), writeMajority, None) {
      _.remove(node, productId)
    }

  case NotFound(DataKey, Some(RemoveItem(productId))) =&gt;
  // nothing to remove
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/ShoppingCart.java#L231-L259" target="_blank" title="Go to snippet source">source</a><code class="language-java">private void receiveRemoveItem(RemoveItem rm) {
  // Try to fetch latest from a majority of nodes first, since ORMap
  // remove must have seen the item to be able to remove it.
  Optional&lt;Object&gt; ctx = Optional.of(rm);
  replicator.tell(
      new Replicator.Get&lt;LWWMap&lt;String, LineItem&gt;&gt;(dataKey, readMajority, ctx), getSelf());
}

private void receiveRemoveItemGetSuccess(GetSuccess&lt;LWWMap&lt;String, LineItem&gt;&gt; g) {
  RemoveItem rm = (RemoveItem) g.getRequest().get();
  removeItem(rm.productId);
}

private void receiveRemoveItemGetFailure(GetFailure&lt;LWWMap&lt;String, LineItem&gt;&gt; f) {
  // ReadMajority failed, fall back to best effort local value
  RemoveItem rm = (RemoveItem) f.getRequest().get();
  removeItem(rm.productId);
}

private void removeItem(String productId) {
  Update&lt;LWWMap&lt;String, LineItem&gt;&gt; update =
      new Update&lt;&gt;(dataKey, LWWMap.create(), writeMajority, cart -&gt; cart.remove(node, productId));
  replicator.tell(update, getSelf());
}

private boolean isResponseToRemoveItem(GetResponse&lt;?&gt; response) {
  return response.key().equals(dataKey)
      &amp;&amp; (response.getRequest().orElse(null) instanceof RemoveItem);
}</code></pre></dd>
</dl><div class="callout warning "><div class="callout-title">Warning</div>
<p><em>Caveat:</em> Even if you use <code>WriteMajority</code> and <code>ReadMajority</code> there is small risk that you may read stale data if the cluster membership has changed between the <code>Update</code> and the <code>Get</code>. For example, in cluster of 5 nodes when you <code>Update</code> and that change is written to 3 nodes: n1, n2, n3. Then 2 more nodes are added and a <code>Get</code> request is reading from 4 nodes, which happens to be n4, n5, n6, n7, i.e. the value on n1, n2, n3 is not seen in the response of the <code>Get</code> request.</p></div>
<h3><a href="#delete" name="delete" class="anchor"><span class="anchor-link"></span></a>Delete</h3>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#delete">Distributed Data - Delete</a>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/scala/docs/ddata/DistributedDataDocSpec.scala#L276-L283" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val replicator = DistributedData(system).replicator
val Counter1Key = PNCounterKey(&quot;counter1&quot;)
val Set2Key = ORSetKey[String](&quot;set2&quot;)

replicator ! Delete(Counter1Key, WriteLocal)

val writeMajority = WriteMajority(timeout = 5.seconds)
replicator ! Delete(Set2Key, writeMajority)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/test/java/jdocs/ddata/DistributedDataDocTest.java#L328-L348" target="_blank" title="Go to snippet source">source</a><code class="language-java">class DemonstrateDelete extends AbstractActor {
  final ActorRef replicator = DistributedData.get(getContext().getSystem()).replicator();

  final Key&lt;PNCounter&gt; counter1Key = PNCounterKey.create(&quot;counter1&quot;);
  final Key&lt;ORSet&lt;String&gt;&gt; set2Key = ORSetKey.create(&quot;set2&quot;);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            &quot;demonstrate delete&quot;,
            msg -&gt; {
              replicator.tell(
                  new Delete&lt;PNCounter&gt;(counter1Key, Replicator.writeLocal()), getSelf());

              final WriteConsistency writeMajority = new WriteMajority(Duration.ofSeconds(5));
              replicator.tell(new Delete&lt;PNCounter&gt;(counter1Key, writeMajority), getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl><div class="callout warning "><div class="callout-title">Warning</div>
<p>As deleted keys continue to be included in the stored data on each node as well as in gossip messages, a continuous series of updates and deletes of top-level entities will result in growing memory usage until an ActorSystem runs out of memory. To use Akka Distributed Data where frequent adds and removes are required, you should use a fixed number of top-level data types that support both updates and removals, for example <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/ORMap.html" title="akka.cluster.ddata.ORMap"><code>ORMap</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/ORMap.html" title="akka.cluster.ddata.ORMap"><code>ORMap</code></a></span> or <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/ORSet.html" title="akka.cluster.ddata.ORSet"><code>ORSet</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/ORSet.html" title="akka.cluster.ddata.ORSet"><code>ORSet</code></a></span>.</p></div>
<h2><a href="#replicated-data-types" name="replicated-data-types" class="anchor"><span class="anchor-link"></span></a>Replicated data types</h2>
<p>Akka contains a set of useful replicated data types and it is fully possible to implement custom replicated data types. For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#replicated-data-types">Distributed Data Replicated data types</a>.</p>
<h3><a href="#delta-crdt" name="delta-crdt" class="anchor"><span class="anchor-link"></span></a>Delta-CRDT</h3>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#delta-crdt">Distributed Data Delta CRDT</a>.</p>
<h3><a href="#custom-data-type" name="custom-data-type" class="anchor"><span class="anchor-link"></span></a>Custom Data Type</h3>
<p>You can implement your own data types. For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#custom-data-type">Distributed Data custom data type</a>.</p>
<a id="ddata-durable"></a>
<h2><a href="#durable-storage" name="durable-storage" class="anchor"><span class="anchor-link"></span></a>Durable Storage</h2>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#durable-storage">Durable Storage</a>.</p>
<h2><a href="#limitations" name="limitations" class="anchor"><span class="anchor-link"></span></a>Limitations</h2>
<p>For the full documentation of this feature and for new projects see <a href="typed/distributed-data.html#limitations">Limitations</a>.</p>
<h2><a href="#learn-more-about-crdts" name="learn-more-about-crdts" class="anchor"><span class="anchor-link"></span></a>Learn More about CRDTs</h2>
<ul>
  <li><a href="https://www.youtube.com/watch?v=oyUHd894w18&amp;feature=youtu.be">Strong Eventual Consistency and Conflict-free Replicated Data Types (video)</a> talk by Mark Shapiro</li>
  <li><a href="https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a> paper by Mark Shapiro et. al.</li>
</ul>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>The <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/cluster/ddata/DistributedData.html" title="akka.cluster.ddata.DistributedData"><code>DistributedData</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/cluster/ddata/DistributedData.html" title="akka.cluster.ddata.DistributedData"><code>DistributedData</code></a></span> extension can be configured with the following properties:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.4/akka-distributed-data/src/main/resources/reference.conf#L10-L152" target="_blank" title="Go to snippet source">source</a><code class="language-conf"># Settings for the DistributedData extension
akka.cluster.distributed-data {
  # Actor name of the Replicator actor, /system/ddataReplicator
  name = ddataReplicator

  # Replicas are running on members tagged with this role.
  # All members are used if undefined or empty.
  role = &quot;&quot;

  # How often the Replicator should send out gossip information
  gossip-interval = 2 s
  
  # How often the subscribers will be notified of changes, if any
  notify-subscribers-interval = 500 ms

  # Logging of data with payload size in bytes larger than
  # this value. Maximum detected size per key is logged once,
  # with an increase threshold of 10%.
  # It can be disabled by setting the property to off.
  log-data-size-exceeding = 10 KiB

  # Maximum number of entries to transfer in one round of gossip exchange when
  # synchronizing the replicas. Next chunk will be transferred in next round of gossip.
  # The actual number of data entries in each Gossip message is dynamically
  # adjusted to not exceed the maximum remote message size (maximum-frame-size).
  max-delta-elements = 500
  
  # The id of the dispatcher to use for Replicator actors.
  # If specified you need to define the settings of the actual dispatcher.
  use-dispatcher = &quot;akka.actor.internal-dispatcher&quot;

  # How often the Replicator checks for pruning of data associated with
  # removed cluster nodes. If this is set to &#39;off&#39; the pruning feature will
  # be completely disabled.
  pruning-interval = 120 s
  
  # How long time it takes to spread the data to all other replica nodes.
  # This is used when initiating and completing the pruning process of data associated
  # with removed cluster nodes. The time measurement is stopped when any replica is 
  # unreachable, but it&#39;s still recommended to configure this with certain margin.
  # It should be in the magnitude of minutes even though typical dissemination time
  # is shorter (grows logarithmic with number of nodes). There is no advantage of 
  # setting this too low. Setting it to large value will delay the pruning process.
  max-pruning-dissemination = 300 s
  
  # The markers of that pruning has been performed for a removed node are kept for this
  # time and thereafter removed. If and old data entry that was never pruned is somehow
  # injected and merged with existing data after this time the value will not be correct.
  # This would be possible (although unlikely) in the case of a long network partition.
  # It should be in the magnitude of hours. For durable data it is configured by 
  # &#39;akka.cluster.distributed-data.durable.pruning-marker-time-to-live&#39;.
 pruning-marker-time-to-live = 6 h
  
  # Serialized Write and Read messages are cached when they are sent to 
  # several nodes. If no further activity they are removed from the cache
  # after this duration.
  serializer-cache-time-to-live = 10s

  # Update and Get operations are sent to oldest nodes first.
  # This is useful together with Cluster Singleton, which is running on oldest nodes.
  prefer-oldest = off
  
  # Settings for delta-CRDT
  delta-crdt {
    # enable or disable delta-CRDT replication
    enabled = on
    
    # Some complex deltas grow in size for each update and above this
    # threshold such deltas are discarded and sent as full state instead.
    # This is number of elements or similar size hint, not size in bytes.
    max-delta-size = 50
  }

  # Map of keys and inactivity duration for entries that will automatically be removed
  # without tombstones when they have been inactive for the given duration.
  # Prefix matching is supported by using * at the end of a key.
  # Matching tombstones will also be removed after the expiry duration.
  expire-keys-after-inactivity {
    # Example syntax:
    # &quot;key-1&quot; = 10 minutes
    # &quot;cache-*&quot; = 2 minutes
  }
  
  durable {
    # List of keys that are durable. Prefix matching is supported by using * at the
    # end of a key.  
    keys = []
    
    # The markers of that pruning has been performed for a removed node are kept for this
    # time and thereafter removed. If and old data entry that was never pruned is
    # injected and merged with existing data after this time the value will not be correct.
    # This would be possible if replica with durable data didn&#39;t participate in the pruning
    # (e.g. it was shutdown) and later started after this time. A durable replica should not 
    # be stopped for longer time than this duration and if it is joining again after this
    # duration its data should first be manually removed (from the lmdb directory).
    # It should be in the magnitude of days. Note that there is a corresponding setting
    # for non-durable data: &#39;akka.cluster.distributed-data.pruning-marker-time-to-live&#39;.
    pruning-marker-time-to-live = 10 d
    
    # Fully qualified class name of the durable store actor. It must be a subclass
    # of akka.actor.Actor and handle the protocol defined in 
    # akka.cluster.ddata.DurableStore. The class must have a constructor with 
    # com.typesafe.config.Config parameter.
    store-actor-class = akka.cluster.ddata.LmdbDurableStore
    
    use-dispatcher = akka.cluster.distributed-data.durable.pinned-store
    
    pinned-store {
      executor = thread-pool-executor
      type = PinnedDispatcher
    }
    
    # Config for the LmdbDurableStore
    lmdb {
      # Directory of LMDB file. There are two options:
      # 1. A relative or absolute path to a directory that ends with &#39;ddata&#39;
      #    the full name of the directory will contain name of the ActorSystem
      #    and its remote port.
      # 2. Otherwise the path is used as is, as a relative or absolute path to
      #    a directory.
      #
      # When running in production you may want to configure this to a specific
      # path (alt 2), since the default directory contains the remote port of the
      # actor system to make the name unique. If using a dynamically assigned 
      # port (0) it will be different each time and the previously stored data 
      # will not be loaded.
      dir = &quot;ddata&quot;
      
      # Size in bytes of the memory mapped file.
      map-size = 100 MiB
      
      # Accumulate changes before storing improves performance with the
      # risk of losing the last writes if the JVM crashes.
      # The interval is by default set to &#39;off&#39; to write each update immediately.
      # Enabling write behind by specifying a duration, e.g. 200ms, is especially 
      # efficient when performing many writes to the same key, because it is only 
      # the last value for each key that will be serialized and stored.  
      # write-behind-interval = 200 ms
      write-behind-interval = off
    }
  }
  
}</code></pre>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="cluster-metrics.html"><i class="icon-prev"></i> <span class="link-prev">Classic Cluster Metrics Extension</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="cluster-dc.html">Classic Multi-DC Cluster <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.8.4/akka-docs/src/main/paradox/distributed-data.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg" />
<section class="copyright">
<div>Akka is available under the <a href="https://www.lightbend.com/akka/license" target="_blank">Business Source License 1.1</a>.</div>
<p class="legal">
&copy; 2011-2023 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/snippets.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>
<script type="text/javascript" src="js/metadata-toggle.js"></script>
<script type="text/javascript" src="js/lbHeader.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
appId: 'XUXZ6LW9B1',
apiKey: '5b6260148e92f7c5e38338fcf7eaa3e0',
indexName: 'akka_docs',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
appId: 'XUXZ6LW9B1',
apiKey: '5b6260148e92f7c5e38338fcf7eaa3e0',
indexName: 'akka_docs',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
