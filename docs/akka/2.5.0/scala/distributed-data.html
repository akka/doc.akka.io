

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Distributed Data &#8212; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Remoting" href="remoting.html" />
    <link rel="prev" title="Cluster Metrics Extension" href="cluster-metrics.html" />
    <!-- Hint to search engines that the "canonical" page is under "current", which will boost it appearing in search results -->
    
      <link rel="canonical" href="https://doc.akka.io/docs/akka/current/distributed-data.html" />
    

    <!--Google Analytics-->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-21117439-1']);
      _gaq.push(['_setDomainName', 'akka.io']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })()
    </script>
    <!--Google Analytics & Marketo-->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
      ga('tsTracker.require', 'linker');
      ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
      ga('tsTracker.send', 'pageview');

      (function() {
          var didInit = false;
          function initMunchkin() {
          if(didInit === false) {
            didInit = true;
            Munchkin.init('558-NCX-702');
          }
          }
          var s = document.createElement('script');
          s.type = 'text/javascript';
          s.async = true;
          s.src = '//munchkin.marketo.net/munchkin.js';
          s.onreadystatechange = function() {
          if (this.readyState == 'complete' || this.readyState == 'loaded') {
            initMunchkin();
          }
          };
          s.onload = initMunchkin;
          document.getElementsByTagName('head')[0].appendChild(s);
        })();
    </script>


  </head>
  <body role="document">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="https://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="https://akka.io/docs">Documentation</a></li>
          <li><a href="https://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="https://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Distributed Data - Version 2.5.0</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <div class="breadcrumb">
              <div style="position: relative">
                <input type="search" id="search" class="form-control" style="position: relative" placeholder="Search in the doc" />
              </div>
              <div>
                <div>
                  <span class="divider">«</span> <a href="cluster-metrics.html">Cluster Metrics Extension</a> <span class="divider">|</span>
                </div>
                <div>
                  <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
                </div>
                <div>
                  <span class="divider">|</span> <a href="remoting.html">Remoting</a> <span class="divider">»</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="span9">
          </div><div class="span9">
            
  <div class="section" id="distributed-data">
<span id="distributed-data-scala"></span><h1>Distributed Data</h1>
<p><em>Akka Distributed Data</em> is useful when you need to share data between nodes in an
Akka Cluster. The data is accessed with an actor providing a key-value store like API.
The keys are unique identifiers with type information of the data values. The values
are <em>Conflict Free Replicated Data Types</em> (CRDTs).</p>
<p>All data entries are spread to all nodes, or nodes with a certain role, in the cluster
via direct replication and gossip based dissemination. You have fine grained control
of the consistency level for reads and writes.</p>
<p>The nature CRDTs makes it possible to perform updates from any node without coordination.
Concurrent updates from different nodes will automatically be resolved by the monotonic
merge function, which all data types must provide. The state changes always converge.
Several useful data types for counters, sets, maps and registers are provided and
you can also implement your own custom data types.</p>
<p>It is eventually consistent and geared toward providing high read and write availability
(partition tolerance), with low latency. Note that in an eventually consistent system a read may return an
out-of-date value.</p>
<div class="section" id="using-the-replicator">
<h2>Using the Replicator</h2>
<p>The <code class="docutils literal"><span class="pre">akka.cluster.ddata.Replicator</span></code> actor provides the API for interacting with the data.
The <code class="docutils literal"><span class="pre">Replicator</span></code> actor must be started on each node in the cluster, or group of nodes tagged
with a specific role. It communicates with other <code class="docutils literal"><span class="pre">Replicator</span></code> instances with the same path
(without address) that are running on other nodes . For convenience it can be used with the
<code class="docutils literal"><span class="pre">akka.cluster.ddata.DistributedData</span></code> extension but it can also be started as an ordinary
actor using the <code class="docutils literal"><span class="pre">Replicator.props</span></code>. If it is started as an ordinary actor it is important
that it is given the same name, started on same path, on all nodes.</p>
<p>Cluster members with status <a class="reference internal" href="cluster-usage.html#weakly-up-scala"><span class="std std-ref">WeaklyUp</span></a>,
will participate in Distributed Data. This means that the data will be replicated to the
<a class="reference internal" href="cluster-usage.html#weakly-up-scala"><span class="std std-ref">WeaklyUp</span></a> nodes with the background gossip protocol. Note that it
will not participate in any actions where the consistency mode is to read/write from all
nodes or the majority of nodes. The <a class="reference internal" href="cluster-usage.html#weakly-up-scala"><span class="std std-ref">WeaklyUp</span></a> node is not counted
as part of the cluster. So 3 nodes + 5 <a class="reference internal" href="cluster-usage.html#weakly-up-scala"><span class="std std-ref">WeaklyUp</span></a> is essentially a
3 node cluster as far as consistent actions are concerned.</p>
<p>Below is an example of an actor that schedules tick messages to itself and for each tick
adds or removes elements from a <code class="docutils literal"><span class="pre">ORSet</span></code> (observed-remove set). It also subscribes to
changes of this.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.util.concurrent.ThreadLocalRandom</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorLogging</span>
<span class="k">import</span> <span class="nn">akka.cluster.Cluster</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.DistributedData</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.ORSet</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.ORSetKey</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.Replicator</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.Replicator._</span>

<span class="k">object</span> <span class="nc">DataBot</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Tick</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">DataBot</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">DataBot._</span>

  <span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">)</span>

  <span class="k">import</span> <span class="nn">context.dispatcher</span>
  <span class="k">val</span> <span class="n">tickTask</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">,</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">,</span> <span class="n">self</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">)</span>

  <span class="k">val</span> <span class="nc">DataKey</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;key&quot;</span><span class="o">)</span>

  <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Subscribe</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="n">self</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Tick</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="n">current</span><span class="o">().</span><span class="n">nextInt</span><span class="o">(</span><span class="mi">97</span><span class="o">,</span> <span class="mi">123</span><span class="o">).</span><span class="n">toChar</span><span class="o">.</span><span class="n">toString</span>
      <span class="k">if</span> <span class="o">(</span><span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="n">current</span><span class="o">().</span><span class="n">nextBoolean</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// add</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Adding: {}&quot;</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="nc">WriteLocal</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="n">s</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// remove</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Removing: {}&quot;</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="nc">WriteLocal</span><span class="o">)(</span><span class="k">_</span> <span class="o">-</span> <span class="n">s</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="k">_:</span> <span class="kt">UpdateResponse</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="c1">// ignore</span>

    <span class="k">case</span> <span class="n">c</span> <span class="k">@</span> <span class="nc">Changed</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">)</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Current elements: {}&quot;</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="n">elements</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">tickTask</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>

<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="update">
<span id="replicator-update-scala"></span><h3>Update</h3>
<p>To modify and replicate a data value you send a <code class="docutils literal"><span class="pre">Replicator.Update</span></code> message to the local
<code class="docutils literal"><span class="pre">Replicator</span></code>.</p>
<p>The current data value for the <code class="docutils literal"><span class="pre">key</span></code> of the <code class="docutils literal"><span class="pre">Update</span></code> is passed as parameter to the <code class="docutils literal"><span class="pre">modify</span></code>
function of the <code class="docutils literal"><span class="pre">Update</span></code>. The function is supposed to return the new value of the data, which
will then be replicated according to the given consistency level.</p>
<p>The <code class="docutils literal"><span class="pre">modify</span></code> function is called by the <code class="docutils literal"><span class="pre">Replicator</span></code> actor and must therefore be a pure
function that only uses the data parameter and stable fields from enclosing scope. It must
for example not access <code class="docutils literal"><span class="pre">sender()</span></code> reference of an enclosing actor.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Update</span></code> is intended to only be sent from an actor running in same local <code class="docutils literal"><span class="pre">ActorSystem</span></code> as</dt>
<dd>the <code class="docutils literal"><span class="pre">Replicator</span></code>, because the <code class="docutils literal"><span class="pre">modify</span></code> function is typically not serializable.</dd>
</dl>
<p>You supply a write consistency level which has the following meaning:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">WriteLocal</span></code> the value will immediately only be written to the local replica,
and later disseminated with gossip</li>
<li><code class="docutils literal"><span class="pre">WriteTo(n)</span></code> the value will immediately be written to at least <code class="docutils literal"><span class="pre">n</span></code> replicas,
including the local replica</li>
<li><code class="docutils literal"><span class="pre">WriteMajority</span></code> the value will immediately be written to a majority of replicas, i.e.
at least <strong>N/2 + 1</strong> replicas, where N is the number of nodes in the cluster
(or cluster role group)</li>
<li><code class="docutils literal"><span class="pre">WriteAll</span></code> the value will immediately be written to all nodes in the cluster
(or all nodes in the cluster role group)</li>
</ul>
<dl class="docutils">
<dt>When you specify to write to <code class="docutils literal"><span class="pre">n</span></code> out of <code class="docutils literal"><span class="pre">x</span></code> nodes, the update will first replicate to <code class="docutils literal"><span class="pre">n</span></code> nodes. If there are not</dt>
<dd>enough Acks after 1/5th of the timeout, the update will be replicated to <code class="docutils literal"><span class="pre">n</span></code> other nodes. If there are less than n nodes
left all of the remaining nodes are used. Reachable nodes are prefered over unreachable nodes.</dd>
</dl>
<p>Note that <code class="docutils literal"><span class="pre">WriteMajority</span></code> has a <code class="docutils literal"><span class="pre">minCap</span></code> parameter that is useful to specify to achieve better safety for small clusters.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>

<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set1Key</span> <span class="k">=</span> <span class="nc">GSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set2Key</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set2&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">ActiveFlagKey</span> <span class="k">=</span> <span class="nc">FlagKey</span><span class="o">(</span><span class="s">&quot;active&quot;</span><span class="o">)</span>

<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">PNCounter</span><span class="o">(),</span> <span class="nc">WriteLocal</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeTo3</span> <span class="k">=</span> <span class="nc">WriteTo</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">writeTo3</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot;hello&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeMajority</span> <span class="k">=</span> <span class="nc">WriteMajority</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Set2Key</span><span class="o">,</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">writeMajority</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot;hello&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeAll</span> <span class="k">=</span> <span class="nc">WriteAll</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">ActiveFlagKey</span><span class="o">,</span> <span class="nc">Flag</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="n">writeAll</span><span class="o">)(</span><span class="k">_</span><span class="o">.</span><span class="n">switchOn</span><span class="o">)</span>
</pre></div>
</div>
<p>As reply of the <code class="docutils literal"><span class="pre">Update</span></code> a <code class="docutils literal"><span class="pre">Replicator.UpdateSuccess</span></code> is sent to the sender of the
<code class="docutils literal"><span class="pre">Update</span></code> if the value was successfully replicated according to the supplied consistency
level within the supplied timeout. Otherwise a <code class="docutils literal"><span class="pre">Replicator.UpdateFailure</span></code> subclass is
sent back. Note that a <code class="docutils literal"><span class="pre">Replicator.UpdateTimeout</span></code> reply does not mean that the update completely failed
or was rolled back. It may still have been replicated to some nodes, and will eventually
be replicated to all nodes with the gossip protocol.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">UpdateSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ok</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">UpdateSuccess</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="c1">// ok</span>
<span class="k">case</span> <span class="nc">UpdateTimeout</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span>  <span class="k">=&gt;</span>
<span class="c1">// write to 3 nodes failed within 1.second</span>
</pre></div>
</div>
<p>You will always see your own writes. For example if you send two <code class="docutils literal"><span class="pre">Update</span></code> messages
changing the value of the same <code class="docutils literal"><span class="pre">key</span></code>, the <code class="docutils literal"><span class="pre">modify</span></code> function of the second message will
see the change that was performed by the first <code class="docutils literal"><span class="pre">Update</span></code> message.</p>
<p>In the <code class="docutils literal"><span class="pre">Update</span></code> message you can pass an optional request context, which the <code class="docutils literal"><span class="pre">Replicator</span></code>
does not care about, but is included in the reply messages. This is a convenient
way to pass contextual information (e.g. original sender) without having to use <code class="docutils literal"><span class="pre">ask</span></code>
or maintain local correlation data structures.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="n">writeTwo</span> <span class="k">=</span> <span class="nc">WriteTo</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>

<span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;increment&quot;</span> <span class="k">=&gt;</span>
    <span class="c1">// incoming command to increase the counter</span>
    <span class="k">val</span> <span class="n">upd</span> <span class="k">=</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">PNCounter</span><span class="o">(),</span> <span class="n">writeTwo</span><span class="o">,</span> <span class="n">request</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sender</span><span class="o">()))(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="n">upd</span>

  <span class="k">case</span> <span class="nc">UpdateSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="s">&quot;ack&quot;</span>
  <span class="k">case</span> <span class="nc">UpdateTimeout</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="s">&quot;nack&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="get">
<span id="replicator-get-scala"></span><h3>Get</h3>
<p>To retrieve the current value of a data you send <code class="docutils literal"><span class="pre">Replicator.Get</span></code> message to the
<code class="docutils literal"><span class="pre">Replicator</span></code>. You supply a consistency level which has the following meaning:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ReadLocal</span></code> the value will only be read from the local replica</li>
<li><code class="docutils literal"><span class="pre">ReadFrom(n)</span></code> the value will be read and merged from <code class="docutils literal"><span class="pre">n</span></code> replicas,
including the local replica</li>
<li><code class="docutils literal"><span class="pre">ReadMajority</span></code> the value will be read and merged from a majority of replicas, i.e.
at least <strong>N/2 + 1</strong> replicas, where N is the number of nodes in the cluster
(or cluster role group)</li>
<li><code class="docutils literal"><span class="pre">ReadAll</span></code> the value will be read and merged from all nodes in the cluster
(or all nodes in the cluster role group)</li>
</ul>
<p>Note that <code class="docutils literal"><span class="pre">ReadMajority</span></code> has a <code class="docutils literal"><span class="pre">minCap</span></code> parameter that is useful to specify to achieve better safety for small clusters.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set1Key</span> <span class="k">=</span> <span class="nc">GSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set2Key</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set2&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">ActiveFlagKey</span> <span class="k">=</span> <span class="nc">FlagKey</span><span class="o">(</span><span class="s">&quot;active&quot;</span><span class="o">)</span>

<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">ReadLocal</span><span class="o">)</span>

<span class="k">val</span> <span class="n">readFrom3</span> <span class="k">=</span> <span class="nc">ReadFrom</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">readFrom3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">readMajority</span> <span class="k">=</span> <span class="nc">ReadMajority</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Set2Key</span><span class="o">,</span> <span class="n">readMajority</span><span class="o">)</span>

<span class="k">val</span> <span class="n">readAll</span> <span class="k">=</span> <span class="nc">ReadAll</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">ActiveFlagKey</span><span class="o">,</span> <span class="n">readAll</span><span class="o">)</span>
</pre></div>
</div>
<p>As reply of the <code class="docutils literal"><span class="pre">Get</span></code> a <code class="docutils literal"><span class="pre">Replicator.GetSuccess</span></code> is sent to the sender of the
<code class="docutils literal"><span class="pre">Get</span></code> if the value was successfully retrieved according to the supplied consistency
level within the supplied timeout. Otherwise a <code class="docutils literal"><span class="pre">Replicator.GetFailure</span></code> is sent.
If the key does not exist the reply will be <code class="docutils literal"><span class="pre">Replicator.NotFound</span></code>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">value</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">).</span><span class="n">value</span>
<span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// key counter1 does not exist</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">elements</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">).</span><span class="n">elements</span>
<span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span>
<span class="c1">// read from 3 nodes failed within 1.second</span>
<span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="c1">// key set1 does not exist</span>
</pre></div>
</div>
<p>You will always read your own writes. For example if you send a <code class="docutils literal"><span class="pre">Update</span></code> message
followed by a <code class="docutils literal"><span class="pre">Get</span></code> of the same <code class="docutils literal"><span class="pre">key</span></code> the <code class="docutils literal"><span class="pre">Get</span></code> will retrieve the change that was
performed by the preceding <code class="docutils literal"><span class="pre">Update</span></code> message. However, the order of the reply messages are
not defined, i.e. in the previous example you may receive the <code class="docutils literal"><span class="pre">GetSuccess</span></code> before
the <code class="docutils literal"><span class="pre">UpdateSuccess</span></code>.</p>
<p>In the <code class="docutils literal"><span class="pre">Get</span></code> message you can pass an optional request context in the same way as for the
<code class="docutils literal"><span class="pre">Update</span></code> message, described above. For example the original sender can be passed and replied
to after receiving and transforming <code class="docutils literal"><span class="pre">GetSuccess</span></code>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="n">readTwo</span> <span class="k">=</span> <span class="nc">ReadFrom</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>

<span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;get-count&quot;</span> <span class="k">=&gt;</span>
    <span class="c1">// incoming request to retrieve current value of the counter</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">readTwo</span><span class="o">,</span> <span class="n">request</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sender</span><span class="o">()))</span>

  <span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">value</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">).</span><span class="n">value</span><span class="o">.</span><span class="n">longValue</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="n">value</span>
  <span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="o">-</span><span class="mi">1L</span>
  <span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="mi">0L</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="consistency">
<h3>Consistency</h3>
<p>The consistency level that is supplied in the <a class="reference internal" href="#replicator-update-scala"><span class="std std-ref">Update</span></a> and <a class="reference internal" href="#replicator-get-scala"><span class="std std-ref">Get</span></a>
specifies per request how many replicas that must respond successfully to a write and read request.</p>
<p>For low latency reads you use <code class="docutils literal"><span class="pre">ReadLocal</span></code> with the risk of retrieving stale data, i.e. updates
from other nodes might not be visible yet.</p>
<p>When using <code class="docutils literal"><span class="pre">WriteLocal</span></code> the update is only written to the local replica and then disseminated
in the background with the gossip protocol, which can take few seconds to spread to all nodes.</p>
<p><code class="docutils literal"><span class="pre">WriteAll</span></code> and <code class="docutils literal"><span class="pre">ReadAll</span></code> is the strongest consistency level, but also the slowest and with
lowest availability. For example, it is enough that one node is unavailable for a <code class="docutils literal"><span class="pre">Get</span></code> request
and you will not receive the value.</p>
<p>If consistency is important, you can ensure that a read always reflects the most recent
write by using the following formula:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">nodes_written</span> <span class="o">+</span> <span class="n">nodes_read</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">N</span>
</pre></div>
</div>
<p>where N is the total number of nodes in the cluster, or the number of nodes with the role that is
used for the <code class="docutils literal"><span class="pre">Replicator</span></code>.</p>
<p>For example, in a 7 node cluster this these consistency properties are achieved by writing to 4 nodes
and reading from 4 nodes, or writing to 5 nodes and reading from 3 nodes.</p>
<p>By combining <code class="docutils literal"><span class="pre">WriteMajority</span></code> and <code class="docutils literal"><span class="pre">ReadMajority</span></code> levels a read always reflects the most recent write.
The <code class="docutils literal"><span class="pre">Replicator</span></code> writes and reads to a majority of replicas, i.e. <strong>N / 2 + 1</strong>. For example,
in a 5 node cluster it writes to 3 nodes and reads from 3 nodes. In a 6 node cluster it writes
to 4 nodes and reads from 4 nodes.</p>
<p>You can define a minimum number of nodes for <code class="docutils literal"><span class="pre">WriteMajority</span></code> and <code class="docutils literal"><span class="pre">ReadMajority</span></code>,
this will minimize the risk of reading steal data. Minimum cap is
provided by minCap property of <code class="docutils literal"><span class="pre">WriteMajority</span></code> and <code class="docutils literal"><span class="pre">ReadMajority</span></code> and defines the required majority.
If the minCap is higher then <strong>N / 2 + 1</strong> the minCap will be used.</p>
<p>For example if the minCap is 5 the <code class="docutils literal"><span class="pre">WriteMajority</span></code> and <code class="docutils literal"><span class="pre">ReadMajority</span></code> for cluster of 3 nodes will be 3, for
cluster of 6 nodes will be 5 and for cluster of 12 nodes will be 7(<strong>N / 2 + 1</strong>).</p>
<p>For small clusters (&lt;7) the risk of membership changes between a WriteMajority and ReadMajority
is rather high and then the nice properties of combining majority write and reads are not
guaranteed. Therefore the <code class="docutils literal"><span class="pre">ReadMajority</span></code> and <code class="docutils literal"><span class="pre">WriteMajority</span></code> have a <code class="docutils literal"><span class="pre">minCap</span></code> parameter that
is useful to specify to achieve better safety for small clusters. It means that if the cluster
size is smaller than the majority size it will use the <code class="docutils literal"><span class="pre">minCap</span></code> number of nodes but at most
the total size of the cluster.</p>
<p>Here is an example of using <code class="docutils literal"><span class="pre">WriteMajority</span></code> and <code class="docutils literal"><span class="pre">ReadMajority</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">3.</span><span class="n">seconds</span>
<span class="k">private</span> <span class="k">val</span> <span class="n">readMajority</span> <span class="k">=</span> <span class="nc">ReadMajority</span><span class="o">(</span><span class="n">timeout</span><span class="o">)</span>
<span class="k">private</span> <span class="k">val</span> <span class="n">writeMajority</span> <span class="k">=</span> <span class="nc">WriteMajority</span><span class="o">(</span><span class="n">timeout</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">receiveGetCart</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">GetCart</span> <span class="k">=&gt;</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="n">readMajority</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sender</span><span class="o">()))</span>

  <span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">cart</span> <span class="k">=</span> <span class="nc">Cart</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">toSet</span><span class="o">)</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="n">cart</span>

  <span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="nc">Cart</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>

  <span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="c1">// ReadMajority failure, try again with local read</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">ReadLocal</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">receiveAddItem</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">cmd</span> <span class="k">@</span> <span class="nc">AddItem</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">update</span> <span class="k">=</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">LWWMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">LineItem</span><span class="o">],</span> <span class="n">writeMajority</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">cmd</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">cart</span> <span class="k">=&gt;</span> <span class="n">updateCart</span><span class="o">(</span><span class="n">cart</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="n">update</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In some rare cases, when performing an <code class="docutils literal"><span class="pre">Update</span></code> it is needed to first try to fetch latest data from
other nodes. That can be done by first sending a <code class="docutils literal"><span class="pre">Get</span></code> with <code class="docutils literal"><span class="pre">ReadMajority</span></code> and then continue with
the <code class="docutils literal"><span class="pre">Update</span></code> when the <code class="docutils literal"><span class="pre">GetSuccess</span></code>, <code class="docutils literal"><span class="pre">GetFailure</span></code> or <code class="docutils literal"><span class="pre">NotFound</span></code> reply is received. This might be
needed when you need to base a decision on latest information or when removing entries from <code class="docutils literal"><span class="pre">ORSet</span></code>
or <code class="docutils literal"><span class="pre">ORMap</span></code>. If an entry is added to an <code class="docutils literal"><span class="pre">ORSet</span></code> or <code class="docutils literal"><span class="pre">ORMap</span></code> from one node and removed from another
node the entry will only be removed if the added entry is visible on the node where the removal is
performed (hence the name observed-removed set).</p>
<p>The following example illustrates how to do that:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">receiveRemoveItem</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">cmd</span> <span class="k">@</span> <span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// Try to fetch latest from a majority of nodes first, since ORMap</span>
    <span class="c1">// remove must have seen the item to be able to remove it.</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="n">readMajority</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">cmd</span><span class="o">))</span>

  <span class="k">case</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">LWWMap</span><span class="o">(),</span> <span class="n">writeMajority</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">_</span> <span class="o">-</span> <span class="n">productId</span>
    <span class="o">}</span>

  <span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="c1">// ReadMajority failed, fall back to best effort local value</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">LWWMap</span><span class="o">(),</span> <span class="n">writeMajority</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">_</span> <span class="o">-</span> <span class="n">productId</span>
    <span class="o">}</span>

  <span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)))</span> <span class="k">=&gt;</span>
  <span class="c1">// nothing to remove</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><em>Caveat:</em> Even if you use <code class="docutils literal"><span class="pre">WriteMajority</span></code> and <code class="docutils literal"><span class="pre">ReadMajority</span></code> there is small risk that you may
read stale data if the cluster membership has changed between the <code class="docutils literal"><span class="pre">Update</span></code> and the <code class="docutils literal"><span class="pre">Get</span></code>.
For example, in cluster of 5 nodes when you <code class="docutils literal"><span class="pre">Update</span></code> and that change is written to 3 nodes:
n1, n2, n3. Then 2 more nodes are added and a <code class="docutils literal"><span class="pre">Get</span></code> request is reading from 4 nodes, which
happens to be n4, n5, n6, n7, i.e. the value on n1, n2, n3 is not seen in the response of the
<code class="docutils literal"><span class="pre">Get</span></code> request.</p>
</div>
</div>
<div class="section" id="subscribe">
<h3>Subscribe</h3>
<p>You may also register interest in change notifications by sending <code class="docutils literal"><span class="pre">Replicator.Subscribe</span></code>
message to the <code class="docutils literal"><span class="pre">Replicator</span></code>. It will send <code class="docutils literal"><span class="pre">Replicator.Changed</span></code> messages to the registered
subscriber when the data for the subscribed key is updated. Subscribers will be notified
periodically with the configured <code class="docutils literal"><span class="pre">notify-subscribers-interval</span></code>, and it is also possible to
send an explicit <code class="docutils literal"><span class="pre">Replicator.FlushChanges</span></code> message to the <code class="docutils literal"><span class="pre">Replicator</span></code> to notify the subscribers
immediately.</p>
<p>The subscriber is automatically removed if the subscriber is terminated. A subscriber can
also be deregistered with the <code class="docutils literal"><span class="pre">Replicator.Unsubscribe</span></code> message.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="c1">// subscribe to changes of the Counter1Key value</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Subscribe</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">self</span><span class="o">)</span>
<span class="k">var</span> <span class="n">currentValue</span> <span class="k">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">c</span> <span class="k">@</span> <span class="nc">Changed</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">currentValue</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">).</span><span class="n">value</span>
  <span class="k">case</span> <span class="s">&quot;get-count&quot;</span> <span class="k">=&gt;</span>
    <span class="c1">// incoming request to retrieve current value of the counter</span>
    <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">currentValue</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="delete">
<h3>Delete</h3>
<p>A data entry can be deleted by sending a <code class="docutils literal"><span class="pre">Replicator.Delete</span></code> message to the local
local <code class="docutils literal"><span class="pre">Replicator</span></code>. As reply of the <code class="docutils literal"><span class="pre">Delete</span></code> a <code class="docutils literal"><span class="pre">Replicator.DeleteSuccess</span></code> is sent to
the sender of the <code class="docutils literal"><span class="pre">Delete</span></code> if the value was successfully deleted according to the supplied
consistency level within the supplied timeout. Otherwise a <code class="docutils literal"><span class="pre">Replicator.ReplicationDeleteFailure</span></code>
is sent. Note that <code class="docutils literal"><span class="pre">ReplicationDeleteFailure</span></code> does not mean that the delete completely failed or
was rolled back. It may still have been replicated to some nodes, and may eventually be replicated
to all nodes.</p>
<p>A deleted key cannot be reused again, but it is still recommended to delete unused
data entries because that reduces the replication overhead when new nodes join the cluster.
Subsequent <code class="docutils literal"><span class="pre">Delete</span></code>, <code class="docutils literal"><span class="pre">Update</span></code> and <code class="docutils literal"><span class="pre">Get</span></code> requests will be replied with <code class="docutils literal"><span class="pre">Replicator.DataDeleted</span></code>.
Subscribers will receive <code class="docutils literal"><span class="pre">Replicator.Deleted</span></code>.</p>
<p>In the <cite>Delete</cite> message you can pass an optional request context in the same way as for the
<cite>Update</cite> message, described above. For example the original sender can be passed and replied
to after receiving and transforming <cite>DeleteSuccess</cite>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set2Key</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set2&quot;</span><span class="o">)</span>

<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Delete</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">WriteLocal</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeMajority</span> <span class="k">=</span> <span class="nc">WriteMajority</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Delete</span><span class="o">(</span><span class="nc">Set2Key</span><span class="o">,</span> <span class="n">writeMajority</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">As deleted keys continue to be included in the stored data on each node as well as in gossip
messages, a continuous series of updates and deletes of top-level entities will result in
growing memory usage until an ActorSystem runs out of memory. To use Akka Distributed Data
where frequent adds and removes are required, you should use a fixed number of top-level data
types that support both updates and removals, for example <code class="docutils literal"><span class="pre">ORMap</span></code> or <code class="docutils literal"><span class="pre">ORSet</span></code>.</p>
</div>
</div>
<div class="section" id="delta-crdt">
<span id="delta-crdt-scala"></span><h3>delta-CRDT</h3>
<p><a class="reference external" href="http://arxiv.org/abs/1603.01529">Delta State Replicated Data Types</a>
are supported. delta-CRDT is a way to reduce the need for sending the full state
for updates. For example adding element <code class="docutils literal"><span class="pre">'c'</span></code> and <code class="docutils literal"><span class="pre">'d'</span></code> to set <code class="docutils literal"><span class="pre">{'a',</span> <span class="pre">'b'}</span></code> would
result in sending the delta <code class="docutils literal"><span class="pre">{'c',</span> <span class="pre">'d'}</span></code> and merge that with the state on the
receiving side, resulting in set <code class="docutils literal"><span class="pre">{'a',</span> <span class="pre">'b',</span> <span class="pre">'c',</span> <span class="pre">'d'}</span></code>.</p>
<p>The protocol for replicating the deltas supports causal consistency if the data type
is marked with <code class="docutils literal"><span class="pre">RequiresCausalDeliveryOfDeltas</span></code>. Otherwise it is only eventually
consistent. Without causal consistency it means that if elements <code class="docutils literal"><span class="pre">'c'</span></code> and <code class="docutils literal"><span class="pre">'d'</span></code> are
added in two separate <cite>Update</cite> operations these deltas may occasionally be propagated
to nodes in different order than the causal order of the updates. For this example it
can result in that set <code class="docutils literal"><span class="pre">{'a',</span> <span class="pre">'b',</span> <span class="pre">'d'}</span></code> can be seen before element 'c' is seen. Eventually
it will be <code class="docutils literal"><span class="pre">{'a',</span> <span class="pre">'b',</span> <span class="pre">'c',</span> <span class="pre">'d'}</span></code>.</p>
<p>Note that the full state is occasionally also replicated for delta-CRDTs, for example when
new nodes are added to the cluster or when deltas could not be propagated because
of network partitions or similar problems.</p>
<p>The the delta propagation can be disabled with configuration property:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">distributed</span><span class="o">-</span><span class="n">data</span><span class="o">.</span><span class="n">delta</span><span class="o">-</span><span class="n">crdt</span><span class="o">.</span><span class="n">enabled</span><span class="k">=</span><span class="n">off</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="data-types">
<h2>Data Types</h2>
<p>The data types must be convergent (stateful) CRDTs and implement the <code class="docutils literal"><span class="pre">ReplicatedData</span></code> trait,
i.e. they provide a monotonic merge function and the state changes always converge.</p>
<p>You can use your own custom <code class="docutils literal"><span class="pre">ReplicatedData</span></code> or <code class="docutils literal"><span class="pre">DeltaReplicatedData</span></code> types, and several types are provided
by this package, such as:</p>
<ul class="simple">
<li>Counters: <code class="docutils literal"><span class="pre">GCounter</span></code>, <code class="docutils literal"><span class="pre">PNCounter</span></code></li>
<li>Sets: <code class="docutils literal"><span class="pre">GSet</span></code>, <code class="docutils literal"><span class="pre">ORSet</span></code></li>
<li>Maps: <code class="docutils literal"><span class="pre">ORMap</span></code>, <code class="docutils literal"><span class="pre">ORMultiMap</span></code>, <code class="docutils literal"><span class="pre">LWWMap</span></code>, <code class="docutils literal"><span class="pre">PNCounterMap</span></code></li>
<li>Registers: <code class="docutils literal"><span class="pre">LWWRegister</span></code>, <code class="docutils literal"><span class="pre">Flag</span></code></li>
</ul>
<div class="section" id="counters">
<h3>Counters</h3>
<p><code class="docutils literal"><span class="pre">GCounter</span></code> is a &quot;grow only counter&quot;. It only supports increments, no decrements.</p>
<p>It works in a similar way as a vector clock. It keeps track of one counter per node and the total
value is the sum of these counters. The <code class="docutils literal"><span class="pre">merge</span></code> is implemented by taking the maximum count for
each node.</p>
<p>If you need both increments and decrements you can use the <code class="docutils literal"><span class="pre">PNCounter</span></code> (positive/negative counter).</p>
<p>It is tracking the increments (P) separate from the decrements (N). Both P and N are represented
as two internal <code class="docutils literal"><span class="pre">GCounter</span></code>. Merge is handled by merging the internal P and N counters.
The value of the counter is the value of the P counter minus the value of the N counter.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">c0</span> <span class="k">=</span> <span class="nc">PNCounter</span><span class="o">.</span><span class="n">empty</span>
<span class="k">val</span> <span class="n">c1</span> <span class="k">=</span> <span class="n">c0</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">c2</span> <span class="k">=</span> <span class="n">c1</span> <span class="o">+</span> <span class="mi">7</span>
<span class="k">val</span> <span class="n">c3</span><span class="k">:</span> <span class="kt">PNCounter</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="mi">2</span>
<span class="n">println</span><span class="o">(</span><span class="n">c3</span><span class="o">.</span><span class="n">value</span><span class="o">)</span> <span class="c1">// 6</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">GCounter</span></code> and <code class="docutils literal"><span class="pre">PNCounter</span></code> have support for <a class="reference internal" href="#delta-crdt-scala"><span class="std std-ref">delta-CRDT</span></a> and don't need causal
delivery of deltas.</p>
<p>Several related counters can be managed in a map with the <code class="docutils literal"><span class="pre">PNCounterMap</span></code> data type.
When the counters are placed in a <code class="docutils literal"><span class="pre">PNCounterMap</span></code> as opposed to placing them as separate top level
values they are guaranteed to be replicated together as one unit, which is sometimes necessary for
related data.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m0</span> <span class="k">=</span> <span class="nc">PNCounterMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">val</span> <span class="n">m1</span> <span class="k">=</span> <span class="n">m0</span><span class="o">.</span><span class="n">increment</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m2</span> <span class="k">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">decrement</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m3</span> <span class="k">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">increment</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">m3</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">))</span> <span class="c1">// 5</span>
<span class="n">m3</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">s&quot;</span><span class="si">$key</span><span class="s"> -&gt; </span><span class="si">$value</span><span class="s">&quot;</span><span class="o">)</span> <span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sets">
<h3>Sets</h3>
<p>If you only need to add elements to a set and not remove elements the <code class="docutils literal"><span class="pre">GSet</span></code> (grow-only set) is
the data type to use. The elements can be any type of values that can be serialized.
Merge is simply the union of the two sets.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">s0</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="s">&quot;a&quot;</span>
<span class="k">val</span> <span class="n">s2</span> <span class="k">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">&quot;b&quot;</span> <span class="o">+</span> <span class="s">&quot;c&quot;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">))</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="n">elements</span><span class="o">)</span> <span class="c1">// a, b, c</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">GSet</span></code> has support for <a class="reference internal" href="#delta-crdt-scala"><span class="std std-ref">delta-CRDT</span></a> and it doesn't require causal delivery of deltas.</p>
<p>If you need add and remove operations you should use the <code class="docutils literal"><span class="pre">ORSet</span></code> (observed-remove set).
Elements can be added and removed any number of times. If an element is concurrently added and
removed, the add will win. You cannot remove an element that you have not seen.</p>
<p>The <code class="docutils literal"><span class="pre">ORSet</span></code> has a version vector that is incremented when an element is added to the set.
The version for the node that added the element is also tracked for each element in a so
called &quot;birth dot&quot;. The version vector and the dots are used by the <code class="docutils literal"><span class="pre">merge</span></code> function to
track causality of the operations and resolve concurrent updates.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">s0</span> <span class="k">=</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="s">&quot;a&quot;</span>
<span class="k">val</span> <span class="n">s2</span> <span class="k">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">&quot;b&quot;</span>
<span class="k">val</span> <span class="n">s3</span> <span class="k">=</span> <span class="n">s2</span> <span class="o">-</span> <span class="s">&quot;a&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">s3</span><span class="o">.</span><span class="n">elements</span><span class="o">)</span> <span class="c1">// b</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ORSet</span></code> has support for <a class="reference internal" href="#delta-crdt-scala"><span class="std std-ref">delta-CRDT</span></a> and it requires causal delivery of deltas.</p>
</div>
<div class="section" id="maps">
<h3>Maps</h3>
<p><code class="docutils literal"><span class="pre">ORMap</span></code> (observed-remove map) is a map with keys of <code class="docutils literal"><span class="pre">Any</span></code> type and the values are <code class="docutils literal"><span class="pre">ReplicatedData</span></code>
types themselves. It supports add, remove and delete any number of times for a map entry.</p>
<p>If an entry is concurrently added and removed, the add will win. You cannot remove an entry that
you have not seen. This is the same semantics as for the <code class="docutils literal"><span class="pre">ORSet</span></code>.</p>
<p>If an entry is concurrently updated to different values the values will be merged, hence the
requirement that the values must be <code class="docutils literal"><span class="pre">ReplicatedData</span></code> types.</p>
<p>It is rather inconvenient to use the <code class="docutils literal"><span class="pre">ORMap</span></code> directly since it does not expose specific types
of the values. The <code class="docutils literal"><span class="pre">ORMap</span></code> is intended as a low level tool for building more specific maps,
such as the following specialized maps.</p>
<p><code class="docutils literal"><span class="pre">ORMultiMap</span></code> (observed-remove multi-map) is a multi-map implementation that wraps an
<code class="docutils literal"><span class="pre">ORMap</span></code> with an <code class="docutils literal"><span class="pre">ORSet</span></code> for the map's value.</p>
<p><code class="docutils literal"><span class="pre">PNCounterMap</span></code> (positive negative counter map) is a map of named counters (where the name can be of any type).
It is a specialized <code class="docutils literal"><span class="pre">ORMap</span></code> with <code class="docutils literal"><span class="pre">PNCounter</span></code> values.</p>
<p><code class="docutils literal"><span class="pre">LWWMap</span></code> (last writer wins map) is a specialized <code class="docutils literal"><span class="pre">ORMap</span></code> with <code class="docutils literal"><span class="pre">LWWRegister</span></code> (last writer wins register)
values.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m0</span> <span class="k">=</span> <span class="nc">ORMultiMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="k">val</span> <span class="n">m1</span> <span class="k">=</span> <span class="n">m0</span> <span class="o">+</span> <span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="k">val</span> <span class="n">m2</span> <span class="k">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">addBinding</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m3</span> <span class="k">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">removeBinding</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m4</span> <span class="k">=</span> <span class="n">m3</span><span class="o">.</span><span class="n">addBinding</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">m4</span><span class="o">.</span><span class="n">entries</span><span class="o">)</span>
</pre></div>
</div>
<p>When a data entry is changed the full state of that entry is replicated to other nodes, i.e.
when you update a map the whole map is replicated. Therefore, instead of using one <code class="docutils literal"><span class="pre">ORMap</span></code>
with 1000 elements it is more efficient to split that up in 10 top level <code class="docutils literal"><span class="pre">ORMap</span></code> entries
with 100 elements each. Top level entries are replicated individually, which has the
trade-off that different entries may not be replicated at the same time and you may see
inconsistencies between related entries. Separate top level entries cannot be updated atomically
together.</p>
<p>Note that <code class="docutils literal"><span class="pre">LWWRegister</span></code> and therefore <code class="docutils literal"><span class="pre">LWWMap</span></code> relies on synchronized clocks and should only be used
when the choice of value is not important for concurrent updates occurring within the clock skew. Read more
in the below section about <code class="docutils literal"><span class="pre">LWWRegister</span></code>.</p>
</div>
<div class="section" id="flags-and-registers">
<h3>Flags and Registers</h3>
<p><code class="docutils literal"><span class="pre">Flag</span></code> is a data type for a boolean value that is initialized to <code class="docutils literal"><span class="pre">false</span></code> and can be switched
to <code class="docutils literal"><span class="pre">true</span></code>. Thereafter it cannot be changed. <code class="docutils literal"><span class="pre">true</span></code> wins over <code class="docutils literal"><span class="pre">false</span></code> in merge.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">f0</span> <span class="k">=</span> <span class="nc">Flag</span><span class="o">.</span><span class="n">empty</span>
<span class="k">val</span> <span class="n">f1</span> <span class="k">=</span> <span class="n">f0</span><span class="o">.</span><span class="n">switchOn</span>
<span class="n">println</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="n">enabled</span><span class="o">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">LWWRegister</span></code> (last writer wins register) can hold any (serializable) value.</p>
<p>Merge of a <code class="docutils literal"><span class="pre">LWWRegister</span></code> takes the register with highest timestamp. Note that this
relies on synchronized clocks. <cite>LWWRegister</cite> should only be used when the choice of
value is not important for concurrent updates occurring within the clock skew.</p>
<p>Merge takes the register updated by the node with lowest address (<code class="docutils literal"><span class="pre">UniqueAddress</span></code> is ordered)
if the timestamps are exactly the same.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">LWWRegister</span><span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">withValue</span><span class="o">(</span><span class="s">&quot;Hi&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">s&quot;</span><span class="si">${</span><span class="n">r1</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s"> by </span><span class="si">${</span><span class="n">r1</span><span class="o">.</span><span class="n">updatedBy</span><span class="si">}</span><span class="s"> at </span><span class="si">${</span><span class="n">r1</span><span class="o">.</span><span class="n">timestamp</span><span class="si">}</span><span class="s">&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Instead of using timestamps based on <code class="docutils literal"><span class="pre">System.currentTimeMillis()</span></code> time it is possible to
use a timestamp value based on something else, for example an increasing version number
from a database record that is used for optimistic concurrency control.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Record</span><span class="o">(</span><span class="n">version</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">recordClock</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LWWRegister</span><span class="o">.</span><span class="nc">Clock</span><span class="o">[</span><span class="kt">Record</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">currentTimestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Record</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
    <span class="n">value</span><span class="o">.</span><span class="n">version</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">record1</span> <span class="k">=</span> <span class="nc">Record</span><span class="o">(</span><span class="n">version</span> <span class="k">=</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Alice&quot;</span><span class="o">,</span> <span class="s">&quot;Union Square&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">LWWRegister</span><span class="o">(</span><span class="n">record1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">record2</span> <span class="k">=</span> <span class="nc">Record</span><span class="o">(</span><span class="n">version</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span> <span class="s">&quot;Alice&quot;</span><span class="o">,</span> <span class="s">&quot;Madison Square&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="nc">LWWRegister</span><span class="o">(</span><span class="n">record2</span><span class="o">)</span>

<span class="k">val</span> <span class="n">r3</span> <span class="k">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">r2</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">r3</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
</pre></div>
</div>
<p>For first-write-wins semantics you can use the <code class="docutils literal"><span class="pre">LWWRegister#reverseClock</span></code> instead of the
<code class="docutils literal"><span class="pre">LWWRegister#defaultClock</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">defaultClock</span></code> is using max value of <code class="docutils literal"><span class="pre">System.currentTimeMillis()</span></code> and <code class="docutils literal"><span class="pre">currentTimestamp</span> <span class="pre">+</span> <span class="pre">1</span></code>.
This means that the timestamp is increased for changes on the same node that occurs within
the same millisecond. It also means that it is safe to use the <code class="docutils literal"><span class="pre">LWWRegister</span></code> without
synchronized clocks when there is only one active writer, e.g. a Cluster Singleton. Such a
single writer should then first read current value with <code class="docutils literal"><span class="pre">ReadMajority</span></code> (or more) before
changing and writing the value with <code class="docutils literal"><span class="pre">WriteMajority</span></code> (or more).</p>
</div>
<div class="section" id="custom-data-type">
<h3>Custom Data Type</h3>
<p>You can rather easily implement your own data types. The only requirement is that it implements
the <code class="docutils literal"><span class="pre">merge</span></code> function of the <code class="docutils literal"><span class="pre">ReplicatedData</span></code> trait.</p>
<p>A nice property of stateful CRDTs is that they typically compose nicely, i.e. you can combine several
smaller data types to build richer data structures. For example, the <code class="docutils literal"><span class="pre">PNCounter</span></code> is composed of
two internal <code class="docutils literal"><span class="pre">GCounter</span></code> instances to keep track of increments and decrements separately.</p>
<p>Here is s simple implementation of a custom <code class="docutils literal"><span class="pre">TwoPhaseSet</span></code> that is using two internal <code class="docutils literal"><span class="pre">GSet</span></code> types
to keep track of addition and removals.  A <code class="docutils literal"><span class="pre">TwoPhaseSet</span></code> is a set where an element may be added and
removed, but never added again thereafter.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">TwoPhaseSet</span><span class="o">(</span>
  <span class="n">adds</span><span class="k">:</span>     <span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span>
  <span class="n">removals</span><span class="k">:</span> <span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">ReplicatedData</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">TwoPhaseSet</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span>
    <span class="n">copy</span><span class="o">(</span><span class="n">adds</span> <span class="k">=</span> <span class="n">adds</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">element</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span>
    <span class="n">copy</span><span class="o">(</span><span class="n">removals</span> <span class="k">=</span> <span class="n">removals</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">element</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">elements</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">adds</span><span class="o">.</span><span class="n">elements</span> <span class="n">diff</span> <span class="n">removals</span><span class="o">.</span><span class="n">elements</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span>
    <span class="n">copy</span><span class="o">(</span>
      <span class="n">adds</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">adds</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">adds</span><span class="o">),</span>
      <span class="n">removals</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">removals</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">removals</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Data types should be immutable, i.e. &quot;modifying&quot; methods should return a new instance.</p>
<p>Implement the additional methods of <code class="docutils literal"><span class="pre">DeltaReplicatedData</span></code> if it has support for delta-CRDT replication.</p>
<div class="section" id="serialization">
<h4>Serialization</h4>
<p>The data types must be serializable with an <a class="reference internal" href="serialization.html#serialization-scala"><span class="std std-ref">Akka Serializer</span></a>.
It is highly recommended that you implement  efficient serialization with Protobuf or similar
for your custom data types. The built in data types are marked with <code class="docutils literal"><span class="pre">ReplicatedDataSerialization</span></code>
and serialized with <code class="docutils literal"><span class="pre">akka.cluster.ddata.protobuf.ReplicatedDataSerializer</span></code>.</p>
<p>Serialization of the data types are used in remote messages and also for creating message
digests (SHA-1) to detect changes. Therefore it is important that the serialization is efficient
and produce the same bytes for the same content. For example sets and maps should be sorted
deterministically in the serialization.</p>
<p>This is a protobuf representation of the above <code class="docutils literal"><span class="pre">TwoPhaseSet</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">option</span> <span class="n">java_package</span> <span class="k">=</span> <span class="s">&quot;docs.ddata.protobuf.msg&quot;</span><span class="o">;</span>
<span class="n">option</span> <span class="n">optimize_for</span> <span class="k">=</span> <span class="nc">SPEED</span><span class="o">;</span>

<span class="n">message</span> <span class="nc">TwoPhaseSet</span> <span class="o">{</span>
  <span class="n">repeated</span> <span class="n">string</span> <span class="n">adds</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">repeated</span> <span class="n">string</span> <span class="n">removals</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The serializer for the <code class="docutils literal"><span class="pre">TwoPhaseSet</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.util.ArrayList</span>
<span class="k">import</span> <span class="nn">java.util.Collections</span>
<span class="k">import</span> <span class="nn">scala.collection.JavaConverters._</span>
<span class="k">import</span> <span class="nn">akka.actor.ExtendedActorSystem</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.GSet</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.protobuf.SerializationSupport</span>
<span class="k">import</span> <span class="nn">akka.serialization.Serializer</span>
<span class="k">import</span> <span class="nn">docs.ddata.TwoPhaseSet</span>
<span class="k">import</span> <span class="nn">docs.ddata.protobuf.msg.TwoPhaseSetMessages</span>

<span class="k">class</span> <span class="nc">TwoPhaseSetSerializer</span><span class="o">(</span><span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ExtendedActorSystem</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Serializer</span> <span class="k">with</span> <span class="nc">SerializationSupport</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">includeManifest</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span> <span class="k">=</span> <span class="mi">99999</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=&gt;</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">m</span><span class="o">).</span><span class="n">toByteArray</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="s">s&quot;Can&#39;t serialize object of type </span><span class="si">${</span><span class="n">obj</span><span class="o">.</span><span class="n">getClass</span><span class="si">}</span><span class="s">&quot;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">clazz</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSetMessages.TwoPhaseSet</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet</span><span class="o">.</span><span class="n">newBuilder</span><span class="o">()</span>
    <span class="c1">// using java collections and sorting for performance (avoid conversions)</span>
    <span class="k">val</span> <span class="n">adds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">adds</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">adds</span><span class="o">.</span><span class="n">add</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">adds</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Collections</span><span class="o">.</span><span class="n">sort</span><span class="o">(</span><span class="n">adds</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">addAllAdds</span><span class="o">(</span><span class="n">adds</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">val</span> <span class="n">removals</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">removals</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">removals</span><span class="o">.</span><span class="n">add</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">removals</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Collections</span><span class="o">.</span><span class="n">sort</span><span class="o">(</span><span class="n">removals</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">addAllRemovals</span><span class="o">(</span><span class="n">removals</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">b</span><span class="o">.</span><span class="n">build</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet</span><span class="o">.</span><span class="n">parseFrom</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">addsSet</span> <span class="k">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">getAddsList</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">toSet</span>
    <span class="k">val</span> <span class="n">removalsSet</span> <span class="k">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">getRemovalsList</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">toSet</span>
    <span class="k">val</span> <span class="n">adds</span> <span class="k">=</span> <span class="n">addsSet</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">])((</span><span class="n">acc</span><span class="o">,</span> <span class="n">el</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">el</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">removals</span> <span class="k">=</span> <span class="n">removalsSet</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">])((</span><span class="n">acc</span><span class="o">,</span> <span class="n">el</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">el</span><span class="o">))</span>
    <span class="c1">// GSet will accumulate deltas when adding elements,</span>
    <span class="c1">// but those are not of interest in the result of the deserialization</span>
    <span class="nc">TwoPhaseSet</span><span class="o">(</span><span class="n">adds</span><span class="o">.</span><span class="n">resetDelta</span><span class="o">,</span> <span class="n">removals</span><span class="o">.</span><span class="n">resetDelta</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that the elements of the sets are sorted so the SHA-1 digests are the same
for the same elements.</p>
<p>You register the serializer in configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">actor</span> <span class="o">{</span>
  <span class="n">serializers</span> <span class="o">{</span>
    <span class="n">two</span><span class="o">-</span><span class="n">phase</span><span class="o">-</span><span class="n">set</span> <span class="k">=</span> <span class="s">&quot;docs.ddata.protobuf.TwoPhaseSetSerializer&quot;</span>
  <span class="o">}</span>
  <span class="n">serialization</span><span class="o">-</span><span class="n">bindings</span> <span class="o">{</span>
    <span class="s">&quot;docs.ddata.TwoPhaseSet&quot;</span> <span class="k">=</span> <span class="n">two</span><span class="o">-</span><span class="n">phase</span><span class="o">-</span><span class="n">set</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Using compression can sometimes be a good idea to reduce the data size. Gzip compression is
provided by the <code class="docutils literal"><span class="pre">akka.cluster.ddata.protobuf.SerializationSupport</span></code> trait:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=&gt;</span> <span class="n">compress</span><span class="o">(</span><span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">m</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
    <span class="s">s&quot;Can&#39;t serialize object of type </span><span class="si">${</span><span class="n">obj</span><span class="o">.</span><span class="n">getClass</span><span class="si">}</span><span class="s">&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">clazz</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">decompress</span><span class="o">(</span><span class="n">bytes</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The two embedded <code class="docutils literal"><span class="pre">GSet</span></code> can be serialized as illustrated above, but in general when composing
new data types from the existing built in types it is better to make use of the existing
serializer for those types. This can be done by declaring those as bytes fields in protobuf:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">message</span> <span class="nc">TwoPhaseSet2</span> <span class="o">{</span>
  <span class="n">optional</span> <span class="n">bytes</span> <span class="n">adds</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">optional</span> <span class="n">bytes</span> <span class="n">removals</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>and use the methods <code class="docutils literal"><span class="pre">otherMessageToProto</span></code> and <code class="docutils literal"><span class="pre">otherMessageFromBinary</span></code> that are provided
by the <code class="docutils literal"><span class="pre">SerializationSupport</span></code> trait to serialize and deserialize the <code class="docutils literal"><span class="pre">GSet</span></code> instances. This
works with any type that has a registered Akka serializer. This is how such an serializer would
look like for the <code class="docutils literal"><span class="pre">TwoPhaseSet</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.ExtendedActorSystem</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.GSet</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.protobuf.ReplicatedDataSerializer</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.protobuf.SerializationSupport</span>
<span class="k">import</span> <span class="nn">akka.serialization.Serializer</span>
<span class="k">import</span> <span class="nn">docs.ddata.TwoPhaseSet</span>
<span class="k">import</span> <span class="nn">docs.ddata.protobuf.msg.TwoPhaseSetMessages</span>

<span class="k">class</span> <span class="nc">TwoPhaseSetSerializer2</span><span class="o">(</span><span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ExtendedActorSystem</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Serializer</span> <span class="k">with</span> <span class="nc">SerializationSupport</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">includeManifest</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span> <span class="k">=</span> <span class="mi">99999</span>

  <span class="k">val</span> <span class="n">replicatedDataSerializer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ReplicatedDataSerializer</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=&gt;</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">m</span><span class="o">).</span><span class="n">toByteArray</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="s">s&quot;Can&#39;t serialize object of type </span><span class="si">${</span><span class="n">obj</span><span class="o">.</span><span class="n">getClass</span><span class="si">}</span><span class="s">&quot;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">clazz</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSetMessages.TwoPhaseSet2</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet2</span><span class="o">.</span><span class="n">newBuilder</span><span class="o">()</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">adds</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">setAdds</span><span class="o">(</span><span class="n">otherMessageToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">adds</span><span class="o">).</span><span class="n">toByteString</span><span class="o">())</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">removals</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">setRemovals</span><span class="o">(</span><span class="n">otherMessageToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">removals</span><span class="o">).</span><span class="n">toByteString</span><span class="o">())</span>
    <span class="n">b</span><span class="o">.</span><span class="n">build</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet2</span><span class="o">.</span><span class="n">parseFrom</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">adds</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">hasAdds</span><span class="o">)</span>
        <span class="n">otherMessageFromBinary</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">getAdds</span><span class="o">.</span><span class="n">toByteArray</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
      <span class="k">else</span>
        <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">removals</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">hasRemovals</span><span class="o">)</span>
        <span class="n">otherMessageFromBinary</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">getRemovals</span><span class="o">.</span><span class="n">toByteArray</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
      <span class="k">else</span>
        <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="nc">TwoPhaseSet</span><span class="o">(</span><span class="n">adds</span><span class="o">,</span> <span class="n">removals</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="durable-storage">
<span id="ddata-durable-scala"></span><h3>Durable Storage</h3>
<p>By default the data is only kept in memory. It is redundant since it is replicated to other nodes
in the cluster, but if you stop all nodes the data is lost, unless you have saved it
elsewhere.</p>
<p>Entries can be configured to be durable, i.e. stored on local disk on each node. The stored data will be loaded
next time the replicator is started, i.e. when actor system is restarted. This means data will survive as
long as at least one node from the old cluster takes part in a new cluster. The keys of the durable entries
are configured with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span>akka.cluster.distributed-data.durable.keys = [&quot;a&quot;, &quot;b&quot;, &quot;durable*&quot;]
</pre></div>
</div>
<p>Prefix matching is supported by using <code class="docutils literal"><span class="pre">*</span></code> at the end of a key.</p>
<p>All entries can be made durable by specifying:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span>akka.cluster.distributed-data.durable.keys = [&quot;*&quot;]
</pre></div>
</div>
<p><a class="reference external" href="https://symas.com/products/lightning-memory-mapped-database/">LMDB</a> is the default storage implementation. It is
possible to replace that with another implementation by implementing the actor protocol described in
<code class="docutils literal"><span class="pre">akka.cluster.ddata.DurableStore</span></code> and defining the <code class="docutils literal"><span class="pre">akka.cluster.distributed-data.durable.store-actor-class</span></code>
property for the new implementation.</p>
<p>The location of the files for the data is configured with:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span># Directory of LMDB file. There are two options:
# 1. A relative or absolute path to a directory that ends with &#39;ddata&#39;
#    the full name of the directory will contain name of the ActorSystem
#    and its remote port.
# 2. Otherwise the path is used as is, as a relative or absolute path to
#    a directory.
akka.cluster.distributed-data.durable.lmdb.dir = &quot;ddata&quot;
</pre></div>
</div>
<p>When running in production you may want to configure the directory to a specific
path (alt 2), since the default directory contains the remote port of the
actor system to make the name unique. If using a dynamically assigned
port (0) it will be different each time and the previously stored data
will not be loaded.</p>
<p>Making the data durable has of course a performance cost. By default, each update is flushed
to disk before the <code class="docutils literal"><span class="pre">UpdateSuccess</span></code> reply is sent. For better performance, but with the risk of losing
the last writes if the JVM crashes, you can enable write behind mode. Changes are then accumulated during
a time period before it is written to LMDB and flushed to disk. Enabling write behind is especially
efficient when performing many writes to the same key, because it is only the last value for each key
that will be serialized and stored. The risk of losing writes if the JVM crashes is small since the
data is typically replicated to other nodes immediately according to the given <code class="docutils literal"><span class="pre">WriteConsistency</span></code>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">distributed</span><span class="o">-</span><span class="n">data</span><span class="o">.</span><span class="n">lmdb</span><span class="o">.</span><span class="n">write</span><span class="o">-</span><span class="n">behind</span><span class="o">-</span><span class="n">interval</span> <span class="k">=</span> <span class="mi">200</span> <span class="n">ms</span>
</pre></div>
</div>
<p>Note that you should be prepared to receive <code class="docutils literal"><span class="pre">WriteFailure</span></code> as reply to an <code class="docutils literal"><span class="pre">Update</span></code> of a
durable entry if the data could not be stored for some reason. When enabling <code class="docutils literal"><span class="pre">write-behind-interval</span></code>
such errors will only be logged and <code class="docutils literal"><span class="pre">UpdateSuccess</span></code> will still be the reply to the <code class="docutils literal"><span class="pre">Update</span></code>.</p>
<p>There is one important caveat when it comes pruning of <a class="reference internal" href="#crdt-garbage-scala"><span class="std std-ref">CRDT Garbage</span></a> for durable data.
If and old data entry that was never pruned is injected and merged with existing data after
that the pruning markers have been removed the value will not be correct. The time-to-live
of the markers is defined by configuration
<code class="docutils literal"><span class="pre">akka.cluster.distributed-data.durable.remove-pruning-marker-after</span></code> and is in the magnitude of days.
This would be possible if a node with durable data didn't participate in the pruning
(e.g. it was shutdown) and later started after this time. A node with durable data should not
be stopped for longer time than this duration and if it is joining again after this
duration its data should first be manually removed (from the lmdb directory).</p>
</div>
<div class="section" id="crdt-garbage">
<span id="crdt-garbage-scala"></span><h3>CRDT Garbage</h3>
<p>One thing that can be problematic with CRDTs is that some data types accumulate history (garbage).
For example a <code class="docutils literal"><span class="pre">GCounter</span></code> keeps track of one counter per node. If a <code class="docutils literal"><span class="pre">GCounter</span></code> has been updated
from one node it will associate the identifier of that node forever. That can become a problem
for long running systems with many cluster nodes being added and removed. To solve this problem
the <code class="docutils literal"><span class="pre">Replicator</span></code> performs pruning of data associated with nodes that have been removed from the
cluster. Data types that need pruning have to implement the <code class="docutils literal"><span class="pre">RemovedNodePruning</span></code> trait. See the
API documentation of the <code class="docutils literal"><span class="pre">Replicator</span></code> for details.</p>
</div>
</div>
<div class="section" id="samples">
<h2>Samples</h2>
<p>Several interesting samples are included and described in the
tutorial named <a class="reference external" href="https://example.lightbend.com/v1/download/akka-samples-distributed-data-scala">Akka Distributed Data Samples with Scala</a> (<a class="reference external" href="http://github.com/akka/akka-samples/tree/master/akka-sample-distributed-data-scala">source code</a>)</p>
<ul class="simple">
<li>Low Latency Voting Service</li>
<li>Highly Available Shopping Cart</li>
<li>Distributed Service Registry</li>
<li>Replicated Cache</li>
<li>Replicated Metrics</li>
</ul>
</div>
<div class="section" id="limitations">
<h2>Limitations</h2>
<p>There are some limitations that you should be aware of.</p>
<p>CRDTs cannot be used for all types of problems, and eventual consistency does not fit
all domains. Sometimes you need strong consistency.</p>
<p>It is not intended for <em>Big Data</em>. The number of top level entries should not exceed 100000.
When a new node is added to the cluster all these entries are transferred (gossiped) to the
new node. The entries are split up in chunks and all existing nodes collaborate in the gossip,
but it will take a while (tens of seconds) to transfer all entries and this means that you
cannot have too many top level entries. The current recommended limit is 100000. We will
be able to improve this if needed, but the design is still not intended for billions of entries.</p>
<p>All data is held in memory, which is another reason why it is not intended for <em>Big Data</em>.</p>
<p>When a data entry is changed the full state of that entry may be replicated to other nodes
if it doesn't support <a class="reference internal" href="#delta-crdt-scala"><span class="std std-ref">delta-CRDT</span></a>. The full state is also replicated for delta-CRDTs,
for example when new nodes are added to the cluster or when deltas could not be propagated because
of network partitions or similar problems. This means that you cannot have too large
data entries, because then the remote message size will be too large.</p>
</div>
<div class="section" id="learn-more-about-crdts">
<h2>Learn More about CRDTs</h2>
<ul class="simple">
<li><a class="reference external" href="http://www.ustream.tv/recorded/61448875">The Final Causal Frontier</a>
talk by Sean Cribbs</li>
<li><a class="reference external" href="https://vimeo.com/43903960">Eventually Consistent Data Structures</a>
talk by Sean Cribbs</li>
<li><a class="reference external" href="http://research.microsoft.com/apps/video/default.aspx?id=153540&amp;r=1">Strong Eventual Consistency and Conflict-free Replicated Data Types</a>
talk by Mark Shapiro</li>
<li><a class="reference external" href="http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>
paper by Mark Shapiro et. al.</li>
</ul>
</div>
<div class="section" id="dependencies">
<h2>Dependencies</h2>
<p>To use Distributed Data you must add the following dependency in your project.</p>
<p>sbt:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-distributed-data&quot;</span> <span class="o">%</span> <span class="s">&quot;2.5.0&quot;</span>
</pre></div>
</div>
<p>maven:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">com</span><span class="o">.</span><span class="n">typesafe</span><span class="o">.</span><span class="n">akka</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">akka</span><span class="o">-</span><span class="n">distributed</span><span class="o">-</span><span class="n">data_2</span><span class="o">.</span><span class="mi">11</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">2.5</span><span class="o">.</span><span class="mi">0</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration">
<h2>Configuration</h2>
<p>The <code class="docutils literal"><span class="pre">DistributedData</span></code> extension can be configured with the following properties:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span># Settings for the DistributedData extension
akka.cluster.distributed-data {
  # Actor name of the Replicator actor, /system/ddataReplicator
  name = ddataReplicator

  # Replicas are running on members tagged with this role.
  # All members are used if undefined or empty.
  role = &quot;&quot;

  # How often the Replicator should send out gossip information
  gossip-interval = 2 s
  
  # How often the subscribers will be notified of changes, if any
  notify-subscribers-interval = 500 ms

  # Maximum number of entries to transfer in one gossip message when synchronizing
  # the replicas. Next chunk will be transferred in next round of gossip.
  max-delta-elements = 1000
  
  # The id of the dispatcher to use for Replicator actors. If not specified
  # default dispatcher is used.
  # If specified you need to define the settings of the actual dispatcher.
  use-dispatcher = &quot;&quot;

  # How often the Replicator checks for pruning of data associated with
  # removed cluster nodes. If this is set to &#39;off&#39; the pruning feature will
  # be completely disabled.
  pruning-interval = 120 s
  
  # How long time it takes to spread the data to all other replica nodes.
  # This is used when initiating and completing the pruning process of data associated
  # with removed cluster nodes. The time measurement is stopped when any replica is 
  # unreachable, but it&#39;s still recommended to configure this with certain margin.
  # It should be in the magnitude of minutes even though typical dissemination time
  # is shorter (grows logarithmic with number of nodes). There is no advantage of 
  # setting this too low. Setting it to large value will delay the pruning process.
  max-pruning-dissemination = 300 s
  
  # The markers of that pruning has been performed for a removed node are kept for this
  # time and thereafter removed. If and old data entry that was never pruned is somehow
  # injected and merged with existing data after this time the value will not be correct.
  # This would be possible (although unlikely) in the case of a long network partition.
  # It should be in the magnitude of hours. For durable data it is configured by 
  # &#39;akka.cluster.distributed-data.durable.pruning-marker-time-to-live&#39;.
 pruning-marker-time-to-live = 6 h
  
  # Serialized Write and Read messages are cached when they are sent to 
  # several nodes. If no further activity they are removed from the cache
  # after this duration.
  serializer-cache-time-to-live = 10s
  
  # Settings for delta-CRDT
  delta-crdt {
    # enable or disable delta-CRDT replication
    enabled = on
  }
  
  durable {
    # List of keys that are durable. Prefix matching is supported by using * at the
    # end of a key.  
    keys = []
    
    # The markers of that pruning has been performed for a removed node are kept for this
    # time and thereafter removed. If and old data entry that was never pruned is
    # injected and merged with existing data after this time the value will not be correct.
    # This would be possible if replica with durable data didn&#39;t participate in the pruning
    # (e.g. it was shutdown) and later started after this time. A durable replica should not 
    # be stopped for longer time than this duration and if it is joining again after this
    # duration its data should first be manually removed (from the lmdb directory).
    # It should be in the magnitude of days. Note that there is a corresponding setting
    # for non-durable data: &#39;akka.cluster.distributed-data.pruning-marker-time-to-live&#39;.
    pruning-marker-time-to-live = 10 d
    
    # Fully qualified class name of the durable store actor. It must be a subclass
    # of akka.actor.Actor and handle the protocol defined in 
    # akka.cluster.ddata.DurableStore. The class must have a constructor with 
    # com.typesafe.config.Config parameter.
    store-actor-class = akka.cluster.ddata.LmdbDurableStore
    
    use-dispatcher = akka.cluster.distributed-data.durable.pinned-store
    
    pinned-store {
      executor = thread-pool-executor
      type = PinnedDispatcher
    }
    
    # Config for the LmdbDurableStore
    lmdb {
      # Directory of LMDB file. There are two options:
      # 1. A relative or absolute path to a directory that ends with &#39;ddata&#39;
      #    the full name of the directory will contain name of the ActorSystem
      #    and its remote port.
      # 2. Otherwise the path is used as is, as a relative or absolute path to
      #    a directory.
      #
      # When running in production you may want to configure this to a specific
      # path (alt 2), since the default directory contains the remote port of the
      # actor system to make the name unique. If using a dynamically assigned 
      # port (0) it will be different each time and the previously stored data 
      # will not be loaded.
      dir = &quot;ddata&quot;
      
      # Size in bytes of the memory mapped file.
      map-size = 100 MiB
      
      # Accumulate changes before storing improves performance with the
      # risk of losing the last writes if the JVM crashes.
      # The interval is by default set to &#39;off&#39; to write each update immediately.
      # Enabling write behind by specifying a duration, e.g. 200ms, is especially 
      # efficient when performing many writes to the same key, because it is only 
      # the last value for each key that will be serialized and stored.  
      # write-behind-interval = 200 ms
      write-behind-interval = off
    }
  }
  
}
</pre></div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="https://akka.io/docs">Documentation</a></li>
      <li><a href="https://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="https://akka.io/downloads">Downloads</a></li>
      <li><a href="https://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="https://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="https://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="https://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Apr 12, 2017
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>