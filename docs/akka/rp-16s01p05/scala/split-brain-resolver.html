


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Split Brain Resolver &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4-bin-rp-16s01p05',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Lightbend Reactive Platform" href="index-rp.html" />
    <link rel="next" title="Configuration Checker" href="../common/config-checker.html" />
    <link rel="prev" title="Lightbend Reactive Platform" href="index-rp.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="https://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>    
        <ul class="nav">
          <li><a href="https://akka.io/docs">Documentation</a></li>
          <li><a href="https://akka.io/faq">FAQ</a></li>
          <li><a href="https://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>           
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Split Brain Resolver</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="../common/config-checker.html">Configuration Checker</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="index-rp.html">Lightbend Reactive Platform</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version 2.4-bin-rp-16s01p05
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="split-brain-resolver">
<span id="split-brain-resolver-scala"></span><h1>Split Brain Resolver</h1>
<p>When operating an Akka cluster you must consider how to handle
<a class="reference external" href="http://en.wikipedia.org/wiki/Network_partition">network partitions</a> (a.k.a. split brain scenarios)
and machine crashes (including JVM and hardware failures). This is crucial for correct behavior if
you use Cluster Singleton or Cluster Sharding, especially together with Akka Persistence.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a feature of the <a class="reference external" href="http://www.lightbend.com/products/lightbend-reactive-platform">Lightbend Reactive Platform</a>
that is exclusively available for
<a class="reference external" href="http://www.lightbend.com/services/expert-support">Lightbend Project Success Subscription</a> customers.</p>
</div>
<p>To use the Split Brain Resolver feature you must
<a class="reference external" href="https://together.typesafe.com/products/reactivePlatform">install Lightbend Reactive Platform</a>.</p>
<div class="section" id="the-problem">
<h2>The Problem</h2>
<p>A fundamental problem in distributed systems is that network partitions (split brain scenarios) and
machine crashes are indistinguishable for the observer, i.e. a node can observe that there is a problem
with another node, but it cannot tell if it has crashed and will never be available again or if there is
a network issue that might or might not heal again after a while. Temporary and permanent failures are
indistinguishable because decisions must be made in finite time, and there always exists a temporary
failure that lasts longer than the time limit for the decision.</p>
<p>A third type of problem is if a process is unresponsive, e.g. because of overload, CPU starvation or
long garbage collection pauses. This is also indistinguishable from network partitions and crashes.
The only signal we have for decision is &quot;no reply in given time for heartbeats&quot; and this means that
every phenomena causing delays or lost heartbeats are indistinguishable from each other and must be
handled in the same way.</p>
<p>When there is a crash we would like to remove the crashed node immediately from the cluster membership.
When there is a network partition or unresponsive process we would like to wait for a while in the hope
of that it is a transient problem that will heal again, but at some point we must give up and continue with
the nodes on one side of the partition and shut down nodes on the other side. Also, certain features are
not fully available during partitions so it might not matter that the partition is transient or not if
it just takes too long. Those two goals are in conflict with each other and there is a trade-off
between how quickly we can remove a crashed node and premature action on transient network partitions.</p>
<p>This is a difficult problem to solve given that the nodes on the different sides of the network partition
cannot communicate with each other. We must ensure that both sides can make this decision by themselves and
that they take the same decision about which part will keep running and which part will shut itself down.</p>
<p>The Akka cluster has a failure detector that will notice network partitions and machine crashes (but it
cannot distinguish the two). It uses periodic heartbeat messages to check if other nodes are available
and healthy. These observations by the failure detector are referred to as a node being <em>unreachable</em>
and it may become <em>reachable</em> again if the failure detector observes that it can communicate with it again.</p>
<p>The failure detector in itself is not enough for making the right decision in all situations.
The naïve approach is to remove an unreachable node from the cluster membership after a timeout.
This works great for crashes and short transient network partitions, but not for long network
partitions. Both sides of the network partition will see the other side as unreachable and
after a while remove it from its cluster membership. Since this happens on both sides the result
is that two separate disconnected clusters have been created.
This approach is provided by the opt-in (off by default) auto-down feature in the OSS version of
Akka Cluster.</p>
<p>If you use the timeout based auto-down feature in combination with Cluster Singleton or Cluster Sharding
that would mean that two singleton instances or two sharded entities with same identifier would be running.
One would be running: one in each cluster.
For example when used together with Akka Persistence that could result in that two instances of a
persistent actor with the same <tt class="docutils literal"><span class="pre">persistenceId</span></tt> are running and writing concurrently to the
same stream of persistent events, which will have fatal consequences when replaying these events.</p>
<p>The default setting in Akka Cluster is to not remove unreachable nodes automatically and
the <a class="reference internal" href="cluster-usage.html#automatic-vs-manual-downing-scala"><em>recommendation</em></a> is that the decision of what to
do should be taken by a human operator or an external monitoring system. This is a valid solution,
but not very convenient if you do not have this staff or external system for other reasons.</p>
<p>If the unreachable nodes are not downed at all they will still be part of the cluster membership.
Meaning that Cluster Singleton and Cluster Sharding will not failover to another node. While there
are unreachable nodes new nodes that are joining the cluster will not be promoted to full worthy
members (with status Up). Similarly, leaving members will not be removed until all unreachable
nodes have been resolved. In other words, keeping unreachable members for an unbounded time is
undesirable.</p>
<p>With that introduction of the problem domain it is time to look at the provided strategies for
handling network partition, unresponsive nodes and crashed nodes.</p>
</div>
<div class="section" id="strategies">
<h2>Strategies</h2>
<p>There is not a &quot;one size fits all&quot; solution to this problem. You have to pick a strategy that fits
the characteristics of your system. Every strategy has a failure scenario where it makes a &quot;wrong&quot;
decision. This section describes the different strategies and guidelines of when to use what.</p>
<p>You enable a strategy with the configuration property <tt class="docutils literal"><span class="pre">akka.cluster.split-brain-resolver.active-strategy</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You must also remove auto-down configuration, remove this property (or set to off): <tt class="docutils literal"><span class="pre">akka.cluster.auto-down-unreachable-after</span></tt></p>
</div>
<p>All strategies are inactive until the cluster membership and the information about unreachable nodes
have been stable for a certain time period. Continuously adding more nodes while there is a network
partition does not influence this timeout, since the status of those nodes will not be changed to Up
while there are unreachable nodes. Joining nodes are not counted in the logic of the strategies.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">split</span><span class="o">-</span><span class="n">brain</span><span class="o">-</span><span class="n">resolver</span> <span class="o">{</span>
  <span class="k">#</span> <span class="nc">Enable</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">available</span> <span class="n">strategies</span> <span class="o">(</span><span class="n">see</span> <span class="n">descriptions</span> <span class="n">below</span><span class="o">)</span><span class="k">:</span>
  <span class="k">#</span> <span class="kt">static-quorum</span><span class="o">,</span> <span class="n">keep</span><span class="o">-</span><span class="n">majority</span><span class="o">,</span> <span class="n">keep</span><span class="o">-</span><span class="n">oldest</span><span class="o">,</span> <span class="n">keep</span><span class="o">-</span><span class="n">referee</span> 
  <span class="n">active</span><span class="o">-</span><span class="n">strategy</span> <span class="k">=</span> <span class="n">off</span>
  
  <span class="k">#</span> <span class="nc">Decision</span> <span class="n">is</span> <span class="n">taken</span> <span class="n">by</span> <span class="n">the</span> <span class="n">strategy</span> <span class="n">when</span> <span class="n">there</span> <span class="n">has</span> <span class="n">been</span> <span class="n">no</span> <span class="n">membership</span> <span class="n">or</span>
  <span class="k">#</span> <span class="n">reachability</span> <span class="n">changes</span> <span class="k">for</span> <span class="k">this</span> <span class="n">duration</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span> <span class="n">the</span> <span class="n">cluster</span> <span class="n">state</span> <span class="n">is</span> <span class="n">stable</span><span class="o">.</span>
  <span class="n">stable</span><span class="o">-</span><span class="n">after</span> <span class="k">=</span> <span class="mi">20</span><span class="n">s</span>
<span class="o">}</span>      
</pre></div>
</div>
<p>Set the <tt class="docutils literal"><span class="pre">stable-after</span></tt> to a shorter duration to have quicker removal of crashed nodes, at the price
of risking too early action on transient network partitions that otherwise would have healed. Do not
set this to a shorter duration than the membership dissemination time in the cluster, which depends
on the cluster size. Recommended minimum duration for different cluster sizes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">cluster size</th>
<th class="head">stable-after</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>5</td>
<td>7 s</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>10 s</td>
</tr>
<tr class="row-even"><td>20</td>
<td>13 s</td>
</tr>
<tr class="row-odd"><td>50</td>
<td>17 s</td>
</tr>
<tr class="row-even"><td>100</td>
<td>20 s</td>
</tr>
<tr class="row-odd"><td>1000</td>
<td>30 s</td>
</tr>
</tbody>
</table>
<p>The different strategies may have additional settings that are described below.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is important that you use the same configuration on all nodes.</p>
</div>
<p>The side of the split that decides to shut itself down will use the cluster <em>down</em> command
to initiate the removal of a cluster member. When that has been spread among the reachable nodes
it will be removed from the cluster membership. That does not automatically shut down the
<tt class="docutils literal"><span class="pre">ActorSystem</span></tt> or exit the JVM. To implement that you have to use the <tt class="docutils literal"><span class="pre">registerOnMemberRemoved</span></tt>
callback.</p>
<p>This is how to shut down the <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> and thereafter exit the JVM:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">registerOnMemberRemoved</span> <span class="o">{</span>
  <span class="c1">// exit JVM when ActorSystem has been terminated</span>
  <span class="n">system</span><span class="o">.</span><span class="n">registerOnTermination</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="n">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
  <span class="c1">// shut down ActorSystem</span>
  <span class="n">system</span><span class="o">.</span><span class="n">terminate</span><span class="o">()</span>

  <span class="c1">// In case ActorSystem shutdown takes longer than 10 seconds,</span>
  <span class="c1">// exit the JVM forcefully anyway.</span>
  <span class="c1">// We must spawn a separate thread to not block current thread,</span>
  <span class="c1">// since that would have blocked the shutdown of the ActorSystem.</span>
  <span class="k">new</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="nc">Await</span><span class="o">.</span><span class="n">ready</span><span class="o">(</span><span class="n">system</span><span class="o">.</span><span class="n">whenTerminated</span><span class="o">,</span> <span class="mf">10.</span><span class="n">seconds</span><span class="o">)).</span><span class="n">isFailure</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="n">exit</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}.</span><span class="n">start</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="static-quorum">
<h3>Static Quorum</h3>
<p>The strategy named <tt class="docutils literal"><span class="pre">static-quorum</span></tt> will down the unreachable nodes if the number of remaining
nodes are greater than or equal to a configured <tt class="docutils literal"><span class="pre">quorum-size</span></tt>. Otherwise it will down the reachable nodes,
i.e. it will shut down that side of the partition. In other words, the <tt class="docutils literal"><span class="pre">quorum-size</span></tt> defines the minimum
number of nodes that the cluster must have to be operational.</p>
<p>This strategy is a good choice when you have a fixed number of nodes in the cluster, or when you can
define a fixed number of nodes with a certain role.</p>
<p>For example, in a 9 node cluster you will configure the <tt class="docutils literal"><span class="pre">quorum-size</span></tt> to 5. If there is a network split
of 4 and 5 nodes the side with 5 nodes will survive and the other 4 nodes will be downed. Thereafter,
in the 5 node cluster, no more failures can be handled, because the remaining cluster size would be
less than 5. In the case of another failure in that 5 node cluster all nodes will be downed.</p>
<p>Therefore it is important that you join new nodes when old nodes have been removed.</p>
<p>Another consequence of this is that if there are unreachable nodes when starting up the cluster,
before reaching this limit, the cluster may shut itself down immediately. This is not an issue
if you start all nodes at approximately the same time or use the <tt class="docutils literal"><span class="pre">akka.cluster.min-nr-of-members</span></tt>
to define required number of members before the leader changes member status of 'Joining' members to 'Up'
You can tune the timeout after which downing decisions are made using the <tt class="docutils literal"><span class="pre">stable-after</span></tt> setting.</p>
<p>Note that you must not add more members to the cluster than <strong>quorum-size * 2 - 1</strong>, because then
both sides may down each other and thereby form two separate clusters. For example,
<tt class="docutils literal"><span class="pre">quorum-size</span></tt> configured to 3 in a 6 node cluster may result in a split where each side
consists of 3 nodes each, i.e. each side thinks it has enough nodes to continue by
itself. A warning is logged if this recommendation is violated. <tt class="docutils literal"><span class="pre">static-quorum</span></tt> will
never result in two separate clusters as long as you do not violate this rule.</p>
<p>If the cluster is split in 3 (or more) parts each part that is smaller than then configured <tt class="docutils literal"><span class="pre">quorum-size</span></tt>
will down itself and possibly shutdown the whole cluster.</p>
<p>If more nodes than the configured <tt class="docutils literal"><span class="pre">quorum-size</span></tt> crash at the same time the other running nodes
will down themselves because they think that they are not in majority, and thereby the whole
cluster is terminated.</p>
<p>The decision can be based on nodes with a configured <tt class="docutils literal"><span class="pre">role</span></tt> instead of all nodes in the cluster.
This can be useful when some types of nodes are more valuable than others. You might for example
have some nodes responsible for persistent data and some nodes with stateless worker services.
Then it probably more important to keep as many persistent data nodes as possible even though
it means shutting down more worker nodes.</p>
<p>There is another use of the <tt class="docutils literal"><span class="pre">role</span></tt> as well. By defining a <tt class="docutils literal"><span class="pre">role</span></tt> for a few (e.g. 7) stable
nodes in the cluster and using that in the configuration of <tt class="docutils literal"><span class="pre">static-quorum</span></tt> you will be able
to dynamically add and remove other nodes without this role and still have good decisions of what
nodes to keep running and what nodes to shut down in the case of network partitions. The advantage
of this approach compared to <tt class="docutils literal"><span class="pre">keep-majority</span></tt> (described below) is that you do not risk splitting
the cluster in two separate clusters. You must still obey the rule of not starting too many nodes
with this <tt class="docutils literal"><span class="pre">role</span></tt> as described above. It also suffers the risk of shutting down all nodes if there
is a failure when there are not enough number of nodes with this <tt class="docutils literal"><span class="pre">role</span></tt> remaining in the cluster,
as described above.</p>
<p>Configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">split</span><span class="o">-</span><span class="n">brain</span><span class="o">-</span><span class="n">resolver</span><span class="o">.</span><span class="n">active</span><span class="o">-</span><span class="n">strategy</span><span class="k">=</span><span class="n">static</span><span class="o">-</span><span class="n">quorum</span>
</pre></div>
</div>
<div class="highlight-scala"><pre>akka.cluster.split-brain-resolver.static-quorum {
  # minimum number of nodes that the cluster must have 
  quorum-size = undefined
    
  # if the 'role' is defined the decision is based only on members with that 'role'
  role = ""
}
</pre>
</div>
</div>
<div class="section" id="keep-majority">
<h3>Keep Majority</h3>
<p>The strategy named <tt class="docutils literal"><span class="pre">keep-majority</span></tt> will down the unreachable nodes if the current node is in
the majority part based on the last known membership information. Otherwise down the reachable nodes,
i.e. the own part. If the parts are of equal size the part containing the node with the lowest
address is kept.</p>
<p>This strategy is a good choice when the number of nodes in the cluster change dynamically and you can
therefore not use <tt class="docutils literal"><span class="pre">static-quorum</span></tt>.</p>
<p>There is a small risk that the decision on both sides of the partition is not based on the same
information and therefore resulting in different decisions. This can happen when there are
membership changes at the same time as the network partition occurs. For example, the status of two
members are changed to <tt class="docutils literal"><span class="pre">Up</span></tt> on one side but that information is not disseminated to the other
side before the connection is broken. Then one side sees two more nodes and both sides might consider
themselves having majority, resulting in that each side downing the other side and thereby forming
two separate clusters. It can also happen when some nodes crash after the network partition but
before the strategy has decided what to do.</p>
<p>In this regard it is more safe to use <tt class="docutils literal"><span class="pre">static-quorum</span></tt>, but the advantages of the dynamic
nature of this strategy may outweigh the risk.</p>
<p>Note that if there are more than two partitions and none is in majority each part will shut down
itself, terminating the whole cluster.</p>
<p>If more than half of the nodes crash at the same time the other running nodes will down themselves
because they think that they are not in majority, and thereby the whole cluster is terminated.</p>
<p>The decision can be based on nodes with a configured <tt class="docutils literal"><span class="pre">role</span></tt> instead of all nodes in the cluster.
This can be useful when some types of nodes are more valuable than others. You might for example
have some nodes responsible for persistent data and some nodes with stateless worker services.
Then it probably more important to keep as many persistent data nodes as possible even though
it means shutting down more worker nodes.</p>
<p>Configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">split</span><span class="o">-</span><span class="n">brain</span><span class="o">-</span><span class="n">resolver</span><span class="o">.</span><span class="n">active</span><span class="o">-</span><span class="n">strategy</span><span class="k">=</span><span class="n">keep</span><span class="o">-</span><span class="n">majority</span>
</pre></div>
</div>
<div class="highlight-scala"><pre>akka.cluster.split-brain-resolver.keep-majority {
  # if the 'role' is defined the decision is based only on members with that 'role'
  role = ""
}
</pre>
</div>
</div>
<div class="section" id="keep-oldest">
<h3>Keep Oldest</h3>
<p>The strategy named <tt class="docutils literal"><span class="pre">keep-oldest</span></tt> will down the part that does not contain the oldest
member. The oldest member is interesting because the active Cluster Singleton instance
is running on the oldest member.</p>
<p>There is one exception to this rule if <tt class="docutils literal"><span class="pre">down-if-alone</span></tt> is configured to <tt class="docutils literal"><span class="pre">on</span></tt>.
Then, if the oldest node has partitioned from all other nodes the oldest will down itself
and keep all other nodes running. The strategy will not down the single oldest node when
it is the only remaining node in the cluster.</p>
<p>Note that if the oldest node crashes the others will remove it from the cluster
when <tt class="docutils literal"><span class="pre">down-if-alone</span></tt> is <tt class="docutils literal"><span class="pre">on</span></tt>, otherwise they will down themselves if the
oldest node crashes, i.e. shut down the whole cluster together with the oldest node.</p>
<p>This strategy is good to use if you use Cluster Singleton and do not want to shut down the node
where the singleton instance runs. If the oldest node crashes a new singleton instance will be
started on the next oldest node. The drawback is that the strategy may keep only a few nodes
in a large cluster. For example, if one part with the oldest consists of 2 nodes and the
other part consists of 98 nodes then it will keep 2 nodes and shut down 98 nodes.</p>
<p>There is one risk with this strategy. If the different sides of a partition have different
opinions about which is the oldest node they may both shut down themselves or they may both
think that they should down the other side and continue running themselves. The latter results
in two separate clusters and two running singleton instances, one in each cluster. This can
happen in the rare event of the oldest node being removed from one side, but that information
has not been disseminated to the other side before the network partition happens. It can also
happen when the node crashes after the network partition but before the strategy has decided
what to do.</p>
<p>The decision can be based on nodes with a configured <tt class="docutils literal"><span class="pre">role</span></tt> instead of all nodes in the cluster,
i.e. using the oldest member (singleton) within the nodes with that role.</p>
<p>Configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">split</span><span class="o">-</span><span class="n">brain</span><span class="o">-</span><span class="n">resolver</span><span class="o">.</span><span class="n">active</span><span class="o">-</span><span class="n">strategy</span><span class="k">=</span><span class="n">keep</span><span class="o">-</span><span class="n">oldest</span>
</pre></div>
</div>
<div class="highlight-scala"><pre>akka.cluster.split-brain-resolver.keep-oldest {
  # Enable downing of the oldest node when it is partitioned from all other nodes
  down-if-alone = on
    
  # if the 'role' is defined the decision is based only on members with that 'role',
  # i.e. using the oldest member (singleton) within the nodes with that role
  role = ""
}
</pre>
</div>
</div>
<div class="section" id="keep-referee">
<h3>Keep Referee</h3>
<p>The strategy named <tt class="docutils literal"><span class="pre">keep-referee</span></tt> will down the part that does not contain the given
referee node.</p>
<p>If the remaining number of nodes are less than the configured <cite>down-all-if-less-than-nodes</cite>
all nodes will be downed. If the referee node itself is removed all nodes will be downed.</p>
<p>This strategy is good if you have one node that hosts some critical resource and the
system cannot run without it. The drawback is that the referee node is a single point
of failure, by design. <tt class="docutils literal"><span class="pre">keep-referee</span></tt> will never result in two separate clusters.</p>
<p>Configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">split</span><span class="o">-</span><span class="n">brain</span><span class="o">-</span><span class="n">resolver</span><span class="o">.</span><span class="n">active</span><span class="o">-</span><span class="n">strategy</span><span class="k">=</span><span class="n">keep</span><span class="o">-</span><span class="n">referee</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">split</span><span class="o">-</span><span class="n">brain</span><span class="o">-</span><span class="n">resolver</span><span class="o">.</span><span class="n">keep</span><span class="o">-</span><span class="n">referee</span> <span class="o">{</span>
  <span class="k">#</span> <span class="n">referee</span> <span class="n">address</span> <span class="n">on</span> <span class="n">the</span> <span class="n">form</span> <span class="n">of</span> <span class="s">&quot;akka.tcp://system@hostname:port&quot;</span>
  <span class="n">address</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
  <span class="n">down</span><span class="o">-</span><span class="n">all</span><span class="o">-</span><span class="k">if</span><span class="o">-</span><span class="n">less</span><span class="o">-</span><span class="n">than</span><span class="o">-</span><span class="n">nodes</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cluster-singleton-and-cluster-sharding">
<h2>Cluster Singleton and Cluster Sharding</h2>
<p>The purpose of Cluster Singleton and Cluster Sharding is to run at most one instance
of a given actor at any point in time. When such an instance is shut down a new instance
is supposed to be started elsewhere in the cluster. It is important that the new instance is
not started before the old instance has been stopped. This is especially important when the
singleton or the sharded instance is persistent, since there must only be one active
writer of the journaled events of a persistent actor instance.</p>
<p>Since the strategies on different sides of a network partition cannot communicate with each other
and they may take the decision at slightly different points in time there must be a time based
margin that makes sure that the new instance is not started before the old has been stopped.
This duration is configured with the following property:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">#</span> <span class="nc">Time</span> <span class="n">margin</span> <span class="n">after</span> <span class="n">which</span> <span class="n">shards</span> <span class="n">or</span> <span class="n">singletons</span> <span class="n">that</span> <span class="n">belonged</span> <span class="n">to</span> <span class="n">a</span> <span class="n">downed</span><span class="o">/</span><span class="n">removed</span>
<span class="k">#</span> <span class="n">partition</span> <span class="n">are</span> <span class="n">created</span> <span class="n">in</span> <span class="n">surviving</span> <span class="n">partition</span><span class="o">.</span> <span class="nc">The</span> <span class="n">purpose</span> <span class="n">of</span> <span class="k">this</span> <span class="n">margin</span> <span class="n">is</span> <span class="n">that</span> 
<span class="k">#</span> <span class="n">in</span> <span class="k">case</span> <span class="n">of</span> <span class="n">a</span> <span class="n">network</span> <span class="n">partition</span> <span class="n">the</span> <span class="n">persistent</span> <span class="n">actors</span> <span class="n">in</span> <span class="n">the</span> <span class="n">non</span><span class="o">-</span><span class="n">surviving</span> <span class="n">partitions</span>
<span class="k">#</span> <span class="n">must</span> <span class="n">be</span> <span class="n">stopped</span> <span class="n">before</span> <span class="n">corresponding</span> <span class="n">persistent</span> <span class="n">actors</span> <span class="n">are</span> <span class="n">started</span> <span class="n">somewhere</span> <span class="k">else</span><span class="o">.</span>
<span class="k">#</span> <span class="nc">This</span> <span class="n">is</span> <span class="n">useful</span> <span class="k">if</span> <span class="n">you</span> <span class="n">implement</span> <span class="n">downing</span> <span class="n">strategies</span> <span class="n">that</span> <span class="n">handle</span> <span class="n">network</span> <span class="n">partitions</span><span class="o">,</span>
<span class="k">#</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">by</span> <span class="n">keeping</span> <span class="n">the</span> <span class="n">larger</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">partition</span> <span class="n">and</span> <span class="n">shutting</span> <span class="n">down</span> <span class="n">the</span> <span class="n">smaller</span> <span class="n">side</span><span class="o">.</span>
<span class="k">#</span> <span class="nc">It</span> <span class="n">will</span> <span class="n">not</span> <span class="n">add</span> <span class="n">any</span> <span class="n">extra</span> <span class="n">safety</span> <span class="k">for</span> <span class="n">auto</span><span class="o">-</span><span class="n">down</span><span class="o">-</span><span class="n">unreachable</span><span class="o">-</span><span class="n">after</span><span class="o">,</span> <span class="n">since</span> <span class="n">that</span> <span class="n">is</span> <span class="n">not</span>
<span class="k">#</span> <span class="n">handling</span> <span class="n">network</span> <span class="n">partitions</span><span class="o">.</span> <span class="nc">If</span> <span class="nc">Split</span> <span class="nc">Brain</span> <span class="nc">Resolver</span> <span class="n">is</span> <span class="n">enabled</span> <span class="n">the</span> <span class="n">default</span> <span class="n">value</span>
<span class="k">#</span> <span class="n">of</span> <span class="k">this</span> <span class="n">property</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> 
<span class="k">#</span> <span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">split</span><span class="o">-</span><span class="n">brain</span><span class="o">-</span><span class="n">resolver</span><span class="o">.</span><span class="n">stable</span><span class="o">-</span><span class="n">after</span><span class="o">.</span>
<span class="k">#</span> <span class="nc">Disable</span> <span class="k">with</span> <span class="s">&quot;off&quot;</span> <span class="n">or</span> <span class="n">specify</span> <span class="n">a</span> <span class="n">duration</span> <span class="n">to</span> <span class="n">enable</span><span class="o">.</span>
<span class="n">down</span><span class="o">-</span><span class="n">removal</span><span class="o">-</span><span class="n">margin</span> <span class="k">=</span> <span class="n">off</span>
</pre></div>
</div>
<p>You would like to configure this to a short duration to have quick failover, but that will increase the
risk of having multiple singleton/sharded instances running at the same time and it may take different
amount of time to act on the decision (dissemination of the down/removal). It is recommended
to configure this to the same value as the <tt class="docutils literal"><span class="pre">stable-after</span></tt> property. Recommended minimum duration
for different cluster sizes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">cluster size</th>
<th class="head">down-removal-margin</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>5</td>
<td>7 s</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>10 s</td>
</tr>
<tr class="row-even"><td>20</td>
<td>13 s</td>
</tr>
<tr class="row-odd"><td>50</td>
<td>17 s</td>
</tr>
<tr class="row-even"><td>100</td>
<td>20 s</td>
</tr>
<tr class="row-odd"><td>1000</td>
<td>30 s</td>
</tr>
</tbody>
</table>
<div class="section" id="expected-failover-time">
<h3>Expected Failover Time</h3>
<p>As you have seen there are several configured timeouts that adds to the total failover latency.
With default configuration those are:</p>
<ul class="simple">
<li>failure detection 5 seconds</li>
<li>stable-after 20 seconds</li>
<li>down-removal-margin 20 seconds</li>
</ul>
<p>In total you can expect the failover time of a singleton or sharded instance to be around 45 seconds
with default configuration. The default configuration is sized for a cluster of 100 nodes. If you have
around 10 nodes you can reduce the <tt class="docutils literal"><span class="pre">stable-after</span></tt> and <tt class="docutils literal"><span class="pre">down-removal-margin</span></tt> to around 10 seconds,
resulting in a expected failover time of around 25 seconds.</p>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="https://akka.io/docs">Documentation</a></li>
      <li><a href="https://akka.io/faq">FAQ</a></li>
      <li><a href="https://akka.io/downloads">Downloads</a></li>
      <li><a href="https://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="https://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="https://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="https://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Apr 14, 2016
    </p>          
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 10,
      facetFilters: '[' +
      '["language:' + lang + '","language:general"]' +
      ',"version:2.4.2"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>