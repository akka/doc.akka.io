<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Learning Akka Typed from Classic &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/typed/from-classic.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-8.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-2.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"  type="text/javascript" charset="UTF-8" data-domain-script="28b912e7-09e9-43d5-91e4-3d1897044004" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="oss-wrapper">
<div class="oss-brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="oss-ad no-drop-down">
<nav id="lightbendRotator" class="lightbend-rotator">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Promo Rotator - Lightbend is Changing its Software Licensing Model for Akka Technology. [License FAQ] - Akka Banner" href="https://www.lightbend.com/akka/license-faq">
<strong>Lightbend</strong> is Changing its Software Licensing Model for Akka Technology. <span class="akka-btn">License FAQ</span>
</a>
</nav>
</div>
</div>
</div>

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.0-M1
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html#learning-akka-typed-from-classic" class="active page">Learning Akka Typed from Classic</a>
    <ul>
      <li><a href="../typed/from-classic.html#dependencies" class="header">Dependencies</a></li>
      <li><a href="../typed/from-classic.html#package-names" class="header">Package names</a></li>
      <li><a href="../typed/from-classic.html#actor-definition" class="header">Actor definition</a></li>
      <li><a href="../typed/from-classic.html#actorof-and-props" class="header">actorOf and Props</a></li>
      <li><a href="../typed/from-classic.html#actorref" class="header">ActorRef</a></li>
      <li><a href="../typed/from-classic.html#actorsystem" class="header">ActorSystem</a></li>
      <li><a href="../typed/from-classic.html#become" class="header">become</a></li>
      <li><a href="../typed/from-classic.html#sender" class="header">sender</a></li>
      <li><a href="../typed/from-classic.html#parent" class="header">parent</a></li>
      <li><a href="../typed/from-classic.html#supervision" class="header">Supervision</a></li>
      <li><a href="../typed/from-classic.html#lifecycle-hooks" class="header">Lifecycle hooks</a></li>
      <li><a href="../typed/from-classic.html#watch" class="header">watch</a></li>
      <li><a href="../typed/from-classic.html#stopping" class="header">Stopping</a></li>
      <li><a href="../typed/from-classic.html#actorselection" class="header">ActorSelection</a></li>
      <li><a href="../typed/from-classic.html#ask" class="header">ask</a></li>
      <li><a href="../typed/from-classic.html#pipeto" class="header">pipeTo</a></li>
      <li><a href="../typed/from-classic.html#actorcontext-children" class="header">ActorContext.children</a></li>
      <li><a href="../typed/from-classic.html#remote-deployment" class="header">Remote deployment</a></li>
      <li><a href="../typed/from-classic.html#routers" class="header">Routers</a></li>
      <li><a href="../typed/from-classic.html#fsm" class="header">FSM</a></li>
      <li><a href="../typed/from-classic.html#timers" class="header">Timers</a></li>
      <li><a href="../typed/from-classic.html#stash" class="header">Stash</a></li>
      <li><a href="../typed/from-classic.html#persistentactor" class="header">PersistentActor</a></li>
      <li><a href="../typed/from-classic.html#asynchronous-testing" class="header">Asynchronous Testing</a></li>
      <li><a href="../typed/from-classic.html#synchronous-testing" class="header">Synchronous Testing</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.0-M1
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html#learning-akka-typed-from-classic" class="active page">Learning Akka Typed from Classic</a>
    <ul>
      <li><a href="../typed/from-classic.html#dependencies" class="header">Dependencies</a></li>
      <li><a href="../typed/from-classic.html#package-names" class="header">Package names</a></li>
      <li><a href="../typed/from-classic.html#actor-definition" class="header">Actor definition</a></li>
      <li><a href="../typed/from-classic.html#actorof-and-props" class="header">actorOf and Props</a></li>
      <li><a href="../typed/from-classic.html#actorref" class="header">ActorRef</a></li>
      <li><a href="../typed/from-classic.html#actorsystem" class="header">ActorSystem</a></li>
      <li><a href="../typed/from-classic.html#become" class="header">become</a></li>
      <li><a href="../typed/from-classic.html#sender" class="header">sender</a></li>
      <li><a href="../typed/from-classic.html#parent" class="header">parent</a></li>
      <li><a href="../typed/from-classic.html#supervision" class="header">Supervision</a></li>
      <li><a href="../typed/from-classic.html#lifecycle-hooks" class="header">Lifecycle hooks</a></li>
      <li><a href="../typed/from-classic.html#watch" class="header">watch</a></li>
      <li><a href="../typed/from-classic.html#stopping" class="header">Stopping</a></li>
      <li><a href="../typed/from-classic.html#actorselection" class="header">ActorSelection</a></li>
      <li><a href="../typed/from-classic.html#ask" class="header">ask</a></li>
      <li><a href="../typed/from-classic.html#pipeto" class="header">pipeTo</a></li>
      <li><a href="../typed/from-classic.html#actorcontext-children" class="header">ActorContext.children</a></li>
      <li><a href="../typed/from-classic.html#remote-deployment" class="header">Remote deployment</a></li>
      <li><a href="../typed/from-classic.html#routers" class="header">Routers</a></li>
      <li><a href="../typed/from-classic.html#fsm" class="header">FSM</a></li>
      <li><a href="../typed/from-classic.html#timers" class="header">Timers</a></li>
      <li><a href="../typed/from-classic.html#stash" class="header">Stash</a></li>
      <li><a href="../typed/from-classic.html#persistentactor" class="header">PersistentActor</a></li>
      <li><a href="../typed/from-classic.html#asynchronous-testing" class="header">Asynchronous Testing</a></li>
      <li><a href="../typed/from-classic.html#synchronous-testing" class="header">Synchronous Testing</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="../typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#learning-akka-typed-from-classic" name="learning-akka-typed-from-classic" class="anchor"><span class="anchor-link"></span></a>Learning Akka Typed from Classic</h1>
<p>Akka Classic is the original Actor APIs, which have been improved by more type safe and guided Actor APIs, known as Akka Typed.</p>
<p>If you already know the classic Actor APIs and would like to learn Akka Typed, this reference is a good resource. Many concepts are the same and this page tries to highlight differences and how to do certain things in Typed compared to classic.</p>
<p>You should probably learn some of the basics of Akka Typed to see how it looks like before diving into the differences and details described here. A good starting point for that is the <a href="guide/tutorial_3.html">IoT example</a> in the Getting Started Guide or the examples shown in <a href="actors.html">Introduction to Actors</a>.</p>
<p>Another good resource to learning Akka Typed is Manuel Bernhardt&rsquo;s <a href="https://manuel.bernhardt.io/articles/#akka-typed">Tour of Akka Typed</a>.</p>
<p>Note that Akka Classic is still fully supported and existing applications can continue to use the classic APIs. It is also possible to use Akka Typed together with classic actors within the same ActorSystem, see <a href="coexisting.html">coexistence</a>. For new projects we recommend using the new Actor APIs.</p>
<h2><a href="#dependencies" name="dependencies" class="anchor"><span class="anchor-link"></span></a>Dependencies</h2>
<p>The dependencies of the Typed modules are named by adding <code>-typed</code> suffix of the corresponding classic module, with a few exceptions.</p>
<p>For example <code>akka-cluster-typed</code>:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val AkkaVersion = "2.8.0-M1"
libraryDependencies += "com.typesafe.akka" %% "akka-cluster-typed" % AkkaVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
      &lt;artifactId&gt;akka-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.8.0-M1&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
    &lt;artifactId&gt;akka-cluster-typed_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("com.typesafe.akka:akka-bom_${versions.ScalaBinary}:2.8.0-M1")

  implementation "com.typesafe.akka:akka-cluster-typed_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<p>Artifact names:</p>
<table>
  <thead>
    <tr>
      <th>Classic </th>
      <th>Typed </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>akka-actor </td>
      <td>akka-actor-typed </td>
    </tr>
    <tr>
      <td>akka-cluster </td>
      <td>akka-cluster-typed </td>
    </tr>
    <tr>
      <td>akka-cluster-sharding </td>
      <td>akka-cluster-sharding-typed </td>
    </tr>
    <tr>
      <td>akka-cluster-tools </td>
      <td>akka-cluster-typed </td>
    </tr>
    <tr>
      <td>akka-distributed-data </td>
      <td>akka-cluster-typed </td>
    </tr>
    <tr>
      <td>akka-persistence </td>
      <td>akka-persistence-typed </td>
    </tr>
    <tr>
      <td>akka-stream </td>
      <td>akka-stream-typed </td>
    </tr>
    <tr>
      <td>akka-testkit </td>
      <td>akka-actor-testkit-typed </td>
    </tr>
  </tbody>
</table>
<p>Cluster Singleton and Distributed Data are included in <code>akka-cluster-typed</code>.</p>
<p>Artifacts not listed in above table don&rsquo;t have a specific API for Akka Typed.</p>
<h2><a href="#package-names" name="package-names" class="anchor"><span class="anchor-link"></span></a>Package names</h2>
<p>The convention of the package names in Akka Typed is to add <code>typed.scaladsl</code> and <code>typed.javadsl</code> to the corresponding Akka classic package name. <code>scaladsl</code> and <code>javadsl</code> is the convention to separate Scala and Java APIs, which is familiar from Akka Streams.</p>
<p>Examples of a few package names:</p>
<table>
  <thead>
    <tr>
      <th>Classic </th>
      <th>Typed for Scala </th>
      <th>Typed for Java </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>akka.actor </td>
      <td>akka.actor.typed.scaladsl </td>
      <td>akka.actor.typed.javadsl </td>
    </tr>
    <tr>
      <td>akka.cluster </td>
      <td>akka.cluster.typed </td>
      <td>akka.cluster.typed </td>
    </tr>
    <tr>
      <td>akka.cluster.sharding </td>
      <td>akka.cluster.sharding.typed.scaladsl </td>
      <td>akka.cluster.sharding.typed.javadsl </td>
    </tr>
    <tr>
      <td>akka.persistence </td>
      <td>akka.persistence.typed.scaladsl </td>
      <td>akka.persistence.typed.javadsl </td>
    </tr>
  </tbody>
</table>
<h2><a href="#actor-definition" name="actor-definition" class="anchor"><span class="anchor-link"></span></a>Actor definition</h2>
<p>A classic actor is defined by a class extending <span class="group-scala"><code>akka.actor.Actor</code></span><span class="group-java"><code>akka.actor.AbstractActor</code></span>.</p>
<p>An actor in Typed is defined by a class extending <span class="group-scala"><code>akka.actor.typed.scaladsl.AbstractBehavior</code></span><span class="group-java"><code>akka.actor.typed.javadsl.AbstractBehavior</code></span>.</p>
<p>It&rsquo;s also possible to define an actor in Typed from functions instead of extending a class. This is called the <a href="style-guide.html#functional-versus-object-oriented-style">functional style</a>.</p>
<p>Classic HelloWorld actor:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.0-M1/akka-actor-typed-tests/src/test/scala/docs/akka/typed/fromclassic/ClassicSample.scala#L8-L34" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import akka.actor.Actor
import akka.actor.ActorLogging
import akka.actor.Props

object HelloWorld {
  final case class Greet(whom: String)
  final case class Greeted(whom: String)

  def props(): Props =
    Props(new HelloWorld)
}

class HelloWorld extends Actor with ActorLogging {
  import HelloWorld._

  override def receive: Receive = {
    case Greet(whom) =&gt;
      log.info(&quot;Hello {}!&quot;, whom)
      sender() ! Greeted(whom)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.0-M1/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/fromclassic/ClassicSample.java#L8-L51" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.actor.AbstractActor;
import akka.actor.Props;
import akka.event.Logging;
import akka.event.LoggingAdapter;

public class HelloWorld extends AbstractActor {

  public static final class Greet {
    public final String whom;

    public Greet(String whom) {
      this.whom = whom;
    }
  }

  public static final class Greeted {
    public final String whom;

    public Greeted(String whom) {
      this.whom = whom;
    }
  }

  public static Props props() {
    return Props.create(HelloWorld.class, HelloWorld::new);
  }

  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  @Override
  public Receive createReceive() {
    return receiveBuilder().match(Greet.class, this::onGreet).build();
  }

  private void onGreet(Greet command) {
    log.info(&quot;Hello {}!&quot;, command.whom);
    getSender().tell(new Greeted(command.whom), getSelf());
  }
}</code></pre></dd>
</dl>
<p>Typed HelloWorld actor:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.0-M1/akka-actor-typed-tests/src/test/scala/docs/akka/typed/fromclassic/TypedSample.scala#L8-L35" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import akka.actor.typed.ActorRef
import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.AbstractBehavior
import akka.actor.typed.scaladsl.ActorContext
import akka.actor.typed.scaladsl.Behaviors

object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  def apply(): Behavior[HelloWorld.Greet] =
    Behaviors.setup(context =&gt; new HelloWorld(context))
}

class HelloWorld(context: ActorContext[HelloWorld.Greet]) extends AbstractBehavior[HelloWorld.Greet](context) {
  import HelloWorld._

  override def onMessage(message: Greet): Behavior[Greet] = {
    context.log.info(&quot;Hello {}!&quot;, message.whom)
    message.replyTo ! Greeted(message.whom, context.self)
    this
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.0-M1/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/fromclassic/TypedSample.java#L8-L63" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

import java.util.HashMap;
import java.util.Map;

public class HelloWorld extends AbstractBehavior&lt;HelloWorld.Greet&gt; {

  public static final class Greet {
    public final String whom;
    public final ActorRef&lt;Greeted&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeted&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  public static final class Greeted {
    public final String whom;
    public final ActorRef&lt;Greet&gt; from;

    public Greeted(String whom, ActorRef&lt;Greet&gt; from) {
      this.whom = whom;
      this.from = from;
    }
  }

  public static Behavior&lt;Greet&gt; create() {
    return Behaviors.setup(HelloWorld::new);
  }

  private HelloWorld(ActorContext&lt;Greet&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Greet&gt; createReceive() {
    return newReceiveBuilder().onMessage(Greet.class, this::onGreet).build();
  }

  private Behavior&lt;Greet&gt; onGreet(Greet command) {
    getContext().getLog().info(&quot;Hello {}!&quot;, command.whom);
    command.replyTo.tell(new Greeted(command.whom, getContext().getSelf()));
    return this;
  }
}</code></pre></dd>
</dl>
<p>Why is it called <code>Behavior</code> and not <code>Actor</code>?</p>
<p>In Typed, the <code>Behavior</code> defines how to handle incoming messages. After processing a message, a different <code>Behavior</code> may be returned for processing the next message. This means that an actor is started with an initial <code>Behavior</code> and may change <code>Behavior</code> over its lifecycle. This is described more in the section about <a href="from-classic.html#become">become</a>.</p>
<p>Note that the <code>Behavior</code> has a type parameter describing the type of messages that it can handle. This information is not defined explicitly for a classic actor.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#defining-an-actor-class">Classic</a></li>
  <li><a href="actors.html#first-example">Typed</a></li>
</ul>
<h2><a href="#actorof-and-props" name="actorof-and-props" class="anchor"><span class="anchor-link"></span></a>actorOf and Props</h2>
<p>A classic actor is started with the <code>actorOf</code> method of the <code>ActorContext</code> or <code>ActorSystem</code>.</p>
<p>Corresponding method in Typed is called <code>spawn</code> in the <span class="group-scala"><code>akka.actor.typed.scaladsl.ActorContext</code></span><span class="group-java"><code>akka.actor.typed.javadsl.ActorContext</code></span>.</p>
<p>There is no <code>spawn</code> method in the <span class="group-scala"><code>akka.actor.typed.scaladsl.ActorSystem</code></span><span class="group-java"><code>akka.actor.typed.javadsl.ActorSystem</code></span> for creating top level actors. Instead, there is a single top level actor defined by a user guardian <code>Behavior</code> that is given when starting the <code>ActorSystem</code>. Other actors are started as children of that user guardian actor or children of other actors in the actor hierarchy. This is explained more in <a href="from-classic.html#actorsystem">ActorSystem</a>.</p>
<p>Note that when mixing classic and typed and have a classic system, spawning top level actors from the side is possible, see <a href="coexisting.html#top-level-typed-actor-classic-system">Coexistence</a>.</p>
<p>The <code>actorOf</code> method takes an <code>akka.actor.Props</code> parameter, which is like a factory for creating the actor instance, and it&rsquo;s also used when creating a new instance when the actor is restarted. The <code>Props</code> may also define additional properties such as which dispatcher to use for the actor.</p>
<p>In typed, the <code>spawn</code> method creates an actor directly from a given <code>Behavior</code> without using a <code>Props</code> factory. It does however accept an optional <code>akka.actor.typed.Props</code> for specifying Actor metadata. The factory aspect is instead defined via <code>Behaviors.setup</code> when using the object-oriented style with a class extending <code>AbstractBehavior</code>. For the function style there is typically no need for the factory.</p>
<p>Additional properties such as which dispatcher to use for the actor can still be given via an optional <code>akka.actor.typed.Props</code> parameter of the <code>spawn</code> method.</p>
<p>The <code>name</code> parameter of <code>actorOf</code> is optional and if not defined the actor will have a generated name. Corresponding in Typed is achieved with the <code>spawnAnonymous</code> method.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#creating-actors-with-props">Classic</a></li>
  <li><a href="actor-lifecycle.html#creating-actors">Typed</a></li>
</ul>
<h2><a href="#actorref" name="actorref" class="anchor"><span class="anchor-link"></span></a>ActorRef</h2>
<p><code>akka.actor.ActorRef</code> has its correspondence in <code>akka.actor.typed.ActorRef</code>. The difference being that the latter has a type parameter describing which messages the actor can handle. This information is not defined for a classic actor and you can send any type of message to a classic <code>ActorRef</code> even though the actor may not understand it.</p>
<h2><a href="#actorsystem" name="actorsystem" class="anchor"><span class="anchor-link"></span></a>ActorSystem</h2>
<p><code>akka.actor.ActorSystem</code> has its correspondence in <code>akka.actor.typed.ActorSystem</code>. One difference is that when creating an <code>ActorSystem</code> in Typed you give it a <code>Behavior</code> that will be used as the top level actor, also known as the user guardian.</p>
<p>Additional actors for an application are created from the user guardian alongside performing the initialization of Akka components such as Cluster Sharding. In contrast, in a classic <code>ActorSystem</code>, such initialization is typically performed from the &ldquo;outside&rdquo;.</p>
<p>The <code>actorOf</code> method of the classic <code>ActorSystem</code> is typically used to create a few (or many) top level actors. The <code>ActorSystem</code> in Typed doesn&rsquo;t have that capability. Instead, such actors are started as children of the user guardian actor or children of other actors in the actor hierarchy. The rationale for this is partly about consistency. In a typed system you can’t create children to an arbitrary actor from anywhere in your app without messaging it, so this will also hold true for the user guardian actor. That noted, in cases where you do need to spawn outside of this guardian then you can use the <a href="actor-lifecycle.html#spawnprotocol"><code>SpawnProtocol</code></a> to spawn as needed.</p>
<h2><a href="#become" name="become" class="anchor"><span class="anchor-link"></span></a>become</h2>
<p>A classic actor can change its message processing behavior by using <code>become</code> in <code>ActorContext</code>. In Typed this is done by returning a new <code>Behavior</code> after processing a message. The returned <code>Behavior</code> will be used for the next received message.</p>
<p>There is no correspondence to <code>unbecome</code> in Typed. Instead you must explicitly keep track of and return the &ldquo;previous&rdquo; <code>Behavior</code>.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#actor-hotswap">Classic</a></li>
</ul>
<h2><a href="#sender" name="sender" class="anchor"><span class="anchor-link"></span></a>sender</h2>
<p>There is no <span class="group-scala"><code>sender()</code></span><span class="group-java"><code>getSender()</code></span> in Typed. Instead you have to explicitly include an <code>ActorRef</code> representing the sender—or rather representing where to send a reply to—in the messages.</p>
<p>The reason for not having an implicit sender in Typed is that it wouldn&rsquo;t be possible to know the type for the sender <span class="group-scala"><code>ActorRef[T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> at compile time. It&rsquo;s also much better to define this explicitly in the messages as it becomes more clear what the message protocol expects.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#actors-tell-sender">Classic</a></li>
  <li><a href="interaction-patterns.html#request-response">Typed</a></li>
</ul>
<h2><a href="#parent" name="parent" class="anchor"><span class="anchor-link"></span></a>parent</h2>
<p>There is no <span class="group-scala"><code>parent</code></span><span class="group-java"><code>getParent</code></span> in Typed. Instead you have to explicitly include the <code>ActorRef</code> of the parent as a parameter when constructing the <code>Behavior</code>.</p>
<p>The reason for not having a parent in Typed is that it wouldn&rsquo;t be possible to know the type for the parent <span class="group-scala"><code>ActorRef[T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> at compile time without having an additional type parameter in the <code>Behavior</code>. For testing purposes it&rsquo;s also better to pass in the <code>parent</code> since it can be replaced by a probe or being stubbed out in tests.</p>
<h2><a href="#supervision" name="supervision" class="anchor"><span class="anchor-link"></span></a>Supervision</h2>
<p>An important difference between classic and typed is that in typed, actors are stopped by default if an exception is thrown and no supervision strategy is defined. In contrast, in classic, by default, actors are restarted.</p>
<p>In classic actors the supervision strategy for child actors are defined by overriding the <code>supervisorStrategy</code> method in the parent actor.</p>
<p>In Typed the supervisor strategy is defined by wrapping the <code>Behavior</code> of the child actor with <code>Behaviors.supervise</code>.</p>
<p>The classic <code>BackoffSupervisor</code> is supported by <code>SupervisorStrategy.restartWithBackoff</code> as an ordinary <code>SupervisorStrategy</code> in Typed.</p>
<p><code>SupervisorStrategy.Escalate</code> isn&rsquo;t supported in Typed, but similar can be achieved as described in <a href="fault-tolerance.html#bubble-failures-up-through-the-hierarchy">Bubble failures up through the hierarchy</a>.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../fault-tolerance.html">Classic</a></li>
  <li><a href="fault-tolerance.html">Typed</a></li>
</ul>
<h2><a href="#lifecycle-hooks" name="lifecycle-hooks" class="anchor"><span class="anchor-link"></span></a>Lifecycle hooks</h2>
<p>Classic actors have methods <code>preStart</code>, <code>preRestart</code>, <code>postRestart</code> and <code>postStop</code> that can be overridden to act on changes to the actor&rsquo;s lifecycle.</p>
<p>This is supported with corresponding <code>PreRestart</code> and <code>PostStop</code> signal messages in Typed. There are no <code>PreStart</code> and <code>PostRestart</code> signals because such action can be done from <code>Behaviors.setup</code> or the constructor of the <code>AbstractBehavior</code> class.</p>
<p>Note that in classic, the <code>postStop</code> lifecycle hook is also called when the actor is restarted. That is not the case in Typed, only the <code>PreRestart</code> signal is emitted. If you need to do resource cleanup on both restart and stop, you have to do that for both <code>PreRestart</code> and <code>PostStop</code>.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#start-hook">Classic</a></li>
  <li><a href="fault-tolerance.html#the-prerestart-signal">Typed</a></li>
</ul>
<h2><a href="#watch" name="watch" class="anchor"><span class="anchor-link"></span></a>watch</h2>
<p><code>watch</code> and the <code>Terminated</code> message are pretty much the same, with some additional capabilities in Typed.</p>
<p><code>Terminated</code> is a signal in Typed since it is a different type than the declared message type of the <code>Behavior</code>.</p>
<p>The <code>watchWith</code> method of the <code>ActorContext</code> in Typed can be used to send a message instead of the <code>Terminated</code> signal.</p>
<p>When watching child actors it&rsquo;s possible to see if the child terminated voluntarily or due to a failure via the <code>ChildFailed</code> signal, which is a subclass of <code>Terminated</code>.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#deathwatch">Classic</a></li>
  <li><a href="actor-lifecycle.html#watching-actors">Typed</a></li>
</ul>
<h2><a href="#stopping" name="stopping" class="anchor"><span class="anchor-link"></span></a>Stopping</h2>
<p>Classic actors can be stopped with the <code>stop</code> method of <code>ActorContext</code> or <code>ActorSystem</code>. In Typed an actor stops itself by returning <code>Behaviors.stopped</code>. There is also a <code>stop</code> method in the <code>ActorContext</code> but it can only be used for stopping direct child actors and not any arbitrary actor.</p>
<p><code>PoisonPill</code> is not supported in Typed. Instead, if you need to request an actor to stop you should define a message that the actor understands and let it return <code>Behaviors.stopped</code> when receiving that message.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#stopping-actors">Classic</a></li>
  <li><a href="actor-lifecycle.html#stopping-actors">Typed</a></li>
</ul>
<h2><a href="#actorselection" name="actorselection" class="anchor"><span class="anchor-link"></span></a>ActorSelection</h2>
<p><code>ActorSelection</code> isn&rsquo;t supported in Typed. Instead the <a href="actor-discovery.html">Receptionist</a> is supposed to be used for finding actors by a registered key.</p>
<p><code>ActorSelection</code> can be used for sending messages to a path without having an <code>ActorRef</code> of the destination. Note that a <a href="routers.html#group-router">Group Router</a> can be used for that.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#actorselection">Classic</a></li>
  <li><a href="actor-discovery.html">Typed</a></li>
</ul>
<h2><a href="#ask" name="ask" class="anchor"><span class="anchor-link"></span></a>ask</h2>
<p>The classic <code>ask</code> pattern returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> for the response.</p>
<p>Corresponding <code>ask</code> exists in Typed and is good when the requester itself isn&rsquo;t an actor. It is located in <span class="group-scala"><code>akka.actor.typed.scaladsl.AskPattern</code></span><span class="group-java"><code>akka.actor.typed.javadsl.AskPattern</code></span>.</p>
<p>When the requester is an actor it is better to use the <code>ask</code> method of the <code>ActorContext</code> in Typed. It has the advantage of not having to mix <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> callbacks that are running on different threads with actor code.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#actors-ask">Classic</a></li>
  <li><a href="interaction-patterns.html#request-response-with-ask-between-two-actors">Typed</a></li>
</ul>
<h2><a href="#pipeto" name="pipeto" class="anchor"><span class="anchor-link"></span></a>pipeTo</h2>
<p><code>pipeTo</code> is typically used together with <code>ask</code> in an actor. The <code>ask</code> method of the <code>ActorContext</code> in Typed removes the need for <code>pipeTo</code>. However, for interactions with other APIs that return <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> it is still useful to send the result as a message to the actor. For this purpose there is a <code>pipeToSelf</code> method in the <code>ActorContext</code> in Typed.</p>
<h2><a href="#actorcontext-children" name="actorcontext-children" class="anchor"><span class="anchor-link"></span></a>ActorContext.children</h2>
<p>The <code>ActorContext</code> has methods <span class="group-scala"><code>children</code> and <code>child</code></span><span class="group-java"><code>getChildren</code> and <code>getChild</code></span> to retrieve the <code>ActorRef</code> of started child actors in both Typed and Classic.</p>
<p>The type of the returned <code>ActorRef</code> is unknown, since different types can be used for different children. Therefore, this is not a useful way to lookup children when the purpose is to send messages to them.</p>
<p>Instead of finding children via the <code>ActorContext</code>, it is recommended to use an application specific collection for bookkeeping of children, such as a <span class="group-scala"><code>Map[String, ActorRef[Child.Command]]</code></span> <span class="group-java"><code>Map&lt;String, ActorRef&lt;Child.Command&gt;&gt;</code></span>. It can look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.0-M1/akka-actor-typed-tests/src/test/scala/docs/akka/typed/fromclassic/TypedSample.scala#L39-L68" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object Parent {
  sealed trait Command
  case class DelegateToChild(name: String, message: Child.Command) extends Command
  private case class ChildTerminated(name: String) extends Command

  def apply(): Behavior[Command] = {
    def updated(children: Map[String, ActorRef[Child.Command]]): Behavior[Command] = {
      Behaviors.receive { (context, command) =&gt;
        command match {
          case DelegateToChild(name, childCommand) =&gt;
            children.get(name) match {
              case Some(ref) =&gt;
                ref ! childCommand
                Behaviors.same
              case None =&gt;
                val ref = context.spawn(Child(), name)
                context.watchWith(ref, ChildTerminated(name))
                ref ! childCommand
                updated(children + (name -&gt; ref))
            }

          case ChildTerminated(name) =&gt;
            updated(children - name)
        }
      }
    }

    updated(Map.empty)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.0-M1/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/fromclassic/TypedSample.java#L67-L122" target="_blank" title="Go to snippet source">source</a><code class="language-java">public class Parent extends AbstractBehavior&lt;Parent.Command&gt; {

  public interface Command {}

  public static class DelegateToChild implements Command {
    public final String name;
    public final Child.Command message;

    public DelegateToChild(String name, Child.Command message) {
      this.name = name;
      this.message = message;
    }
  }

  private static class ChildTerminated implements Command {
    final String name;

    ChildTerminated(String name) {
      this.name = name;
    }
  }

  public static Behavior&lt;Command&gt; create() {
    return Behaviors.setup(Parent::new);
  }

  private Map&lt;String, ActorRef&lt;Child.Command&gt;&gt; children = new HashMap&lt;&gt;();

  private Parent(ActorContext&lt;Command&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(DelegateToChild.class, this::onDelegateToChild)
        .onMessage(ChildTerminated.class, this::onChildTerminated)
        .build();
  }

  private Behavior&lt;Command&gt; onDelegateToChild(DelegateToChild command) {
    ActorRef&lt;Child.Command&gt; ref = children.get(command.name);
    if (ref == null) {
      ref = getContext().spawn(Child.create(), command.name);
      getContext().watchWith(ref, new ChildTerminated(command.name));
      children.put(command.name, ref);
    }
    ref.tell(command.message);
    return this;
  }

  private Behavior&lt;Command&gt; onChildTerminated(ChildTerminated command) {
    children.remove(command.name);
    return this;
  }
}</code></pre></dd>
</dl>
<p>Remember to remove entries from the <code>Map</code> when the children are terminated. For that purpose it&rsquo;s convenient to use <code>watchWith</code>, as illustrated in the example above, because then you can include the key to the <code>Map</code> in the termination message. In that way the name of the actor doesn&rsquo;t have to be the same as identifier used for bookkeeping.</p>
<p>Retrieving the children from the <code>ActorContext</code> can still be useful for some use cases, such as:</p>
<ul>
  <li>see if a child name is in use</li>
  <li>stopping children</li>
  <li>the type of the child is well known and <code>unsafeUpcast</code> of the <code>ActorRef</code> is considered &ldquo;safe enough&rdquo;</li>
</ul>
<h2><a href="#remote-deployment" name="remote-deployment" class="anchor"><span class="anchor-link"></span></a>Remote deployment</h2>
<p>Starting an actor on a remote node—so called remote deployment—isn&rsquo;t supported in Typed.</p>
<p>This feature would be discouraged because it often results in tight coupling between nodes and undesirable failure handling. For example if the node of the parent actor crashes, all remote deployed child actors are brought down with it. Sometimes that can be desired but many times it is used without realizing. This can be achieved by other means, such as using <code>watch</code>.</p>
<h2><a href="#routers" name="routers" class="anchor"><span class="anchor-link"></span></a>Routers</h2>
<p>Routers are provided in Typed, but in a much simplified form compared to the classic routers.</p>
<p>Destinations of group routers are registered in the <code>Receptionist</code>, which makes them Cluster aware and also more dynamic than classic group routers.</p>
<p>Pool routers are only for local actor destinations in Typed, since <a href="from-classic.html#remote-deployment">remote deployment isn&rsquo;t supported</a>.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../routing.html">Classic</a></li>
  <li><a href="routers.html">Typed</a></li>
</ul>
<h2><a href="#fsm" name="fsm" class="anchor"><span class="anchor-link"></span></a>FSM</h2>
<p>With classic actors there is explicit support for building Finite State Machines. No support is needed in Akka Typed as it is straightforward to represent FSMs with behaviors.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../fsm.html">Classic</a></li>
  <li><a href="fsm.html">Typed</a></li>
</ul>
<h2><a href="#timers" name="timers" class="anchor"><span class="anchor-link"></span></a>Timers</h2>
<p>In classic actors you <span class="group-scala">mixin <code>with Timers</code></span><span class="group-java"><code>extend AbstractActorWithTimers</code></span> to gain access to delayed and periodic scheduling of messages. In Typed you have access to similar capabilities via <code>Behaviors.withTimers</code>.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#actors-timers">Classic</a></li>
  <li><a href="interaction-patterns.html#scheduling-messages-to-self">Typed</a></li>
</ul>
<h2><a href="#stash" name="stash" class="anchor"><span class="anchor-link"></span></a>Stash</h2>
<p>In classic actors you <span class="group-scala">mixin <code>with Stash</code></span><span class="group-java"><code>extend AbstractActorWithStash</code></span> to gain access to stashing of messages. In Typed you have access to similar capabilities via <code>Behaviors.withStash</code>.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../actors.html#stash">Classic</a></li>
  <li><a href="stash.html">Typed</a></li>
</ul>
<h2><a href="#persistentactor" name="persistentactor" class="anchor"><span class="anchor-link"></span></a>PersistentActor</h2>
<p>The correspondence of the classic <code>PersistentActor</code> is <span class="group-scala"><code>akka.persistence.typed.scaladsl.EventSourcedBehavior</code></span><span class="group-java"><code>akka.persistence.typed.javadsl.EventSourcedBehavior</code></span>.</p>
<p>The Typed API is much more guided to facilitate Event Sourcing best practices. It also has tighter integration with Cluster Sharding.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../persistence.html">Classic</a></li>
  <li><a href="persistence.html">Typed</a></li>
</ul>
<h2><a href="#asynchronous-testing" name="asynchronous-testing" class="anchor"><span class="anchor-link"></span></a>Asynchronous Testing</h2>
<p>The Test Kits for asynchronous testing are rather similar.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../testing.html#async-integration-testing">Classic</a></li>
  <li><a href="testing-async.html#asynchronous-testing">Typed</a></li>
</ul>
<h2><a href="#synchronous-testing" name="synchronous-testing" class="anchor"><span class="anchor-link"></span></a>Synchronous Testing</h2>
<p>Classic and typed have different Test Kits for synchronous testing.</p>
<p>Behaviors in Typed can be tested in isolation without having to be packaged into an actor. As a consequence, tests can run fully synchronously without having to worry about timeouts and spurious failures.</p>
<p>The <code>BehaviorTestKit</code> provides a nice way of unit testing a <code>Behavior</code> in a deterministic way, but it has some limitations to be aware of. Similar limitations exists for synchronous testing of classic actors.</p>
<p>Links to reference documentation:</p>
<ul>
  <li><a href="../testing.html#sync-testing">Classic</a></li>
  <li><a href="testing-sync.html#synchronous-behavior-testing">Typed</a></li>
</ul>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/style-guide.html"><i class="icon-prev"></i> <span class="link-prev">Style guide</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/index-cluster.html">Cluster <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.8.0-M1/akka-docs/src/main/paradox/typed/from-classic.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<div>Akka is available under the <a href="https://www.lightbend.com/akka/license" target="_blank">Business Source License 1.1</a>.</div>
<p class="legal">
&copy; 2011-2022 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/snippets.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>
<script type="text/javascript" src="../js/lbHeader.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
