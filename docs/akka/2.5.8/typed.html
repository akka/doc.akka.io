<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Akka Typed &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/typed/index.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.8
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="typed.html#akka-typed" class="active page">Akka Typed</a>
    <ul>
      <li><a href="typed.html#dependency" class="header">Dependency</a></li>
      <li><a href="typed.html#introduction" class="header">Introduction</a></li>
      <li><a href="typed.html#a-little-bit-of-theory" class="header">A Little Bit of Theory</a></li>
      <li><a href="typed.html#a-more-complex-example" class="header">A More Complex Example</a></li>
      <li><a href="typed.html#status-of-this-project-and-relation-to-akka-actors" class="header">Status of this Project and Relation to Akka Actors</a></li>
    </ul></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
    <li><a href="typed-actors.html" class="page">Typed Actors</a></li>
  </ul></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.8
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="typed.html#akka-typed" class="active page">Akka Typed</a>
    <ul>
      <li><a href="typed.html#dependency" class="header">Dependency</a></li>
      <li><a href="typed.html#introduction" class="header">Introduction</a></li>
      <li><a href="typed.html#a-little-bit-of-theory" class="header">A Little Bit of Theory</a></li>
      <li><a href="typed.html#a-more-complex-example" class="header">A More Complex Example</a></li>
      <li><a href="typed.html#status-of-this-project-and-relation-to-akka-actors" class="header">Status of this Project and Relation to Akka Actors</a></li>
    </ul></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
    <li><a href="typed-actors.html" class="page">Typed Actors</a></li>
  </ul></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#akka-typed" name="akka-typed" class="anchor"><span class="anchor-link"></span></a>Akka Typed</h1><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="common/may-change.html">may change</a> in the sense  of being the subject of active research. This means that API or semantics can  change without warning or deprecation period and it is not recommended to use  this module in production just yet—you have been warned.</p></div>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>Akka Typed APIs are bundled in the <code>akka-typed</code> artifact. Make sure that you have the following dependency in your project:</p>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre><code>&quot;com.typesafe.akka&quot; %% &quot;akka-typed&quot; % &quot;2.5.8&quot;
</code></pre></dd>
  <dt>Gradle</dt>
  <dd>
  <pre><code>dependencies {
  compile group: &#39;com.typesafe.akka&#39;, name: &#39;akka-typed_2.11&#39;, version: &#39;2.5.8&#39;
}
</code></pre></dd>
  <dt>Maven</dt>
  <dd>
  <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-typed_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></dd>
</dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>As discussed in <a href="general/actor-systems.html">Actor Systems</a> (and following chapters) Actors are about sending messages between independent units of computation, but how does that look like? In all of the following these imports are assumed:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import akka.typed._
import akka.typed.scaladsl.Actor
import akka.typed.scaladsl.AskPattern._
import scala.concurrent.Future
import scala.concurrent.duration._
import scala.concurrent.Await</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import akka.typed.ActorRef;
import akka.typed.ActorSystem;
import akka.typed.Behavior;
import akka.typed.Terminated;
import akka.typed.javadsl.Actor;
import akka.typed.javadsl.AskPattern;
import akka.util.Timeout;
</code></pre></dd>
</dl>
<p>With these in place we can define our first Actor, and of course it will say hello!</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String)

  val greeter = Actor.immutable[Greet] { (_, msg) ⇒
    println(s&quot;Hello ${msg.whom}!&quot;)
    msg.replyTo ! Greeted(msg.whom)
    Actor.same
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public abstract static class HelloWorld {
  //no instances of this class, it&#39;s only a name space for messages
  // and static methods
  private HelloWorld() {
  }

  public static final class Greet{
    public final String whom;
    public final ActorRef&lt;Greeted&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeted&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  public static final class Greeted {
    public final String whom;

    public Greeted(String whom) {
      this.whom = whom;
    }
  }

  public static final Behavior&lt;Greet&gt; greeter = Actor.immutable((ctx, msg) -&gt; {
    System.out.println(&quot;Hello &quot; + msg.whom + &quot;!&quot;);
    msg.replyTo.tell(new Greeted(msg.whom));
    return Actor.same();
  });
}</code></pre></dd>
</dl>
<p>This small piece of code defines two message types, one for commanding the Actor to greet someone and one that the Actor will use to confirm that it has done so. The <code>Greet</code> type contains not only the information of whom to greet, it also holds an <code>ActorRef</code> that the sender of the message supplies so that the <code>HelloWorld</code> Actor can send back the confirmation message.</p>
<p>The behavior of the Actor is defined as the <code>greeter</code> value with the help of the <code>immutable</code> behavior constructor. This constructor is called immutable because the behavior instance doesn&rsquo;t have or close over any mutable state. Processing the next message may result in a new behavior that can potentially be different from this one. State is updated by returning a new behavior that holds the new immutable state. In this case we don&rsquo;t need to update any state, so we return <code>Same</code>.</p>
<p>The type of the messages handled by this behavior is declared to be of class <code>Greet</code>, which implies that the supplied function’s <code>msg</code> argument is also typed as such. This is why we can access the <code>whom</code> and <code>replyTo</code> members without needing to use a pattern match.</p>
<p>On the last line we see the <code>HelloWorld</code> Actor send a message to another Actor, which is done using the <span class="group-scala"><code>!</code> operator (pronounced “tell”).</span><span class="group-java"><code>tell</code> method.</span> Since the <code>replyTo</code> address is declared to be of type <span class="group-scala"><code>ActorRef[Greeted]</code></span><span class="group-java"><code>ActorRef&lt;Greeted&gt;</code></span>, the compiler will only permit us to send messages of this type, other usage will not be accepted.</p>
<p>The accepted message types of an Actor together with all reply types defines the protocol spoken by this Actor; in this case it is a simple request–reply protocol but Actors can model arbitrarily complex protocols when needed. The protocol is bundled together with the behavior that implements it in a nicely wrapped scope—the <code>HelloWorld</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>Now we want to try out this Actor, so we must start an ActorSystem to host it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import HelloWorld._
// using global pool since we want to run tasks after system.terminate
import scala.concurrent.ExecutionContext.Implicits.global

val system: ActorSystem[Greet] = ActorSystem(greeter, &quot;hello&quot;)

val future: Future[Greeted] = system ? (Greet(&quot;world&quot;, _))

for {
  greeting ← future.recover { case ex ⇒ ex.getMessage }
  done ← { println(s&quot;result: $greeting&quot;); system.terminate() }
} println(&quot;system terminated&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">final ActorSystem&lt;HelloWorld.Greet&gt; system =
  ActorSystem.create(HelloWorld.greeter, &quot;hello&quot;);

final CompletionStage&lt;HelloWorld.Greeted&gt; reply =
  AskPattern.ask(system,
    (ActorRef&lt;HelloWorld.Greeted&gt; replyTo) -&gt; new HelloWorld.Greet(&quot;world&quot;, replyTo),
    new Timeout(3, TimeUnit.SECONDS), system.scheduler());

reply.thenAccept(greeting -&gt; {
  System.out.println(&quot;result: &quot; + greeting.whom);
  system.terminate();
});</code></pre></dd>
</dl>
<p>After importing the Actor’s protocol definition we start an Actor system from the defined <code>greeter</code> behavior.</p>
<p>As Carl Hewitt said, one Actor is no Actor—it would be quite lonely with nobody to talk to. In this sense the example is a little cruel because we only give the <code>HelloWorld</code> Actor a fake person to talk to—the “ask” pattern (represented by the <code>?</code> operator) can be used to send a message such that the reply fulfills a <span class="group-scala"><code>Promise</code> to which we get back the corresponding <code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>.</p><div class="group-scala">
<p>Note that the <code>Future</code> that is returned by the “ask” operation is properly typed already, no type checks or casts needed. This is possible due to the type information that is part of the message protocol: the <code>?</code> operator takes as argument a function that accepts an <code>ActorRef[U]</code> (which explains the <code>_</code> hole in the expression on line 7 above) and the <code>replyTo</code> parameter which we fill in is of type <code>ActorRef[Greeted]</code>, which means that the value that fulfills the <code>Promise</code> can only be of type <code>Greeted</code>.</p></div><div class="group-java">
<p>Note that the <code>CompletionStage</code> that is returned by the “ask” operation is properly typed already, no type checks or casts needed. This is possible due to the type information that is part of the message protocol: the <code>ask</code> operator takes as argument a function that pass an <code>ActorRef&lt;U&gt;</code>, which is the <code>replyTo</code> parameter of the <code>Greet</code> message, which means that when sending the reply message to that <code>ActorRef</code> the message that fulfills the <code>CompletionStage</code> can only be of type <code>Greeted</code>.</p></div>
<p>We use this here to send the <code>Greet</code> command to the Actor and when the reply comes back we will print it out and tell the actor system to shut down. Once that is done as well we print the <code>&quot;system terminated&quot;</code> messages and the program ends.</p><div class="group-scala">
<p>The <code>recovery</code> combinator on the original <code>Future</code> is needed in order to ensure proper system shutdown even in case something went wrong; the <code>flatMap</code> and <code>map</code> combinators that the <code>for</code> expression gets turned into care only about the “happy path” and if the <code>future</code> failed with a timeout then no <code>greeting</code> would be extracted and nothing would happen.</p></div>
<p>This shows that there are aspects of Actor messaging that can be type-checked by the compiler, but this ability is not unlimited, there are bounds to what we can statically express. Before we go on with a more complex (and realistic) example we make a small detour to highlight some of the theory behind this.</p>
<h2><a href="#a-little-bit-of-theory" name="a-little-bit-of-theory" class="anchor"><span class="anchor-link"></span></a>A Little Bit of Theory</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a> as defined by Hewitt, Bishop and Steiger in 1973 is a computational model that expresses exactly what it means for computation to be distributed. The processing units—Actors—can only communicate by exchanging messages and upon reception of a message an Actor can do the following three fundamental actions:</p>
<ol>
  <li>send a finite number of messages to Actors it knows</li>
  <li>create a finite number of new Actors</li>
  <li>designate the behavior to be applied to the next message</li>
</ol>
<p>The Akka Typed project expresses these actions using behaviors and addresses. Messages can be sent to an address and behind this façade there is a behavior that receives the message and acts upon it. The binding between address and behavior can change over time as per the third point above, but that is not visible on the outside.</p>
<p>With this preamble we can get to the unique property of this project, namely that it introduces static type checking to Actor interactions: addresses are parameterized and only messages that are of the specified type can be sent to them. The association between an address and its type parameter must be made when the address (and its Actor) is created. For this purpose each behavior is also parameterized with the type of messages it is able to process. Since the behavior can change behind the address façade, designating the next behavior is a constrained operation: the successor must handle the same type of messages as its predecessor. This is necessary in order to not invalidate the addresses that refer to this Actor.</p>
<p>What this enables is that whenever a message is sent to an Actor we can statically ensure that the type of the message is one that the Actor declares to handle—we can avoid the mistake of sending completely pointless messages. What we cannot statically ensure, though, is that the behavior behind the address will be in a given state when our message is received. The fundamental reason is that the association between address and behavior is a dynamic runtime property, the compiler cannot know it while it translates the source code.</p>
<p>This is the same as for normal Java objects with internal variables: when compiling the program we cannot know what their value will be, and if the result of a method call depends on those variables then the outcome is uncertain to a degree—we can only be certain that the returned value is of a given type.</p>
<p>We have seen above that the return type of an Actor command is described by the type of reply-to address that is contained within the message. This allows a conversation to be described in terms of its types: the reply will be of type A, but it might also contain an address of type B, which then allows the other Actor to continue the conversation by sending a message of type B to this new address. While we cannot statically express the “current” state of an Actor, we can express the current state of a protocol between two Actors, since that is just given by the last message type that was received or sent.</p>
<p>In the next section we demonstrate this on a more realistic example.</p>
<h2><a href="#a-more-complex-example" name="a-more-complex-example" class="anchor"><span class="anchor-link"></span></a>A More Complex Example</h2>
<p>Consider an Actor that runs a chat room: client Actors may connect by sending a message that contains their screen name and then they can post messages. The chat room Actor will disseminate all posted messages to all currently connected client Actors. The protocol definition could look like the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait Command
final case class GetSession(screenName: String, replyTo: ActorRef[SessionEvent])
  extends Command

sealed trait SessionEvent
final case class SessionGranted(handle: ActorRef[PostMessage]) extends SessionEvent
final case class SessionDenied(reason: String) extends SessionEvent
final case class MessagePosted(screenName: String, message: String) extends SessionEvent

final case class PostMessage(message: String)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">static interface Command {}
public static final class GetSession implements Command {
  public final String screenName;
  public final ActorRef&lt;SessionEvent&gt; replyTo;
  public GetSession(String screenName, ActorRef&lt;SessionEvent&gt; replyTo) {
    this.screenName = screenName;
    this.replyTo = replyTo;
  }
}

static interface SessionEvent {}
public static final class SessionGranted implements SessionEvent {
  public final ActorRef&lt;PostMessage&gt; handle;
  public SessionGranted(ActorRef&lt;PostMessage&gt; handle) {
    this.handle = handle;
  }
}
public static final class SessionDenied implements SessionEvent {
  public final String reason;
  public SessionDenied(String reason) {
    this.reason = reason;
  }
}
public static final class MessagePosted implements SessionEvent {
  public final String screenName;
  public final String message;
  public MessagePosted(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

public static final class PostMessage {
  public final String message;
  public PostMessage(String message) {
    this.message = message;
  }
}</code></pre></dd>
</dl>
<p>Initially the client Actors only get access to an <span class="group-scala"><code>ActorRef[GetSession]</code></span><span class="group-java"><code>ActorRef&lt;GetSession&gt;</code></span> which allows them to make the first step. Once a client’s session has been established it gets a <code>SessionGranted</code> message that contains a <code>handle</code> to unlock the next protocol step, posting messages. The <code>PostMessage</code> command will need to be sent to this particular address that represents the session that has been added to the chat room. The other aspect of a session is that the client has revealed its own address, via the <code>replyTo</code> argument, so that subsequent <code>MessagePosted</code> events can be sent to it.</p>
<p>This illustrates how Actors can express more than just the equivalent of method calls on Java objects. The declared message types and their contents describe a full protocol that can involve multiple Actors and that can evolve over multiple steps. The implementation of the chat room protocol would be as simple as the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private final case class PostSessionMessage(screenName: String, message: String)
  extends Command

val behavior: Behavior[Command] =
  chatRoom(List.empty)

private def chatRoom(sessions: List[ActorRef[SessionEvent]]): Behavior[Command] =
  Actor.immutable[Command] { (ctx, msg) ⇒
    msg match {
      case GetSession(screenName, client) ⇒
        val wrapper = ctx.spawnAdapter {
          p: PostMessage ⇒ PostSessionMessage(screenName, p.message)
        }
        client ! SessionGranted(wrapper)
        chatRoom(client :: sessions)
      case PostSessionMessage(screenName, message) ⇒
        val mp = MessagePosted(screenName, message)
        sessions foreach (_ ! mp)
        Actor.same
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">private static final class PostSessionMessage implements Command {
  public final String screenName;
  public final String message;
  public PostSessionMessage(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

public static Behavior&lt;Command&gt; behavior() {
  return chatRoom(new ArrayList&lt;ActorRef&lt;SessionEvent&gt;&gt;());
}

private static Behavior&lt;Command&gt; chatRoom(List&lt;ActorRef&lt;SessionEvent&gt;&gt; sessions) {
  return Actor.immutable(Command.class)
    .onMessage(GetSession.class, (ctx, getSession) -&gt; {
      ActorRef&lt;PostMessage&gt; wrapper = ctx.spawnAdapter(p -&gt;
        new PostSessionMessage(getSession.screenName, p.message));
      getSession.replyTo.tell(new SessionGranted(wrapper));
      List&lt;ActorRef&lt;SessionEvent&gt;&gt; newSessions =
        new ArrayList&lt;ActorRef&lt;SessionEvent&gt;&gt;(sessions);
      newSessions.add(getSession.replyTo);
      return chatRoom(newSessions);
    })
    .onMessage(PostSessionMessage.class, (ctx, post) -&gt; {
      MessagePosted mp = new MessagePosted(post.screenName, post.message);
      sessions.forEach(s -&gt; s.tell(mp));
      return Actor.same();
    })
    .build();
}</code></pre></dd>
</dl>
<p>The core of this behavior is stateful, the chat room itself does not change into something else when sessions are established, but we introduce a variable that tracks the opened sessions. Note that by using a method parameter a <code>var</code> is not needed. When a new <code>GetSession</code> command comes in we add that client to the list that is in the returned behavior. Then we also need to create the session’s <code>ActorRef</code> that will be used to post messages. In this case we want to create a very simple Actor that just repackages the <code>PostMessage</code> command into a <code>PostSessionMessage</code> command which also includes the screen name. Such a wrapper Actor can be created by using the <code>spawnAdapter</code> method on the <code>ActorContext</code>, so that we can then go on to reply to the client with the <code>SessionGranted</code> result.</p>
<p>The behavior that we declare here can handle both subtypes of <code>Command</code>. <code>GetSession</code> has been explained already and the <code>PostSessionMessage</code> commands coming from the wrapper Actors will trigger the dissemination of the contained chat room message to all connected clients. But we do not want to give the ability to send <code>PostSessionMessage</code> commands to arbitrary clients, we reserve that right to the wrappers we create—otherwise clients could pose as completely different screen names (imagine the <code>GetSession</code> protocol to include authentication information to further secure this). Therefore <code>PostSessionMessage</code> has <code>private</code> visibility and can&rsquo;t be created outside the actor.</p>
<p>If we did not care about securing the correspondence between a session and a screen name then we could change the protocol such that <code>PostMessage</code> is removed and all clients just get an <span class="group-scala"><code>ActorRef[PostSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PostSessionMessage&gt;</code></span> to send to. In this case no wrapper would be needed and we could just use <span class="group-scala"><code>ctx.self</code></span><span class="group-java"><code>ctx.getSelf()</code></span>. The type-checks work out in that case because <span class="group-scala"><code>ActorRef[-T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> is contravariant in its type parameter, meaning that we can use a <span class="group-scala"><code>ActorRef[Command]</code></span><span class="group-java"><code>ActorRef&lt;Command&gt;</code></span> wherever an <span class="group-scala"><code>ActorRef[PostSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PostSessionMessage&gt;</code></span> is needed—this makes sense because the former simply speaks more languages than the latter. The opposite would be problematic, so passing an <span class="group-scala"><code>ActorRef[PostSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PostSessionMessage&gt;</code></span> where <span class="group-scala"><code>ActorRef[Command]</code></span><span class="group-java"><code>ActorRef&lt;Command&gt;</code></span> is required will lead to a type error.</p>
<h3><a href="#trying-it-out" name="trying-it-out" class="anchor"><span class="anchor-link"></span></a>Trying it out</h3>
<p>In order to see this chat room in action we need to write a client Actor that can use it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import ChatRoom._

val gabbler =
  Actor.immutable[SessionEvent] { (_, msg) ⇒
    msg match {
      case SessionGranted(handle) ⇒
        handle ! PostMessage(&quot;Hello World!&quot;)
        Actor.same
      case MessagePosted(screenName, message) ⇒
        println(s&quot;message has been posted by &#39;$screenName&#39;: $message&quot;)
        Actor.stopped
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static abstract class Gabbler {
  private Gabbler() {
  }

  public static Behavior&lt;ChatRoom.SessionEvent&gt; behavior() {
    return Actor.immutable(ChatRoom.SessionEvent.class)
      .onMessage(ChatRoom.SessionDenied.class, (ctx, msg) -&gt; {
        System.out.println(&quot;cannot start chat room session: &quot; + msg.reason);
        return Actor.stopped();
      })
      .onMessage(ChatRoom.SessionGranted.class, (ctx, msg) -&gt; {
        msg.handle.tell(new ChatRoom.PostMessage(&quot;Hello World!&quot;));
        return Actor.same();
      })
      .onMessage(ChatRoom.MessagePosted.class, (ctx, msg) -&gt; {
        System.out.println(&quot;message has been posted by &#39;&quot; +
          msg.screenName +&quot;&#39;: &quot; + msg.message);
        return Actor.stopped();
      })
      .build();
  }

}</code></pre></dd>
</dl>
<p>From this behavior we can create an Actor that will accept a chat room session, post a message, wait to see it published, and then terminate. The last step requires the ability to change behavior, we need to transition from the normal running behavior into the terminated state. This is why here we do not return <code>same</code>, as above, but another special value <code>stopped</code>.</p><div class="group-scala">
<p>Since <code>SessionEvent</code> is a sealed trait the Scala compiler will warn us if we forget to handle one of the subtypes; in this case it reminded us that alternatively to <code>SessionGranted</code> we may also receive a <code>SessionDenied</code> event.</p></div>
<p>Now to try things out we must start both a chat room and a gabbler and of course we do this inside an Actor system. Since there can be only one guardian supervisor we could either start the chat room from the gabbler (which we don’t want—it complicates its logic) or the gabbler from the chat room (which is nonsensical) or we start both of them from a third Actor—our only sensible choice:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val main: Behavior[akka.NotUsed] =
  Actor.deferred { ctx ⇒
    val chatRoom = ctx.spawn(ChatRoom.behavior, &quot;chatroom&quot;)
    val gabblerRef = ctx.spawn(gabbler, &quot;gabbler&quot;)
    ctx.watch(gabblerRef)
    chatRoom ! GetSession(&quot;ol’ Gabbler&quot;, gabblerRef)

    Actor.immutable[akka.NotUsed] {
      (_, _) ⇒ Actor.unhandled
    } onSignal {
      case (ctx, Terminated(ref)) ⇒
        Actor.stopped
    }
  }

val system = ActorSystem(main, &quot;ChatRoomDemo&quot;)
Await.result(system.whenTerminated, 3.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Behavior&lt;Void&gt; main = Actor.deferred(ctx -&gt; {
  ActorRef&lt;ChatRoom.Command&gt; chatRoom =
    ctx.spawn(ChatRoom.behavior(), &quot;chatRoom&quot;);
  ActorRef&lt;ChatRoom.SessionEvent&gt; gabbler =
      ctx.spawn(Gabbler.behavior(), &quot;gabbler&quot;);
  ctx.watch(gabbler);
  chatRoom.tell(new ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabbler));

  return Actor.immutable(Void.class)
    .onSignal(Terminated.class, (c, sig) -&gt; Actor.stopped())
    .build();
});

final ActorSystem&lt;Void&gt; system =
  ActorSystem.create(main, &quot;ChatRoomDemo&quot;);

Await.result(system.whenTerminated(), Duration.create(3, TimeUnit.SECONDS));</code></pre></dd>
</dl>
<p>In good tradition we call the <code>main</code> Actor what it is, it directly corresponds to the <code>main</code> method in a traditional Java application. This Actor will perform its job on its own accord, we do not need to send messages from the outside, so we declare it to be of type <span class="group-scala"><code>NotUsed</code></span><span class="group-java"><code>Void</code></span>. Actors receive not only external messages, they also are notified of certain system events, so-called Signals. In order to get access to those we choose to implement this particular one using the <code>immutable</code> behavior decorator. The provided <code>onSignal</code> function will be invoked for signals (subclasses of <code>Signal</code>) or the <code>onMessage</code> function for user messages.</p>
<p>This particular <code>main</code> Actor is created using <code>Actor.deferred</code>, which is like a factory for a behavior. Creation of the behavior instance is deferred until the actor is started, as opposed to <code>Actor.immutable</code> that creates the behavior instance immediately before the actor is running. The factory function in <code>deferred</code> pass the <code>ActorContext</code> as parameter and that can for example be used for spawning child actors. This <code>main</code> Actor creates the chat room and the gabbler and the session between them is initiated, and when the gabbler is finished we will receive the <code>Terminated</code> event due to having called <code>ctx.watch</code> for it. This allows us to shut down the Actor system: when the main Actor terminates there is nothing more to do.</p>
<p>Therefore after creating the Actor system with the <code>main</code> Actor’s <code>Behavior</code> we just await its termination.</p>
<h2><a href="#status-of-this-project-and-relation-to-akka-actors" name="status-of-this-project-and-relation-to-akka-actors" class="anchor"><span class="anchor-link"></span></a>Status of this Project and Relation to Akka Actors</h2>
<p>Akka Typed is the result of many years of research and previous attempts (including Typed Channels in the 2.2.x series) and it is on its way to stabilization, but maturing such a profound change to the core concept of Akka will take a long time. We expect that this module will stay marked <a href="common/may-change.html">may change</a> for multiple major releases of Akka and the plain <code>akka.actor.Actor</code> will not be deprecated or go away anytime soon.</p>
<p>Being a research project also entails that the reference documentation is not as detailed as it will be for a final version, please refer to the API documentation for greater depth and finer detail.</p>
<h3><a href="#main-differences" name="main-differences" class="anchor"><span class="anchor-link"></span></a>Main Differences</h3>
<p>The most prominent difference is the removal of the <code>sender()</code> functionality. This turned out to be the Achilles heel of the Typed Channels project, it is the feature that makes its type signatures and macros too complex to be viable. The solution chosen in Akka Typed is to explicitly include the properly typed reply-to address in the message, which both burdens the user with this task but also places this aspect of protocol design where it belongs.</p>
<p>The other prominent difference is the removal of the <code>Actor</code> trait. In order to avoid closing over unstable references from different execution contexts (e.g. Future transformations) we turned all remaining methods that were on this trait into messages: the behavior receives the <code>ActorContext</code> as an argument during processing and the lifecycle hooks have been converted into Signals.</p>
<p>A side-effect of this is that behaviors can now be tested in isolation without having to be packaged into an Actor, tests can run fully synchronously without having to worry about timeouts and spurious failures. Another side-effect is that behaviors can nicely be composed and decorated, see <code>tap</code>, or <span class="group-scala"><code>widen</code></span><span class="group-java"><code>widened</code></span> combinators; nothing about these is special or internal, new combinators can be written as external libraries or tailor-made for each project.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="actors.html"><i class="icon-prev"></i> <span class="link-prev">Actors</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="fault-tolerance.html">Fault Tolerance <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="https://github.com/johanandren/akka/tree/master/akka-docs/src/main/paradox/typed.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
