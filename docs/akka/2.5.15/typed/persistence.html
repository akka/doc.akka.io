<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Persistence &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/typed/persistence.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.15
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html#persistence" class="active page">Persistence</a>
    <ul>
      <li><a href="../typed/persistence.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/persistence.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/persistence.html#example" class="header">Example</a></li>
      <li><a href="../typed/persistence.html#basic-example" class="header">Basic example</a></li>
      <li><a href="../typed/persistence.html#larger-example" class="header">Larger example</a></li>
      <li><a href="../typed/persistence.html#effects-and-side-effects" class="header">Effects and Side Effects</a></li>
      <li><a href="../typed/persistence.html#serialization" class="header">Serialization</a></li>
      <li><a href="../typed/persistence.html#recovery" class="header">Recovery</a></li>
      <li><a href="../typed/persistence.html#tagging" class="header">Tagging</a></li>
      <li><a href="../typed/persistence.html#event-adapters" class="header">Event adapters</a></li>
      <li><a href="../typed/persistence.html#wrapping-persistent-behaviors" class="header">Wrapping Persistent Behaviors</a></li>
      <li><a href="../typed/persistence.html#journal-failures" class="header">Journal failures</a></li>
      <li><a href="../typed/persistence.html#journal-rejections" class="header">Journal rejections</a></li>
    </ul></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.15
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html#persistence" class="active page">Persistence</a>
    <ul>
      <li><a href="../typed/persistence.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/persistence.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/persistence.html#example" class="header">Example</a></li>
      <li><a href="../typed/persistence.html#basic-example" class="header">Basic example</a></li>
      <li><a href="../typed/persistence.html#larger-example" class="header">Larger example</a></li>
      <li><a href="../typed/persistence.html#effects-and-side-effects" class="header">Effects and Side Effects</a></li>
      <li><a href="../typed/persistence.html#serialization" class="header">Serialization</a></li>
      <li><a href="../typed/persistence.html#recovery" class="header">Recovery</a></li>
      <li><a href="../typed/persistence.html#tagging" class="header">Tagging</a></li>
      <li><a href="../typed/persistence.html#event-adapters" class="header">Event adapters</a></li>
      <li><a href="../typed/persistence.html#wrapping-persistent-behaviors" class="header">Wrapping Persistent Behaviors</a></li>
      <li><a href="../typed/persistence.html#journal-failures" class="header">Journal failures</a></li>
      <li><a href="../typed/persistence.html#journal-rejections" class="header">Journal rejections</a></li>
    </ul></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#persistence" name="persistence" class="anchor"><span class="anchor-link"></span></a>Persistence</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Persistence Typed, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-persistence-typed" % "2.5.15"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-persistence-typed_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5.15&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-persistence-typed_2.12', version: '2.5.15'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Akka Persistence is a library for building event sourced actors. For background about how it works see the <a href="../persistence.html">untyped Akka Persistence section</a>. This documentation shows how the typed API for persistence works and assumes you know what is meant by <code>Command</code>, <code>Event</code> and <code>State</code>.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="../common/may-change.html">may change</a> in the sense  of being the subject of active research. This means that API or semantics can  change without warning or deprecation period and it is not recommended to use  this module in production just yet—you have been warned.</p></div>
<h2><a href="#example" name="example" class="anchor"><span class="anchor-link"></span></a>Example</h2>
<p>Let&rsquo;s start with a simple example. The minimum required for a <code>PersistentBehavior</code> is:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait Command
sealed trait Event
case class State()

val behavior: Behavior[Command] =
  PersistentBehaviors.receive[Command, Event, State](
    persistenceId = &quot;abc&quot;,
    emptyState = State(),
    commandHandler =
      (ctx, state, cmd) ⇒
        throw new RuntimeException(&quot;TODO: process the command &amp; return an Effect&quot;),
    eventHandler =
      (state, evt) ⇒
        throw new RuntimeException(&quot;TODO: process the event return the next state&quot;)
  )</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/BasicPersistentBehaviorsCompileOnly.scala#L17-L31">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public interface Command {}
public interface Event {}
public static class State {}

public static class MyPersistentBehavior extends PersistentBehavior&lt;Command, Event, State&gt; {
  public MyPersistentBehavior(String persistenceId) {
    super(persistenceId, SupervisorStrategy.restartWithBackoff(Duration.ofSeconds(10), Duration.ofSeconds(30), 0.2));
  }

  @Override
  public State emptyState() {
    return new State();
  }

  @Override
  public CommandHandler&lt;Command, Event, State&gt; commandHandler() {
    return (state, command) -&gt; {
      throw new RuntimeException(&quot;TODO: process the command &amp; return an Effect&quot;);
    };
  }

  @Override
  public EventHandler&lt;State, Event&gt;  eventHandler() {
    return (state, event) -&gt; {
      throw new RuntimeException(&quot;TODO: process the event return the next state&quot;);
    };
  }

  @Override
  public void onRecoveryCompleted(State state) {
    throw new RuntimeException(&quot;TODO: add some end-of-recovery side-effect here&quot;);
  }

  @Override
  public Set&lt;String&gt; tagsFor(Event event) {
    throw new RuntimeException(&quot;TODO: inspect the event and return any tags it should have&quot;);
  }
}

static PersistentBehavior&lt;Command, Event, State&gt; persistentBehavior = new MyPersistentBehavior(&quot;pid&quot;);</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/BasicPersistentBehaviorsTest.java#L22-L67">Full source at GitHub</a></dd>
</dl>
<p>The first important thing to notice is the <code>Behavior</code> of a persistent actor is typed to the type of the <code>Command</code> because this is the type of message a persistent actor should receive. In Akka Typed this is now enforced by the type system. The event and state are only used internally.</p>
<p>The components that make up a PersistentBehavior are:</p>
<ul>
  <li><code>persistenceId</code> is the stable unique identifier for the persistent actor.</li>
  <li><code>emptyState</code> defines the <code>State</code> when the entity is first created e.g. a Counter would start with 0 as state.</li>
  <li><code>commandHandler</code> defines how to handle command by producing Effects e.g. persisting events, stopping the persistent actor.</li>
  <li><code>eventHandler</code> returns the new state given the current state when an event has been persisted.</li>
</ul>
<p>Next we&rsquo;ll discuss each of these in detail.</p>
<h3><a href="#command-handler" name="command-handler" class="anchor"><span class="anchor-link"></span></a>Command handler</h3>
<p>The command handler is a function with <span class="group-java">2 parameters for</span><span class="group-scala">3 parameters for the <code>ActorContext</code>,</span> current <code>State</code> and <code>Command</code>.</p>
<p>A command handler returns an <code>Effect</code> directive that defines what event or events, if any, to persist. Effects are created using <span class="group-java">a factory that is returned via the <code>Effect()</code> method</span> <span class="group-scala">the <code>Effect</code> factory</span> and can be one of: </p>
<ul>
  <li><code>persist</code> will persist one single event or several events atomically, i.e. all events  are stored or none of them are stored if there is an error</li>
  <li><code>none</code> no events are to be persisted, for example a read-only command</li>
  <li><code>unhandled</code> the command is unhandled (not supported) in current state</li>
  <li><code>stop</code> stop this actor</li>
</ul>
<p>In addition to returning the primary <code>Effect</code> for the command <code>PersistentBehavior</code>s can also chain side effects (<code>SideEffect</code>s) are to be performed after successful persist which is achieved with the <code>andThen</code> and <code>thenRun</code> function e.g <span class="group-scala"><code>Effect.persist(..).andThen</code></span><span class="group-java"><code>Effect().persist(..).andThen</code></span>. The <code>thenRun</code> function is a convenience around creating a <code>SideEffect</code>.</p>
<p>In the example below a reply is sent to the <code>replyTo</code> ActorRef. Note that the new state after applying the event is passed as parameter to the <code>thenRun</code> function. All <code>thenRun</code> registered callbacks are executed sequentially after successful execution of the persist statement (or immediately, in case of <code>none</code> and <code>unhandled</code>).</p>
<h3><a href="#event-handler" name="event-handler" class="anchor"><span class="anchor-link"></span></a>Event handler</h3>
<p>When an event has been persisted successfully the new state is created by applying the event to the current state with the <code>eventHandler</code>.</p>
<p>The event handler returns the new state, which must be immutable so you return a new instance of the state. The same event handler is also used when the entity is started up to recover its state from the stored events.</p>
<p>It is not recommended to perform side effects in the event handler, as those are also executed during recovery of an persistent actor</p>
<h2><a href="#basic-example" name="basic-example" class="anchor"><span class="anchor-link"></span></a>Basic example</h2>
<p>Command and event:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait SimpleCommand
case class Cmd(data: String) extends SimpleCommand

sealed trait SimpleEvent
case class Evt(data: String) extends SimpleEvent</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentActorCompileOnlyTest.scala#L21-L25">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static class SimpleCommand {
  public final String data;

  public SimpleCommand(String data) {
    this.data = data;
  }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L50-L56">Full source at GitHub</a></dd>
</dl>
<p>State is a List containing all the events:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">case class ExampleState(events: List[String] = Nil)</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentActorCompileOnlyTest.scala#L29">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">static class SimpleState {
  private final List&lt;String&gt; events;

  SimpleState(List&lt;String&gt; events) {
    this.events = events;
  }

  SimpleState() {
    this.events = new ArrayList&lt;&gt;();
  }


  SimpleState addEvent(SimpleEvent event) {
    List&lt;String&gt; newEvents = new ArrayList&lt;&gt;(events);
    newEvents.add(event.data);
    return new SimpleState(newEvents);
  }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L70-L87">Full source at GitHub</a></dd>
</dl>
<p>The command handler persists the <code>Cmd</code> payload in an <code>Evt</code><span class="group-java">. In this simple example the command handler is defined using a lambda, for the more complicated example below a <code>CommandHandlerBuilder</code> is used</span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val commandHandler: CommandHandler[SimpleCommand, SimpleEvent, ExampleState] =
  CommandHandler.command {
    case Cmd(data) ⇒ Effect.persist(Evt(data))
  }</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentActorCompileOnlyTest.scala#L33-L36">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Override
public CommandHandler&lt;SimpleCommand, SimpleEvent, SimpleState&gt; commandHandler() {
  return (state, cmd) -&gt; Effect().persist(new SimpleEvent(cmd.data));
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L99-L102">Full source at GitHub</a></dd>
</dl>
<p>The event handler appends the event to the state. This is called after successfully persisting the event in the database <span class="group-java">. As with the command handler the event handler is defined using a lambda, see below for a more complicated example using the <code>EventHandlerBuilder</code></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventHandler: (ExampleState, SimpleEvent) ⇒ ExampleState = {
  case (state, Evt(data)) ⇒ state.copy(data :: state.events)
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentActorCompileOnlyTest.scala#L40-L42">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Override
public EventHandler&lt;SimpleState, SimpleEvent&gt; eventHandler() {
  return (state, event) -&gt; state.addEvent(event);
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L106-L109">Full source at GitHub</a></dd>
</dl>
<p>These are used to create a <code>PersistentBehavior</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val simpleBehavior: PersistentBehavior[SimpleCommand, SimpleEvent, ExampleState] =
  PersistentBehaviors.receive[SimpleCommand, SimpleEvent, ExampleState](
    persistenceId = &quot;sample-id-1&quot;,
    emptyState = ExampleState(Nil),
    commandHandler = commandHandler,
    eventHandler = eventHandler)</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentActorCompileOnlyTest.scala#L46-L51">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static PersistentBehavior&lt;SimpleCommand, SimpleEvent, SimpleState&gt; pb = new PersistentBehavior&lt;SimpleCommand, SimpleEvent, SimpleState&gt;(&quot;p1&quot;) {
  @Override
  public SimpleState emptyState() {
    return new SimpleState();
  }

  @Override
  public CommandHandler&lt;SimpleCommand, SimpleEvent, SimpleState&gt; commandHandler() {
    return (state, cmd) -&gt; Effect().persist(new SimpleEvent(cmd.data));
  }

  @Override
  public EventHandler&lt;SimpleState, SimpleEvent&gt; eventHandler() {
    return (state, event) -&gt; state.addEvent(event);
  }

  @Override
  public EventAdapter&lt;SimpleEvent, Wrapper&lt;SimpleEvent&gt;&gt; eventAdapter() {
    return new EventAdapterExample();
  }
};
</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L92-L119">Full source at GitHub</a></dd>
</dl>
<p>The <code>PersistentBehavior</code> can then be run as with any plain typed actor as described in <a href="actors-typed.md">typed actors documentation</a>.</p>
<p><span class="group-java">The <code>ActorContext</code> can be obtained with <code>Behaviors.setup</code> and be passed as a constructor parameter.</span></p>
<h2><a href="#larger-example" name="larger-example" class="anchor"><span class="anchor-link"></span></a>Larger example</h2>
<p>After processing a message, plain typed actors are able to return the <code>Behavior</code> that is used for next message.</p>
<p>As you can see in the above examples this is not supported by typed persistent actors. Instead, the state is returned by <code>eventHandler</code>. The reason a new behavior can&rsquo;t be returned is that behavior is part of the actor&rsquo;s state and must also carefully be reconstructed during recovery. If it would have been supported it would mean that the behavior must be restored when replaying events and also encoded in the state anyway when snapshots are used. That would be very prone to mistakes and thus not allowed in Typed Persistence.</p>
<p>For basic actors you can use the same set of command handlers independent of what state the entity is in, as shown in above example. For more complex actors it&rsquo;s useful to be able to change the behavior in the sense that different functions for processing commands may be defined depending on what state the actor is in. This is useful when implementing finite state machine (FSM) like entities.</p>
<p>The next example shows how to define different behavior based on the current <code>State</code>. It is an actor that represents the state of a blog post. Before a post is started the only command it can process is to <code>AddPost</code>. Once it is started then it we can look it up with <code>GetPost</code>, modify it with <code>ChangeBody</code> or publish it with <code>Publish</code>.</p>
<p>The state is captured by:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object BlogState {
  val empty = BlogState(None, published = false)
}

final case class BlogState(content: Option[PostContent], published: Boolean) {
  def withContent(newContent: PostContent): BlogState =
    copy(content = Some(newContent))
  def isEmpty: Boolean = content.isEmpty
  def postId: String = content match {
    case Some(c) ⇒ c.postId
    case None    ⇒ throw new IllegalStateException(&quot;postId unknown before post is created&quot;)
  }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/InDepthPersistentBehaviorSpec.scala#L29-L41">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">interface BlogState {}

public static class BlankState implements BlogState {}

public static class DraftState implements BlogState {
  final PostContent postContent;
  final boolean published;

  DraftState(PostContent postContent, boolean published) {
    this.postContent = postContent;
    this.published = published;
  }

  public DraftState withContent(PostContent newContent) {
    return new DraftState(newContent, this.published);
  }

  public String postId() {
    return postContent.postId;
  }
}

public static class PublishedState implements BlogState {
  final PostContent postContent;

  PublishedState(PostContent postContent) {
    this.postContent = postContent;
  }

  public PublishedState withContent(PostContent newContent) {
    return new PublishedState(newContent);
  }

  public String postId() {
    return postContent.postId;
  }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/InDepthPersistentBehaviorTest.java#L54-L90">Full source at GitHub</a></dd>
</dl>
<p>The commands, of which only a subset are valid depending on the state:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait BlogCommand extends Serializable
final case class AddPost(content: PostContent, replyTo: ActorRef[AddPostDone]) extends BlogCommand
final case class AddPostDone(postId: String)
final case class GetPost(replyTo: ActorRef[PostContent]) extends BlogCommand
final case class ChangeBody(newBody: String, replyTo: ActorRef[Done]) extends BlogCommand
final case class Publish(replyTo: ActorRef[Done]) extends BlogCommand
final case object PassivatePost extends BlogCommand
final case class PostContent(postId: String, title: String, body: String)</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/InDepthPersistentBehaviorSpec.scala#L45-L52">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public interface BlogCommand {
}
public static class AddPost implements BlogCommand {
  final PostContent content;
  final ActorRef&lt;AddPostDone&gt; replyTo;

  public AddPost(PostContent content, ActorRef&lt;AddPostDone&gt; replyTo) {
    this.content = content;
    this.replyTo = replyTo;
  }
}
public static class AddPostDone implements BlogCommand {
  final String postId;

  public AddPostDone(String postId) {
    this.postId = postId;
  }
}
public static class GetPost implements BlogCommand {
  final ActorRef&lt;PostContent&gt; replyTo;

  public GetPost(ActorRef&lt;PostContent&gt; replyTo) {
    this.replyTo = replyTo;
  }
}
public static class ChangeBody implements BlogCommand {
  final String newBody;
  final ActorRef&lt;Done&gt; replyTo;

  public ChangeBody(String newBody, ActorRef&lt;Done&gt; replyTo) {
    this.newBody = newBody;
    this.replyTo = replyTo;
  }
}
public static class Publish implements BlogCommand {
  final ActorRef&lt;Done&gt; replyTo;

  public Publish(ActorRef&lt;Done&gt; replyTo) {
    this.replyTo = replyTo;
  }
}
public static class PassivatePost implements BlogCommand {

}
public static class PostContent implements BlogCommand {
  final String postId;
  final String title;
  final String body;

  public PostContent(String postId, String title, String body) {
    this.postId = postId;
    this.title = title;
    this.body = body;
  }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/InDepthPersistentBehaviorTest.java#L94-L148">Full source at GitHub</a></dd>
</dl>
<p><span class="group-java">The commandler handler to process each command is decided by the state class (or state predicate) that is given to the <code>commandHandlerBuilder</code> and the match cases in the builders. Several builders can be composed with <code>orElse</code>:</span> <span class="group-scala">The command handler to process each command is decided by a <code>CommandHandler.byState</code> command handler, which is a function from <code>State =&gt; CommandHandler</code>:</span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private val commandHandler: (ActorContext[BlogCommand], BlogState, BlogCommand) ⇒ Effect[BlogEvent, BlogState] =
  CommandHandler.byState {
    case state if state.isEmpty  ⇒ initial
    case state if !state.isEmpty ⇒ postAdded
  }</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/InDepthPersistentBehaviorSpec.scala#L98-L102">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Override
public CommandHandler&lt;BlogCommand, BlogEvent, BlogState&gt; commandHandler() {
  return
      initialCommandHandler()
          .orElse(draftCommandHandler())
          .orElse(publishedCommandHandler())
          .orElse(commonCommandHandler())
          .build();
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/InDepthPersistentBehaviorTest.java#L212-L220">Full source at GitHub</a></dd>
</dl>
<p>The <span class="group-java"><code>CommandHandlerBuilder</code></span><span class="group-scala"><code>CommandHandler</code></span> for a post that hasn&rsquo;t been initialized with content:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private val initial: (ActorContext[BlogCommand], BlogState, BlogCommand) ⇒ Effect[BlogEvent, BlogState] =
  (ctx, state, cmd) ⇒
    cmd match {
      case AddPost(content, replyTo) ⇒
        val evt = PostAdded(content.postId, content)
        Effect.persist(evt).thenRun { state2 ⇒
          // After persist is done additional side effects can be performed
          replyTo ! AddPostDone(content.postId)
        }
      case PassivatePost ⇒
        Effect.stop
      case _ ⇒
        Effect.unhandled
    }</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/InDepthPersistentBehaviorSpec.scala#L56-L69">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">private CommandHandlerBuilder&lt;BlogCommand, BlogEvent, BlankState, BlogState&gt; initialCommandHandler() {
  return commandHandlerBuilder(BlankState.class)
      .matchCommand(AddPost.class, (state, cmd) -&gt; {
        PostAdded event = new PostAdded(cmd.content.postId, cmd.content);
        return Effect().persist(event)
            .andThen(() -&gt; cmd.replyTo.tell(new AddPostDone(cmd.content.postId)));
      });
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/InDepthPersistentBehaviorTest.java#L163-L170">Full source at GitHub</a></dd>
</dl>
<p>And a different <span class="group-java"><code>CommandHandlerBuilder</code></span><span class="group-scala"><code>CommandHandler</code></span> for after the post content has been added:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private val postAdded: (ActorContext[BlogCommand], BlogState, BlogCommand) ⇒ Effect[BlogEvent, BlogState] = {
  (ctx, state, cmd) ⇒
    cmd match {
      case ChangeBody(newBody, replyTo) ⇒
        val evt = BodyChanged(state.postId, newBody)
        Effect.persist(evt).thenRun { _ ⇒
          replyTo ! Done
        }
      case Publish(replyTo) ⇒
        Effect.persist(Published(state.postId)).thenRun { _ ⇒
          println(s&quot;Blog post ${state.postId} was published&quot;)
          replyTo ! Done
        }
      case GetPost(replyTo) ⇒
        replyTo ! state.content.get
        Effect.none
      case _: AddPost ⇒
        Effect.unhandled
      case PassivatePost ⇒
        Effect.stop
    }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/InDepthPersistentBehaviorSpec.scala#L73-L94">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">private CommandHandlerBuilder&lt;BlogCommand, BlogEvent, DraftState, BlogState&gt; draftCommandHandler() {
  return commandHandlerBuilder(DraftState.class)
      .matchCommand(ChangeBody.class, (state, cmd) -&gt; {
        BodyChanged event = new BodyChanged(state.postId(), cmd.newBody);
        return Effect().persist(event).andThen(() -&gt; cmd.replyTo.tell(Done.getInstance()));
      })
      .matchCommand(Publish.class, (state, cmd) -&gt; Effect()
          .persist(new Published(state.postId())).andThen(() -&gt; {
            System.out.println(&quot;Blog post published: &quot; + state.postId());
            cmd.replyTo.tell(Done.getInstance());
          }))
      .matchCommand(GetPost.class, (state, cmd) -&gt; {
        cmd.replyTo.tell(state.postContent);
        return Effect().none();
      });
}

private CommandHandlerBuilder&lt;BlogCommand, BlogEvent, PublishedState, BlogState&gt; publishedCommandHandler() {
  return commandHandlerBuilder(PublishedState.class)
      .matchCommand(ChangeBody.class, (state, cmd) -&gt; {
        BodyChanged event = new BodyChanged(state.postId(), cmd.newBody);
        return Effect().persist(event).andThen(() -&gt; cmd.replyTo.tell(Done.getInstance()));
      })
      .matchCommand(GetPost.class, (state, cmd) -&gt; {
        cmd.replyTo.tell(state.postContent);
        return Effect().none();
      });
}

private CommandHandlerBuilder&lt;BlogCommand, BlogEvent, BlogState, BlogState&gt; commonCommandHandler() {
  return commandHandlerBuilder(BlogState.class)
      .matchCommand(AddPost.class, (state, cmd) -&gt; Effect().unhandled())
      .matchCommand(PassivatePost.class, (state, cmd) -&gt; Effect().stop());
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/InDepthPersistentBehaviorTest.java#L174-L207">Full source at GitHub</a></dd>
</dl>
<p>The event handler is always the same independent of state. The main reason for not making the event handler part of the <code>CommandHandler</code> is that contrary to Commands, all events must be handled and that is typically independent of what the current state is. The event handler can still decide what to do based on the state, if that is needed.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private val eventHandler: (BlogState, BlogEvent) ⇒ BlogState = { (state, event) ⇒
  event match {
    case PostAdded(postId, content) ⇒
      state.withContent(content)

    case BodyChanged(_, newBody) ⇒
      state.content match {
        case Some(c) ⇒ state.copy(content = Some(c.copy(body = newBody)))
        case None    ⇒ state
      }

    case Published(_) ⇒
      state.copy(published = true)
  }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/InDepthPersistentBehaviorSpec.scala#L106-L120">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Override
public EventHandler&lt;BlogState, BlogEvent&gt; eventHandler() {
  return eventHandlerBuilder()
      .matchEvent(PostAdded.class, (state, event) -&gt;
          new DraftState(event.content, false))
      .matchEvent(BodyChanged.class, DraftState.class, (state, chg) -&gt;
          state.withContent(new PostContent(state.postId(), state.postContent.title, chg.newBody)))
      .matchEvent(BodyChanged.class, PublishedState.class, (state, chg) -&gt;
          state.withContent(new PostContent(state.postId(), state.postContent.title, chg.newBody)))
      .matchEvent(Published.class, DraftState.class, (state, event) -&gt;
          new PublishedState(state.postContent))
      .build();
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/InDepthPersistentBehaviorTest.java#L224-L236">Full source at GitHub</a></dd>
</dl>
<p>And finally the behavior is created <span class="group-scala">from the <code>PersistentBehaviors.receive</code></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">def behavior(entityId: String): Behavior[BlogCommand] =
  PersistentBehaviors.receive[BlogCommand, BlogEvent, BlogState](
    persistenceId = &quot;Blog-&quot; + entityId,
    emptyState = BlogState.empty,
    commandHandler,
    eventHandler)</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/InDepthPersistentBehaviorSpec.scala#L124-L129">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static class BlogBehavior extends PersistentBehavior&lt;BlogCommand, BlogEvent, BlogState&gt; {
public static Behavior&lt;BlogCommand&gt; behavior(String entityId) {
  return Behaviors.setup(ctx -&gt;
      new BlogBehavior(&quot;Blog-&quot; + entityId, ctx)
  );
}

@Override
public BlogState emptyState() {
  return new BlankState();
}

// commandHandler, eventHandler as in above snippets
</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/InDepthPersistentBehaviorTest.java#L152-L252">Full source at GitHub</a></dd>
</dl>
<h2><a href="#effects-and-side-effects" name="effects-and-side-effects" class="anchor"><span class="anchor-link"></span></a>Effects and Side Effects</h2>
<p>Each command has a single <code>Effect</code> which can be:</p>
<ul>
  <li>Persist events</li>
  <li>None: Accept the comment but no effects</li>
  <li>Unhandled: Don&rsquo;t handle this message</li>
</ul>
<p>Note that there is only one of these. It is not possible to both persist and say none/unhandled. These are created using <span class="group-java">a factory that is returned via the <code>Effect()</code> method</span> <span class="group-scala">the <code>Effect</code> factory</span> and once created additional <code>SideEffects</code> can be added.</p>
<p>Most of them time this will be done with the <code>thenRun</code> method on the <code>Effect</code> above. It is also possible factor out common <code>SideEffect</code>s. For example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// Example factoring out a chained effect rather than using `andThen`
val commonChainedEffects = SideEffect[Mood](_ ⇒ println(&quot;Command processed&quot;))
// Then in a command handler:
Effect.persist(Remembered(&quot;Yep&quot;)) // persist event
  .andThen(commonChainedEffects) // add on common chained effect</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentActorCompileOnlyTest.scala#L346-L350">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// Factored out Chained effect
static final SideEffect&lt;ExampleState&gt;  commonChainedEffect = SideEffect.create(s -&gt; System.out.println(&quot;Command handled!&quot;));

return commandHandlerBuilder(ExampleState.class)
  .matchCommand(Cmd.class, (state, cmd) -&gt; Effect().persist(new Evt(cmd.data))
    .andThen(() -&gt; cmd.sender.tell(new Ack()))
    .andThen(commonChainedEffect)
  )
  .build();</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L154-L174">Full source at GitHub</a></dd>
</dl>
<h3><a href="#side-effects-ordering-and-guarantees" name="side-effects-ordering-and-guarantees" class="anchor"><span class="anchor-link"></span></a>Side effects ordering and guarantees</h3>
<p>Any <code>SideEffect</code>s are executed on an at-once basis and will not be executed if the persist fails. The <code>SideEffect</code>s are executed sequentially, it is not possible to execute <code>SideEffect</code>s in parallel.</p>
<h2><a href="#serialization" name="serialization" class="anchor"><span class="anchor-link"></span></a>Serialization</h2>
<p>The same <a href="../serialization.html">serialization</a> mechanism as for untyped actors is also used in Akka Typed, also for persistent actors. When picking serialization solution for the events you should also consider that it must be possible read old events when the application has evolved. Strategies for that can be found in the <a href="../persistence-schema-evolution.html">schema evolution</a>.</p>
<h2><a href="#recovery" name="recovery" class="anchor"><span class="anchor-link"></span></a>Recovery</h2>
<p>It is strongly discouraged to perform side effects in <code>applyEvent</code>, so side effects should be performed once recovery has completed <span class="group-scala">in the <code>onRecoveryCompleted</code> callback.</span> <span class="group-java">by overriding <code>onRecoveryCompleted</code></span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val recoveryBehavior: Behavior[Command] =
  PersistentBehaviors.receive[Command, Event, State](
    persistenceId = &quot;abc&quot;,
    emptyState = State(),
    commandHandler =
      (ctx, state, cmd) ⇒
        throw new RuntimeException(&quot;TODO: process the command &amp; return an Effect&quot;),
    eventHandler =
      (state, evt) ⇒
        throw new RuntimeException(&quot;TODO: process the event return the next state&quot;)
  ).onRecoveryCompleted { (ctx, state) ⇒
      throw new RuntimeException(&quot;TODO: add some end-of-recovery side-effect here&quot;)
    }</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/BasicPersistentBehaviorsCompileOnly.scala#L38-L50">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Override
public void onRecoveryCompleted(State state) {
  throw new RuntimeException(&quot;TODO: add some end-of-recovery side-effect here&quot;);
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/BasicPersistentBehaviorsTest.java#L53-L56">Full source at GitHub</a></dd>
</dl>
<p>The <code>onRecoveryCompleted</code> takes <span class="group-scala">an <code>ActorContext</code> and</span> the current <code>State</code>, and doesn&rsquo;t return anything.</p>
<h2><a href="#tagging" name="tagging" class="anchor"><span class="anchor-link"></span></a>Tagging</h2>
<p>Persistence typed allows you to use event tags without using <a href="../persistence.html#event-adapters"><code>EventAdapter</code></a>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val taggingBehavior: Behavior[Command] =
  PersistentBehaviors.receive[Command, Event, State](
    persistenceId = &quot;abc&quot;,
    emptyState = State(),
    commandHandler =
      (ctx, state, cmd) ⇒
        throw new RuntimeException(&quot;TODO: process the command &amp; return an Effect&quot;),
    eventHandler =
      (state, evt) ⇒
        throw new RuntimeException(&quot;TODO: process the event return the next state&quot;)
  ).withTagger(_ ⇒ Set(&quot;tag1&quot;, &quot;tag2&quot;))</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/BasicPersistentBehaviorsCompileOnly.scala#L54-L64">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Override
public Set&lt;String&gt; tagsFor(Event event) {
  throw new RuntimeException(&quot;TODO: inspect the event and return any tags it should have&quot;);
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/BasicPersistentBehaviorsTest.java#L60-L63">Full source at GitHub</a></dd>
</dl>
<h2><a href="#event-adapters" name="event-adapters" class="anchor"><span class="anchor-link"></span></a>Event adapters</h2>
<p>Event adapters can be programmatically added to your <code>PersistentBehavior</code>s that can convert from your <code>Event</code> type to another type that is then passed to the journal.</p>
<p>Defining an event adapter is done by extending an EventAdapter:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">case class Wrapper[T](t: T)
class WrapperEventAdapter[T] extends EventAdapter[T, Wrapper[T]] {
  override def toJournal(e: T): Wrapper[T] = Wrapper(e)
  override def fromJournal(p: Wrapper[T]): T = p.t
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentBehaviorSpec.scala#L34-L38">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static class Wrapper&lt;T&gt; {
  private final T t;
  public Wrapper(T t) {
    this.t = t;
  }
  public T getT() {
    return t;
  }
}

public static class EventAdapterExample extends EventAdapter&lt;SimpleEvent, Wrapper&lt;SimpleEvent&gt;&gt; {
  @Override
  public Wrapper&lt;SimpleEvent&gt; toJournal(SimpleEvent simpleEvent) {
    return new Wrapper&lt;&gt;(simpleEvent);
  }
  @Override
  public SimpleEvent fromJournal(Wrapper&lt;SimpleEvent&gt; simpleEventWrapper) {
    return simpleEventWrapper.getT();
  }
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L27-L46">Full source at GitHub</a></dd>
</dl>
<p>Then install it on a persistent behavior:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">persistentBehavior.eventAdapter(new WrapperEventAdapter[Event]))</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/akka/persistence/typed/scaladsl/PersistentBehaviorSpec.scala#L507">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Override
public EventAdapter&lt;SimpleEvent, Wrapper&lt;SimpleEvent&gt;&gt; eventAdapter() {
  return new EventAdapterExample();
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/akka/persistence/typed/javadsl/PersistentActorCompileOnlyTest.java#L113-L116">Full source at GitHub</a></dd>
</dl>
<h2><a href="#wrapping-persistent-behaviors" name="wrapping-persistent-behaviors" class="anchor"><span class="anchor-link"></span></a>Wrapping Persistent Behaviors</h2>
<p>When creating a <code>PersistentBehavior</code>, it is possible to wrap <code>PersistentBehavior</code> in other behaviors such as <code>Behaviors.setup</code> in order to access the <code>ActorContext</code> object. For instance to access the actor logging upon taking snapshots for debug purpose.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val samplePersistentBehavior = PersistentBehaviors.receive[Command, Event, State](
  persistenceId = &quot;abc&quot;,
  emptyState = State(),
  commandHandler =
    (ctx, state, cmd) ⇒
      throw new RuntimeException(&quot;TODO: process the command &amp; return an Effect&quot;),
  eventHandler =
    (state, evt) ⇒
      throw new RuntimeException(&quot;TODO: process the event return the next state&quot;)
).onRecoveryCompleted { (ctx, state) ⇒
    throw new RuntimeException(&quot;TODO: add some end-of-recovery side-effect here&quot;)
  }

val debugAlwaysSnapshot: Behavior[Command] = Behaviors.setup {
  context ⇒
    samplePersistentBehavior.snapshotWhen((state, _, _) ⇒ {
      context.log.info(
        &quot;Snapshot actor {} =&gt; state: {}&quot;,
        context.self.path.name, state)
      true
    })
}</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/BasicPersistentBehaviorsCompileOnly.scala#L68-L89">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">static Behavior&lt;Command&gt; debugAlwaysSnapshot = Behaviors.setup((context) -&gt; {
          return new MyPersistentBehavior(&quot;pid&quot;) {
            @Override
            public boolean shouldSnapshot(State state, Event event, long sequenceNr) {
              context.getLog().info(&quot;Snapshot actor {} =&gt; state: {}&quot;,
                      context.getSelf().path().name(), state);
              return true;
            }
          };
        }
);</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/BasicPersistentBehaviorsTest.java#L71-L81">Full source at GitHub</a></dd>
</dl>
<h2><a href="#journal-failures" name="journal-failures" class="anchor"><span class="anchor-link"></span></a>Journal failures</h2>
<p>By default a <code>PersistentBehavior</code> will stop if an exception is thrown from the journal. It is possible to override this with any <code>BackoffSupervisorStrategy</code>. It is not possible to use the normal supervision wrapping for this as it isn&rsquo;t valid to <code>resume</code> a behavior on a journal failure as it is not known if the event was persisted.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val supervisedBehavior = samplePersistentBehavior.onPersistFailure(
  SupervisorStrategy.restartWithBackoff(
    minBackoff = 10.seconds,
    maxBackoff = 60.seconds,
    randomFactor = 0.1
  ))</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/BasicPersistentBehaviorsCompileOnly.scala#L93-L98">Full source at GitHub</a></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static class MyPersistentBehavior extends PersistentBehavior&lt;Command, Event, State&gt; {
  public MyPersistentBehavior(String persistenceId) {
    super(persistenceId, SupervisorStrategy.restartWithBackoff(Duration.ofSeconds(10), Duration.ofSeconds(30), 0.2));
  }</code></pre><a href="https://github.com/akka/akka/tree/v2.5.15/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/BasicPersistentBehaviorsTest.java#L27-L30">Full source at GitHub</a></dd>
</dl>
<h2><a href="#journal-rejections" name="journal-rejections" class="anchor"><span class="anchor-link"></span></a>Journal rejections</h2>
<p>Journals can reject events. The difference from a failure is that the journal must decide to reject an event before trying to persist it e.g. because of a serialization exception. If an event is rejected it definitely won&rsquo;t be in the journal. This is signalled to a <code>PersistentBehavior</code> via a <code>EventRejectedException</code> and can be handled with a <a href="fault-tolerance.html">supervisor</a>. </p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/cluster-sharding.html"><i class="icon-prev"></i> <span class="link-prev">Cluster Sharding</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/fsm.html">Behaviors as Finite state machines <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/master/akka-docs/src/main/paradox/typed/persistence.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2018 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
