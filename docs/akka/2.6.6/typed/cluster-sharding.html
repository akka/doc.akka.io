<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Cluster Sharding &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Shard a clustered compute process across the network with locationally transparent message routing using Akka Cluster Sharding."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-7.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-1.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="../images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="../images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="../images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="../images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="../images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="../images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="../images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.6
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="../typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="../typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="../typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="../typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html#cluster-sharding" class="active page">Cluster Sharding</a>
    <ul>
      <li><a href="../typed/cluster-sharding.html#module-info" class="header">Module info</a></li>
      <li><a href="../typed/cluster-sharding.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/cluster-sharding.html#basic-example" class="header">Basic example</a></li>
      <li><a href="../typed/cluster-sharding.html#persistence-example" class="header">Persistence example</a></li>
      <li><a href="../typed/cluster-sharding.html#shard-allocation" class="header">Shard allocation</a></li>
      <li><a href="../typed/cluster-sharding.html#how-it-works" class="header">How it works</a></li>
      <li><a href="../typed/cluster-sharding.html#sharding-state-store-mode" class="header">Sharding State Store Mode</a></li>
      <li><a href="../typed/cluster-sharding.html#passivation" class="header">Passivation</a></li>
      <li><a href="../typed/cluster-sharding.html#remembering-entities" class="header">Remembering Entities</a></li>
      <li><a href="../typed/cluster-sharding.html#inspecting-cluster-sharding-state" class="header">Inspecting cluster sharding state</a></li>
      <li><a href="../typed/cluster-sharding.html#lease" class="header">Lease</a></li>
      <li><a href="../typed/cluster-sharding.html#removal-of-internal-cluster-sharding-data" class="header">Removal of internal Cluster Sharding data</a></li>
      <li><a href="../typed/cluster-sharding.html#configuration" class="header">Configuration</a></li>
      <li><a href="../typed/cluster-sharding.html#example-project" class="header">Example project</a></li>
    </ul></li>
    <li><a href="../typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="../typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="../typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="../typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="../typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="../serialization.html" class="page">Serialization</a></li>
    <li><a href="../serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="../multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="../multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="../remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="../remoting.html" class="page">Classic Remoting (Deprecated)</a></li>
    <li><a href="../split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="../coordination.html" class="page">Coordination</a></li>
    <li><a href="../typed/choosing-cluster.html" class="page">Choosing Akka Cluster</a></li>
  </ul></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.6
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="../typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="../typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="../typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="../typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html#cluster-sharding" class="active page">Cluster Sharding</a>
    <ul>
      <li><a href="../typed/cluster-sharding.html#module-info" class="header">Module info</a></li>
      <li><a href="../typed/cluster-sharding.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/cluster-sharding.html#basic-example" class="header">Basic example</a></li>
      <li><a href="../typed/cluster-sharding.html#persistence-example" class="header">Persistence example</a></li>
      <li><a href="../typed/cluster-sharding.html#shard-allocation" class="header">Shard allocation</a></li>
      <li><a href="../typed/cluster-sharding.html#how-it-works" class="header">How it works</a></li>
      <li><a href="../typed/cluster-sharding.html#sharding-state-store-mode" class="header">Sharding State Store Mode</a></li>
      <li><a href="../typed/cluster-sharding.html#passivation" class="header">Passivation</a></li>
      <li><a href="../typed/cluster-sharding.html#remembering-entities" class="header">Remembering Entities</a></li>
      <li><a href="../typed/cluster-sharding.html#inspecting-cluster-sharding-state" class="header">Inspecting cluster sharding state</a></li>
      <li><a href="../typed/cluster-sharding.html#lease" class="header">Lease</a></li>
      <li><a href="../typed/cluster-sharding.html#removal-of-internal-cluster-sharding-data" class="header">Removal of internal Cluster Sharding data</a></li>
      <li><a href="../typed/cluster-sharding.html#configuration" class="header">Configuration</a></li>
      <li><a href="../typed/cluster-sharding.html#example-project" class="header">Example project</a></li>
    </ul></li>
    <li><a href="../typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="../typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="../typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="../typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="../typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="../serialization.html" class="page">Serialization</a></li>
    <li><a href="../serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="../multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="../multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="../remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="../remoting.html" class="page">Classic Remoting (Deprecated)</a></li>
    <li><a href="../split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="../coordination.html" class="page">Coordination</a></li>
    <li><a href="../typed/choosing-cluster.html" class="page">Choosing Akka Cluster</a></li>
  </ul></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#cluster-sharding" name="cluster-sharding" class="anchor"><span class="anchor-link"></span></a>Cluster Sharding</h1>
<p>You are viewing the documentation for the new actor APIs, to view the Akka Classic documentation, see <a href="../cluster-sharding.html">Classic Cluster Sharding</a></p>
<h2><a href="#module-info" name="module-info" class="anchor"><span class="anchor-link"></span></a>Module info</h2>
<p>To use Akka Cluster Sharding, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-cluster-sharding-typed" % "2.6.6"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.12&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-cluster-sharding-typed_${scala.binary.version}&lt;/artifactId&gt;
  &lt;version&gt;2.6.6&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">versions += [
  ScalaBinary: "2.12"
]
dependencies {
  compile group: 'com.typesafe.akka', name: "akka-cluster-sharding-typed_${versions.ScalaBinary}", version: '2.6.6'
}</code></pre></dd></dl>
<table class="project-info">
<tr><th colspan="2">Project Info: Akka Cluster Sharding (typed)</th></tr>
  <tr><th>Artifact</th><td><div>com.typesafe.akka</div>
  <div>akka-cluster-sharding-typed</div>
  <div>2.6.6</div></td></tr>
  <tr><th>JDK versions</th><td><div>Adopt OpenJDK 8</div><div>Adopt OpenJDK 11</div></td></tr>
  <tr><th>Scala versions</th><td>2.12.11, 2.13.1</td></tr>
  <tr><th>JPMS module name</th><td>akka.cluster.sharding.typed</td></tr>
  <tr><th>License</th><td><div><a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache-2.0</a></div>
  </td></tr>
  <tr><th>Readiness level</th><td><div class="readiness-level"><a href="https://developer.lightbend.com/docs/introduction/getting-help/support-terminology.html#supported" target="_blank" rel="noopener">Supported</a>, <a href="https://www.lightbend.com/lightbend-subscription" target="_blank" rel="noopener">Lightbend Subscription</a> provides support</div>
  <div>Since 2.6.0, 2019-11-06</div>
  </td></tr>
  <tr><th>Home page</th><td><a href="https://akka.io/">https://akka.io/</a></td></tr>
  <tr><th>API documentation</th><td>
  <div><a href="https://doc.akka.io/api/akka/2.6.6/akka/cluster/sharding/typed/index.html" target="_blank" rel="noopener noreferrer">API (Scaladoc)</a></div>
  <div><a href="https://doc.akka.io/japi/akka/2.6.6/akka/cluster/sharding/typed/package-summary.html" target="_blank" rel="noopener noreferrer">API (Javadoc)</a></div>
  </td></tr>
  <tr><th>Forums</th><td>
  <div><a href="https://discuss.akka.io" target="_blank" rel="noopener noreferrer">Lightbend Discuss</a></div>
  <div><a href="https://gitter.im/akka/akka" target="_blank" rel="noopener noreferrer">akka/akka Gitter channel</a></div>
  </td></tr>
  <tr><th>Release notes</th><td><a href="https://akka.io/blog/news-archive.html">akka.io blog</a></td></tr>
  <tr><th>Issues</th><td><a href="https://github.com/akka/akka/issues" target="_blank" rel="noopener noreferrer">Github issues</a></td></tr>
  <tr><th>Sources</th><td><a href="https://github.com/akka/akka" target="_blank" rel="noopener noreferrer">https://github.com/akka/akka</a></td></tr>
</table>

<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>

<p>Cluster sharding is useful when you need to distribute actors across several nodes in the cluster and want to be able to interact with them using their logical identifier, but without having to care about their physical location in the cluster, which might also change over time.</p>

<p>It could for example be actors representing Aggregate Roots in Domain-Driven Design terminology. Here we call these actors &ldquo;entities&rdquo;. These actors typically have persistent (durable) state, but this feature is not limited to actors with persistent state.</p>

<p>The <a href="https://akka.io/blog/news/2019/12/16/akka-cluster-sharding-intro-video">Introduction to Akka Cluster Sharding video</a> is a good starting point for learning Cluster Sharding.</p>

<p>Cluster sharding is typically used when you have many stateful actors that together consume more resources (e.g. memory) than fit on one machine. If you only have a few stateful actors it might be easier to run them on a <a href="cluster-singleton.html">Cluster Singleton</a> node. </p>

<p>In this context sharding means that actors with an identifier, so called entities, can be automatically distributed across multiple nodes in the cluster. Each entity actor runs only at one place, and messages can be sent to the entity without requiring the sender to know the location of the destination actor. This is achieved by sending the messages via a <code>ShardRegion</code> actor provided by this extension, which knows how to route the message with the entity id to the final destination.</p>

<p>Cluster sharding will not be active on members with status <a href="cluster-membership.html#weaklyup-members">WeaklyUp</a> if that feature is enabled.</p>
<div class="callout warning "><div class="callout-title">Warning</div>
<p>Make sure to not use a Cluster downing strategy that may split the cluster into several separate clusters in case of network problems or system overload (long GC pauses), since that will result in <em>multiple shards and entities</em> being started, one in each separate cluster! See <a href="cluster.html#downing">Downing</a>.</p></div>
<h2><a href="#basic-example" name="basic-example" class="anchor"><span class="anchor-link"></span></a>Basic example</h2>
<p>Sharding is accessed via the <code>ClusterSharding</code> extension</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L28-L33" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.cluster.sharding.typed.ShardingEnvelope
import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import akka.cluster.sharding.typed.scaladsl.EntityTypeKey
import akka.cluster.sharding.typed.scaladsl.EntityRef

val sharding = ClusterSharding(system)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L18-L24" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.cluster.sharding.typed.ShardingEnvelope;
import akka.cluster.sharding.typed.javadsl.ClusterSharding;
import akka.cluster.sharding.typed.javadsl.EntityTypeKey;
import akka.cluster.sharding.typed.javadsl.EntityRef;
import akka.cluster.sharding.typed.javadsl.Entity;
import akka.persistence.typed.PersistenceId;

ClusterSharding sharding = ClusterSharding.get(system);</code></pre></dd>
</dl>
<p>It is common for sharding to be used with persistence however any <code>Behavior</code> can be used with sharding e.g. a basic counter:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L37-L56" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class GetValue(replyTo: ActorRef[Int]) extends Command

  def apply(entityId: String): Behavior[Command] = {
    def updated(value: Int): Behavior[Command] = {
      Behaviors.receiveMessage[Command] {
        case Increment =&gt;
          updated(value + 1)
        case GetValue(replyTo) =&gt;
          replyTo ! value
          Behaviors.same
      }
    }

    updated(0)

  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L43-L88" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Counter extends AbstractBehavior&lt;Counter.Command&gt; {

  public interface Command {}

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    private final ActorRef&lt;Integer&gt; replyTo;

    public GetValue(ActorRef&lt;Integer&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static Behavior&lt;Command&gt; create(String entityId) {
    return Behaviors.setup(context -&gt; new Counter(context, entityId));
  }

  private final String entityId;
  private int value = 0;

  private Counter(ActorContext&lt;Command&gt; context, String entityId) {
    super(context);
    this.entityId = entityId;
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Increment.class, msg -&gt; onIncrement())
        .onMessage(GetValue.class, this::onGetValue)
        .build();
  }

  private Behavior&lt;Command&gt; onIncrement() {
    value++;
    return this;
  }

  private Behavior&lt;Command&gt; onGetValue(GetValue msg) {
    msg.replyTo.tell(value);
    return this;
  }
}</code></pre></dd>
</dl>
<p>Each Entity type has a key that is then used to retrieve an EntityRef for a given entity identifier. Note in the sample&rsquo;s <span class="group-scala"><code>Counter.apply</code></span><span class="group-java"><code>Counter.create</code></span> function that the <code>entityId</code> parameter is not called, it is included to demonstrate how one can pass it to an entity. Another way to do this is by sending the <code>entityId</code> as part of the message if needed.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L60-L63" target="_blank" title="Go to snippet source"></a><code class="language-scala">val TypeKey = EntityTypeKey[Counter.Command](&quot;Counter&quot;)

val shardRegion: ActorRef[ShardingEnvelope[Counter.Command]] =
  sharding.init(Entity(TypeKey)(createBehavior = entityContext =&gt; Counter(entityContext.entityId)))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L195-L198" target="_blank" title="Go to snippet source"></a><code class="language-java">EntityTypeKey&lt;Counter.Command&gt; typeKey = EntityTypeKey.create(Counter.Command.class, &quot;Counter&quot;);

ActorRef&lt;ShardingEnvelope&lt;Counter.Command&gt;&gt; shardRegion =
    sharding.init(Entity.of(typeKey, ctx -&gt; Counter.create(ctx.getEntityId())));</code></pre></dd>
</dl>
<p>Messages to a specific entity are then sent via an <code>EntityRef</code>. It is also possible to wrap methods in a <code>ShardingEnvelope</code> or define extractor functions and send messages directly to the shard region.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L67-L72" target="_blank" title="Go to snippet source"></a><code class="language-scala">// With an EntityRef
val counterOne: EntityRef[Counter.Command] = sharding.entityRefFor(TypeKey, &quot;counter-1&quot;)
counterOne ! Counter.Increment

// Entity id is specified via an `ShardingEnvelope`
shardRegion ! ShardingEnvelope(&quot;counter-1&quot;, Counter.Increment)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L202-L205" target="_blank" title="Go to snippet source"></a><code class="language-java">EntityRef&lt;Counter.Command&gt; counterOne = sharding.entityRefFor(typeKey, &quot;counter-1&quot;);
counterOne.tell(Counter.Increment.INSTANCE);

shardRegion.tell(new ShardingEnvelope&lt;&gt;(&quot;counter-1&quot;, Counter.Increment.INSTANCE));</code></pre></dd>
</dl>
<p>Cluster sharding <code>init</code> should be called on every node for each entity type. Which nodes entity actors are created on can be controlled with <a href="cluster.html#node-roles">roles</a>. <code>init</code> will create a <code>ShardRegion</code> or a proxy depending on whether the node&rsquo;s role matches the entity&rsquo;s role. </p>
<p>Specifying the role:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L84-L85" target="_blank" title="Go to snippet source"></a><code class="language-scala">sharding.init(
  Entity(TypeKey)(createBehavior = entityContext =&gt; Counter(entityContext.entityId)).withRole(&quot;backend&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L214-L218" target="_blank" title="Go to snippet source"></a><code class="language-java">EntityTypeKey&lt;Counter.Command&gt; typeKey = EntityTypeKey.create(Counter.Command.class, &quot;Counter&quot;);

ActorRef&lt;ShardingEnvelope&lt;Counter.Command&gt;&gt; shardRegionOrProxy =
    sharding.init(
        Entity.of(typeKey, ctx -&gt; Counter.create(ctx.getEntityId())).withRole(&quot;backend&quot;));</code></pre></dd>
</dl>
<h2><a href="#persistence-example" name="persistence-example" class="anchor"><span class="anchor-link"></span></a>Persistence example</h2>
<p>When using sharding, entities can be moved to different nodes in the cluster. Persistence can be used to recover the state of an actor after it has moved.</p>
<p>Akka Persistence is based on the single-writer principle, for a particular <code>PersistenceId</code> only one persistent actor instance should be active. If multiple instances were to persist events at the same time, the events would be interleaved and might not be interpreted correctly on replay. Cluster Sharding is typically used together with persistence to ensure that there is only one active entity for each <code>PersistenceId</code> (<code>entityId</code>).</p>
<p>Here is an example of a persistent actor that is used as a sharded entity:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/HelloWorldPersistentEntityExample.scala#L46-L91" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.typed.Behavior
import akka.cluster.sharding.typed.scaladsl.EntityTypeKey
import akka.persistence.typed.scaladsl.Effect

object HelloWorld {

  // Command
  trait Command extends CborSerializable
  final case class Greet(whom: String)(val replyTo: ActorRef[Greeting]) extends Command
  // Response
  final case class Greeting(whom: String, numberOfPeople: Int) extends CborSerializable

  // Event
  final case class Greeted(whom: String) extends CborSerializable

  // State
  final case class KnownPeople(names: Set[String]) extends CborSerializable {
    def add(name: String): KnownPeople = copy(names = names + name)

    def numberOfPeople: Int = names.size
  }

  private val commandHandler: (KnownPeople, Command) =&gt; Effect[Greeted, KnownPeople] = { (_, cmd) =&gt;
    cmd match {
      case cmd: Greet =&gt; greet(cmd)
    }
  }

  private def greet(cmd: Greet): Effect[Greeted, KnownPeople] =
    Effect.persist(Greeted(cmd.whom)).thenRun(state =&gt; cmd.replyTo ! Greeting(cmd.whom, state.numberOfPeople))

  private val eventHandler: (KnownPeople, Greeted) =&gt; KnownPeople = { (state, evt) =&gt;
    state.add(evt.whom)
  }

  val TypeKey: EntityTypeKey[Command] =
    EntityTypeKey[Command](&quot;HelloWorld&quot;)

  def apply(entityId: String, persistenceId: PersistenceId): Behavior[Command] = {
    Behaviors.setup { context =&gt;
      context.log.info(&quot;Starting HelloWorld {}&quot;, entityId)
      EventSourcedBehavior(persistenceId, emptyState = KnownPeople(Set.empty), commandHandler, eventHandler)
    }
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/HelloWorldPersistentEntityExample.java#L18-L23" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.typed.javadsl.Behaviors;
import akka.cluster.sharding.typed.javadsl.EntityTypeKey;
import akka.persistence.typed.PersistenceId;
import akka.persistence.typed.javadsl.CommandHandler;
import akka.persistence.typed.javadsl.Effect;
import akka.persistence.typed.javadsl.EventHandler;

public static class HelloWorld
    extends EventSourcedBehavior&lt;HelloWorld.Command, HelloWorld.Greeted, HelloWorld.KnownPeople&gt; {

  // Command
  public interface Command extends CborSerializable {}

  public static final class Greet implements Command {
    public final String whom;
    public final ActorRef&lt;Greeting&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeting&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  // Response
  public static final class Greeting implements CborSerializable {
    public final String whom;
    public final int numberOfPeople;

    public Greeting(String whom, int numberOfPeople) {
      this.whom = whom;
      this.numberOfPeople = numberOfPeople;
    }
  }

  // Event
  public static final class Greeted implements CborSerializable {
    public final String whom;

    @JsonCreator
    public Greeted(String whom) {
      this.whom = whom;
    }
  }

  // State
  static final class KnownPeople implements CborSerializable {
    private Set&lt;String&gt; names = Collections.emptySet();

    KnownPeople() {}

    private KnownPeople(Set&lt;String&gt; names) {
      this.names = names;
    }

    KnownPeople add(String name) {
      Set&lt;String&gt; newNames = new HashSet&lt;&gt;(names);
      newNames.add(name);
      return new KnownPeople(newNames);
    }

    int numberOfPeople() {
      return names.size();
    }
  }

  public static final EntityTypeKey&lt;Command&gt; ENTITY_TYPE_KEY =
      EntityTypeKey.create(Command.class, &quot;HelloWorld&quot;);

  public static Behavior&lt;Command&gt; create(String entityId, PersistenceId persistenceId) {
    return Behaviors.setup(context -&gt; new HelloWorld(context, entityId, persistenceId));
  }

  private HelloWorld(
      ActorContext&lt;Command&gt; context, String entityId, PersistenceId persistenceId) {
    super(persistenceId);
    context.getLog().info(&quot;Starting HelloWorld {}&quot;, entityId);
  }

  @Override
  public KnownPeople emptyState() {
    return new KnownPeople();
  }

  @Override
  public CommandHandler&lt;Command, Greeted, KnownPeople&gt; commandHandler() {
    return newCommandHandlerBuilder().forAnyState().onCommand(Greet.class, this::greet).build();
  }

  private Effect&lt;Greeted, KnownPeople&gt; greet(KnownPeople state, Greet cmd) {
    return Effect()
        .persist(new Greeted(cmd.whom))
        .thenRun(newState -&gt; cmd.replyTo.tell(new Greeting(cmd.whom, newState.numberOfPeople())));
  }

  @Override
  public EventHandler&lt;KnownPeople, Greeted&gt; eventHandler() {
    return (state, evt) -&gt; state.add(evt.whom);
  }
}</code></pre></dd>
</dl>
<p>To initialize and use the entity:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/HelloWorldPersistentEntityExample.scala#L20-L42" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.cluster.sharding.typed.scaladsl.ClusterSharding
import akka.cluster.sharding.typed.scaladsl.Entity
import akka.util.Timeout

class HelloWorldService(system: ActorSystem[_]) {
  import system.executionContext

  private val sharding = ClusterSharding(system)

  // registration at startup
  sharding.init(Entity(typeKey = HelloWorld.TypeKey) { entityContext =&gt;
    HelloWorld(entityContext.entityId, PersistenceId(entityContext.entityTypeKey.name, entityContext.entityId))
  })

  private implicit val askTimeout: Timeout = Timeout(5.seconds)

  def greet(worldId: String, whom: String): Future[Int] = {
    val entityRef = sharding.entityRefFor(HelloWorld.TypeKey, worldId)
    val greeting = entityRef ? HelloWorld.Greet(whom)
    greeting.map(_.numberOfPeople)
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/HelloWorldPersistentEntityExample.java#L27-L33" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.cluster.sharding.typed.javadsl.ClusterSharding;
import akka.cluster.sharding.typed.javadsl.EntityRef;
import akka.cluster.sharding.typed.javadsl.Entity;
import akka.persistence.typed.javadsl.EventSourcedBehavior;
import akka.serialization.jackson.CborSerializable;
import akka.util.Timeout;
import com.fasterxml.jackson.annotation.JsonCreator;

public static class HelloWorldService {
  private final ActorSystem&lt;?&gt; system;
  private final ClusterSharding sharding;
  private final Duration askTimeout = Duration.ofSeconds(5);

  // registration at startup
  public HelloWorldService(ActorSystem&lt;?&gt; system) {
    this.system = system;
    sharding = ClusterSharding.get(system);

    // registration at startup
    sharding.init(
        Entity.of(
            HelloWorld.ENTITY_TYPE_KEY,
            entityContext -&gt;
                HelloWorld.create(
                    entityContext.getEntityId(),
                    PersistenceId.of(
                        entityContext.getEntityTypeKey().name(), entityContext.getEntityId()))));
  }

  // usage example
  public CompletionStage&lt;Integer&gt; sayHello(String worldId, String whom) {
    EntityRef&lt;HelloWorld.Command&gt; entityRef =
        sharding.entityRefFor(HelloWorld.ENTITY_TYPE_KEY, worldId);
    CompletionStage&lt;HelloWorld.Greeting&gt; result =
        entityRef.ask(replyTo -&gt; new HelloWorld.Greet(whom, replyTo), askTimeout);
    return result.thenApply(greeting -&gt; greeting.numberOfPeople);
  }
}</code></pre></dd>
</dl>
<p>Note how an unique <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/persistence/typed/PersistenceId.html" title="akka.persistence.typed.PersistenceId"><code>PersistenceId</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/persistence/typed/PersistenceId.html" title="akka.persistence.typed.PersistenceId"><code>PersistenceId</code></a></span> can be constructed from the <code>EntityTypeKey</code> and the <code>entityId</code> provided by the <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/typed/javadsl/EntityContext.html" title="akka.cluster.sharding.typed.javadsl.EntityContext"><code>EntityContext</code></a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/typed/scaladsl/EntityContext.html" title="akka.cluster.sharding.typed.scaladsl.EntityContext"><code>EntityContext</code></a></span> in the factory function for the <code>Behavior</code>. This is a typical way of defining the <code>PersistenceId</code> but other formats are possible, as described in the <a href="persistence.html#persistenceid">PersistenceId section</a>.</p>
<p>Sending messages to persistent entities is the same as if the entity wasn&rsquo;t persistent. The only difference is when an entity is moved the state will be restored. In the above example <a href="interaction-patterns.html#outside-ask">ask</a> is used but <code>tell</code> or any of the other <a href="interaction-patterns.html">Interaction Patterns</a> can be used.</p>
<p>See <a href="persistence.html">persistence</a> for more details.</p>
<h2><a href="#shard-allocation" name="shard-allocation" class="anchor"><span class="anchor-link"></span></a>Shard allocation</h2>
<p>A shard is a group of entities that will be managed together. The grouping is typically defined by a hashing function of the <code>entityId</code>. For a specific entity identifier the shard identifier must always be the same. Otherwise the entity actor might accidentally be started in several places at the same time.</p>
<p>By default the shard identifier is the absolute value of the <code>hashCode</code> of the entity identifier modulo the total number of shards. The number of shards is configured by:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/main/resources/reference.conf#L4-L11" target="_blank" title="Go to snippet source"></a><code class="language-conf">akka.cluster.sharding {
  # Number of shards used by the default HashCodeMessageExtractor
  # when no other message extractor is defined. This value must be
  # the same for all nodes in the cluster and that is verified by
  # configuration check when joining. Changing the value requires
  # stopping all nodes in the cluster.
  number-of-shards = 1000
}</code></pre>
<p>As a rule of thumb, the number of shards should be a factor ten greater than the planned maximum number of cluster nodes. It doesn&rsquo;t have to be exact. Fewer shards than number of nodes will result in that some nodes will not host any shards. Too many shards will result in less efficient management of the shards, e.g. rebalancing overhead, and increased latency because the coordinator is involved in the routing of the first message for each shard.</p>
<p>The <code>number-of-shards</code> configuration value must be the same for all nodes in the cluster and that is verified by configuration check when joining. Changing the value requires stopping all nodes in the cluster.</p>
<p>The shards are allocated to the nodes in the cluster. The decision of where to allocate a shard is done by a shard allocation strategy. The default implementation <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/ShardCoordinator$$LeastShardAllocationStrategy.html" title="akka.cluster.sharding.ShardCoordinator.LeastShardAllocationStrategy"><code>ShardCoordinator.LeastShardAllocationStrategy</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/ShardCoordinator.LeastShardAllocationStrategy.html" title="akka.cluster.sharding.ShardCoordinator.LeastShardAllocationStrategy"><code>ShardCoordinator.LeastShardAllocationStrategy</code></a></span> allocates new shards to the <code>ShardRegion</code> (node) with least number of previously allocated shards. This strategy can be replaced by an application specific implementation.</p>
<h3><a href="#external-shard-allocation" name="external-shard-allocation" class="anchor"><span class="anchor-link"></span></a>External shard allocation</h3>
<p>An alternative allocation strategy is the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/external/ExternalShardAllocationStrategy.html" title="akka.cluster.sharding.external.ExternalShardAllocationStrategy"><code>ExternalShardAllocationStrategy</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/external/ExternalShardAllocationStrategy.html" title="akka.cluster.sharding.external.ExternalShardAllocationStrategy"><code>ExternalShardAllocationStrategy</code></a></span> which allows explicit control over where shards are allocated via the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/external/ExternalShardAllocation.html" title="akka.cluster.sharding.external.ExternalShardAllocation"><code>ExternalShardAllocation</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/external/ExternalShardAllocation.html" title="akka.cluster.sharding.external.ExternalShardAllocation"><code>ExternalShardAllocation</code></a></span> extension. This can be used, for example, to match up Kafka Partition consumption with shard locations.</p>
<p>To use it set it as the allocation strategy on your <code>Entity</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ExternalShardAllocationCompileOnlySpec.scala#L28-L31" target="_blank" title="Go to snippet source"></a><code class="language-scala">val TypeKey = EntityTypeKey[Counter.Command](&quot;Counter&quot;)

val entity = Entity(TypeKey)(createBehavior = entityContext =&gt; Counter(entityContext.entityId))
  .withAllocationStrategy(new ExternalShardAllocationStrategy(system, TypeKey.name))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ExternalShardAllocationCompileOnlyTest.java#L30-L33" target="_blank" title="Go to snippet source"></a><code class="language-java">EntityTypeKey&lt;Counter.Command&gt; typeKey = EntityTypeKey.create(Counter.Command.class, &quot;Counter&quot;);

ActorRef&lt;ShardingEnvelope&lt;Counter.Command&gt;&gt; shardRegion =
    sharding.init(Entity.of(typeKey, ctx -&gt; Counter.create(ctx.getEntityId())));</code></pre></dd>
</dl>
<p>For any shardId that has not been allocated it will be allocated to the requesting node. To make explicit allocations:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ExternalShardAllocationCompileOnlySpec.scala#L38-L39" target="_blank" title="Go to snippet source"></a><code class="language-scala">val client: ExternalShardAllocationClient = ExternalShardAllocation(system).clientFor(TypeKey.name)
val done: Future[Done] = client.updateShardLocation(&quot;shard-id-1&quot;, Address(&quot;akka&quot;, &quot;system&quot;, &quot;127.0.0.1&quot;, 2552))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ExternalShardAllocationCompileOnlyTest.java#L37-L40" target="_blank" title="Go to snippet source"></a><code class="language-java">ExternalShardAllocationClient client =
    ExternalShardAllocation.get(system).getClient(typeKey.name());
CompletionStage&lt;Done&gt; done =
    client.setShardLocation(&quot;shard-id-1&quot;, new Address(&quot;akka&quot;, &quot;system&quot;, &quot;127.0.0.1&quot;, 2552));</code></pre></dd>
</dl>
<p>Any new or moved shard allocations will be moved on the next rebalance.</p>
<p>The communication from the client to the shard allocation strategy is via <a href="distributed-data.html">Distributed Data</a>. It uses a single <code>LWWMap</code> that can support 10s of thousands of shards. Later versions could use multiple keys to support a greater number of shards.</p>
<h4><a href="#example-project-for-external-allocation-strategy" name="example-project-for-external-allocation-strategy" class="anchor"><span class="anchor-link"></span></a>Example project for external allocation strategy</h4>
<p><a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-samples-kafka-to-sharding">Kafka to Cluster Sharding</a> is an example project that can be downloaded, and with instructions of how to run, that demonstrates how to use external sharding to co-locate Kafka partition consumption with shards.</p>
<h3><a href="#custom-shard-allocation" name="custom-shard-allocation" class="anchor"><span class="anchor-link"></span></a>Custom shard allocation</h3>
<p>An optional custom shard allocation strategy can be passed into the optional parameter when initializing an entity type or explicitly using the <code>withAllocationStrategy</code> function. See the API documentation of <span class="group-scala"><code>akka.cluster.sharding.ShardAllocationStrategy</code></span><span class="group-java"><code>akka.cluster.sharding.AbstractShardAllocationStrategy</code></span> for details of how to implement a custom <code>ShardAllocationStrategy</code>.</p>
<h2><a href="#how-it-works" name="how-it-works" class="anchor"><span class="anchor-link"></span></a>How it works</h2>
<p>See <a href="cluster-sharding-concepts.html">Cluster Sharding concepts</a>.</p>
<h2><a href="#sharding-state-store-mode" name="sharding-state-store-mode" class="anchor"><span class="anchor-link"></span></a>Sharding State Store Mode</h2>
<p>There are two cluster sharding states managed:</p>
<ol>
  <li><a href="cluster-sharding-concepts.html#shardcoordinator-state">ShardCoordinator State</a> - the <code>Shard</code> locations</li>
  <li><a href="cluster-sharding.html#remembering-entities">Remembering Entities</a> - the entities in each <code>Shard</code>, which is optional, and disabled by default</li>
</ol>
<p>For these, there are currently two modes which define how these states are stored:</p>
<ul>
  <li><a href="cluster-sharding.html#distributed-data-mode">Distributed Data Mode</a> - uses Akka <a href="distributed-data.html">Distributed Data</a> (CRDTs) (the default)</li>
  <li><a href="cluster-sharding.html#persistence-mode">Persistence Mode</a> - (deprecated) uses Akka <a href="persistence.html">Persistence</a> (Event Sourcing)</li>
</ul><div class="callout warning "><div class="callout-title">Warning</div>
<p>Persistence for state store mode is deprecated. </p></div>
<p>Changing the mode requires <a href="../additional/rolling-updates.html#cluster-sharding-configuration-change">a full cluster restart</a>.</p>
<h3><a href="#distributed-data-mode" name="distributed-data-mode" class="anchor"><span class="anchor-link"></span></a>Distributed Data Mode</h3>
<p>This mode is enabled with configuration (enabled by default):</p>
<pre><code>akka.cluster.sharding.state-store-mode = ddata
</code></pre>
<p>The state of the <code>ShardCoordinator</code> is replicated across the cluster but is not durable, not stored to disk. The <code>ShardCoordinator</code> state replication is handled by <a href="distributed-data.html">Distributed Data</a> with <code>WriteMajority</code>/<code>ReadMajority</code> consistency. When all nodes in the cluster have been stopped, the state is no longer needed and dropped.</p>
<p>The state of <a href="cluster-sharding.html#remembering-entities">Remembering Entities</a> is durable and stored to disk. This means remembered entities are restarted even after a complete (non-rolling) cluster restart when the disk is still available.</p>
<p>Cluster Sharding uses its own Distributed Data <code>Replicator</code> per node. If using roles with sharding there is one <code>Replicator</code> per role, which enables a subset of all nodes for some entity types and another subset for other entity types. Each such replicator has a name that contains the node role and therefore the role configuration must be the same on all nodes in the cluster, for example you can&rsquo;t change the roles when performing a rolling upgrade. Changing roles requires <a href="../additional/rolling-updates.html#cluster-sharding-configuration-change">a full cluster restart</a>.</p>
<p>The settings for Distributed Data are configured in the section <code>akka.cluster.sharding.distributed-data</code>. It&rsquo;s not possible to have different <code>distributed-data</code> settings for different sharding entity types.</p>
<h3><a href="#persistence-mode" name="persistence-mode" class="anchor"><span class="anchor-link"></span></a>Persistence Mode</h3>
<p>This mode is enabled with configuration:</p>
<pre><code>akka.cluster.sharding.state-store-mode = persistence
</code></pre>
<p>Since it is running in a cluster <a href="persistence.html">Persistence</a> must be configured with a distributed journal.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Persistence mode for <a href="cluster-sharding.html#remembering-entities">Remembering Entities</a> will be replaced by a pluggable data access API with storage implementations, see <a href="https://github.com/akka/akka/issues/27763">#27763</a>. New sharding applications should no longer choose persistence mode. Existing users of persistence mode <a href="https://github.com/akka/akka/issues/26177">can eventually migrate to the replacement options</a>. </p></div>
<h2><a href="#passivation" name="passivation" class="anchor"><span class="anchor-link"></span></a>Passivation</h2>
<p>If the state of the entities are persistent you may stop entities that are not used to reduce memory consumption. This is done by the application specific implementation of the entity actors for example by defining receive timeout (<code>context.setReceiveTimeout</code>). If a message is already enqueued to the entity when it stops itself the enqueued message in the mailbox will be dropped. To support graceful passivation without losing such messages the entity actor can send <code>ClusterSharding.Passivate</code> to the <span class="group-scala"><code>ActorRef[ShardCommand]</code></span><span class="group-java"><code>ActorRef&lt;ShardCommand&gt;</code></span> that was passed in to the factory method when creating the entity. The optional <code>stopMessage</code> message will be sent back to the entity, which is then supposed to stop itself, otherwise it will be stopped automatically. Incoming messages will be buffered by the <code>Shard</code> between reception of <code>Passivate</code> and termination of the entity. Such buffered messages are thereafter delivered to a new incarnation of the entity.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L95-L124" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Counter {
  sealed trait Command
  case object Increment extends Command
  final case class GetValue(replyTo: ActorRef[Int]) extends Command
  private case object Idle extends Command
  case object GoodByeCounter extends Command

  def apply(shard: ActorRef[ClusterSharding.ShardCommand], entityId: String): Behavior[Command] = {
    Behaviors.setup { ctx =&gt;
      def updated(value: Int): Behavior[Command] =
        Behaviors.receiveMessage[Command] {
          case Increment =&gt;
            updated(value + 1)
          case GetValue(replyTo) =&gt;
            replyTo ! value
            Behaviors.same
          case Idle =&gt;
            // after receive timeout
            shard ! ClusterSharding.Passivate(ctx.self)
            Behaviors.same
          case GoodByeCounter =&gt;
            // the stopMessage, used for rebalance and passivate
            Behaviors.stopped
        }

      ctx.setReceiveTimeout(30.seconds, Idle)
      updated(0)
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L92-L168" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Counter2 extends AbstractBehavior&lt;Counter2.Command&gt; {

  public interface Command {}

  private enum Idle implements Command {
    INSTANCE
  }

  public enum GoodByeCounter implements Command {
    INSTANCE
  }

  public enum Increment implements Command {
    INSTANCE
  }

  public static class GetValue implements Command {
    private final ActorRef&lt;Integer&gt; replyTo;

    public GetValue(ActorRef&lt;Integer&gt; replyTo) {
      this.replyTo = replyTo;
    }
  }

  public static Behavior&lt;Command&gt; create(
      ActorRef&lt;ClusterSharding.ShardCommand&gt; shard, String entityId) {
    return Behaviors.setup(
        ctx -&gt; {
          ctx.setReceiveTimeout(Duration.ofSeconds(30), Idle.INSTANCE);
          return new Counter2(ctx, shard, entityId);
        });
  }

  private final ActorRef&lt;ClusterSharding.ShardCommand&gt; shard;
  private final String entityId;
  private int value = 0;

  private Counter2(
      ActorContext&lt;Command&gt; context,
      ActorRef&lt;ClusterSharding.ShardCommand&gt; shard,
      String entityId) {
    super(context);
    this.shard = shard;
    this.entityId = entityId;
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder()
        .onMessage(Increment.class, msg -&gt; onIncrement())
        .onMessage(GetValue.class, this::onGetValue)
        .onMessage(Idle.class, msg -&gt; onIdle())
        .onMessage(GoodByeCounter.class, msg -&gt; onGoodByeCounter())
        .build();
  }

  private Behavior&lt;Command&gt; onIncrement() {
    value++;
    return this;
  }

  private Behavior&lt;Command&gt; onGetValue(GetValue msg) {
    msg.replyTo.tell(value);
    return this;
  }

  private Behavior&lt;Command&gt; onIdle() {
    // after receive timeout
    shard.tell(new ClusterSharding.Passivate&lt;&gt;(getContext().getSelf()));
    return this;
  }

  private Behavior&lt;Command&gt; onGoodByeCounter() {
    // the stopMessage, used for rebalance and passivate
    return Behaviors.stopped();
  }
}</code></pre></dd>
</dl>
<p>and then initialized with:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L128-L131" target="_blank" title="Go to snippet source"></a><code class="language-scala">val TypeKey = EntityTypeKey[Counter.Command](&quot;Counter&quot;)

ClusterSharding(system).init(Entity(TypeKey)(createBehavior = entityContext =&gt;
  Counter(entityContext.shard, entityContext.entityId)).withStopMessage(Counter.GoodByeCounter))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L176-L182" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>EntityTypeKey&lt;Counter2.Command&gt; typeKey =
    EntityTypeKey.create(Counter2.Command.class, &quot;Counter&quot;);

sharding.init(
    Entity.of(typeKey, ctx -&gt; Counter2.create(ctx.getShard(), ctx.getEntityId()))
        .withStopMessage(Counter2.GoodByeCounter.INSTANCE));</code></pre></dd>
</dl>
<p>Note that in the above example the <code>stopMessage</code> is specified as <code>GoodByeCounter</code>. That message will be sent to the entity when it&rsquo;s supposed to stop itself due to rebalance or passivation. If the <code>stopMessage</code> is not defined it will be stopped automatically without receiving a specific message. It can be useful to define a custom stop message if the entity needs to perform some asynchronous cleanup or interactions before stopping.</p>
<h3><a href="#automatic-passivation" name="automatic-passivation" class="anchor"><span class="anchor-link"></span></a>Automatic Passivation</h3>
<p>The entities are automatically passivated if they haven&rsquo;t received a message within the duration configured in <code>akka.cluster.sharding.passivate-idle-entity-after</code> or by explicitly setting the <code>passivateIdleEntityAfter</code> flag on <code>ClusterShardingSettings</code> to a suitable time to keep the actor alive. Note that only messages sent through sharding are counted, so direct messages to the <code>ActorRef</code> or messages that the actor sends to itself are not counted in this activity. Passivation can be disabled by setting <code>akka.cluster.sharding.passivate-idle-entity-after = off</code>. It is disabled automatically if <a href="cluster-sharding.html#remembering-entities">Remembering Entities</a> is enabled.</p>
<h2><a href="#remembering-entities" name="remembering-entities" class="anchor"><span class="anchor-link"></span></a>Remembering Entities</h2>
<p>Remembering entities pertains to restarting entities after a rebalance or recovering from a crash. Enabling or disabling (the default) this feature drives the behavior of the restarts:</p>
<ul>
  <li>enabled: entities are restarted, even though no new messages are sent to them. This will also disable <a href="cluster-sharding.html#passivation">Automtic Passivation</a>.</li>
  <li>disabled: entities are restarted, on demand when a new message arrives.</li>
</ul>
<p>Note that the state of the entities themselves will not be restored unless they have been made persistent, for example with <a href="persistence.html">Event Sourcing</a>.</p>
<p>To make the list of entities in each <code>Shard</code> persistent (durable) set the <code>rememberEntities</code> flag to true in <code>ClusterShardingSettings</code> when starting a shard region (or its proxy) for a given <code>entity</code> type or configure <code>akka.cluster.sharding.remember-entities = on</code>.</p>
<p>The performance cost of <code>rememberEntities</code> is rather high when starting/stopping entities and when shards are rebalanced. This cost increases with number of entities per shard, thus it is not recommended with more than 10000 active entities per shard. </p>
<h3><a href="#behavior-when-enabled" name="behavior-when-enabled" class="anchor"><span class="anchor-link"></span></a>Behavior When Enabled</h3>
<p>When <code>rememberEntities</code> is enabled, whenever a <code>Shard</code> is rebalanced onto another node or recovers after a crash it will recreate all the entities which were previously running in that <code>Shard</code>. To permanently stop entities, a <code>Passivate</code> message must be sent to the parent of the entity actor, otherwise the entity will be automatically restarted after the entity restart backoff specified in the configuration.</p>
<p>When <a href="cluster-sharding.html#distributed-data-mode">Distributed Data mode</a> is used the identifiers of the entities are stored in <a href="distributed-data.html#durable-storage">Durable Storage</a> of Distributed Data. You may want to change the configuration of the <code>akka.cluster.sharding.distributed-data.durable.lmdb.dir</code>, since the default directory contains the remote port of the actor system. If using a dynamically assigned port (0) it will be different each time and the previously stored data will not be loaded.</p>
<p>The reason for storing the identifiers of the active entities in durable storage, i.e. stored to disk, is that the same entities should be started also after a complete cluster restart. If this is not needed you can disable durable storage and benefit from better performance by using the following configuration:</p>
<pre><code>akka.cluster.sharding.distributed-data.durable.keys = []
</code></pre>
<h3><a href="#behavior-when-not-enabled" name="behavior-when-not-enabled" class="anchor"><span class="anchor-link"></span></a>Behavior When Not Enabled</h3>
<p>When <code>rememberEntities</code> is disabled (the default), a <code>Shard</code> will not automatically restart any entities after a rebalance or recovering from a crash. Instead, entities are started once the first message for that entity has been received in the <code>Shard</code>.</p>
<h3><a href="#startup-after-minimum-number-of-members" name="startup-after-minimum-number-of-members" class="anchor"><span class="anchor-link"></span></a>Startup after minimum number of members</h3>
<p>It&rsquo;s recommended to use Cluster Sharding with the Cluster setting <code>akka.cluster.min-nr-of-members</code> or <code>akka.cluster.role.&lt;role-name&gt;.min-nr-of-members</code>. <code>min-nr-of-members</code> will defer the allocation of the shards until at least that number of regions have been started and registered to the coordinator. This avoids that many shards are allocated to the first region that registers and only later are rebalanced to other nodes.</p>
<p>See <a href="cluster.html#how-to-startup-when-a-cluster-size-is-reached">How To Startup when Cluster Size Reached</a> for more information about <code>min-nr-of-members</code>.</p>
<h2><a href="#inspecting-cluster-sharding-state" name="inspecting-cluster-sharding-state" class="anchor"><span class="anchor-link"></span></a>Inspecting cluster sharding state</h2>
<p>Two requests to inspect the cluster state are available:</p>
<p><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/typed/GetShardRegionState.html" title="akka.cluster.sharding.typed.GetShardRegionState"><code>GetShardRegionState</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/typed/GetShardRegionState.html" title="akka.cluster.sharding.typed.GetShardRegionState"><code>GetShardRegionState</code></a></span> which will reply with a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/ShardRegion$$CurrentShardRegionState.html" title="akka.cluster.sharding.ShardRegion.CurrentShardRegionState"><code>ShardRegion.CurrentShardRegionState</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/ShardRegion.CurrentShardRegionState.html" title="akka.cluster.sharding.ShardRegion.CurrentShardRegionState"><code>ShardRegion.CurrentShardRegionState</code></a></span> that contains the identifiers of the shards running in a Region and what entities are alive for each of them.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L184-L189" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.cluster.sharding.typed.GetShardRegionState
import akka.cluster.sharding.ShardRegion.CurrentShardRegionState

val replyTo: ActorRef[CurrentShardRegionState] = replyMessageAdapter

ClusterSharding(system).shardState ! GetShardRegionState(Counter.TypeKey, replyTo)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L28-L271" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.cluster.sharding.typed.GetShardRegionState;
import akka.cluster.sharding.ShardRegion.CurrentShardRegionState;

ActorRef&lt;CurrentShardRegionState&gt; replyTo = replyMessageAdapter;

ClusterSharding.get(system).shardState().tell(new GetShardRegionState(typeKey, replyTo));</code></pre></dd>
</dl>
<p><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/typed/GetClusterShardingStats.html" title="akka.cluster.sharding.typed.GetClusterShardingStats"><code>GetClusterShardingStats</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/typed/GetClusterShardingStats.html" title="akka.cluster.sharding.typed.GetClusterShardingStats"><code>GetClusterShardingStats</code></a></span> which will query all the regions in the cluster and reply with a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/akka/cluster/sharding/ShardRegion$$ClusterShardingStats.html" title="akka.cluster.sharding.ShardRegion.ClusterShardingStats"><code>ShardRegion.ClusterShardingStats</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/akka/cluster/sharding/ShardRegion.ClusterShardingStats.html" title="akka.cluster.sharding.ShardRegion.ClusterShardingStats"><code>ShardRegion.ClusterShardingStats</code></a></span> containing the identifiers of the shards running in each region and a count of entities that are alive in each shard.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/scala/docs/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala#L202-L209" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.cluster.sharding.typed.GetClusterShardingStats
import akka.cluster.sharding.ShardRegion.ClusterShardingStats
import scala.concurrent.duration._

val replyTo: ActorRef[ClusterShardingStats] = replyMessageAdapter
val timeout: FiniteDuration = 5.seconds

ClusterSharding(system).shardState ! GetClusterShardingStats(Counter.TypeKey, timeout, replyTo)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/test/java/jdocs/akka/cluster/sharding/typed/ShardingCompileOnlyTest.java#L33-L286" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.cluster.sharding.typed.GetClusterShardingStats;
import akka.cluster.sharding.ShardRegion.ClusterShardingStats;

ActorRef&lt;ClusterShardingStats&gt; replyTo = replyMessageAdapter;
Duration timeout = Duration.ofSeconds(5);

ClusterSharding.get(system)
    .shardState()
    .tell(new GetClusterShardingStats(typeKey, timeout, replyTo));</code></pre></dd>
</dl>
<p>If any shard queries failed, for example due to timeout if a shard was too busy to reply within the configured <code>akka.cluster.sharding.shard-region-query-timeout</code>, <code>ShardRegion.CurrentShardRegionState</code> and <code>ShardRegion.ClusterShardingStats</code> will also include the set of shard identifiers by region that failed.</p>
<p>The purpose of these messages is testing and monitoring, they are not provided to give access to directly sending messages to the individual entities.</p>
<h2><a href="#lease" name="lease" class="anchor"><span class="anchor-link"></span></a>Lease</h2>
<p>A <a href="../coordination.html">lease</a> can be used as an additional safety measure to ensure a shard does not run on two nodes.</p>
<p>Reasons for how this can happen:</p>
<ul>
  <li>Network partitions without an appropriate downing provider</li>
  <li>Mistakes in the deployment process leading to two separate Akka Clusters</li>
  <li>Timing issues between removing members from the Cluster on one side of a network partition and shutting them down on the other side</li>
</ul>
<p>A lease can be a final backup that means that each shard won&rsquo;t create child entity actors unless it has the lease. </p>
<p>To use a lease for sharding set <code>akka.cluster.sharding.use-lease</code> to the configuration location of the lease to use. Each shard will try and acquire a lease with with the name <code>&lt;actor system name&gt;-shard-&lt;type name&gt;-&lt;shard id&gt;</code> and the owner is set to the <code>Cluster(system).selfAddress.hostPort</code>.</p>
<p>If a shard can&rsquo;t acquire a lease it will remain uninitialized so messages for entities it owns will be buffered in the <code>ShardRegion</code>. If the lease is lost after initialization the Shard will be terminated.</p>
<h2><a href="#removal-of-internal-cluster-sharding-data" name="removal-of-internal-cluster-sharding-data" class="anchor"><span class="anchor-link"></span></a>Removal of internal Cluster Sharding data</h2>
<p>Removal of internal Cluster Sharding data is only relevant for &ldquo;Persistent Mode&rdquo;. The Cluster Sharding <code>ShardCoordinator</code> stores locations of the shards. This data is safely be removed when restarting the whole Akka Cluster. Note that this does not include application data.</p>
<p>There is a utility program <code>akka.cluster.sharding.RemoveInternalClusterShardingData</code> that removes this data.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Never use this program while there are running Akka Cluster nodes that are using Cluster Sharding. Stop all Cluster nodes before using this program.</p></div>
<p>It can be needed to remove the data if the Cluster Sharding coordinator cannot startup because of corrupt data, which may happen if accidentally two clusters were running at the same time, e.g. caused by an invalid downing provider when there was a network partition.</p>
<p>Use this program as a standalone Java main program:</p>
<pre><code>java -classpath &lt;jar files, including akka-cluster-sharding&gt;
  akka.cluster.sharding.RemoveInternalClusterShardingData
    -2.3 entityType1 entityType2 entityType3
</code></pre>
<p>The program is included in the <code>akka-cluster-sharding</code> jar file. It is easiest to run it with same classpath and configuration as your ordinary application. It can be run from sbt or Maven in similar way.</p>
<p>Specify the entity type names (same as you use in the <code>init</code> method of <code>ClusterSharding</code>) as program arguments.</p>
<p>If you specify <code>-2.3</code> as the first program argument it will also try to remove data that was stored by Cluster Sharding in Akka 2.3.x using different persistenceId.</p>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>The <code>ClusterSharding</code> extension can be configured with the following properties. These configuration properties are read by the <code>ClusterShardingSettings</code> when created with an ActorSystem parameter. It is also possible to amend the <code>ClusterShardingSettings</code> or create it from another config section with the same layout as below. </p>
<p>One important configuration property is <code>number-of-shards</code> as described in <a href="cluster-sharding.html#shard-allocation">Shard allocation</a></p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding/src/main/resources/reference.conf#L10-L204" target="_blank" title="Go to snippet source"></a><code class="language-conf"># Settings for the ClusterShardingExtension
akka.cluster.sharding {

  # The extension creates a top level actor with this name in top level system scope,
  # e.g. &#39;/system/sharding&#39;
  guardian-name = sharding

  # Specifies that entities runs on cluster nodes with a specific role.
  # If the role is not specified (or empty) all nodes in the cluster are used.
  role = &quot;&quot;

  # When this is set to &#39;on&#39; the active entity actors will automatically be restarted
  # upon Shard restart. i.e. if the Shard is started on a different ShardRegion
  # due to rebalance or crash.
  remember-entities = off

  # Set this to a time duration to have sharding passivate entities when they have not
  # received any message in this length of time. Set to &#39;off&#39; to disable.
  # It is always disabled if `remember-entities` is enabled.
  passivate-idle-entity-after = 120s

  # If the coordinator can&#39;t store state changes it will be stopped
  # and started again after this duration, with an exponential back-off
  # of up to 5 times this duration.
  coordinator-failure-backoff = 5 s

  # The ShardRegion retries registration and shard location requests to the
  # ShardCoordinator with this interval if it does not reply.
  retry-interval = 2 s

  # Maximum number of messages that are buffered by a ShardRegion actor.
  buffer-size = 100000

  # Timeout of the shard rebalancing process.
  # Additionally, if an entity doesn&#39;t handle the stopMessage
  # after (handoff-timeout - 5.seconds).max(1.second) it will be stopped forcefully
  handoff-timeout = 60 s

  # Time given to a region to acknowledge it&#39;s hosting a shard.
  shard-start-timeout = 10 s

  # If the shard is remembering entities and can&#39;t store state changes
  # will be stopped and then started again after this duration. Any messages
  # sent to an affected entity may be lost in this process.
  shard-failure-backoff = 10 s

  # If the shard is remembering entities and an entity stops itself without
  # using passivate. The entity will be restarted after this duration or when
  # the next message for it is received, which ever occurs first.
  entity-restart-backoff = 10 s

  # Rebalance check is performed periodically with this interval.
  rebalance-interval = 10 s

  # Absolute path to the journal plugin configuration entity that is to be
  # used for the internal persistence of ClusterSharding. If not defined
  # the default journal plugin is used. Note that this is not related to
  # persistence used by the entity actors.
  # Only used when state-store-mode=persistence
  journal-plugin-id = &quot;&quot;

  # Absolute path to the snapshot plugin configuration entity that is to be
  # used for the internal persistence of ClusterSharding. If not defined
  # the default snapshot plugin is used. Note that this is not related to
  # persistence used by the entity actors.
  # Only used when state-store-mode=persistence
  snapshot-plugin-id = &quot;&quot;

  # Defines how the coordinator stores its state. Same is also used by the
  # shards for rememberEntities.
  # Valid values are &quot;ddata&quot; or &quot;persistence&quot;. 
  state-store-mode = &quot;ddata&quot;

  # The shard saves persistent snapshots after this number of persistent
  # events. Snapshots are used to reduce recovery times.
  # Only used when state-store-mode=persistence
  snapshot-after = 1000

  # The shard deletes persistent events (messages and snapshots) after doing snapshot
  # keeping this number of old persistent batches.
  # Batch is of size `snapshot-after`.
  # When set to 0 after snapshot is successfully done all events with equal or lower sequence number will be deleted.
  # Default value of 2 leaves last maximum 2*`snapshot-after` events and 3 snapshots (2 old ones + latest snapshot)
  keep-nr-of-batches = 2

  # Setting for the default shard allocation strategy
  least-shard-allocation-strategy {
    # Threshold of how large the difference between most and least number of
    # allocated shards must be to begin the rebalancing.
    # The difference between number of shards in the region with most shards and
    # the region with least shards must be greater than (&gt;) the `rebalanceThreshold`
    # for the rebalance to occur.
    # It is also the maximum number of shards that will start rebalancing per rebalance-interval
    # 1 gives the best distribution and therefore typically the best choice.
    # Increasing the threshold can result in quicker rebalance but has the
    # drawback of increased difference between number of shards (and therefore load)
    # on different nodes before rebalance will occur.
    rebalance-threshold = 1

    # The number of ongoing rebalancing processes is limited to this number.
    max-simultaneous-rebalance = 3
  }

  external-shard-allocation-strategy {
    # How long to wait for the client to persist an allocation to ddata or get a all shard locations
    client-timeout = 5s
  }

  # Timeout of waiting the initial distributed state for the shard coordinator (an initial state will be queried again if the timeout happened)
  # and for a shard to get its state when remembered entities is enabled
  # The read from ddata is a ReadMajority, for small clusters (&lt; majority-min-cap) every node needs to respond
  # so is more likely to time out if there are nodes restarting e.g. when there is a rolling re-deploy happening
  # Only used when state-store-mode=ddata
  waiting-for-state-timeout = 2 s

  # Timeout of waiting for update the distributed state (update will be retried if the timeout happened)
  # Only used when state-store-mode=ddata
  updating-state-timeout = 5 s

  # Timeout to wait for querying all shards for a given `ShardRegion`.
  shard-region-query-timeout = 3 s

  # The shard uses this strategy to determines how to recover the underlying entity actors. The strategy is only used
  # by the persistent shard when rebalancing or restarting. The value can either be &quot;all&quot; or &quot;constant&quot;. The &quot;all&quot;
  # strategy start all the underlying entity actors at the same time. The constant strategy will start the underlying
  # entity actors at a fix rate. The default strategy &quot;all&quot;.
  entity-recovery-strategy = &quot;all&quot;

  # Default settings for the constant rate entity recovery strategy
  entity-recovery-constant-rate-strategy {
    # Sets the frequency at which a batch of entity actors is started.
    frequency = 100 ms
    # Sets the number of entity actors to be restart at a particular interval
    number-of-entities = 5
  }

  # Settings for the coordinator singleton. Same layout as akka.cluster.singleton.
  # The &quot;role&quot; of the singleton configuration is not used. The singleton role will
  # be the same as &quot;akka.cluster.sharding.role&quot;.
  # A lease can be configured in these settings for the coordinator singleton
  coordinator-singleton = ${akka.cluster.singleton}

  coordinator-state {
    # State updates are required to be written to a majority of nodes plus this
    # number of additional nodes. Can also be set to &quot;all&quot; to require
    # writes to all nodes. The reason for write/read to more than majority
    # is to have more tolerance for membership changes between write and read.
    # The tradeoff of increasing this is that updates will be slower.
    # It is more important to increase the `read-majority-plus`.
    write-majority-plus = 5
    # State retrieval when ShardCoordinator is started is required to be read
    # from a majority of nodes plus this number of additional nodes. Can also
    # be set to &quot;all&quot; to require reads from all nodes. The reason for write/read
    # to more than majority is to have more tolerance for membership changes between
    # write and read.
    # The tradeoff of increasing this is that coordinator startup will be slower.
    read-majority-plus = 5
  }
  
  # Settings for the Distributed Data replicator. 
  # Same layout as akka.cluster.distributed-data.
  # The &quot;role&quot; of the distributed-data configuration is not used. The distributed-data
  # role will be the same as &quot;akka.cluster.sharding.role&quot;.
  # Note that there is one Replicator per role and it&#39;s not possible
  # to have different distributed-data settings for different sharding entity types.
  # Only used when state-store-mode=ddata
  distributed-data = ${akka.cluster.distributed-data}
  distributed-data {
    # minCap parameter to MajorityWrite and MajorityRead consistency level.
    majority-min-cap = 5
    durable.keys = [&quot;shard-*&quot;]
    
    # When using many entities with &quot;remember entities&quot; the Gossip message
    # can become to large if including to many in same message. Limit to
    # the same number as the number of ORSet per shard.
    max-delta-elements = 5

    # ShardCoordinator is singleton running on oldest
    prefer-oldest = on
  }

  # The id of the dispatcher to use for ClusterSharding actors.
  # If specified you need to define the settings of the actual dispatcher.
  # This dispatcher for the entity actors is defined by the user provided
  # Props, i.e. this dispatcher is not used for the entity actors.
  use-dispatcher = &quot;akka.actor.internal-dispatcher&quot;

  # Config path of the lease that each shard must acquire before starting entity actors
  # default is no lease
  # A lease can also be used for the singleton coordinator by settings it in the coordinator-singleton properties
  use-lease = &quot;&quot;

  # The interval between retries for acquiring the lease
  lease-retry-interval = 5s
}</code></pre>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-cluster-sharding-typed/src/main/resources/reference.conf#L4-L11" target="_blank" title="Go to snippet source"></a><code class="language-conf">akka.cluster.sharding {
  # Number of shards used by the default HashCodeMessageExtractor
  # when no other message extractor is defined. This value must be
  # the same for all nodes in the cluster and that is verified by
  # configuration check when joining. Changing the value requires
  # stopping all nodes in the cluster.
  number-of-shards = 1000
}</code></pre>
<h2><a href="#example-project" name="example-project" class="anchor"><span class="anchor-link"></span></a>Example project</h2>
<p><span class="group-java"><a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-samples-cluster-sharding-java">Sharding example project</a></span> <span class="group-scala"><a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-samples-cluster-sharding-scala">Sharding example project</a></span> is an example project that can be downloaded, and with instructions of how to run.</p>
<p>This project contains a KillrWeather sample illustrating how to use Cluster Sharding.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/cluster-singleton.html"><i class="icon-prev"></i> <span class="link-prev">Cluster Singleton</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/cluster-sharding-concepts.html">Cluster Sharding concepts <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/main/paradox/typed/cluster-sharding.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2020 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
