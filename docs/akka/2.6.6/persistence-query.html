<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Persistence Query &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Query side to Akka Persistence allowing for building CQRS applications."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/persistence-query.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page-7.css"/>
<link rel="stylesheet" type="text/css" href="css/banner-1.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png"/>
<link rel="manifest" href="images/manifest.json"/>
<meta name="msapplication-TileImage" content="images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.6
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence</a>
  <ul>
    <li><a href="typed/persistence.html" class="page">Event Sourcing</a></li>
    <li><a href="typed/cqrs.html" class="page">CQRS</a></li>
    <li><a href="typed/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="typed/persistence-snapshot.html" class="page">Snapshotting</a></li>
    <li><a href="typed/persistence-testing.html" class="page">Testing</a></li>
    <li><a href="typed/persistence-fsm.html" class="page">EventSourced behaviors as finite state machines</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Schema Evolution for Event Sourced Actors</a></li>
    <li><a href="persistence-query.html#persistence-query" class="active page">Persistence Query</a>
    <ul>
      <li><a href="persistence-query.html#dependency" class="header">Dependency</a></li>
      <li><a href="persistence-query.html#introduction" class="header">Introduction</a></li>
      <li><a href="persistence-query.html#design-overview" class="header">Design overview</a></li>
      <li><a href="persistence-query.html#read-journals" class="header">Read Journals</a></li>
      <li><a href="persistence-query.html#performance-and-denormalization" class="header">Performance and denormalization</a></li>
      <li><a href="persistence-query.html#query-plugins" class="header">Query plugins</a></li>
      <li><a href="persistence-query.html#scaling-out" class="header">Scaling out</a></li>
      <li><a href="persistence-query.html#example-project" class="header">Example project</a></li>
    </ul></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-plugins.html" class="page">Persistence Plugins</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.6
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence</a>
  <ul>
    <li><a href="typed/persistence.html" class="page">Event Sourcing</a></li>
    <li><a href="typed/cqrs.html" class="page">CQRS</a></li>
    <li><a href="typed/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="typed/persistence-snapshot.html" class="page">Snapshotting</a></li>
    <li><a href="typed/persistence-testing.html" class="page">Testing</a></li>
    <li><a href="typed/persistence-fsm.html" class="page">EventSourced behaviors as finite state machines</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Schema Evolution for Event Sourced Actors</a></li>
    <li><a href="persistence-query.html#persistence-query" class="active page">Persistence Query</a>
    <ul>
      <li><a href="persistence-query.html#dependency" class="header">Dependency</a></li>
      <li><a href="persistence-query.html#introduction" class="header">Introduction</a></li>
      <li><a href="persistence-query.html#design-overview" class="header">Design overview</a></li>
      <li><a href="persistence-query.html#read-journals" class="header">Read Journals</a></li>
      <li><a href="persistence-query.html#performance-and-denormalization" class="header">Performance and denormalization</a></li>
      <li><a href="persistence-query.html#query-plugins" class="header">Query plugins</a></li>
      <li><a href="persistence-query.html#scaling-out" class="header">Scaling out</a></li>
      <li><a href="persistence-query.html#example-project" class="header">Example project</a></li>
    </ul></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-plugins.html" class="page">Persistence Plugins</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#persistence-query" name="persistence-query" class="anchor"><span class="anchor-link"></span></a>Persistence Query</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Persistence Query, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-persistence-query" % "2.6.6"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.12&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-persistence-query_${scala.binary.version}&lt;/artifactId&gt;
  &lt;version&gt;2.6.6&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">versions += [
  ScalaBinary: "2.12"
]
dependencies {
  compile group: 'com.typesafe.akka', name: "akka-persistence-query_${versions.ScalaBinary}", version: '2.6.6'
}</code></pre></dd></dl>
<p>This will also add dependency on the <a href="persistence.html">Akka Persistence</a> module.</p>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Akka persistence query complements <a href="typed/persistence.html">Event Sourcing</a> by providing a universal asynchronous stream based query interface that various journal plugins can implement in order to expose their query capabilities.</p>
<p>The most typical use case of persistence query is implementing the so-called query side (also known as &ldquo;read side&rdquo;) in the popular CQRS architecture pattern - in which the writing side of the application (e.g. implemented using Akka persistence) is completely separated from the &ldquo;query side&rdquo;. Akka Persistence Query itself is <em>not</em> directly the query side of an application, however it can help to migrate data from the write side to the query side database. In very simple scenarios Persistence Query may be powerful enough to fulfill the query needs of your app, however we highly recommend (in the spirit of CQRS) of splitting up the write/read sides into separate datastores as the need arises.</p>
<p>The <a href="https://akka.io/blog/news/2020/02/05/akka-cqrs-video">CQRS with Akka 2.6 video</a> is a good starting point for learning how to use <code>eventsByTag</code> to implement CQRS with Akka. Also, watch the introduction to <a href="https://akka.io/blog/news/2020/01/07/akka-event-sourcing-video">Event Sourcing with Akka 2.6 video</a>.</p>
<h2><a href="#design-overview" name="design-overview" class="anchor"><span class="anchor-link"></span></a>Design overview</h2>
<p>Akka persistence query is purposely designed to be a very loosely specified API. This is in order to keep the provided APIs general enough for each journal implementation to be able to expose its best features, e.g. a SQL journal can use complex SQL queries or if a journal is able to subscribe to a live event stream this should also be possible to expose the same API - a typed stream of events.</p>
<p><strong>Each read journal must explicitly document which types of queries it supports.</strong> Refer to your journal&rsquo;s plugins documentation for details on which queries and semantics it supports.</p>
<p>While Akka Persistence Query does not provide actual implementations of ReadJournals, it defines a number of pre-defined query types for the most common query scenarios, that most journals are likely to implement (however they are not required to).</p>
<h2><a href="#read-journals" name="read-journals" class="anchor"><span class="anchor-link"></span></a>Read Journals</h2>
<p>In order to issue queries one has to first obtain an instance of a <code>ReadJournal</code>. Read journals are implemented as <a href="https://akka.io/community/#plugins-to-akka-persistence-query">Community plugins</a>, each targeting a specific datastore (for example Cassandra or JDBC databases). For example, given a library that provides a <code>akka.persistence.query.my-read-journal</code> obtaining the related journal is as simple as:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L213-L224" target="_blank" title="Go to snippet source"></a><code class="language-scala">// obtain read journal by plugin id
val readJournal =
  PersistenceQuery(system).readJournalFor[MyScaladslReadJournal](&quot;akka.persistence.query.my-read-journal&quot;)

// issue query to journal
val source: Source[EventEnvelope, NotUsed] =
  readJournal.eventsByPersistenceId(&quot;user-1337&quot;, 0, Long.MaxValue)

// materialize stream, consuming events
source.runForeach { event =&gt;
  println(&quot;Event: &quot; + event)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L207-L218" target="_blank" title="Go to snippet source"></a><code class="language-java">// obtain read journal by plugin id
final MyJavadslReadJournal readJournal =
    PersistenceQuery.get(system)
        .getReadJournalFor(
            MyJavadslReadJournal.class, &quot;akka.persistence.query.my-read-journal&quot;);

// issue query to journal
Source&lt;EventEnvelope, NotUsed&gt; source =
    readJournal.eventsByPersistenceId(&quot;user-1337&quot;, 0, Long.MAX_VALUE);

// materialize stream, consuming events
source.runForeach(event -&gt; System.out.println(&quot;Event: &quot; + event), system);</code></pre></dd>
</dl>
<p>Journal implementers are encouraged to put this identifier in a variable known to the user, such that one can access it via <span class="group-scala"><code>readJournalFor[NoopJournal](NoopJournal.identifier)</code></span><span class="group-java"><code>getJournalFor(NoopJournal.class, NoopJournal.identifier)</code></span>, however this is not enforced.</p>
<p>Read journal implementations are available as <a href="https://akka.io/community/#plugins-to-akka-persistence-query">Community plugins</a>.</p>
<h3><a href="#predefined-queries" name="predefined-queries" class="anchor"><span class="anchor-link"></span></a>Predefined queries</h3>
<p>Akka persistence query comes with a number of query interfaces built in and suggests Journal implementors to implement them according to the semantics described below. It is important to notice that while these query types are very common a journal is not obliged to implement all of them - for example because in a given journal such query would be significantly inefficient.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Refer to the documentation of the <code>ReadJournal</code> plugin you are using for a specific list of supported query types. For example, Journal plugins should document their stream completion strategies.</p></div>
<p>The predefined queries are:</p>
<h4><a href="#persistenceidsquery-and-currentpersistenceidsquery" name="persistenceidsquery-and-currentpersistenceidsquery" class="anchor"><span class="anchor-link"></span></a>PersistenceIdsQuery and CurrentPersistenceIdsQuery</h4>
<p><code>persistenceIds</code> which is designed to allow users to subscribe to a stream of all persistent ids in the system. By default this stream should be assumed to be a &ldquo;live&rdquo; stream, which means that the journal should keep emitting new persistence ids as they come into the system:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L228" target="_blank" title="Go to snippet source"></a><code class="language-scala">readJournal.persistenceIds()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L229" target="_blank" title="Go to snippet source"></a><code class="language-java">readJournal.persistenceIds();</code></pre></dd>
</dl>
<p>If your usage does not require a live stream, you can use the <code>currentPersistenceIds</code> query:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L232" target="_blank" title="Go to snippet source"></a><code class="language-scala">readJournal.currentPersistenceIds()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L242" target="_blank" title="Go to snippet source"></a><code class="language-java">readJournal.currentPersistenceIds();</code></pre></dd>
</dl>
<h4><a href="#eventsbypersistenceidquery-and-currenteventsbypersistenceidquery" name="eventsbypersistenceidquery-and-currenteventsbypersistenceidquery" class="anchor"><span class="anchor-link"></span></a>EventsByPersistenceIdQuery and CurrentEventsByPersistenceIdQuery</h4>
<p><code>eventsByPersistenceId</code> is a query equivalent to replaying an <a href="typed/persistence.html#event-sourcing-concepts">event sourced actor</a>, however, since it is a stream it is possible to keep it alive and watch for additional incoming events persisted by the persistent actor identified by the given <code>persistenceId</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L256-L257" target="_blank" title="Go to snippet source"></a><code class="language-scala">readJournal.eventsByPersistenceId(&quot;user-us-1337&quot;, fromSequenceNr = 0L, toSequenceNr = Long.MaxValue)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L255" target="_blank" title="Go to snippet source"></a><code class="language-java">readJournal.eventsByPersistenceId(&quot;user-us-1337&quot;, 0L, Long.MAX_VALUE);</code></pre></dd>
</dl>
<p>Most journals will have to revert to polling in order to achieve this, which can typically be configured with a <code>refresh-interval</code> configuration property.</p>
<p>If your usage does not require a live stream, you can use the <code>currentEventsByPersistenceId</code> query.</p>
<h4><a href="#eventsbytag-and-currenteventsbytag" name="eventsbytag-and-currenteventsbytag" class="anchor"><span class="anchor-link"></span></a>EventsByTag and CurrentEventsByTag</h4>
<p><code>eventsByTag</code> allows querying events regardless of which <code>persistenceId</code> they are associated with. This query is hard to implement in some journals or may need some additional preparation of the used data store to be executed efficiently. The goal of this query is to allow querying for all events which are &ldquo;tagged&rdquo; with a specific tag. That includes the use case to query all domain events of an Aggregate Root type. Please refer to your read journal plugin&rsquo;s documentation to find out if and how it is supported.</p>
<p>Some journals may support <a href="typed/persistence.html#tagging">tagging of events</a> or <a href="persistence.html#event-adapters">Event Adapters</a> that wraps the events in a <code>akka.persistence.journal.Tagged</code> with the given <code>tags</code>. The journal may support other ways of doing tagging - again, how exactly this is implemented depends on the used journal. Here is an example of such a tagging with an <code>EventSourcedBehavior</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/BasicPersistentBehaviorCompileOnly.scala#L153-L170" target="_blank" title="Go to snippet source"></a><code class="language-scala">val NumberOfEntityGroups = 10

def tagEvent(entityId: String, event: Event): Set[String] = {
  val entityGroup = s&quot;group-${math.abs(entityId.hashCode % NumberOfEntityGroups)}&quot;
  event match {
    case _: OrderCompleted =&gt; Set(entityGroup, &quot;order-completed&quot;)
    case _                 =&gt; Set(entityGroup)
  }
}

def apply(entityId: String): Behavior[Command] = {
  EventSourcedBehavior[Command, Event, State](
    persistenceId = PersistenceId(&quot;ShoppingCart&quot;, entityId),
    emptyState = State(),
    commandHandler = (state, cmd) =&gt; throw new NotImplementedError(&quot;TODO: process the command &amp; return an Effect&quot;),
    eventHandler = (state, evt) =&gt; throw new NotImplementedError(&quot;TODO: process the event return the next state&quot;))
    .withTagger(event =&gt; tagEvent(entityId, event))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-persistence-typed/src/test/java/jdocs/akka/persistence/typed/BasicPersistentBehaviorTest.java#L448-L459" target="_blank" title="Go to snippet source"></a><code class="language-java">private final String entityId;

public static final int NUMBER_OF_ENTITY_GROUPS = 10;

@Override
public Set&lt;String&gt; tagsFor(Event event) {
  String entityGroup = &quot;group-&quot; + Math.abs(entityId.hashCode() % NUMBER_OF_ENTITY_GROUPS);
  Set&lt;String&gt; tags = new HashSet&lt;&gt;();
  tags.add(entityGroup);
  if (event instanceof OrderCompleted) tags.add(&quot;order-completed&quot;);
  return tags;
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>A very important thing to keep in mind when using queries spanning multiple persistenceIds, such as <code>EventsByTag</code> is that the order of events at which the events appear in the stream rarely is guaranteed (or stable between materializations).</p>
<p>Journals <em>may</em> choose to opt for strict ordering of the events, and should then document explicitly what kind of ordering guarantee they provide - for example &ldquo;<em>ordered by timestamp ascending, independently of persistenceId</em>&rdquo; is easy to achieve on relational databases, yet may be hard to implement efficiently on plain key-value datastores.</p></div>
<p>In the example below we query all events which have been tagged (we assume this was performed by the write-side using <a href="typed/persistence.html#tagging">tagging of events</a> or <a href="persistence.html#event-adapters">Event Adapters</a>, or that the journal is smart enough that it can figure out what we mean by this tag - for example if the journal stored the events as json it may try to find those with the field <code>tag</code> set to this value etc.).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L238-L252" target="_blank" title="Go to snippet source"></a><code class="language-scala">// assuming journal is able to work with numeric offsets we can:

val completedOrders: Source[EventEnvelope, NotUsed] =
  readJournal.eventsByTag(&quot;order-completed&quot;, Offset.noOffset)

// find first 10 completed orders:
val firstCompleted: Future[Vector[OrderCompleted]] =
  completedOrders
    .map(_.event)
    .collectType[OrderCompleted]
    .take(10) // cancels the query stream after pulling 10 elements
    .runFold(Vector.empty[OrderCompleted])(_ :+ _)

// start another query, from the known offset
val furtherOrders = readJournal.eventsByTag(&quot;order-completed&quot;, offset = Sequence(10))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L268-L288" target="_blank" title="Go to snippet source"></a><code class="language-java">// assuming journal is able to work with numeric offsets we can:
final Source&lt;EventEnvelope, NotUsed&gt; completedOrders =
    readJournal.eventsByTag(&quot;order-completed&quot;, new Sequence(0L));

// find first 10 completed orders:
final CompletionStage&lt;List&lt;OrderCompleted&gt;&gt; firstCompleted =
    completedOrders
        .map(EventEnvelope::event)
        .collectType(OrderCompleted.class)
        .take(10) // cancels the query stream after pulling 10 elements
        .runFold(
            new ArrayList&lt;&gt;(10),
            (acc, e) -&gt; {
              acc.add(e);
              return acc;
            },
            system);

// start another query, from the known offset
Source&lt;EventEnvelope, NotUsed&gt; furtherOrders =
    readJournal.eventsByTag(&quot;order-completed&quot;, new Sequence(10));</code></pre></dd>
</dl>
<p>As you can see, we can use all the usual stream operators available from <a href="stream/index.html">Streams</a> on the resulting query stream, including for example taking the first 10 and cancelling the stream. It is worth pointing out that the built-in <code>EventsByTag</code> query has an optionally supported offset parameter (of type <code>Long</code>) which the journals can use to implement resumable-streams. For example a journal may be able to use a WHERE clause to begin the read starting from a specific row, or in a datastore that is able to order events by insertion time it could treat the Long as a timestamp and select only older events.</p>
<p>If your usage does not require a live stream, you can use the <code>currentEventsByTag</code> query.</p>
<h3><a href="#materialized-values-of-queries" name="materialized-values-of-queries" class="anchor"><span class="anchor-link"></span></a>Materialized values of queries</h3>
<p>Journals are able to provide additional information related to a query by exposing <a href="stream/stream-quickstart.html#materialized-values-quick">Materialized values</a>, which are a feature of <a href="stream/index.html">Streams</a> that allows to expose additional values at stream materialization time.</p>
<p>More advanced query journals may use this technique to expose information about the character of the materialized stream, for example if it&rsquo;s finite or infinite, strictly ordered or not ordered at all. The materialized value type is defined as the second type parameter of the returned <code>Source</code>, which allows journals to provide users with their specialised query object, as demonstrated in the sample below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L30-L33" target="_blank" title="Go to snippet source"></a><code class="language-scala">final case class RichEvent(tags: Set[String], payload: Any)

// a plugin can provide:
case class QueryMetadata(deterministicOrder: Boolean, infinite: Boolean)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L36-L58" target="_blank" title="Go to snippet source"></a><code class="language-java">static class RichEvent {
  public final Set&lt;String&gt; tags;
  public final Object payload;

  public RichEvent(Set&lt;String&gt; tags, Object payload) {
    this.tags = tags;
    this.payload = payload;
  }
}
// a plugin can provide:
static final class QueryMetadata {
  public final boolean deterministicOrder;
  public final boolean infinite;

  public QueryMetadata(boolean deterministicOrder, boolean infinite) {
    this.deterministicOrder = deterministicOrder;
    this.infinite = infinite;
  }
}</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L96" target="_blank" title="Go to snippet source"></a><code class="language-scala">def byTagsWithMeta(tags: Set[String]): Source[RichEvent, QueryMetadata] = {</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L146" target="_blank" title="Go to snippet source"></a><code class="language-java">public Source&lt;RichEvent, QueryMetadata&gt; byTagsWithMeta(Set&lt;String&gt; tags) {</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L261-L275" target="_blank" title="Go to snippet source"></a><code class="language-scala">val query: Source[RichEvent, QueryMetadata] =
  readJournal.byTagsWithMeta(Set(&quot;red&quot;, &quot;blue&quot;))

query
  .mapMaterializedValue { meta =&gt;
    println(
      s&quot;The query is: &quot; +
      s&quot;ordered deterministically: ${meta.deterministicOrder}, &quot; +
      s&quot;infinite: ${meta.infinite}&quot;)
  }
  .map { event =&gt;
    println(s&quot;Event payload: ${event.payload}&quot;)
  }
  .runWith(Sink.ignore)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L301-L327" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>Set&lt;String&gt; tags = new HashSet&lt;String&gt;();
tags.add(&quot;red&quot;);
tags.add(&quot;blue&quot;);
final Source&lt;RichEvent, QueryMetadata&gt; events =
    readJournal
        .byTagsWithMeta(tags)
        .mapMaterializedValue(
            meta -&gt; {
              System.out.println(
                  &quot;The query is: &quot;
                      + &quot;ordered deterministically: &quot;
                      + meta.deterministicOrder
                      + &quot; &quot;
                      + &quot;infinite: &quot;
                      + meta.infinite);
              return meta;
            });

events
    .map(
        event -&gt; {
          System.out.println(&quot;Event payload: &quot; + event.payload);
          return event.payload;
        })
    .runWith(Sink.ignore(), system);
</code></pre></dd>
</dl>
<h2><a href="#performance-and-denormalization" name="performance-and-denormalization" class="anchor"><span class="anchor-link"></span></a>Performance and denormalization</h2>
<p>When building systems using <a href="typed/persistence.html#event-sourcing-concepts">Event sourcing</a> and CQRS ([Command &amp; Query Responsibility Segregation](<a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj554200(v=pandp.10)?redirectedfrom=MSDN)">https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj554200(v=pandp.10)?redirectedfrom=MSDN)</a>) techniques it is tremendously important to realise that the write-side has completely different needs from the read-side, and separating those concerns into datastores that are optimised for either side makes it possible to offer the best experience for the write and read sides independently.</p>
<p>For example, in a bidding system it is important to &ldquo;take the write&rdquo; and respond to the bidder that we have accepted the bid as soon as possible, which means that write-throughput is of highest importance for the write-side – often this means that data stores which are able to scale to accommodate these requirements have a less expressive query side.</p>
<p>On the other hand the same application may have some complex statistics view or we may have analysts working with the data to figure out best bidding strategies and trends – this often requires some kind of expressive query capabilities like for example SQL or writing Spark jobs to analyse the data. Therefore the data stored in the write-side needs to be projected into the other read-optimised datastore.</p><div class="callout note "><div class="callout-title">Note</div>
<p>When referring to <strong>Materialized Views</strong> in Akka Persistence think of it as &ldquo;some persistent storage of the result of a Query&rdquo;. In other words, it means that the view is created once, in order to be afterwards queried multiple times, as in this format it may be more efficient or interesting to query it (instead of the source events directly).</p></div>
<h3><a href="#materialize-view-to-reactive-streams-compatible-datastore" name="materialize-view-to-reactive-streams-compatible-datastore" class="anchor"><span class="anchor-link"></span></a>Materialize view to Reactive Streams compatible datastore</h3>
<p>If the read datastore exposes a <a href="https://www.reactive-streams.org">Reactive Streams</a> interface then implementing a simple projection is as simple as, using the read-journal and feeding it into the databases driver interface, for example like so:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L153-L166" target="_blank" title="Go to snippet source"></a><code class="language-scala">implicit val system = ActorSystem()

val readJournal =
  PersistenceQuery(system).readJournalFor[MyScaladslReadJournal](JournalId)
val dbBatchWriter: Subscriber[immutable.Seq[Any]] =
  ReactiveStreamsCompatibleDBDriver.batchWriter

// Using an example (Reactive Streams) Database driver
readJournal
  .eventsByPersistenceId(&quot;user-1337&quot;, fromSequenceNr = 0L, toSequenceNr = Long.MaxValue)
  .map(envelope =&gt; envelope.event)
  .map(convertToReadSideTypes) // convert to datatype
  .grouped(20) // batch inserts into groups of 20
  .runWith(Sink.fromSubscriber(dbBatchWriter)) // write batches to read-side database</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L346-L354" target="_blank" title="Go to snippet source"></a><code class="language-java">final ReactiveStreamsCompatibleDBDriver driver = new ReactiveStreamsCompatibleDBDriver();
final Subscriber&lt;List&lt;Object&gt;&gt; dbBatchWriter = driver.batchWriter();

// Using an example (Reactive Streams) Database driver
readJournal
    .eventsByPersistenceId(&quot;user-1337&quot;, 0L, Long.MAX_VALUE)
    .map(envelope -&gt; envelope.event())
    .grouped(20) // batch inserts into groups of 20
    .runWith(Sink.fromSubscriber(dbBatchWriter), system); // write batches to read-side database</code></pre></dd>
</dl>
<h3><a href="#materialize-view-using-mapasync" name="materialize-view-using-mapasync" class="anchor"><span class="anchor-link"></span></a>Materialize view using mapAsync</h3>
<p>If the target database does not provide a reactive streams <code>Subscriber</code> that can perform writes, you may have to implement the write logic using plain functions or Actors instead.</p>
<p>In case your write logic is state-less and you need to convert the events from one data type to another before writing into the alternative datastore, then the projection will look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L325-L327" target="_blank" title="Go to snippet source"></a><code class="language-scala">trait ExampleStore {
  def save(event: Any): Future[Unit]
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L359-L366" target="_blank" title="Go to snippet source"></a><code class="language-java">static class ExampleStore {
  CompletionStage&lt;Void&gt; save(Object any) {
    // ...
  }
}</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L331-L338" target="_blank" title="Go to snippet source"></a><code class="language-scala">val store: ExampleStore = ???

readJournal
  .eventsByTag(&quot;bid&quot;, NoOffset)
  .mapAsync(1) { e =&gt;
    store.save(e)
  }
  .runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L378-L383" target="_blank" title="Go to snippet source"></a><code class="language-java">final ExampleStore store = new ExampleStore();

readJournal
    .eventsByTag(&quot;bid&quot;, new Sequence(0L))
    .mapAsync(1, store::save)
    .runWith(Sink.ignore(), system);</code></pre></dd>
</dl>
<h3><a href="#resumable-projections" name="resumable-projections" class="anchor"><span class="anchor-link"></span></a>Resumable projections</h3>
<p>Sometimes you may need to implement &ldquo;resumable&rdquo; projections, that will not start from the beginning of time each time when run. In this case you will need to store the sequence number (or <code>offset</code>) of the processed event and use it the next time this projection is started. This pattern is not built-in, however is rather simple to implement yourself.</p>
<p>The example below additionally highlights how you would use Actors to implement the write side, in case you need to do some complex logic that would be best handled inside an Actor before persisting the event into the other datastore:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L293-L316" target="_blank" title="Go to snippet source"></a><code class="language-scala">def runQuery(writer: ActorRef[TheOneWhoWritesToQueryJournal.Command])(implicit system: ActorSystem[_]): Unit = {

  val readJournal =
    PersistenceQuery(system.toClassic).readJournalFor[MyScaladslReadJournal](JournalId)

  import system.executionContext
  implicit val timeout = Timeout(3.seconds)

  val bidProjection = new MyResumableProjection(&quot;bid&quot;)

  bidProjection.latestOffset.foreach { startFromOffset =&gt;
    readJournal
      .eventsByTag(&quot;bid&quot;, Sequence(startFromOffset))
      .mapAsync(8) { envelope =&gt;
        writer
          .ask((replyTo: ActorRef[Done]) =&gt; TheOneWhoWritesToQueryJournal.Update(envelope.event, replyTo))
          .map(_ =&gt; envelope.offset)
      }
      .mapAsync(1) { offset =&gt;
        bidProjection.saveProgress(offset)
      }
      .runWith(Sink.ignore)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/ResumableProjectionExample.java#L38-L62" target="_blank" title="Go to snippet source"></a><code class="language-java">  final Duration timeout = Duration.ofSeconds(3);

  final MyResumableProjection bidProjection = new MyResumableProjection(&quot;bid&quot;);

  long startFromOffset =
      bidProjection.latestOffset().toCompletableFuture().get(3, TimeUnit.SECONDS);

  readJournal
      .eventsByTag(&quot;bid&quot;, new Sequence(startFromOffset))
      .mapAsync(
          8,
          envelope -&gt; {
            final CompletionStage&lt;Done&gt; f =
                AskPattern.ask(
                    writer,
                    (ActorRef&lt;Done&gt; replyTo) -&gt;
                        new TheOneWhoWritesToQueryJournal.Update(envelope.event(), replyTo),
                    timeout,
                    system.scheduler());
            return f.thenApplyAsync(in -&gt; envelope.offset(), system.executionContext());
          })
      .mapAsync(1, offset -&gt; bidProjection.saveProgress(offset))
      .runWith(Sink.ignore(), system);
}
</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L172-L194" target="_blank" title="Go to snippet source"></a><code class="language-scala">object TheOneWhoWritesToQueryJournal {

  sealed trait Command
  final case class Update(payload: Any, replyTo: ActorRef[Done]) extends Command

  def apply(id: String, store: ExampleStore): Behavior[Command] = {
    updated(ComplexState(), store)
  }

  private def updated(state: ComplexState, store: ExampleStore): Behavior[Command] = {
    Behaviors.receiveMessage {
      case command: Update =&gt;
        val newState = updateState(state, command)
        if (state.readyToSave) store.save(Record(state))
        updated(newState, store)
    }
  }

  private def updateState(state: ComplexState, command: Command): ComplexState = {
    // some complicated aggregation logic here ...
    state
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/ResumableProjectionExample.java#L66-L109" target="_blank" title="Go to snippet source"></a><code class="language-java">static final class TheOneWhoWritesToQueryJournal
    extends AbstractBehavior&lt;TheOneWhoWritesToQueryJournal.Command&gt; {

  interface Command {}

  static class Update implements Command {
    public final Object payload;
    public final ActorRef&lt;Done&gt; replyTo;

    Update(Object payload, ActorRef&lt;Done&gt; replyTo) {
      this.payload = payload;
      this.replyTo = replyTo;
    }
  }

  public static Behavior&lt;Command&gt; create(String id, ExampleStore store) {
    return Behaviors.setup(context -&gt; new TheOneWhoWritesToQueryJournal(context, store));
  }

  private final ExampleStore store;

  private ComplexState state = new ComplexState();

  private TheOneWhoWritesToQueryJournal(ActorContext&lt;Command&gt; context, ExampleStore store) {
    super(context);
    this.store = store;
  }

  @Override
  public Receive&lt;Command&gt; createReceive() {
    return newReceiveBuilder().onMessage(Update.class, this::onUpdate).build();
  }

  private Behavior&lt;Command&gt; onUpdate(Update msg) {
    state = updateState(state, msg);
    if (state.readyToSave()) store.save(Record.of(state));
    return this;
  }

  ComplexState updateState(ComplexState state, Update msg) {
    // some complicated aggregation logic here ...
    return state;
  }
}</code></pre></dd>
</dl>
<a id="read-journal-plugin-api"></a>
<h2><a href="#query-plugins" name="query-plugins" class="anchor"><span class="anchor-link"></span></a>Query plugins</h2>
<p>Query plugins are various (mostly community driven) <code>ReadJournal</code> implementations for all kinds of available datastores. The complete list of available plugins is maintained on the Akka Persistence Query <a href="https://akka.io/community/#plugins-to-akka-persistence-query">Community Plugins</a> page.</p>
<p>The plugin for LevelDB is described in <a href="persistence-query-leveldb.html">Persistence Query for LevelDB</a>.</p>
<p>This section aims to provide tips and guide plugin developers through implementing a custom query plugin. Most users will not need to implement journals themselves, except if targeting a not yet supported datastore.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Since different data stores provide different query capabilities journal plugins <strong>must extensively document</strong> their exposed semantics as well as handled query scenarios.</p></div>
<h3><a href="#readjournal-plugin-api" name="readjournal-plugin-api" class="anchor"><span class="anchor-link"></span></a>ReadJournal plugin API</h3>
<p>A read journal plugin must implement <code>akka.persistence.query.ReadJournalProvider</code> which creates instances of <code>akka.persistence.query.scaladsl.ReadJournal</code> and <code>akka.persistence.query.javadsl.ReadJournal</code>. The plugin must implement both the <code>scaladsl</code> and the <code>javadsl</code> <span class="group-scala">traits</span><span class="group-java">interfaces</span> because the <code>akka.stream.scaladsl.Source</code> and <code>akka.stream.javadsl.Source</code> are different types and even though those types can be converted to each other it is most convenient for the end user to get access to the Java or Scala <code>Source</code> directly. As illustrated below one of the implementations can delegate to the other. </p>
<p>Below is a simple journal implementation:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/PersistenceQueryDocSpec.scala#L37-L133" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MyReadJournalProvider(system: ExtendedActorSystem, config: Config) extends ReadJournalProvider {

  override val scaladslReadJournal: MyScaladslReadJournal =
    new MyScaladslReadJournal(system, config)

  override val javadslReadJournal: MyJavadslReadJournal =
    new MyJavadslReadJournal(scaladslReadJournal)
}

class MyScaladslReadJournal(system: ExtendedActorSystem, config: Config)
    extends akka.persistence.query.scaladsl.ReadJournal
    with akka.persistence.query.scaladsl.EventsByTagQuery
    with akka.persistence.query.scaladsl.EventsByPersistenceIdQuery
    with akka.persistence.query.scaladsl.PersistenceIdsQuery
    with akka.persistence.query.scaladsl.CurrentPersistenceIdsQuery {

  private val refreshInterval: FiniteDuration =
    config.getDuration(&quot;refresh-interval&quot;, MILLISECONDS).millis

  /**
   * You can use `NoOffset` to retrieve all events with a given tag or retrieve a subset of all
   * events by specifying a `Sequence` `offset`. The `offset` corresponds to an ordered sequence number for
   * the specific tag. Note that the corresponding offset of each event is provided in the
   * [[akka.persistence.query.EventEnvelope]], which makes it possible to resume the
   * stream at a later point from a given offset.
   *
   * The `offset` is exclusive, i.e. the event with the exact same sequence number will not be included
   * in the returned stream. This means that you can use the offset that is returned in `EventEnvelope`
   * as the `offset` parameter in a subsequent query.
   */
  override def eventsByTag(tag: String, offset: Offset): Source[EventEnvelope, NotUsed] = offset match {
    case Sequence(offsetValue) =&gt;
      Source.fromGraph(new MyEventsByTagSource(tag, offsetValue, refreshInterval))
    case NoOffset =&gt; eventsByTag(tag, Sequence(0L)) //recursive
    case _ =&gt;
      throw new IllegalArgumentException(&quot;MyJournal does not support &quot; + offset.getClass.getName + &quot; offsets&quot;)
  }

  override def eventsByPersistenceId(
      persistenceId: String,
      fromSequenceNr: Long,
      toSequenceNr: Long): Source[EventEnvelope, NotUsed] = {
    // implement in a similar way as eventsByTag
    ???
  }

  override def persistenceIds(): Source[String, NotUsed] = {
    // implement in a similar way as eventsByTag
    ???
  }

  override def currentPersistenceIds(): Source[String, NotUsed] = {
    // implement in a similar way as eventsByTag
    ???
  }

  // possibility to add more plugin specific queries

  def byTagsWithMeta(tags: Set[String]): Source[RichEvent, QueryMetadata] = {
    // implement in a similar way as eventsByTag
    ???
  }

}

class MyJavadslReadJournal(scaladslReadJournal: MyScaladslReadJournal)
    extends akka.persistence.query.javadsl.ReadJournal
    with akka.persistence.query.javadsl.EventsByTagQuery
    with akka.persistence.query.javadsl.EventsByPersistenceIdQuery
    with akka.persistence.query.javadsl.PersistenceIdsQuery
    with akka.persistence.query.javadsl.CurrentPersistenceIdsQuery {

  override def eventsByTag(tag: String, offset: Offset = Sequence(0L)): javadsl.Source[EventEnvelope, NotUsed] =
    scaladslReadJournal.eventsByTag(tag, offset).asJava

  override def eventsByPersistenceId(
      persistenceId: String,
      fromSequenceNr: Long = 0L,
      toSequenceNr: Long = Long.MaxValue): javadsl.Source[EventEnvelope, NotUsed] =
    scaladslReadJournal.eventsByPersistenceId(persistenceId, fromSequenceNr, toSequenceNr).asJava

  override def persistenceIds(): javadsl.Source[String, NotUsed] =
    scaladslReadJournal.persistenceIds().asJava

  override def currentPersistenceIds(): javadsl.Source[String, NotUsed] =
    scaladslReadJournal.currentPersistenceIds().asJava

  // possibility to add more plugin specific queries

  def byTagsWithMeta(tags: java.util.Set[String]): javadsl.Source[RichEvent, QueryMetadata] = {
    import akka.util.ccompat.JavaConverters._
    scaladslReadJournal.byTagsWithMeta(tags.asScala.toSet).asJava
  }
}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/PersistenceQueryDocTest.java#L65-L200" target="_blank" title="Go to snippet source"></a><code class="language-java">static class MyReadJournalProvider implements ReadJournalProvider {
  private final MyJavadslReadJournal javadslReadJournal;

  public MyReadJournalProvider(ExtendedActorSystem system, Config config) {
    this.javadslReadJournal = new MyJavadslReadJournal(system, config);
  }

  @Override
  public MyScaladslReadJournal scaladslReadJournal() {
    return new MyScaladslReadJournal(javadslReadJournal);
  }

  @Override
  public MyJavadslReadJournal javadslReadJournal() {
    return this.javadslReadJournal;
  }
}
static class MyJavadslReadJournal
    implements akka.persistence.query.javadsl.ReadJournal,
        akka.persistence.query.javadsl.EventsByTagQuery,
        akka.persistence.query.javadsl.EventsByPersistenceIdQuery,
        akka.persistence.query.javadsl.PersistenceIdsQuery,
        akka.persistence.query.javadsl.CurrentPersistenceIdsQuery {

  private final Duration refreshInterval;
  private Connection conn;

  public MyJavadslReadJournal(ExtendedActorSystem system, Config config) {
    refreshInterval = config.getDuration(&quot;refresh-interval&quot;);
  }

  /**
   * You can use `NoOffset` to retrieve all events with a given tag or retrieve a subset of all
   * events by specifying a `Sequence` `offset`. The `offset` corresponds to an ordered sequence
   * number for the specific tag. Note that the corresponding offset of each event is provided in
   * the [[akka.persistence.query.EventEnvelope]], which makes it possible to resume the stream at
   * a later point from a given offset.
   *
   * &lt;p&gt;The `offset` is exclusive, i.e. the event with the exact same sequence number will not be
   * included in the returned stream. This means that you can use the offset that is returned in
   * `EventEnvelope` as the `offset` parameter in a subsequent query.
   */
  @Override
  public Source&lt;EventEnvelope, NotUsed&gt; eventsByTag(String tag, Offset offset) {
    if (offset instanceof Sequence) {
      Sequence sequenceOffset = (Sequence) offset;
      return Source.fromGraph(
          new MyEventsByTagSource(conn, tag, sequenceOffset.value(), refreshInterval));
    } else if (offset == NoOffset.getInstance())
      return eventsByTag(tag, Offset.sequence(0L)); // recursive
    else
      throw new IllegalArgumentException(
          &quot;MyJavadslReadJournal does not support &quot; + offset.getClass().getName() + &quot; offsets&quot;);
  }

  @Override
  public Source&lt;EventEnvelope, NotUsed&gt; eventsByPersistenceId(
      String persistenceId, long fromSequenceNr, long toSequenceNr) {
    // implement in a similar way as eventsByTag
    throw new UnsupportedOperationException(&quot;Not implemented yet&quot;);
  }

  @Override
  public Source&lt;String, NotUsed&gt; persistenceIds() {
    // implement in a similar way as eventsByTag
    throw new UnsupportedOperationException(&quot;Not implemented yet&quot;);
  }

  @Override
  public Source&lt;String, NotUsed&gt; currentPersistenceIds() {
    // implement in a similar way as eventsByTag
    throw new UnsupportedOperationException(&quot;Not implemented yet&quot;);
  }

  // possibility to add more plugin specific queries

  public Source&lt;RichEvent, QueryMetadata&gt; byTagsWithMeta(Set&lt;String&gt; tags) {
    // implement in a similar way as eventsByTag
    throw new UnsupportedOperationException(&quot;Not implemented yet&quot;);
  }
}
static class MyScaladslReadJournal
    implements akka.persistence.query.scaladsl.ReadJournal,
        akka.persistence.query.scaladsl.EventsByTagQuery,
        akka.persistence.query.scaladsl.EventsByPersistenceIdQuery,
        akka.persistence.query.scaladsl.PersistenceIdsQuery,
        akka.persistence.query.scaladsl.CurrentPersistenceIdsQuery {

  private final MyJavadslReadJournal javadslReadJournal;

  public MyScaladslReadJournal(MyJavadslReadJournal javadslReadJournal) {
    this.javadslReadJournal = javadslReadJournal;
  }

  @Override
  public akka.stream.scaladsl.Source&lt;EventEnvelope, NotUsed&gt; eventsByTag(
      String tag, akka.persistence.query.Offset offset) {
    return javadslReadJournal.eventsByTag(tag, offset).asScala();
  }

  @Override
  public akka.stream.scaladsl.Source&lt;EventEnvelope, NotUsed&gt; eventsByPersistenceId(
      String persistenceId, long fromSequenceNr, long toSequenceNr) {
    return javadslReadJournal
        .eventsByPersistenceId(persistenceId, fromSequenceNr, toSequenceNr)
        .asScala();
  }

  @Override
  public akka.stream.scaladsl.Source&lt;String, NotUsed&gt; persistenceIds() {
    return javadslReadJournal.persistenceIds().asScala();
  }

  @Override
  public akka.stream.scaladsl.Source&lt;String, NotUsed&gt; currentPersistenceIds() {
    return javadslReadJournal.currentPersistenceIds().asScala();
  }

  // possibility to add more plugin specific queries

  public akka.stream.scaladsl.Source&lt;RichEvent, QueryMetadata&gt; byTagsWithMeta(
      scala.collection.Set&lt;String&gt; tags) {
    Set&lt;String&gt; jTags = scala.collection.JavaConverters.setAsJavaSetConverter(tags).asJava();
    return javadslReadJournal.byTagsWithMeta(jTags).asScala();
  }
}</code></pre></dd>
</dl>
<p>And the <code>eventsByTag</code> could be backed by a GraphStage for example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/scala/docs/persistence/query/MyEventsByTagSource.scala#L16-L105" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MyEventsByTagSource(tag: String, offset: Long, refreshInterval: FiniteDuration)
    extends GraphStage[SourceShape[EventEnvelope]] {

  private case object Continue
  val out: Outlet[EventEnvelope] = Outlet(&quot;MyEventByTagSource.out&quot;)
  override def shape: SourceShape[EventEnvelope] = SourceShape(out)

  override protected def initialAttributes: Attributes = Attributes(ActorAttributes.IODispatcher)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new TimerGraphStageLogic(shape) with OutHandler {
      lazy val system = materializer.system
      private val Limit = 1000
      private val connection: java.sql.Connection = ???
      private var currentOffset = offset
      private var buf = Vector.empty[EventEnvelope]
      private val serialization = SerializationExtension(system)

      override def preStart(): Unit = {
        scheduleWithFixedDelay(Continue, refreshInterval, refreshInterval)
      }

      override def onPull(): Unit = {
        query()
        tryPush()
      }

      override def onDownstreamFinish(): Unit = {
        // close connection if responsible for doing so
      }

      private def query(): Unit = {
        if (buf.isEmpty) {
          try {
            buf = Select.run(tag, currentOffset, Limit)
          } catch {
            case NonFatal(e) =&gt;
              failStage(e)
          }
        }
      }

      private def tryPush(): Unit = {
        if (buf.nonEmpty &amp;&amp; isAvailable(out)) {
          push(out, buf.head)
          buf = buf.tail
        }
      }

      override protected def onTimer(timerKey: Any): Unit = timerKey match {
        case Continue =&gt;
          query()
          tryPush()
      }

      object Select {
        private def statement() =
          connection.prepareStatement(&quot;&quot;&quot;
            SELECT id, persistence_id, seq_nr, serializer_id, serializer_manifest, payload 
            FROM journal WHERE tag = ? AND id &gt; ? 
            ORDER BY id LIMIT ?
      &quot;&quot;&quot;)

        def run(tag: String, from: Long, limit: Int): Vector[EventEnvelope] = {
          val s = statement()
          try {
            s.setString(1, tag)
            s.setLong(2, from)
            s.setLong(3, limit)
            val rs = s.executeQuery()

            val b = Vector.newBuilder[EventEnvelope]
            while (rs.next()) {
              val deserialized = serialization
                .deserialize(rs.getBytes(&quot;payload&quot;), rs.getInt(&quot;serializer_id&quot;), rs.getString(&quot;serializer_manifest&quot;))
                .get
              currentOffset = rs.getLong(&quot;id&quot;)
              b += EventEnvelope(
                Offset.sequence(currentOffset),
                rs.getString(&quot;persistence_id&quot;),
                rs.getLong(&quot;seq_nr&quot;),
                deserialized)
            }
            b.result()
          } finally s.close()
        }
      }
    }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/test/java/jdocs/persistence/query/MyEventsByTagSource.java#L28-L135" target="_blank" title="Go to snippet source"></a><code class="language-java">public class MyEventsByTagSource extends GraphStage&lt;SourceShape&lt;EventEnvelope&gt;&gt; {
  public Outlet&lt;EventEnvelope&gt; out = Outlet.create(&quot;MyEventByTagSource.out&quot;);
  private static final String QUERY =
      &quot;SELECT id, persistence_id, seq_nr, serializer_id, serializer_manifest, payload &quot;
          + &quot;FROM journal WHERE tag = ? AND id &gt; ? &quot;
          + &quot;ORDER BY id LIMIT ?&quot;;

  enum Continue {
    INSTANCE;
  }

  private static final int LIMIT = 1000;
  private final Connection connection;
  private final String tag;
  private final long initialOffset;
  private final Duration refreshInterval;

  // assumes a shared connection, could also be a factory for creating connections/pool
  public MyEventsByTagSource(
      Connection connection, String tag, long initialOffset, Duration refreshInterval) {
    this.connection = connection;
    this.tag = tag;
    this.initialOffset = initialOffset;
    this.refreshInterval = refreshInterval;
  }

  @Override
  public Attributes initialAttributes() {
    return Attributes.apply(ActorAttributes.IODispatcher());
  }

  @Override
  public SourceShape&lt;EventEnvelope&gt; shape() {
    return SourceShape.of(out);
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new TimerGraphStageLogic(shape()) {
      private ActorSystem system = materializer().system();
      private long currentOffset = initialOffset;
      private List&lt;EventEnvelope&gt; buf = new LinkedList&lt;&gt;();
      private final Serialization serialization = SerializationExtension.get(system);

      @Override
      public void preStart() {
        schedulePeriodically(Continue.INSTANCE, refreshInterval);
      }

      @Override
      public void onTimer(Object timerKey) {
        query();
        deliver();
      }

      private void deliver() {
        if (isAvailable(out) &amp;&amp; !buf.isEmpty()) {
          push(out, buf.remove(0));
        }
      }

      private void query() {
        if (buf.isEmpty()) {

          try (PreparedStatement s = connection.prepareStatement(QUERY)) {
            s.setString(1, tag);
            s.setLong(2, currentOffset);
            s.setLong(3, LIMIT);
            try (ResultSet rs = s.executeQuery()) {
              final List&lt;EventEnvelope&gt; res = new ArrayList&lt;&gt;(LIMIT);
              while (rs.next()) {
                Object deserialized =
                    serialization
                        .deserialize(
                            rs.getBytes(&quot;payload&quot;),
                            rs.getInt(&quot;serializer_id&quot;),
                            rs.getString(&quot;serializer_manifest&quot;))
                        .get();
                currentOffset = rs.getLong(&quot;id&quot;);
                res.add(
                    new EventEnvelope(
                        Offset.sequence(currentOffset),
                        rs.getString(&quot;persistence_id&quot;),
                        rs.getLong(&quot;seq_nr&quot;),
                        deserialized));
              }
              buf = res;
            }
          } catch (Exception e) {
            failStage(e);
          }
        }
      }

      {
        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() {
                query();
                deliver();
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<p>The <code>ReadJournalProvider</code> class must have a constructor with one of these signatures:</p>
<ul>
  <li>constructor with a <code>ExtendedActorSystem</code> parameter, a <code>com.typesafe.config.Config</code> parameter, and a <code>String</code> parameter for the config path</li>
  <li>constructor with a <code>ExtendedActorSystem</code> parameter, and a <code>com.typesafe.config.Config</code> parameter</li>
  <li>constructor with one <code>ExtendedActorSystem</code> parameter</li>
  <li>constructor without parameters</li>
</ul>
<p>The plugin section of the actor system&rsquo;s config will be passed in the config constructor parameter. The config path of the plugin is passed in the <code>String</code> parameter.</p>
<p>If the underlying datastore only supports queries that are completed when they reach the end of the &ldquo;result set&rdquo;, the journal has to submit new queries after a while in order to support &ldquo;infinite&rdquo; event streams that include events stored after the initial query has completed. It is recommended that the plugin use a configuration property named <code>refresh-interval</code> for defining such a refresh interval. </p>
<h2><a href="#scaling-out" name="scaling-out" class="anchor"><span class="anchor-link"></span></a>Scaling out</h2>
<p>In a use case where the number of events are very high, the work needed for each event is high or where resilience is important so that if a node crashes the persistent queries are quickly started on a new node and can resume operations <a href="cluster-sharding.html">Cluster Sharding</a> together with event tagging is an excellent fit to shard events over a cluster.</p>
<p>The <a href="https://www.lagomframework.com">Lagom framework</a>, which is built on top of Akka encodes many of the best practices around this. For more details see <span class="group-java"><a href="https://www.lagomframework.com/documentation/current/java/ES_CQRS.html">Managing Data Persistence</a></span> <span class="group-scala"><a href="https://www.lagomframework.com/documentation/current/scala/ES_CQRS.html">Managing Data Persistence</a></span> and <span class="group-java"><a href="https://www.lagomframework.com/documentation/current/java/PersistentEntity.html">Persistent Entity</a></span> <span class="group-scala"><a href="https://www.lagomframework.com/documentation/current/scala/PersistentEntity.html">Persistent Entity</a></span> in the Lagom documentation.</p>
<h3><a href="#plugin-tck" name="plugin-tck" class="anchor"><span class="anchor-link"></span></a>Plugin TCK</h3>
<p>TODO, not available yet.</p>
<h2><a href="#example-project" name="example-project" class="anchor"><span class="anchor-link"></span></a>Example project</h2>
<p><span class="group-java"><a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-samples-cqrs-java">CQRS example project</a></span> <span class="group-scala"><a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-samples-cqrs-scala">CQRS example project</a></span> is an example project that can be downloaded, and with instructions of how to run.</p>
<p>This project contains a Shopping Cart sample illustrating how to use Akka Persistence. The events are tagged to be consumed by even processors to build other representations from the events, or publish the events to other services.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="persistence-schema-evolution.html"><i class="icon-prev"></i> <span class="link-prev">Schema Evolution for Event Sourced Actors</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="persistence-query-leveldb.html">Persistence Query for LevelDB <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.6.6/akka-docs/src/main/paradox/persistence-query.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg" />
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2020 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>
<script type="text/javascript" src="js/metadata-toggle.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
