<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Actors &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/typed/actors.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.11
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/actors.html#actors" class="active page">Actors</a>
    <ul>
      <li><a href="../typed/actors.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/actors.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/actors.html#a-more-complex-example" class="header">A More Complex Example</a></li>
      <li><a href="../typed/actors.html#relation-to-akka-untyped-actors" class="header">Relation to Akka (untyped) Actors</a></li>
      <li><a href="../typed/actors.html#a-little-bit-of-theory" class="header">A Little Bit of Theory</a></li>
    </ul></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.11
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/actors.html#actors" class="active page">Actors</a>
    <ul>
      <li><a href="../typed/actors.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/actors.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/actors.html#a-more-complex-example" class="header">A More Complex Example</a></li>
      <li><a href="../typed/actors.html#relation-to-akka-untyped-actors" class="header">Relation to Akka (untyped) Actors</a></li>
      <li><a href="../typed/actors.html#a-little-bit-of-theory" class="header">A Little Bit of Theory</a></li>
    </ul></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#actors" name="actors" class="anchor"><span class="anchor-link"></span></a>Actors</h1><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="../common/may-change.html">may change</a> in the sense  of being the subject of active research. This means that API or semantics can  change without warning or deprecation period and it is not recommended to use  this module in production just yet—you have been warned.</p></div>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Actor Typed add the following dependency:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor-typed" % "2.5.11"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor-typed_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5.11&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor-typed_2.12', version: '2.5.11'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>As discussed in <a href="../general/actor-systems.html">Actor Systems</a> Actors are about sending messages between independent units of computation, but how does that look like?</p>
<p>In all of the following these imports are assumed:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import java.net.URLEncoder
import java.nio.charset.StandardCharsets

import akka.NotUsed
import akka.actor.typed.scaladsl.AskPattern._
import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ ActorRef, ActorSystem, Behavior, Terminated }
import akka.testkit.typed.scaladsl.ActorTestKit

import scala.concurrent.duration._
import scala.concurrent.{ Await, Future }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.Behavior;
import akka.actor.typed.Terminated;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.AskPattern;
import akka.util.Timeout;
</code></pre></dd>
</dl>
<p>With these in place we can define our first Actor, and of course it will say hello!</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String)

  val greeter = Behaviors.immutable[Greet] { (_, msg) ⇒
    println(s&quot;Hello ${msg.whom}!&quot;)
    msg.replyTo ! Greeted(msg.whom)
    Behaviors.same
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public abstract static class HelloWorld {
  //no instances of this class, it&#39;s only a name space for messages
  // and static methods
  private HelloWorld() {
  }

  public static final class Greet{
    public final String whom;
    public final ActorRef&lt;Greeted&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeted&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  public static final class Greeted {
    public final String whom;

    public Greeted(String whom) {
      this.whom = whom;
    }
  }

  public static final Behavior&lt;Greet&gt; greeter = Behaviors.immutable((ctx, msg) -&gt; {
    System.out.println(&quot;Hello &quot; + msg.whom + &quot;!&quot;);
    msg.replyTo.tell(new Greeted(msg.whom));
    return Behaviors.same();
  });
}</code></pre></dd>
</dl>
<p>This small piece of code defines two message types, one for commanding the Actor to greet someone and one that the Actor will use to confirm that it has done so. The <code>Greet</code> type contains not only the information of whom to greet, it also holds an <code>ActorRef</code> that the sender of the message supplies so that the <code>HelloWorld</code> Actor can send back the confirmation message.</p>
<p>The behavior of the Actor is defined as the <code>greeter</code> value with the help of the <code>immutable</code> behavior constructor. This constructor is called immutable because the behavior instance doesn&rsquo;t have or close over any mutable state. Processing the next message may result in a new behavior that can potentially be different from this one. State is updated by returning a new behavior that holds the new immutable state. In this case we don&rsquo;t need to update any state, so we return <code>Same</code>.</p>
<p>The type of the messages handled by this behavior is declared to be of class <code>Greet</code>, meaning that <code>msg</code> argument is also typed as such. This is why we can access the <code>whom</code> and <code>replyTo</code> members without needing to use a pattern match.</p>
<p>On the last line we see the <code>HelloWorld</code> Actor send a message to another Actor, which is done using the <span class="group-scala"><code>!</code> operator (pronounced “bang” or “tell”).</span><span class="group-java"><code>tell</code> method.</span> Since the <code>replyTo</code> address is declared to be of type <span class="group-scala"><code>ActorRef[Greeted]</code></span><span class="group-java"><code>ActorRef&lt;Greeted&gt;</code></span>, the compiler will only permit us to send messages of this type, other usage will not be accepted.</p>
<p>The accepted message types of an Actor together with all reply types defines the protocol spoken by this Actor; in this case it is a simple request–reply protocol but Actors can model arbitrarily complex protocols when needed. The protocol is bundled together with the behavior that implements it in a nicely wrapped scope—the <code>HelloWorld</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>Now we want to try out this Actor, so we must start an ActorSystem to host it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import HelloWorld._
// using global pool since we want to run tasks after system.terminate
import scala.concurrent.ExecutionContext.Implicits.global

val system: ActorSystem[Greet] = ActorSystem(greeter, &quot;hello&quot;)

val future: Future[Greeted] = system ? (Greet(&quot;world&quot;, _))

for {
  greeting ← future.recover { case ex ⇒ ex.getMessage }
  done ← {
    println(s&quot;result: $greeting&quot;)
    system.terminate()
  }
} println(&quot;system terminated&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">final ActorSystem&lt;HelloWorld.Greet&gt; system =
  ActorSystem.create(HelloWorld.greeter, &quot;hello&quot;);

final CompletionStage&lt;HelloWorld.Greeted&gt; reply =
  AskPattern.ask(system,
    (ActorRef&lt;HelloWorld.Greeted&gt; replyTo) -&gt; new HelloWorld.Greet(&quot;world&quot;, replyTo),
    new Timeout(3, TimeUnit.SECONDS), system.scheduler());

reply.thenAccept(greeting -&gt; {
  System.out.println(&quot;result: &quot; + greeting.whom);
  system.terminate();
});</code></pre></dd>
</dl>
<p>After importing the Actor’s protocol definition we start an Actor system from the defined <code>greeter</code> behavior.</p>
<p>As Carl Hewitt said, one Actor is no Actor—it would be quite lonely with nobody to talk to. In this sense the example is a little cruel because we only give the <code>HelloWorld</code> Actor a fake person to talk to—the “ask” pattern (represented by the <code>?</code> operator) can be used to send a message such that the reply fulfills a <span class="group-scala"><code>Promise</code> to which we get back the corresponding <code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>.</p><div class="group-scala">
<p>Note that the <code>Future</code> that is returned by the “ask” operation is properly typed already, no type checks or casts needed. This is possible due to the type information that is part of the message protocol: the <code>?</code> operator takes as argument a function that accepts an <code>ActorRef[U]</code> (which explains the <code>_</code> hole in the expression on line 7 above) and the <code>replyTo</code> parameter which we fill in is of type <code>ActorRef[Greeted]</code>, which means that the value that fulfills the <code>Promise</code> can only be of type <code>Greeted</code>.</p></div><div class="group-java">
<p>Note that the <code>CompletionStage</code> that is returned by the “ask” operation is properly typed already, no type checks or casts needed. This is possible due to the type information that is part of the message protocol: the <code>ask</code> operator takes as argument a function that pass an <code>ActorRef&lt;U&gt;</code>, which is the <code>replyTo</code> parameter of the <code>Greet</code> message, which means that when sending the reply message to that <code>ActorRef</code> the message that fulfills the <code>CompletionStage</code> can only be of type <code>Greeted</code>.</p></div>
<p>We use this here to send the <code>Greet</code> command to the Actor and when the reply comes back we will print it out and tell the actor system to shut down.</p><div class="group-scala">
<p>The <code>recovery</code> combinator on the original <code>Future</code> is needed in order to ensure proper system shutdown even in case something went wrong; the <code>flatMap</code> and <code>map</code> combinators that the <code>for</code> expression gets turned into care only about the “happy path” and if the <code>future</code> failed with a timeout then no <code>greeting</code> would be extracted and nothing would happen.</p></div>
<p>In the next section we demonstrate this on a more realistic example.</p>
<h2><a href="#a-more-complex-example" name="a-more-complex-example" class="anchor"><span class="anchor-link"></span></a>A More Complex Example</h2>
<p>The next example demonstrates some important patterns:</p>
<ul>
  <li>Using a sealed trait and case class/objects to represent multiple messages an actor can receive</li>
  <li>Handle sessions by using child actors</li>
  <li>Handling state by changing behavior</li>
  <li>Using multiple typed actors to represent different parts of a protocol in a type safe way</li>
</ul>
<p>Consider an Actor that runs a chat room: client Actors may connect by sending a message that contains their screen name and then they can post messages. The chat room Actor will disseminate all posted messages to all currently connected client Actors. The protocol definition could look like the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">sealed trait RoomCommand
final case class GetSession(screenName: String, replyTo: ActorRef[SessionEvent])
  extends RoomCommand

sealed trait SessionEvent
final case class SessionGranted(handle: ActorRef[PostMessage]) extends SessionEvent
final case class SessionDenied(reason: String) extends SessionEvent
final case class MessagePosted(screenName: String, message: String) extends SessionEvent

trait SessionCommand
final case class PostMessage(message: String) extends SessionCommand
private final case class NotifyClient(message: MessagePosted) extends SessionCommand</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">static interface RoomCommand {}
public static final class GetSession implements RoomCommand {
  public final String screenName;
  public final ActorRef&lt;SessionEvent&gt; replyTo;
  public GetSession(String screenName, ActorRef&lt;SessionEvent&gt; replyTo) {
    this.screenName = screenName;
    this.replyTo = replyTo;
  }
}

static interface SessionEvent {}
public static final class SessionGranted implements SessionEvent {
  public final ActorRef&lt;PostMessage&gt; handle;
  public SessionGranted(ActorRef&lt;PostMessage&gt; handle) {
    this.handle = handle;
  }
}
public static final class SessionDenied implements SessionEvent {
  public final String reason;
  public SessionDenied(String reason) {
    this.reason = reason;
  }
}
public static final class MessagePosted implements SessionEvent {
  public final String screenName;
  public final String message;
  public MessagePosted(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

static interface SessionCommand {}
public static final class PostMessage implements SessionCommand {
  public final String message;
  public PostMessage(String message) {
    this.message = message;
  }
}
private static final class NotifyClient implements SessionCommand {
  final MessagePosted message;
  NotifyClient(MessagePosted message) {
    this.message = message;
  }
}</code></pre></dd>
</dl>
<p>Initially the client Actors only get access to an <span class="group-scala"><code>ActorRef[GetSession]</code></span><span class="group-java"><code>ActorRef&lt;GetSession&gt;</code></span> which allows them to make the first step. Once a client’s session has been established it gets a <code>SessionGranted</code> message that contains a <code>handle</code> to unlock the next protocol step, posting messages. The <code>PostMessage</code> command will need to be sent to this particular address that represents the session that has been added to the chat room. The other aspect of a session is that the client has revealed its own address, via the <code>replyTo</code> argument, so that subsequent <code>MessagePosted</code> events can be sent to it.</p>
<p>This illustrates how Actors can express more than just the equivalent of method calls on Java objects. The declared message types and their contents describe a full protocol that can involve multiple Actors and that can evolve over multiple steps. Here&rsquo;s the implementation of the chat room protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private final case class PublishSessionMessage(screenName: String, message: String)
  extends RoomCommand

val behavior: Behavior[RoomCommand] =
  chatRoom(List.empty)

private def chatRoom(sessions: List[ActorRef[SessionCommand]]): Behavior[RoomCommand] =
  Behaviors.immutable[RoomCommand] { (ctx, msg) ⇒
    msg match {
      case GetSession(screenName, client) ⇒
        // create a child actor for further interaction with the client
        val ses = ctx.spawn(
          session(ctx.self, screenName, client),
          name = URLEncoder.encode(screenName, StandardCharsets.UTF_8.name))
        client ! SessionGranted(ses)
        chatRoom(ses :: sessions)
      case PublishSessionMessage(screenName, message) ⇒
        val notification = NotifyClient(MessagePosted(screenName, message))
        sessions foreach (_ ! notification)
        Behaviors.same
    }
  }

private def session(
  room:       ActorRef[PublishSessionMessage],
  screenName: String,
  client:     ActorRef[SessionEvent]): Behavior[SessionCommand] =
  Behaviors.immutable { (ctx, msg) ⇒
    msg match {
      case PostMessage(message) ⇒
        // from client, publish to others via the room
        room ! PublishSessionMessage(screenName, message)
        Behaviors.same
      case NotifyClient(message) ⇒
        // published from the room
        client ! message
        Behaviors.same
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">private static final class PublishSessionMessage implements RoomCommand {
  public final String screenName;
  public final String message;
  public PublishSessionMessage(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

public static Behavior&lt;RoomCommand&gt; behavior() {
  return chatRoom(new ArrayList&lt;ActorRef&lt;SessionCommand&gt;&gt;());
}

private static Behavior&lt;RoomCommand&gt; chatRoom(List&lt;ActorRef&lt;SessionCommand&gt;&gt; sessions) {
  return Behaviors.immutable(RoomCommand.class)
    .onMessage(GetSession.class, (ctx, getSession) -&gt; {
      ActorRef&lt;SessionEvent&gt; client = getSession.replyTo;
      ActorRef&lt;SessionCommand&gt; ses = ctx.spawn(
          session(ctx.getSelf(), getSession.screenName, client),
          URLEncoder.encode(getSession.screenName, StandardCharsets.UTF_8.name()));
      // narrow to only expose PostMessage
      client.tell(new SessionGranted(ses.narrow()));
      List&lt;ActorRef&lt;SessionCommand&gt;&gt; newSessions = new ArrayList&lt;&gt;(sessions);
      newSessions.add(ses);
      return chatRoom(newSessions);
    })
    .onMessage(PublishSessionMessage.class, (ctx, pub) -&gt; {
      NotifyClient notification =
          new NotifyClient((new MessagePosted(pub.screenName, pub.message)));
      sessions.forEach(s -&gt; s.tell(notification));
      return Behaviors.same();
    })
    .build();
}

public static Behavior&lt;ChatRoom.SessionCommand&gt; session(
    ActorRef&lt;RoomCommand&gt; room,
    String screenName,
    ActorRef&lt;SessionEvent&gt; client) {
  return Behaviors.immutable(ChatRoom.SessionCommand.class)
      .onMessage(PostMessage.class, (ctx, post) -&gt; {
        // from client, publish to others via the room
        room.tell(new PublishSessionMessage(screenName, post.message));
        return Behaviors.same();
      })
      .onMessage(NotifyClient.class, (ctx, notification) -&gt; {
        // published from the room
        client.tell(notification.message);
        return Behaviors.same();
      })
      .build();
}</code></pre></dd>
</dl>
<p>The state is managed by changing behavior rather than using any variables.</p>
<p>When a new <code>GetSession</code> command comes in we add that client to the list that is in the returned behavior. Then we also need to create the session’s <code>ActorRef</code> that will be used to post messages. In this case we want to create a very simple Actor that just repackages the <code>PostMessage</code> command into a <code>PublishSessionMessage</code> command which also includes the screen name.</p>
<p>The behavior that we declare here can handle both subtypes of <code>RoomCommand</code>. <code>GetSession</code> has been explained already and the <code>PublishSessionMessage</code> commands coming from the session Actors will trigger the dissemination of the contained chat room message to all connected clients. But we do not want to give the ability to send <code>PublishSessionMessage</code> commands to arbitrary clients, we reserve that right to the internal session actors we create—otherwise clients could pose as completely different screen names (imagine the <code>GetSession</code> protocol to include authentication information to further secure this). Therefore <code>PublishSessionMessage</code> has <code>private</code> visibility and can&rsquo;t be created outside the <code>ChatRoom</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>If we did not care about securing the correspondence between a session and a screen name then we could change the protocol such that <code>PostMessage</code> is removed and all clients just get an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> to send to. In this case no session actor would be needed and we could just use <span class="group-scala"><code>ctx.self</code></span><span class="group-java"><code>ctx.getSelf()</code></span>. The type-checks work out in that case because <span class="group-scala"><code>ActorRef[-T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> is contravariant in its type parameter, meaning that we can use a <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> wherever an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> is needed—this makes sense because the former simply speaks more languages than the latter. The opposite would be problematic, so passing an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> where <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> is required will lead to a type error.</p>
<h3><a href="#trying-it-out" name="trying-it-out" class="anchor"><span class="anchor-link"></span></a>Trying it out</h3>
<p>In order to see this chat room in action we need to write a client Actor that can use it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import ChatRoom._

val gabbler =
  Behaviors.immutable[SessionEvent] { (_, msg) ⇒
    msg match {
      case SessionGranted(handle) ⇒
        handle ! PostMessage(&quot;Hello World!&quot;)
        Behaviors.same
      case MessagePosted(screenName, message) ⇒
        println(s&quot;message has been posted by &#39;$screenName&#39;: $message&quot;)
        Behaviors.stopped
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static abstract class Gabbler {
  private Gabbler() {
  }

  public static Behavior&lt;ChatRoom.SessionEvent&gt; behavior() {
    return Behaviors.immutable(ChatRoom.SessionEvent.class)
      .onMessage(ChatRoom.SessionDenied.class, (ctx, msg) -&gt; {
        System.out.println(&quot;cannot start chat room session: &quot; + msg.reason);
        return Behaviors.stopped();
      })
      .onMessage(ChatRoom.SessionGranted.class, (ctx, msg) -&gt; {
        msg.handle.tell(new ChatRoom.PostMessage(&quot;Hello World!&quot;));
        return Behaviors.same();
      })
      .onMessage(ChatRoom.MessagePosted.class, (ctx, msg) -&gt; {
        System.out.println(&quot;message has been posted by &#39;&quot; +
          msg.screenName +&quot;&#39;: &quot; + msg.message);
        return Behaviors.stopped();
      })
      .build();
  }

}</code></pre></dd>
</dl>
<p>From this behavior we can create an Actor that will accept a chat room session, post a message, wait to see it published, and then terminate. The last step requires the ability to change behavior, we need to transition from the normal running behavior into the terminated state. This is why here we do not return <code>same</code>, as above, but another special value <code>stopped</code>.</p><div class="group-scala">
<p>Since <code>SessionEvent</code> is a sealed trait the Scala compiler will warn us if we forget to handle one of the subtypes; in this case it reminded us that alternatively to <code>SessionGranted</code> we may also receive a <code>SessionDenied</code> event.</p></div>
<p>Now to try things out we must start both a chat room and a gabbler and of course we do this inside an Actor system. Since there can be only one guardian supervisor we could either start the chat room from the gabbler (which we don’t want—it complicates its logic) or the gabbler from the chat room (which is nonsensical) or we start both of them from a third Actor—our only sensible choice:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val main: Behavior[NotUsed] =
  Behaviors.setup { ctx ⇒
    val chatRoom = ctx.spawn(ChatRoom.behavior, &quot;chatroom&quot;)
    val gabblerRef = ctx.spawn(gabbler, &quot;gabbler&quot;)
    ctx.watch(gabblerRef)
    chatRoom ! GetSession(&quot;ol’ Gabbler&quot;, gabblerRef)

    Behaviors.onSignal {
      case (_, Terminated(ref)) ⇒
        Behaviors.stopped
    }
  }

val system = ActorSystem(main, &quot;ChatRoomDemo&quot;)
Await.result(system.whenTerminated, 3.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Behavior&lt;Void&gt; main = Behaviors.setup(ctx -&gt; {
  ActorRef&lt;ChatRoom.RoomCommand&gt; chatRoom =
    ctx.spawn(ChatRoom.behavior(), &quot;chatRoom&quot;);
  ActorRef&lt;ChatRoom.SessionEvent&gt; gabbler =
      ctx.spawn(Gabbler.behavior(), &quot;gabbler&quot;);
  ctx.watch(gabbler);
  chatRoom.tell(new ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabbler));

  return Behaviors.immutable(Void.class)
    .onSignal(Terminated.class, (c, sig) -&gt; Behaviors.stopped())
    .build();
});

final ActorSystem&lt;Void&gt; system =
  ActorSystem.create(main, &quot;ChatRoomDemo&quot;);

system.getWhenTerminated().toCompletableFuture().get();</code></pre></dd>
</dl>
<p>In good tradition we call the <code>main</code> Actor what it is, it directly corresponds to the <code>main</code> method in a traditional Java application. This Actor will perform its job on its own accord, we do not need to send messages from the outside, so we declare it to be of type <span class="group-scala"><code>NotUsed</code></span><span class="group-java"><code>Void</code></span>. Actors receive not only external messages, they also are notified of certain system events, so-called Signals. In order to get access to those we choose to implement this particular one using the <code>immutable</code> behavior decorator. The provided <code>onSignal</code> function will be invoked for signals (subclasses of <code>Signal</code>) or the <code>onMessage</code> function for user messages.</p>
<p>This particular <code>main</code> Actor is created using <code>Behaviors.onStart</code>, which is like a factory for a behavior. Creation of the behavior instance is deferred until the actor is started, as opposed to <code>Behaviors.immutable</code> that creates the behavior instance immediately before the actor is running. The factory function in <code>onStart</code> is passed the <code>ActorContext</code> as parameter and that can for example be used for spawning child actors. This <code>main</code> Actor creates the chat room and the gabbler and the session between them is initiated, and when the gabbler is finished we will receive the <code>Terminated</code> event due to having called <code>ctx.watch</code> for it. This allows us to shut down the Actor system: when the main Actor terminates there is nothing more to do.</p>
<p>Therefore after creating the Actor system with the <code>main</code> Actor’s <code>Behavior</code> we just await its termination.</p>
<h2><a href="#relation-to-akka-untyped-actors" name="relation-to-akka-untyped-actors" class="anchor"><span class="anchor-link"></span></a>Relation to Akka (untyped) Actors</h2>
<p>The most prominent difference is the removal of the <code>sender()</code> functionality. The solution chosen in Akka Typed is to explicitly include the properly typed reply-to address in the message, which both burdens the user with this task but also places this aspect of protocol design where it belongs.</p>
<p>The other prominent difference is the removal of the <code>Actor</code> trait. In order to avoid closing over unstable references from different execution contexts (e.g. Future transformations) we turned all remaining methods that were on this trait into messages: the behavior receives the <code>ActorContext</code> as an argument during processing and the lifecycle hooks have been converted into Signals.</p>
<p>A side-effect of this is that behaviors can now be tested in isolation without having to be packaged into an Actor, tests can run fully synchronously without having to worry about timeouts and spurious failures. Another side-effect is that behaviors can nicely be composed and decorated, for example <code>Behaviors.tap</code> is not special or using something internal. New combinators can be written as external libraries or tailor-made for each project.</p>
<h2><a href="#a-little-bit-of-theory" name="a-little-bit-of-theory" class="anchor"><span class="anchor-link"></span></a>A Little Bit of Theory</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a> as defined by Hewitt, Bishop and Steiger in 1973 is a computational model that expresses exactly what it means for computation to be distributed. The processing units—Actors—can only communicate by exchanging messages and upon reception of a message an Actor can do the following three fundamental actions:</p>
<ol>
  <li>send a finite number of messages to Actors it knows</li>
  <li>create a finite number of new Actors</li>
  <li>designate the behavior to be applied to the next message</li>
</ol>
<p>The Akka Typed project expresses these actions using behaviors and addresses. Messages can be sent to an address and behind this façade there is a behavior that receives the message and acts upon it. The binding between address and behavior can change over time as per the third point above, but that is not visible on the outside.</p>
<p>With this preamble we can get to the unique property of this project, namely that it introduces static type checking to Actor interactions: addresses are parameterized and only messages that are of the specified type can be sent to them. The association between an address and its type parameter must be made when the address (and its Actor) is created. For this purpose each behavior is also parameterized with the type of messages it is able to process. Since the behavior can change behind the address façade, designating the next behavior is a constrained operation: the successor must handle the same type of messages as its predecessor. This is necessary in order to not invalidate the addresses that refer to this Actor.</p>
<p>What this enables is that whenever a message is sent to an Actor we can statically ensure that the type of the message is one that the Actor declares to handle—we can avoid the mistake of sending completely pointless messages. What we cannot statically ensure, though, is that the behavior behind the address will be in a given state when our message is received. The fundamental reason is that the association between address and behavior is a dynamic runtime property, the compiler cannot know it while it translates the source code.</p>
<p>This is the same as for normal Java objects with internal variables: when compiling the program we cannot know what their value will be, and if the result of a method call depends on those variables then the outcome is uncertain to a degree—we can only be certain that the returned value is of a given type.</p>
<p>We have seen above that the return type of an Actor command is described by the type of reply-to address that is contained within the message. This allows a conversation to be described in terms of its types: the reply will be of type A, but it might also contain an address of type B, which then allows the other Actor to continue the conversation by sending a message of type B to this new address. While we cannot statically express the “current” state of an Actor, we can express the current state of a protocol between two Actors, since that is just given by the last message type that was received or sent.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/index.html"><i class="icon-prev"></i> <span class="link-prev">Akka Typed</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/coexisting.html">Coexistence <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/johanandren/akka/tree/master/akka-docs/src/main/paradox/typed/actors.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2018 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
