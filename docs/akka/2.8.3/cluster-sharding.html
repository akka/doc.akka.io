<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Classic Cluster Sharding &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/cluster-sharding.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page-8.css"/>
<link rel="stylesheet" type="text/css" href="css/banner-2.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png"/>
<link rel="manifest" href="images/manifest.json"/>
<meta name="msapplication-TileImage" content="images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"  type="text/javascript" charset="UTF-8" data-domain-script="28b912e7-09e9-43d5-91e4-3d1897044004" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics NOTE this will stop processing data July 1st 2023. At which point this embed code can be removed-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>

<!-- Google Tag Manager: Updated May 17th 2023 - Cookie Compliance checks have been moved into Google Tag Manager -->
<script type="text/javascript">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>

</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="oss-wrapper">
<div class="oss-brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com">
<img class="lightbend-logo" src="images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="oss-ad no-drop-down">
<nav id="lightbendRotator" class="lightbend-rotator">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Promo Rotator - Lightbend Changed its Software Licensing Model for Akka Technology. [License FAQ] - Akka Banner" href="https://www.lightbend.com/akka/license-faq">
<strong>Lightbend</strong> Changed its Software Licensing Model for Akka Technology. <span class="akka-btn">License FAQ</span>
</a>
</nav>
</div>
</div>
</div>

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a>
  <ul>
    <li><a href="index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="index-cluster.html" class="page">Classic Clustering</a>
    <ul>
      <li><a href="cluster-usage.html" class="page">Classic Cluster Usage</a></li>
      <li><a href="cluster-routing.html" class="page">Classic Cluster Aware Routers</a></li>
      <li><a href="cluster-singleton.html" class="page">Classic Cluster Singleton</a></li>
      <li><a href="distributed-pub-sub.html" class="page">Classic Distributed Publish Subscribe in Cluster</a></li>
      <li><a href="cluster-client.html" class="page">Classic Cluster Client</a></li>
      <li><a href="cluster-sharding.html#classic-cluster-sharding" class="active page">Classic Cluster Sharding</a>
      <ul>
        <li><a href="cluster-sharding.html#module-info" class="header">Module info</a></li>
        <li><a href="cluster-sharding.html#introduction" class="header">Introduction</a></li>
        <li><a href="cluster-sharding.html#basic-example" class="header">Basic example</a></li>
        <li><a href="cluster-sharding.html#how-it-works" class="header">How it works</a></li>
        <li><a href="cluster-sharding.html#sharding-state-store-mode" class="header">Sharding State Store Mode</a></li>
        <li><a href="cluster-sharding.html#proxy-only-mode" class="header">Proxy Only Mode</a></li>
        <li><a href="cluster-sharding.html#passivation" class="header">Passivation</a></li>
        <li><a href="cluster-sharding.html#remembering-entities" class="header">Remembering Entities</a></li>
        <li><a href="cluster-sharding.html#supervision" class="header">Supervision</a></li>
        <li><a href="cluster-sharding.html#graceful-shutdown" class="header">Graceful Shutdown</a></li>
        <li><a href="cluster-sharding.html#removal-of-internal-cluster-sharding-data" class="header">Removal of Internal Cluster Sharding Data</a></li>
        <li><a href="cluster-sharding.html#inspecting-cluster-sharding-state" class="header">Inspecting cluster sharding state</a></li>
        <li><a href="cluster-sharding.html#lease" class="header">Lease</a></li>
        <li><a href="cluster-sharding.html#configuration" class="header">Configuration</a></li>
      </ul></li>
      <li><a href="cluster-metrics.html" class="page">Classic Cluster Metrics Extension</a></li>
      <li><a href="distributed-data.html" class="page">Classic Distributed Data</a></li>
      <li><a href="cluster-dc.html" class="page">Classic Multi-DC Cluster</a></li>
      <li><a href="serialization-classic.html" class="page">Classic Serialization</a></li>
    </ul></li>
    <li><a href="index-network.html" class="page">Classic Networking</a></li>
    <li><a href="index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a>
  <ul>
    <li><a href="index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="index-cluster.html" class="page">Classic Clustering</a>
    <ul>
      <li><a href="cluster-usage.html" class="page">Classic Cluster Usage</a></li>
      <li><a href="cluster-routing.html" class="page">Classic Cluster Aware Routers</a></li>
      <li><a href="cluster-singleton.html" class="page">Classic Cluster Singleton</a></li>
      <li><a href="distributed-pub-sub.html" class="page">Classic Distributed Publish Subscribe in Cluster</a></li>
      <li><a href="cluster-client.html" class="page">Classic Cluster Client</a></li>
      <li><a href="cluster-sharding.html#classic-cluster-sharding" class="active page">Classic Cluster Sharding</a>
      <ul>
        <li><a href="cluster-sharding.html#module-info" class="header">Module info</a></li>
        <li><a href="cluster-sharding.html#introduction" class="header">Introduction</a></li>
        <li><a href="cluster-sharding.html#basic-example" class="header">Basic example</a></li>
        <li><a href="cluster-sharding.html#how-it-works" class="header">How it works</a></li>
        <li><a href="cluster-sharding.html#sharding-state-store-mode" class="header">Sharding State Store Mode</a></li>
        <li><a href="cluster-sharding.html#proxy-only-mode" class="header">Proxy Only Mode</a></li>
        <li><a href="cluster-sharding.html#passivation" class="header">Passivation</a></li>
        <li><a href="cluster-sharding.html#remembering-entities" class="header">Remembering Entities</a></li>
        <li><a href="cluster-sharding.html#supervision" class="header">Supervision</a></li>
        <li><a href="cluster-sharding.html#graceful-shutdown" class="header">Graceful Shutdown</a></li>
        <li><a href="cluster-sharding.html#removal-of-internal-cluster-sharding-data" class="header">Removal of Internal Cluster Sharding Data</a></li>
        <li><a href="cluster-sharding.html#inspecting-cluster-sharding-state" class="header">Inspecting cluster sharding state</a></li>
        <li><a href="cluster-sharding.html#lease" class="header">Lease</a></li>
        <li><a href="cluster-sharding.html#configuration" class="header">Configuration</a></li>
      </ul></li>
      <li><a href="cluster-metrics.html" class="page">Classic Cluster Metrics Extension</a></li>
      <li><a href="distributed-data.html" class="page">Classic Distributed Data</a></li>
      <li><a href="cluster-dc.html" class="page">Classic Multi-DC Cluster</a></li>
      <li><a href="serialization-classic.html" class="page">Classic Serialization</a></li>
    </ul></li>
    <li><a href="index-network.html" class="page">Classic Networking</a></li>
    <li><a href="index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#classic-cluster-sharding" name="classic-cluster-sharding" class="anchor"><span class="anchor-link"></span></a>Classic Cluster Sharding</h1><div class="callout note "><div class="callout-title">Note</div>
<p>Akka Classic pertains to the original Actor APIs, which have been improved by more type safe and guided Actor APIs. Akka Classic is still fully supported and existing applications can continue to use the classic APIs. It is also possible to use the new Actor APIs together with classic actors in the same ActorSystem, see <a href="typed/coexisting.html">coexistence</a>. For new projects we recommend using <a href="typed/actors.html">the new Actor API</a>.</p></div>
<p>For the full documentation of this feature and for new projects see <a href="typed/cluster-sharding.html">Cluster Sharding</a>.</p>
<h2><a href="#module-info" name="module-info" class="anchor"><span class="anchor-link"></span></a>Module info</h2>
<p>The Akka dependencies are available from Akka&rsquo;s library repository. To access them there, you need to configure the URL for this repository.</p><dl class="repository"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">resolvers += "Akka library repository".at("https://repo.akka.io/maven")
</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;project&gt
  ...
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;akka-repository&lt;/id&gt;
      &lt;name>Akka library repository&lt;/name&gt;
      &lt;url>https://repo.akka.io/maven&lt;/url&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt
&lt;/project&gt;
</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">repositories {
    mavenCentral()
    maven {
        url "https://repo.akka.io/maven"
    }
}
</code></pre></dd></dl>
<p>To use Cluster Sharding, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val AkkaVersion = "2.8.3"
libraryDependencies += "com.typesafe.akka" %% "akka-cluster-sharding" % AkkaVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
      &lt;artifactId&gt;akka-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.8.3&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
    &lt;artifactId&gt;akka-cluster-sharding_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("com.typesafe.akka:akka-bom_${versions.ScalaBinary}:2.8.3")

  implementation "com.typesafe.akka:akka-cluster-sharding_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<table class="project-info">
<tr><th colspan="2">Project Info: Akka Cluster Sharding (classic)</th></tr>
  <tr><th>Artifact</th><td><div>com.typesafe.akka</div>
  <div>akka-cluster-sharding</div>
  <div>2.8.3</div>
  <div><a href="project/links.html#snapshots-repository">Snapshots are available</a></div>
  </td></tr>
  <tr><th>JDK versions</th><td><div>Adopt OpenJDK 8</div><div>Adopt OpenJDK 11</div></td></tr>
  <tr><th>Scala versions</th><td>2.13.11, 2.12.18, 3.2.2</td></tr>
  <tr><th>JPMS module name</th><td>akka.cluster.sharding</td></tr>
  <tr><th>License</th><td><div><a href="https://raw.githubusercontent.com/akka/akka/v2.8.3/LICENSE" target="_blank" rel="noopener noreferrer">BUSL-1.1</a></div>
  </td></tr>
  <tr><th>Readiness level</th><td><div class="readiness-level"><a href="https://developer.lightbend.com/docs/introduction/getting-help/support-terminology.html#supported" target="_blank" rel="noopener">Supported</a>, <a href="https://www.lightbend.com/lightbend-subscription" target="_blank" rel="noopener">Lightbend Subscription</a> provides support</div>
  <div>Since 2.3.0, 2014-03-05</div>
  </td></tr>
  <tr><th>Home page</th><td><a href="https://akka.io/">https://akka.io/</a></td></tr>
  <tr><th>API documentation</th><td>
  <div><a href="https://doc.akka.io/api/akka/2.8.3/akka/cluster/sharding/index.html" target="_blank" rel="noopener noreferrer">API (Scaladoc)</a></div>
  <div><a href="https://doc.akka.io/japi/akka/2.8.3/akka/cluster/sharding/package-summary.html" target="_blank" rel="noopener noreferrer">API (Javadoc)</a></div>
  </td></tr>
  <tr><th>Forums</th><td>
  <div><a href="https://discuss.akka.io" target="_blank" rel="noopener noreferrer">Lightbend Discuss</a></div>
  <div><a href="https://gitter.im/akka/akka" target="_blank" rel="noopener noreferrer">akka/akka Gitter channel</a></div>
  </td></tr>
  <tr><th>Release notes</th><td><a href="https://akka.io/blog/news-archive.html">akka.io blog</a></td></tr>
  <tr><th>Issues</th><td><a href="https://github.com/akka/akka/issues" target="_blank" rel="noopener noreferrer">Github issues</a></td></tr>
  <tr><th>Sources</th><td><a href="https://github.com/akka/akka" target="_blank" rel="noopener noreferrer">https://github.com/akka/akka</a></td></tr>
</table>

<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>

<p>For an introduction to Sharding concepts see <a href="typed/cluster-sharding.html">Cluster Sharding</a>.</p>

<h2><a href="#basic-example" name="basic-example" class="anchor"><span class="anchor-link"></span></a>Basic example</h2>

<p>This is what an entity actor may look like:</p>

<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L30-L70" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case object Increment
case object Decrement
final case class Get(counterId: Long)
final case class EntityEnvelope(id: Long, payload: Any)

case object Stop
final case class CounterChanged(delta: Int)

class Counter extends PersistentActor {
  import ShardRegion.Passivate

  context.setReceiveTimeout(120.seconds)

  // self.path.name is the entity identifier (utf-8 URL-encoded)
  override def persistenceId: String = &quot;Counter-&quot; + self.path.name

  var count = 0

  def updateState(event: CounterChanged): Unit =
    count += event.delta

  override def receiveRecover: Receive = {
    case evt: CounterChanged =&gt; updateState(evt)
  }

  override def receiveCommand: Receive = {
    case Increment      =&gt; persist(CounterChanged(+1))(updateState)
    case Decrement      =&gt; persist(CounterChanged(-1))(updateState)
    case Get(_)         =&gt; sender() ! count
    case ReceiveTimeout =&gt; context.parent ! Passivate(stopMessage = Stop)
    case Stop           =&gt; context.stop(self)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L155-L237" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class Counter extends AbstractPersistentActor {

  public enum CounterOp {
    INCREMENT,
    DECREMENT
  }

  public static class Get {
    public final long counterId;

    public Get(long counterId) {
      this.counterId = counterId;
    }
  }

  public static class EntityEnvelope {
    public final long id;
    public final Object payload;

    public EntityEnvelope(long id, Object payload) {
      this.id = id;
      this.payload = payload;
    }
  }

  public static class CounterChanged {
    public final int delta;

    public CounterChanged(int delta) {
      this.delta = delta;
    }
  }

  int count = 0;

  // getSelf().path().name() is the entity identifier (utf-8 URL-encoded)
  @Override
  public String persistenceId() {
    return &quot;Counter-&quot; + getSelf().path().name();
  }

  @Override
  public void preStart() throws Exception {
    super.preStart();
    getContext().setReceiveTimeout(Duration.ofSeconds(120));
  }

  void updateState(CounterChanged event) {
    count += event.delta;
  }

  @Override
  public Receive createReceiveRecover() {
    return receiveBuilder().match(CounterChanged.class, this::updateState).build();
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(Get.class, this::receiveGet)
        .matchEquals(CounterOp.INCREMENT, msg -&gt; receiveIncrement())
        .matchEquals(CounterOp.DECREMENT, msg -&gt; receiveDecrement())
        .matchEquals(ReceiveTimeout.getInstance(), msg -&gt; passivate())
        .build();
  }

  private void receiveGet(Get msg) {
    getSender().tell(count, getSelf());
  }

  private void receiveIncrement() {
    persist(new CounterChanged(+1), this::updateState);
  }

  private void receiveDecrement() {
    persist(new CounterChanged(-1), this::updateState);
  }

  private void passivate() {
    getContext().getParent().tell(new ShardRegion.Passivate(PoisonPill.getInstance()), getSelf());
  }
}
</code></pre></dd>
</dl>
<p>The above actor uses Event Sourcing and the support provided in <span class="group-scala"><code>PersistentActor</code></span> <span class="group-java"><code>AbstractPersistentActor</code></span> to store its state. It does not have to be a persistent actor, but in case of failure or migration of entities between nodes it must be able to recover its state if it is valuable.</p>
<p>Note how the <code>persistenceId</code> is defined. The name of the actor is the entity identifier (utf-8 URL-encoded). You may define it another way, but it must be unique.</p>
<p>When using the sharding extension you are first, typically at system startup on each node in the cluster, supposed to register the supported entity types with the <code>ClusterSharding.start</code> method. <code>ClusterSharding.start</code> gives you the reference which you can pass along. Please note that <code>ClusterSharding.start</code> will start a <code>ShardRegion</code> in <a href="cluster-sharding.html#proxy-only-mode">proxy only mode</a> when there is no match between the roles of the current cluster node and the role specified in <code>ClusterShardingSettings</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L677-L682" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val counterRegion: ActorRef = ClusterSharding(system).start(
  typeName = &quot;Counter&quot;,
  entityProps = Props[Counter](),
  settings = ClusterShardingSettings(system),
  extractEntityId = extractEntityId,
  extractShardId = extractShardId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L25-L84" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.japi.Option;
import akka.cluster.sharding.ClusterSharding;
import akka.cluster.sharding.ClusterShardingSettings;

Option&lt;String&gt; roleOption = Option.none();
ClusterShardingSettings settings = ClusterShardingSettings.create(system);
ActorRef startedCounterRegion =
    ClusterSharding.get(system)
        .start(&quot;Counter&quot;, Props.create(Counter.class), settings, messageExtractor);</code></pre></dd>
</dl>
<p>The <span class="group-scala"><code>extractEntityId</code> and <code>extractShardId</code> are two</span> <span class="group-java"><code>messageExtractor</code> defines</span> application specific <span class="group-scala">functions</span> <span class="group-java">methods</span> to extract the entity identifier and the shard identifier from incoming messages.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L187-L201" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val extractEntityId: ShardRegion.ExtractEntityId = {
  case EntityEnvelope(id, payload) =&gt; (id.toString, payload)
  case msg @ Get(id)               =&gt; (id.toString, msg)
}

val numberOfShards = 100

val extractShardId: ShardRegion.ExtractShardId = {
  case EntityEnvelope(id, _)       =&gt; (id % numberOfShards).toString
  case Get(id)                     =&gt; (id % numberOfShards).toString
  case ShardRegion.StartEntity(id) =&gt;
    // StartEntity is used by remembering entities feature
    (id.toLong % numberOfShards).toString
  case _ =&gt; throw new IllegalArgumentException()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L20-L76" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.cluster.sharding.ShardRegion;

ShardRegion.MessageExtractor messageExtractor =
    new ShardRegion.MessageExtractor() {

      @Override
      public String entityId(Object message) {
        if (message instanceof Counter.EntityEnvelope)
          return String.valueOf(((Counter.EntityEnvelope) message).id);
        else if (message instanceof Counter.Get)
          return String.valueOf(((Counter.Get) message).counterId);
        else return null;
      }

      @Override
      public Object entityMessage(Object message) {
        if (message instanceof Counter.EntityEnvelope)
          return ((Counter.EntityEnvelope) message).payload;
        else return message;
      }

      @Override
      public String shardId(Object message) {
        int numberOfShards = 100;
        if (message instanceof Counter.EntityEnvelope) {
          long id = ((Counter.EntityEnvelope) message).id;
          return String.valueOf(id % numberOfShards);
        } else if (message instanceof Counter.Get) {
          long id = ((Counter.Get) message).counterId;
          return String.valueOf(id % numberOfShards);
        } else {
          return null;
        }
      }
    };</code></pre></dd>
</dl>
<p>This example illustrates two different ways to define the entity identifier in the messages:</p>
<ul>
  <li>The <code>Get</code> message includes the identifier itself.</li>
  <li>The <code>EntityEnvelope</code> holds the identifier, and the actual message that is sent to the entity actor is wrapped in the envelope.</li>
</ul>
<p>Note how these two messages types are handled in the <span class="group-scala"><code>extractEntityId</code> function</span> <span class="group-java"><code>entityId</code> and <code>entityMessage</code> methods</span> shown above. The message sent to the entity actor is <span class="group-scala">the second part of the tuple returned by the <code>extractEntityId</code></span> <span class="group-java">what <code>entityMessage</code> returns</span> and that makes it possible to unwrap envelopes if needed.</p>
<p>A shard is a group of entities that will be managed together. The grouping is defined by the <code>extractShardId</code> function shown above. For a specific entity identifier the shard identifier must always be the same. Otherwise the entity actor might accidentally be started in several places at the same time.</p>
<p>Creating a good sharding algorithm is an interesting challenge in itself. Try to produce a uniform distribution, i.e. same amount of entities in each shard. As a rule of thumb, the number of shards should be a factor ten greater than the planned maximum number of cluster nodes. Fewer shards than number of nodes will result in that some nodes will not host any shards. Too many shards will result in less efficient management of the shards, e.g. rebalancing overhead, and increased latency because the coordinator is involved in the routing of the first message for each shard. The sharding algorithm must be the same on all nodes in a running cluster. It can be changed after stopping all nodes in the cluster.</p>
<p>A simple sharding algorithm that works fine in most cases is to take the absolute value of the <code>hashCode</code> of the entity identifier modulo number of shards. As a convenience this is provided by the <code>ShardRegion.HashCodeMessageExtractor</code>.</p>
<p>Messages to the entities are always sent via the local <code>ShardRegion</code>. The <code>ShardRegion</code> actor reference for a named entity type is returned by <code>ClusterSharding.start</code> and it can also be retrieved with <code>ClusterSharding.shardRegion</code>. The <code>ShardRegion</code> will lookup the location of the shard for the entity if it does not already know its location. It will delegate the message to the right node and it will create the entity actor on demand, i.e. when the first message for a specific entity is delivered.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L705-L711" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val counterRegion: ActorRef = ClusterSharding(system).shardRegion(&quot;Counter&quot;)
counterRegion ! Get(123)
expectMsg(0)

counterRegion ! EntityEnvelope(123, Increment)
counterRegion ! Get(123)
expectMsg(1)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L88-L92" target="_blank" title="Go to snippet source">source</a><code class="language-java">ActorRef counterRegion = ClusterSharding.get(system).shardRegion(&quot;Counter&quot;);
counterRegion.tell(new Counter.Get(123), getSelf());

counterRegion.tell(new Counter.EntityEnvelope(123, Counter.CounterOp.INCREMENT), getSelf());
counterRegion.tell(new Counter.Get(123), getSelf());</code></pre></dd>
</dl>
<h2><a href="#how-it-works" name="how-it-works" class="anchor"><span class="anchor-link"></span></a>How it works</h2>
<p>See <a href="typed/cluster-sharding-concepts.html">Cluster Sharding concepts</a> in the documentation of the new APIs.</p>
<a id="cluster-sharding-mode"></a>
<h2><a href="#sharding-state-store-mode" name="sharding-state-store-mode" class="anchor"><span class="anchor-link"></span></a>Sharding State Store Mode</h2>
<p>There are two cluster sharding states managed:</p>
<ol>
  <li><a href="typed/cluster-sharding-concepts.html#shardcoordinator-state">ShardCoordinator State</a> - the <code>Shard</code> locations</li>
  <li><a href="cluster-sharding.html#remembering-entities">Remembering Entities</a> - the entities in each <code>Shard</code>, which is optional, and disabled by default</li>
</ol>
<p>For these, there are currently two modes which define how these states are stored:</p>
<ul>
  <li><a href="cluster-sharding.html#distributed-data-mode">Distributed Data Mode</a> - uses Akka <a href="distributed-data.html">Distributed Data</a> (CRDTs) (the default)</li>
  <li><a href="cluster-sharding.html#persistence-mode">Persistence Mode</a> - (deprecated) uses Akka <a href="persistence.html">Persistence</a> (Event Sourcing)</li>
</ul><div class="callout warning "><div class="callout-title">Warning</div>
<p>Persistence for state store mode is deprecated. It is recommended to migrate to <code>ddata</code> for the coordinator state and if using replicated entities migrate to <code>eventsourced</code> for the replicated entities state.</p>
<p>The data written by the deprecated <code>persistence</code> state store mode for remembered entities can be read by the new remember entities <code>eventsourced</code> mode.</p>
<p>Once you&rsquo;ve migrated you can not go back to <code>persistence</code> mode.</p></div>
<p>Changing the mode requires <a href="additional/rolling-updates.html#cluster-sharding-configuration-change">a full cluster restart</a>.</p>
<h3><a href="#distributed-data-mode" name="distributed-data-mode" class="anchor"><span class="anchor-link"></span></a>Distributed Data Mode</h3>
<p>The state of the <code>ShardCoordinator</code> is replicated across the cluster but is not durable, not stored to disk. The <code>ShardCoordinator</code> state replication is handled by <a href="distributed-data.html">Distributed Data</a> with <code>WriteMajority</code>/<code>ReadMajority</code> consistency. When all nodes in the cluster have been stopped, the state is no longer needed and dropped.</p>
<p>See <a href="typed/cluster-sharding.html#distributed-data-mode">Distributed Data mode</a> in the documentation of the new APIs.</p>
<h3><a href="#persistence-mode" name="persistence-mode" class="anchor"><span class="anchor-link"></span></a>Persistence Mode</h3>
<p>See <a href="typed/cluster-sharding.html#persistence-mode">Persistence Mode</a> in the documentation of the new APIs.</p>
<h2><a href="#proxy-only-mode" name="proxy-only-mode" class="anchor"><span class="anchor-link"></span></a>Proxy Only Mode</h2>
<p>The <code>ShardRegion</code> actor can also be started in proxy only mode, i.e. it will not host any entities itself, but knows how to delegate messages to the right location. A <code>ShardRegion</code> is started in proxy only mode with the <code>ClusterSharding.startProxy</code> method. Also a <code>ShardRegion</code> is started in proxy only mode when there is no match between the roles of the current cluster node and the role specified in <code>ClusterShardingSettings</code> passed to the <code>ClusterSharding.start</code> method.</p>
<h2><a href="#passivation" name="passivation" class="anchor"><span class="anchor-link"></span></a>Passivation</h2>
<p>If the state of the entities are persistent you may stop entities that are not used to reduce memory consumption. This is done by the application specific implementation of the entity actors for example by defining receive timeout (<code>context.setReceiveTimeout</code>). If a message is already enqueued to the entity when it stops itself the enqueued message in the mailbox will be dropped. To support graceful passivation without losing such messages the entity actor can send <code>ShardRegion.Passivate</code> to its parent <code>Shard</code>. The specified wrapped message in <code>Passivate</code> will be sent back to the entity, which is then supposed to stop itself. Incoming messages will be buffered by the <code>Shard</code> between reception of <code>Passivate</code> and termination of the entity. Such buffered messages are thereafter delivered to a new incarnation of the entity.</p>
<p>See <a href="typed/cluster-sharding.html#automatic-passivation">Automatic Passivation</a> in the documentation of the new APIs.</p>
<a id="cluster-sharding-remembering"></a>
<h2><a href="#remembering-entities" name="remembering-entities" class="anchor"><span class="anchor-link"></span></a>Remembering Entities</h2>
<p>See <a href="typed/cluster-sharding.html#remembering-entities">Remembering Entities</a> in the documentation of the new APIs, including behavior when enabled and disabled.</p>
<p>Note that the state of the entities themselves will not be restored unless they have been made persistent, for example with <a href="persistence.html">Event Sourcing</a>.</p>
<p>To make the list of entities in each <code>Shard</code> persistent (durable), set the <code>rememberEntities</code> flag to true in <code>ClusterShardingSettings</code> when calling <code>ClusterSharding.start</code> and make sure the <code>shardIdExtractor</code> handles <code>Shard.StartEntity(EntityId)</code> which implies that a <code>ShardId</code> must be possible to extract from the <code>EntityId</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L206-L213" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val extractShardId: ShardRegion.ExtractShardId = {
  case EntityEnvelope(id, _)       =&gt; (id % numberOfShards).toString
  case Get(id)                     =&gt; (id % numberOfShards).toString
  case ShardRegion.StartEntity(id) =&gt;
    // StartEntity is used by remembering entities feature
    (id.toLong % numberOfShards).toString
  case _ =&gt; throw new IllegalArgumentException()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L133-L148" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public String shardId(Object message) {
  int numberOfShards = 100;
  if (message instanceof Counter.EntityEnvelope) {
    long id = ((Counter.EntityEnvelope) message).id;
    return String.valueOf(id % numberOfShards);
  } else if (message instanceof Counter.Get) {
    long id = ((Counter.Get) message).counterId;
    return String.valueOf(id % numberOfShards);
  } else if (message instanceof ShardRegion.StartEntity) {
    long id = Long.valueOf(((ShardRegion.StartEntity) message).entityId());
    return String.valueOf(id % numberOfShards);
  } else {
    return null;
  }
}</code></pre></dd>
</dl>
<h2><a href="#supervision" name="supervision" class="anchor"><span class="anchor-link"></span></a>Supervision</h2>
<p>If you need to use another <code>supervisorStrategy</code> for the entity actors than the default (restarting) strategy you need to create an intermediate parent actor that defines the <code>supervisorStrategy</code> to the child entity actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L97-L110" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class CounterSupervisor extends Actor {
  val counter = context.actorOf(Props[Counter](), &quot;theCounter&quot;)

  override val supervisorStrategy = OneForOneStrategy() {
    case _: IllegalArgumentException     =&gt; SupervisorStrategy.Resume
    case _: ActorInitializationException =&gt; SupervisorStrategy.Stop
    case _: DeathPactException           =&gt; SupervisorStrategy.Stop
    case _: Exception                    =&gt; SupervisorStrategy.Restart
  }

  def receive = {
    case msg =&gt; counter.forward(msg)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L241-L265" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class CounterSupervisor extends AbstractActor {

  private final ActorRef counter =
      getContext().actorOf(Props.create(Counter.class), &quot;theCounter&quot;);

  private static final SupervisorStrategy strategy =
      new OneForOneStrategy(
          DeciderBuilder.match(IllegalArgumentException.class, e -&gt; SupervisorStrategy.resume())
              .match(ActorInitializationException.class, e -&gt; SupervisorStrategy.stop())
              .match(Exception.class, e -&gt; SupervisorStrategy.restart())
              .matchAny(o -&gt; SupervisorStrategy.escalate())
              .build());

  @Override
  public SupervisorStrategy supervisorStrategy() {
    return strategy;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(Object.class, msg -&gt; counter.forward(msg, getContext()))
        .build();
  }
}</code></pre></dd>
</dl>
<p>You start such a supervisor in the same way as if it was the entity actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L694-L699" target="_blank" title="Go to snippet source">source</a><code class="language-scala">ClusterSharding(system).start(
  typeName = &quot;SupervisedCounter&quot;,
  entityProps = Props[CounterSupervisor](),
  settings = ClusterShardingSettings(system),
  extractEntityId = extractEntityId,
  extractShardId = extractShardId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L96-L98" target="_blank" title="Go to snippet source">source</a><code class="language-java">ClusterSharding.get(system)
    .start(
        &quot;SupervisedCounter&quot;, Props.create(CounterSupervisor.class), settings, messageExtractor);</code></pre></dd>
</dl>
<p>Note that stopped entities will be started again when a new message is targeted to the entity.</p>
<p>If &lsquo;on stop&rsquo; backoff supervision strategy is used, a final termination message must be set and used for passivation, see <a href="fault-tolerance.html#sharding">Backoff supervisor and sharding</a></p>
<h2><a href="#graceful-shutdown" name="graceful-shutdown" class="anchor"><span class="anchor-link"></span></a>Graceful Shutdown</h2>
<p>You can send the <span class="group-scala"><code>ShardRegion.GracefulShutdown</code></span> <span class="group-java"><code>ShardRegion.gracefulShutdownInstance</code></span> message to the <code>ShardRegion</code> actor to hand off all shards that are hosted by that <code>ShardRegion</code> and then the <code>ShardRegion</code> actor will be stopped. You can <code>watch</code> the <code>ShardRegion</code> actor to know when it is completed. During this period other regions will buffer messages for those shards in the same way as when a rebalance is triggered by the coordinator. When the shards have been stopped the coordinator will allocate these shards elsewhere.</p>
<p>This is performed automatically by the <a href="coordinated-shutdown.html">Coordinated Shutdown</a> and is therefore part of the graceful leaving process of a cluster member.</p>
<a id="removeinternalclustershardingdata"></a>
<h2><a href="#removal-of-internal-cluster-sharding-data" name="removal-of-internal-cluster-sharding-data" class="anchor"><span class="anchor-link"></span></a>Removal of Internal Cluster Sharding Data</h2>
<p>See <a href="typed/cluster-sharding.html#removal-of-internal-cluster-sharding-data">removal of Internal Cluster Sharding Data</a> in the documentation of the new APIs.</p>
<h2><a href="#inspecting-cluster-sharding-state" name="inspecting-cluster-sharding-state" class="anchor"><span class="anchor-link"></span></a>Inspecting cluster sharding state</h2>
<p>Two requests to inspect the cluster state are available:</p>
<p><span class="group-scala"><code>ShardRegion.GetShardRegionState</code></span> <span class="group-java"><code>ShardRegion.getShardRegionStateInstance</code></span> which will return a <span class="group-scala"><code>ShardRegion.CurrentShardRegionState</code></span> <span class="group-java"><code>ShardRegion.ShardRegionState</code></span> that contains the identifiers of the shards running in a Region and what entities are alive for each of them. </p>
<p><code>ShardRegion.GetClusterShardingStats</code> which will query all the regions in the cluster and return a <code>ShardRegion.ClusterShardingStats</code> containing the identifiers of the shards running in each region and a count of entities that are alive in each shard. </p>
<p>If any shard queries failed, for example due to timeout if a shard was too busy to reply within the configured <code>akka.cluster.sharding.shard-region-query-timeout</code>, <code>ShardRegion.CurrentShardRegionState</code> and <code>ShardRegion.ClusterShardingStats</code> will also include the set of shard identifiers by region that failed.</p>
<p>The type names of all started shards can be acquired via <span class="group-scala"><code>ClusterSharding.shardTypeNames</code></span> <span class="group-java"><code>ClusterSharding.getShardTypeNames</code></span>.</p>
<p>The purpose of these messages is testing and monitoring, they are not provided to give access to directly sending messages to the individual entities.</p>
<h2><a href="#lease" name="lease" class="anchor"><span class="anchor-link"></span></a>Lease</h2>
<p>A lease can be used as an additional safety measure to ensure a shard does not run on two nodes. See <a href="typed/cluster-sharding.html#lease">Lease</a> in the documentation of the new APIs.</p>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p><code>ClusterShardingSettings</code> is a parameter to the <code>start</code> method of the <code>ClusterSharding</code> extension, i.e. each each entity type can be configured with different settings if needed.</p>
<p>See <a href="typed/cluster-sharding.html#configuration">configuration</a> for more information.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="cluster-client.html"><i class="icon-prev"></i> <span class="link-prev">Classic Cluster Client</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="cluster-metrics.html">Classic Cluster Metrics Extension <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.8.3/akka-docs/src/main/paradox/cluster-sharding.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg" />
<section class="copyright">
<div>Akka is available under the <a href="https://www.lightbend.com/akka/license" target="_blank">Business Source License 1.1</a>.</div>
<p class="legal">
&copy; 2011-2023 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/snippets.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>
<script type="text/javascript" src="js/metadata-toggle.js"></script>
<script type="text/javascript" src="js/lbHeader.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
appId: 'XUXZ6LW9B1',
apiKey: '5b6260148e92f7c5e38338fcf7eaa3e0',
indexName: 'akka_docs',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
appId: 'XUXZ6LW9B1',
apiKey: '5b6260148e92f7c5e38338fcf7eaa3e0',
indexName: 'akka_docs',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
