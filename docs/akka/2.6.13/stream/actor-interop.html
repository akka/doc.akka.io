<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Actors interop &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/stream/actor-interop.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-8.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-1.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"  type="text/javascript" charset="UTF-8" data-domain-script="28b912e7-09e9-43d5-91e4-3d1897044004" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-platform?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="../images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="../images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="../images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="../images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="../images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="../images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="../images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-platform?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.13
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#module-info" class="header">Module info</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-context.html" class="page">Context Propagation</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/futures-interop.html" class="page">Futures interop</a></li>
    <li><a href="../stream/actor-interop.html#actors-interop" class="active page">Actors interop</a>
    <ul>
      <li><a href="../stream/actor-interop.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/actor-interop.html#overview" class="header">Overview</a></li>
    </ul></li>
    <li><a href="../stream/reactive-streams-interop.html" class="page">Reactive Streams Interop</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.13
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#module-info" class="header">Module info</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-context.html" class="page">Context Propagation</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/futures-interop.html" class="page">Futures interop</a></li>
    <li><a href="../stream/actor-interop.html#actors-interop" class="active page">Actors interop</a>
    <ul>
      <li><a href="../stream/actor-interop.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/actor-interop.html#overview" class="header">Overview</a></li>
    </ul></li>
    <li><a href="../stream/reactive-streams-interop.html" class="page">Reactive Streams Interop</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#actors-interop" name="actors-interop" class="anchor"><span class="anchor-link"></span></a>Actors interop</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val AkkaVersion = "2.6.13"
libraryDependencies += "com.typesafe.akka" %% "akka-stream" % AkkaVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
      &lt;artifactId&gt;akka-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.13&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
    &lt;artifactId&gt;akka-stream_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("com.typesafe.akka:akka-bom_${versions.ScalaBinary}:2.6.13")

  implementation "com.typesafe.akka:akka-stream_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<h2><a href="#overview" name="overview" class="anchor"><span class="anchor-link"></span></a>Overview</h2>
<p>There are various use cases where it might be reasonable to use actors and streams together:</p>
<ul>
  <li>when integrating existing API&rsquo;s that might be streams- or actors-based.</li>
  <li>when there is any mutable state that should be shared across multiple streams.</li>
  <li>when there is any mutable state or logic that can be influenced &lsquo;from outside&rsquo; while the stream is running.</li>
</ul>
<p>For piping the elements of a stream as messages to an ordinary actor you can use <code>ask</code> in a <code>mapAsync</code> or use <code>Sink.actorRefWithBackpressure</code>.</p>
<p>Messages can be sent to a stream with <code>Source.queue</code> or via the <code>ActorRef</code> that is materialized by <code>Source.actorRef</code>.</p>
<p>Additionally you can use <code>ActorSource.actorRef</code>, <code>ActorSource.actorRefWithBackpressure</code>, <code>ActorSink.actorRef</code> and <code>ActorSink.actorRefWithBackpressure</code> shown below.</p>
<h3><a href="#ask" name="ask" class="anchor"><span class="anchor-link"></span></a>ask</h3><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/Source-or-Flow/ask.html">Flow.ask operator reference docs</a>, <a href="operators/ActorFlow/ask.html">ActorFlow.ask operator reference docs</a> for Akka Typed</p></div>
<p>A nice way to delegate some processing of elements in a stream to an actor is to use <code>ask</code>. The back-pressure of the stream is maintained by the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the <code>ask</code> and the mailbox of the actor will not be filled with more messages than the given <code>parallelism</code> of the <code>ask</code> operator (similarly to how the <code>mapAsync</code> operator works).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L142-L150" target="_blank" title="Go to snippet source">source</a><code class="language-scala">implicit val askTimeout = Timeout(5.seconds)
val words: Source[String, NotUsed] =
  Source(List(&quot;hello&quot;, &quot;hi&quot;))

words
  .ask[String](parallelism = 5)(ref)
  // continue processing of the replies from the actor
  .map(_.toLowerCase)
  .runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L391-L398" target="_blank" title="Go to snippet source">source</a><code class="language-java">Source&lt;String, NotUsed&gt; words = Source.from(Arrays.asList(&quot;hello&quot;, &quot;hi&quot;));
Timeout askTimeout = Timeout.apply(5, TimeUnit.SECONDS);

words
    .ask(5, ref, String.class, askTimeout)
    // continue processing of the replies from the actor
    .map(elem -&gt; elem.toLowerCase())
    .runWith(Sink.ignore(), system);</code></pre></dd>
</dl>
<p>Note that the messages received in the actor will be in the same order as the stream elements, i.e. the <code>parallelism</code> does not change the ordering of the messages. There is a performance advantage of using parallelism &gt; 1 even though the actor will only process one message at a time because then there is already a message in the mailbox when the actor has completed previous message.</p>
<p>The actor must reply to the <span class="group-scala"><code>sender()</code></span><span class="group-java"><code>getSender()</code></span> for each message from the stream. That reply will complete the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the <code>ask</code> and it will be the element that is emitted downstreams.</p>
<p>In case the target actor is stopped, the operator will fail with an <code>AskStageTargetActorTerminatedException</code></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L122-L129" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class Translator extends Actor {
  def receive = {
    case word: String =&gt;
      // ... process message
      val reply = word.toUpperCase
      sender() ! reply // reply to the ask
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L307-L321" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class Translator extends AbstractActor {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            word -&gt; {
              // ... process message
              String reply = word.toUpperCase();
              // reply to the ask
              getSender().tell(reply, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>The stream can be completed with failure by sending <code>akka.actor.Status.Failure</code> as reply from the actor.</p>
<p>If the <code>ask</code> fails due to timeout the stream will be completed with <code>TimeoutException</code> failure. If that is not desired outcome you can use <code>recover</code> on the <code>ask</code> <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>, or use the other &ldquo;restart&rdquo; operators to restart it.</p>
<p>If you don&rsquo;t care about the reply values and only use them as back-pressure signals you can use <code>Sink.ignore</code> after the <code>ask</code> operator and then actor is effectively a sink of the stream.</p>
<p>Note that while you may implement the same concept using <code>mapAsync</code>, that style would not be aware of the actor terminating.</p>
<p>If you are intending to ask multiple actors by using <a href="../routing.html">Actor routers</a>, then you should use <code>mapAsyncUnordered</code> and perform the ask manually in there, as the ordering of the replies is not important, since multiple actors are being asked concurrently to begin with, and no single actor is the one to be watched by the operator.</p>
<h3><a href="#sink-actorrefwithbackpressure" name="sink-actorrefwithbackpressure" class="anchor"><span class="anchor-link"></span></a>Sink.actorRefWithBackpressure</h3><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/Sink/actorRefWithBackpressure.html">Sink.actorRefWithBackpressure operator reference docs</a></p></div>
<p>The sink sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal. First element is always <em>onInitMessage</em>, then stream is waiting for the given acknowledgement message from the given actor which means that it is ready to process elements. It also requires the given acknowledgement message after each stream element to make back-pressure work.</p>
<p>If the target actor terminates the stream will be cancelled. When the stream is completed successfully the given <code>onCompleteMessage</code> will be sent to the destination actor. When the stream is completed with failure a <code>akka.actor.Status.Failure</code> message will be sent to the destination actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L193-L218" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val words: Source[String, NotUsed] =
  Source(List(&quot;hello&quot;, &quot;hi&quot;))

// sent from actor to stream to &quot;ack&quot; processing of given element
val AckMessage = AckingReceiver.Ack

// sent from stream to actor to indicate start, end or failure of stream:
val InitMessage = AckingReceiver.StreamInitialized
val OnCompleteMessage = AckingReceiver.StreamCompleted
val onErrorMessage = (ex: Throwable) =&gt; AckingReceiver.StreamFailure(ex)

val probe = TestProbe()
val receiver = system.actorOf(Props(new AckingReceiver(probe.ref, ackWith = AckMessage)))
val sink = Sink.actorRefWithBackpressure(
  receiver,
  onInitMessage = InitMessage,
  ackMessage = AckMessage,
  onCompleteMessage = OnCompleteMessage,
  onFailureMessage = onErrorMessage)

words.map(_.toLowerCase).runWith(sink)

probe.expectMsg(&quot;Stream initialized!&quot;)
probe.expectMsg(&quot;hello&quot;)
probe.expectMsg(&quot;hi&quot;)
probe.expectMsg(&quot;Stream completed!&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L405-L424" target="_blank" title="Go to snippet source">source</a><code class="language-java">Source&lt;String, NotUsed&gt; words = Source.from(Arrays.asList(&quot;hello&quot;, &quot;hi&quot;));

final TestKit probe = new TestKit(system);

ActorRef receiver = system.actorOf(Props.create(AckingReceiver.class, probe.getRef()));

Sink&lt;String, NotUsed&gt; sink =
    Sink.&lt;String&gt;actorRefWithBackpressure(
        receiver,
        new StreamInitialized(),
        Ack.INSTANCE,
        new StreamCompleted(),
        ex -&gt; new StreamFailure(ex));

words.map(el -&gt; el.toLowerCase()).runWith(sink, system);

probe.expectMsg(&quot;Stream initialized&quot;);
probe.expectMsg(&quot;hello&quot;);
probe.expectMsg(&quot;hi&quot;);
probe.expectMsg(&quot;Stream completed&quot;);</code></pre></dd>
</dl>
<p>The receiving actor would then need to be implemented similar to the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L223-L251" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object AckingReceiver {
  case object Ack

  case object StreamInitialized
  case object StreamCompleted
  final case class StreamFailure(ex: Throwable)
}

class AckingReceiver(probe: ActorRef, ackWith: Any) extends Actor with ActorLogging {
  import AckingReceiver._

  def receive: Receive = {
    case StreamInitialized =&gt;
      log.info(&quot;Stream initialized!&quot;)
      probe ! &quot;Stream initialized!&quot;
      sender() ! Ack // ack to allow the stream to proceed sending more elements

    case el: String =&gt;
      log.info(&quot;Received element: {}&quot;, el)
      probe ! el
      sender() ! Ack // ack to allow the stream to proceed sending more elements

    case StreamCompleted =&gt;
      log.info(&quot;Stream completed!&quot;)
      probe ! &quot;Stream completed!&quot;
    case StreamFailure(ex) =&gt;
      log.error(ex, &quot;Stream failed!&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L325-L384" target="_blank" title="Go to snippet source">source</a><code class="language-java">enum Ack {
  INSTANCE;
}

static class StreamInitialized {}

static class StreamCompleted {}

static class StreamFailure {
  private final Throwable cause;

  public StreamFailure(Throwable cause) {
    this.cause = cause;
  }

  public Throwable getCause() {
    return cause;
  }
}

static class AckingReceiver extends AbstractLoggingActor {

  private final ActorRef probe;

  public AckingReceiver(ActorRef probe) {
    this.probe = probe;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            StreamInitialized.class,
            init -&gt; {
              log().info(&quot;Stream initialized&quot;);
              probe.tell(&quot;Stream initialized&quot;, getSelf());
              sender().tell(Ack.INSTANCE, self());
            })
        .match(
            String.class,
            element -&gt; {
              log().info(&quot;Received element: {}&quot;, element);
              probe.tell(element, getSelf());
              sender().tell(Ack.INSTANCE, self());
            })
        .match(
            StreamCompleted.class,
            completed -&gt; {
              log().info(&quot;Stream completed&quot;);
              probe.tell(&quot;Stream completed&quot;, getSelf());
            })
        .match(
            StreamFailure.class,
            failed -&gt; {
              log().error(failed.getCause(), &quot;Stream failed!&quot;);
              probe.tell(&quot;Stream failed!&quot;, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Note that replying to the sender of the elements (the &ldquo;stream&rdquo;) is required as lack of those ack signals would be interpreted as back-pressure (as intended), and no new elements will be sent into the actor until it acknowledges some elements. Handling the other signals while is not required, however is a good practice, to see the state of the streams lifecycle in the connected actor as well. Technically it is also possible to use multiple sinks targeting the same actor, however it is not common practice to do so, and one should rather investigate using a <code>Merge</code> operator for this purpose.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Using <code>Sink.actorRef</code> or ordinary <code>tell</code> from a <code>map</code> or <code>foreach</code> operator means that there is no back-pressure signal from the destination actor, i.e. if the actor is not consuming the messages fast enough the mailbox of the actor will grow, unless you use a bounded mailbox with zero <em>mailbox-push-timeout-time</em> or use a rate limiting operator in front. It&rsquo;s often better to use <code>Sink.actorRefWithBackpressure</code> or <code>ask</code> in <code>mapAsync</code>, though.</p></div>
<h3><a href="#source-queue" name="source-queue" class="anchor"><span class="anchor-link"></span></a>Source.queue</h3>
<p><code>Source.queue</code> is an improvement over <code>Sink.actorRef</code>, since it can provide backpressure. The <code>offer</code> method returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>, which completes with the result of the enqueue operation.</p>
<p><code>Source.queue</code> can be used for emitting elements to a stream from an actor (or from anything running outside the stream). The elements will be buffered until the stream can process them. You can <code>offer</code> elements to the queue and they will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received.</p>
<p>Use overflow strategy <code>akka.stream.OverflowStrategy.backpressure</code> to avoid dropping of elements if the buffer is full, instead the returned <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> does not complete until there is space in the buffer and <code>offer</code> should not be called again until it completes.</p>
<p>Using <code>Source.queue</code> you can push elements to the queue and they will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received. Elements in the buffer will be discarded if downstream is terminated.</p>
<p>You could combine it with the <a href="operators/Source-or-Flow/throttle.html"><code>throttle</code></a> operator is used to slow down the stream to <code>5 element</code> per <code>3 seconds</code> and other patterns.</p>
<p><code>SourceQueue.offer</code> returns <span class="group-scala"><code>Future[QueueOfferResult]</code></span><span class="group-java"><code>CompletionStage&lt;QueueOfferResult&gt;</code></span> which completes with <code>QueueOfferResult.Enqueued</code> if element was added to buffer or sent downstream. It completes with <code>QueueOfferResult.Dropped</code> if element was dropped. Can also complete with <code>QueueOfferResult.Failure</code> - when stream failed or <code>QueueOfferResult.QueueClosed</code> when downstream is completed.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L468-L490" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val bufferSize = 10
val elementsToProcess = 5

val queue = Source
  .queue[Int](bufferSize, OverflowStrategy.backpressure)
  .throttle(elementsToProcess, 3.second)
  .map(x =&gt; x * x)
  .toMat(Sink.foreach(x =&gt; println(s&quot;completed $x&quot;)))(Keep.left)
  .run()

val source = Source(1 to 10)

implicit val ec = system.dispatcher
source
  .mapAsync(1)(x =&gt; {
    queue.offer(x).map {
      case QueueOfferResult.Enqueued    =&gt; println(s&quot;enqueued $x&quot;)
      case QueueOfferResult.Dropped     =&gt; println(s&quot;dropped $x&quot;)
      case QueueOfferResult.Failure(ex) =&gt; println(s&quot;Offer failed ${ex.getMessage}&quot;)
      case QueueOfferResult.QueueClosed =&gt; println(&quot;Source Queue closed&quot;)
    }
  })
  .runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L749-L762" target="_blank" title="Go to snippet source">source</a><code class="language-java">int bufferSize = 10;
int elementsToProcess = 5;

SourceQueueWithComplete&lt;Integer&gt; sourceQueue =
    Source.&lt;Integer&gt;queue(bufferSize, OverflowStrategy.backpressure())
        .throttle(elementsToProcess, Duration.ofSeconds(3))
        .map(x -&gt; x * x)
        .to(Sink.foreach(x -&gt; System.out.println(&quot;got: &quot; + x)))
        .run(system);

Source&lt;Integer, NotUsed&gt; source = Source.from(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

source.map(x -&gt; sourceQueue.offer(x)).runWith(Sink.ignore(), system);
</code></pre></dd>
</dl>
<p>When used from an actor you typically <code>pipe</code> the result of the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> back to the actor to continue processing.</p>
<h3><a href="#source-actorref" name="source-actorref" class="anchor"><span class="anchor-link"></span></a>Source.actorRef</h3>
<p>Messages sent to the actor that is materialized by <code>Source.actorRef</code> will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received.</p>
<p>Depending on the defined <code>OverflowStrategy</code> it might drop elements if there is no space available in the buffer. The strategy <code>OverflowStrategy.backpressure</code> is not supported for this Source type, i.e. elements will be dropped if the buffer is filled by sending at a rate that is faster than the stream can consume. You should consider using <code>Source.queue</code> if you want a backpressured actor interface.</p>
<p>The stream can be completed successfully by sending <code>akka.actor.Status.Success</code> to the actor reference. If the content is <code>akka.stream.CompletionStrategy.immediately</code> the completion will be signaled immediately. If the content is <code>akka.stream.CompletionStrategy.draining</code> already buffered elements will be signaled before signaling completion. Any other content will be ignored and fall back to the draining behaviour. </p>
<p>The stream can be completed with failure by sending <code>akka.actor.Status.Failure</code> to the actor reference.</p>
<p>Note: Sending a <code>PoisonPill</code> is deprecated and will be ignored in the future.</p>
<p>The actor will be stopped when the stream is completed, failed or cancelled from downstream, i.e. you can watch it to get notified when that happens.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L526-L546" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val bufferSize = 10

val cm: PartialFunction[Any, CompletionStrategy] = {
  case Done =&gt;
    CompletionStrategy.immediately
}

val ref = Source
  .actorRef[Int](
    completionMatcher = cm,
    failureMatcher = PartialFunction.empty[Any, Throwable],
    bufferSize = bufferSize,
    overflowStrategy = OverflowStrategy.fail) // note: backpressure is not supported
  .map(x =&gt; x * x)
  .toMat(Sink.foreach((x: Int) =&gt; println(s&quot;completed $x&quot;)))(Keep.left)
  .run()

ref ! 1
ref ! 2
ref ! 3
ref ! Done</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L811-L834" target="_blank" title="Go to snippet source">source</a><code class="language-java">int bufferSize = 10;

Source&lt;Integer, ActorRef&gt; source =
    Source.actorRef(
        elem -&gt; {
          // complete stream immediately if we send it Done
          if (elem == Done.done()) return Optional.of(CompletionStrategy.immediately());
          else return Optional.empty();
        },
        // never fail the stream because of a message
        elem -&gt; Optional.empty(),
        bufferSize,
        OverflowStrategy.dropHead()); // note: backpressure is not supported
ActorRef actorRef =
    source
        .map(x -&gt; x * x)
        .to(Sink.foreach(x -&gt; System.out.println(&quot;got: &quot; + x)))
        .run(system);

actorRef.tell(1, ActorRef.noSender());
actorRef.tell(2, ActorRef.noSender());
actorRef.tell(3, ActorRef.noSender());
actorRef.tell(
    new akka.actor.Status.Success(CompletionStrategy.draining()), ActorRef.noSender());</code></pre></dd>
</dl>
<h3><a href="#actorsource-actorref" name="actorsource-actorref" class="anchor"><span class="anchor-link"></span></a>ActorSource.actorRef</h3>
<p>Materialize an <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span>; sending messages to it will emit them on the stream only if they are of the same type as the stream.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSource/actorRef.html">ActorSource.actorRef operator reference docs</a></p></div>
<h3><a href="#actorsource-actorrefwithbackpressure" name="actorsource-actorrefwithbackpressure" class="anchor"><span class="anchor-link"></span></a>ActorSource.actorRefWithBackpressure</h3>
<p>Materialize an <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span>; sending messages to it will emit them on the stream. The source acknowledges reception after emitting a message, to provide back pressure from the source.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSource/actorRefWithBackpressure.html">ActorSource.actorRefWithBackpressure operator reference docs</a></p></div>
<h3><a href="#actorsink-actorref" name="actorsink-actorref" class="anchor"><span class="anchor-link"></span></a>ActorSink.actorRef</h3>
<p>Sends the elements of the stream to the given <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span>, without considering backpressure.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSink/actorRef.html">ActorSink.actorRef operator reference docs</a></p></div>
<h3><a href="#actorsink-actorrefwithbackpressure" name="actorsink-actorrefwithbackpressure" class="anchor"><span class="anchor-link"></span></a>ActorSink.actorRefWithBackpressure</h3>
<p>Sends the elements of the stream to the given <span class="group-java"><code>ActorRef&lt;T&gt;</code></span><span class="group-scala"><code>ActorRef[T]</code></span> with backpressure, to be able to signal demand when the actor is ready to receive more elements.</p><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/ActorSink/actorRefWithBackpressure.html">ActorSink.actorRefWithBackpressure operator reference docs</a></p></div>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../stream/futures-interop.html"><i class="icon-prev"></i> <span class="link-prev">Futures interop</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../stream/reactive-streams-interop.html">Reactive Streams Interop <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.6.13/akka-docs/src/main/paradox/stream/actor-interop.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2021 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/snippets.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
