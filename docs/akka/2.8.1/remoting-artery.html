<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Remoting &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Details about the underlying remoting module for Akka Cluster."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/remoting-artery.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page-8.css"/>
<link rel="stylesheet" type="text/css" href="css/banner-2.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png"/>
<link rel="manifest" href="images/manifest.json"/>
<meta name="msapplication-TileImage" content="images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"  type="text/javascript" charset="UTF-8" data-domain-script="28b912e7-09e9-43d5-91e4-3d1897044004" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="oss-wrapper">
<div class="oss-brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com">
<img class="lightbend-logo" src="images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="oss-ad no-drop-down">
<nav id="lightbendRotator" class="lightbend-rotator">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Promo Rotator - Lightbend Changed its Software Licensing Model for Akka Technology. [License FAQ] - Akka Banner" href="https://www.lightbend.com/akka/license-faq">
<strong>Lightbend</strong> Changed its Software Licensing Model for Akka Technology. <span class="akka-btn">License FAQ</span>
</a>
</nav>
</div>
</div>
</div>

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.1
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="remoting-artery.html#remoting" class="active page">Remoting</a>
    <ul>
      <li><a href="remoting-artery.html#dependency" class="header">Dependency</a></li>
      <li><a href="remoting-artery.html#configuration" class="header">Configuration</a></li>
      <li><a href="remoting-artery.html#introduction" class="header">Introduction</a></li>
      <li><a href="remoting-artery.html#selecting-a-transport" class="header">Selecting a transport</a></li>
      <li><a href="remoting-artery.html#migrating-from-classic-remoting" class="header">Migrating from classic remoting</a></li>
      <li><a href="remoting-artery.html#canonical-address" class="header">Canonical address</a></li>
      <li><a href="remoting-artery.html#acquiring-references-to-remote-actors" class="header">Acquiring references to remote actors</a></li>
      <li><a href="remoting-artery.html#remote-security" class="header">Remote Security</a></li>
      <li><a href="remoting-artery.html#quarantine" class="header">Quarantine</a></li>
      <li><a href="remoting-artery.html#serialization" class="header">Serialization</a></li>
      <li><a href="remoting-artery.html#routers-with-remote-destinations" class="header">Routers with Remote Destinations</a></li>
      <li><a href="remoting-artery.html#what-is-new-in-artery" class="header">What is new in Artery</a></li>
      <li><a href="remoting-artery.html#performance-tuning" class="header">Performance tuning</a></li>
      <li><a href="remoting-artery.html#remote-configuration" class="header">Remote Configuration</a></li>
      <li><a href="remoting-artery.html#creating-actors-remotely" class="header">Creating Actors Remotely</a></li>
    </ul></li>
    <li><a href="remote-security.html" class="page">Remote Security</a></li>
    <li><a href="split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="coordination.html" class="page">Coordination</a></li>
    <li><a href="typed/choosing-cluster.html" class="page">Choosing Akka Cluster</a></li>
  </ul></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.8.1
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="remoting-artery.html#remoting" class="active page">Remoting</a>
    <ul>
      <li><a href="remoting-artery.html#dependency" class="header">Dependency</a></li>
      <li><a href="remoting-artery.html#configuration" class="header">Configuration</a></li>
      <li><a href="remoting-artery.html#introduction" class="header">Introduction</a></li>
      <li><a href="remoting-artery.html#selecting-a-transport" class="header">Selecting a transport</a></li>
      <li><a href="remoting-artery.html#migrating-from-classic-remoting" class="header">Migrating from classic remoting</a></li>
      <li><a href="remoting-artery.html#canonical-address" class="header">Canonical address</a></li>
      <li><a href="remoting-artery.html#acquiring-references-to-remote-actors" class="header">Acquiring references to remote actors</a></li>
      <li><a href="remoting-artery.html#remote-security" class="header">Remote Security</a></li>
      <li><a href="remoting-artery.html#quarantine" class="header">Quarantine</a></li>
      <li><a href="remoting-artery.html#serialization" class="header">Serialization</a></li>
      <li><a href="remoting-artery.html#routers-with-remote-destinations" class="header">Routers with Remote Destinations</a></li>
      <li><a href="remoting-artery.html#what-is-new-in-artery" class="header">What is new in Artery</a></li>
      <li><a href="remoting-artery.html#performance-tuning" class="header">Performance tuning</a></li>
      <li><a href="remoting-artery.html#remote-configuration" class="header">Remote Configuration</a></li>
      <li><a href="remoting-artery.html#creating-actors-remotely" class="header">Creating Actors Remotely</a></li>
    </ul></li>
    <li><a href="remote-security.html" class="page">Remote Security</a></li>
    <li><a href="split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="coordination.html" class="page">Coordination</a></li>
    <li><a href="typed/choosing-cluster.html" class="page">Choosing Akka Cluster</a></li>
  </ul></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#remoting" name="remoting" class="anchor"><span class="anchor-link"></span></a>Remoting</h1><div class="callout note "><div class="callout-title">Note</div>
<p>Remoting is the mechanism by which Actors on different nodes talk to each other internally.</p>
<p>When building an Akka application, you would usually not use the Remoting concepts directly, but instead use the more high-level <a href="index-cluster.html">Akka Cluster</a> utilities or technology-agnostic protocols such as <a href="https://doc.akka.io/docs/akka-http/current/">HTTP</a>, <a href="https://doc.akka.io/docs/akka-grpc/current/">gRPC</a> etc.</p></div>
<p>If migrating from classic remoting see <a href="remoting-artery.html#what-is-new-in-artery">what&rsquo;s new in Artery</a></p>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Remoting, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val AkkaVersion = "2.8.1"
libraryDependencies += "com.typesafe.akka" %% "akka-remote" % AkkaVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
      &lt;artifactId&gt;akka-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.8.1&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
    &lt;artifactId&gt;akka-remote_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("com.typesafe.akka:akka-bom_${versions.ScalaBinary}:2.8.1")

  implementation "com.typesafe.akka:akka-remote_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<p>One option is to use Artery with Aeron, see <a href="remoting-artery.html#selecting-a-transport">Selecting a transport</a>. The Aeron dependency needs to be explicitly added if using the <code>aeron-udp</code> transport:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies ++= Seq(
  "io.aeron" % "aeron-driver" % "1.40.0",
  "io.aeron" % "aeron-client" % "1.40.0"
)</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;io.aeron&lt;/groupId&gt;
    &lt;artifactId&gt;aeron-driver&lt;/artifactId&gt;
    &lt;version&gt;1.40.0&lt;/version&gt;
  &lt;/dependency&gt
  &lt;dependency&gt;
    &lt;groupId&gt;io.aeron&lt;/groupId&gt;
    &lt;artifactId&gt;aeron-client&lt;/artifactId&gt;
    &lt;version&gt;1.40.0&lt;/version&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  implementation "io.aeron:aeron-driver:1.40.0"
  implementation "io.aeron:aeron-client:1.40.0"
}</code></pre></dd></dl><div class="callout note "><div class="callout-title">Java 17</div>
<p>When using Aeron with Java 17 you have to add JVM flag <code>--add-opens=java.base/sun.nio.ch=ALL-UNNAMED</code>.</p></div>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>To enable remote capabilities in your Akka project you should, at a minimum, add the following changes to your <code>application.conf</code> file:</p>
<pre><code>akka {
  actor {
    # provider=remote is possible, but prefer cluster
    provider = cluster 
  }
  remote {
    artery {
      transport = tcp # See Selecting a transport below
      canonical.hostname = &quot;127.0.0.1&quot;
      canonical.port = 25520
    }
  }
}
</code></pre>
<p>As you can see in the example above there are four things you need to add to get started:</p>
<ul>
  <li>Change provider from <code>local</code>. We recommend using <a href="cluster-usage.html">Akka Cluster</a> over using remoting directly.</li>
  <li>Enable Artery to use it as the remoting implementation</li>
  <li>Add host name - the machine you want to run the actor system on; this host name is exactly what is passed to remote systems in order to identify this system and consequently used for connecting back to this system if need be, hence set it to a reachable IP address or resolvable name in case you want to communicate across the network.</li>
  <li>Add port number - the port the actor system should listen on, set to 0 to have it chosen automatically</li>
</ul><div class="callout note "><div class="callout-title">Note</div>
<p>The port number needs to be unique for each actor system on the same machine even if the actor systems have different names. This is because each actor system has its own networking subsystem listening for connections and handling messages as not to interfere with other actor systems.</p></div>
<p>The example above only illustrates the bare minimum of properties you have to add to enable remoting. All settings are described in <a href="remoting-artery.html#remote-configuration-artery">Remote Configuration</a>.</p>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>We recommend <a href="cluster-usage.html">Akka Cluster</a> over using remoting directly. As remoting is the underlying module that allows for Cluster, it is still useful to understand details about it though.</p>
<p>Remoting enables Actor systems on different hosts or JVMs to communicate with each other. By enabling remoting the system will start listening on a provided network address and also gains the ability to connect to other systems through the network. From the application&rsquo;s perspective there is no API difference between local or remote systems, <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span> instances that point to remote systems look exactly the same as local ones: they can be sent messages to, watched, etc. Every <code>ActorRef</code> contains hostname and port information and can be passed around even on the network. This means that on a network every <code>ActorRef</code> is a unique identifier of an actor on that network.</p>
<p>You need to enable <a href="serialization.html">serialization</a> for your actor messages. <a href="serialization-jackson.html">Serialization with Jackson</a> is a good choice in many cases and our recommendation if you don&rsquo;t have other preference.</p>
<p>Remoting is not a server-client technology. All systems using remoting can contact any other system on the network if they possess an <code>ActorRef</code> pointing to those system. This means that every system that is remoting enabled acts as a &ldquo;server&rdquo; to which arbitrary systems on the same network can connect to.</p>
<h2><a href="#selecting-a-transport" name="selecting-a-transport" class="anchor"><span class="anchor-link"></span></a>Selecting a transport</h2>
<p>There are three alternatives of which underlying transport to use. It is configured by property <code>akka.remote.artery.transport</code> with the possible values:</p>
<ul>
  <li><code>tcp</code> - Based on <a href="stream/stream-io.html#streaming-tcp">Akka Streams TCP</a> (default if other not configured)</li>
  <li><code>tls-tcp</code> - Same as <code>tcp</code> with encryption using <a href="stream/stream-io.html#tls">Akka Streams TLS</a></li>
  <li><code>aeron-udp</code> - Based on <a href="https://github.com/real-logic/aeron">Aeron (UDP)</a></li>
</ul>
<p>If you are uncertain of what to select a good choice is to use the default, which is <code>tcp</code>.</p>
<p>The Aeron (UDP) transport is a high performance transport and should be used for systems that require high throughput and low latency. It uses more CPU than TCP when the system is idle or at low message rates. There is no encryption for Aeron.</p>
<p>The TCP and TLS transport is implemented using Akka Streams TCP/TLS. This is the choice when encryption is needed, but it can also be used with plain TCP without TLS. It&rsquo;s also the obvious choice when UDP can&rsquo;t be used. It has very good performance (high throughput and low latency) but latency at high throughput might not be as good as the Aeron transport. It has less operational complexity than the Aeron transport and less risk of trouble in container environments.</p>
<p>Aeron requires 64bit JVM to work reliably and is only officially supported on Linux, Mac and Windows. It may work on other Unixes e.g. Solaris but insufficient testing has taken place for it to be officially supported. If you&rsquo;re on a Big Endian processor, such as Sparc, it is recommended to use TCP.</p><div class="callout note "><div class="callout-title">Note</div>
<p><a href="additional/rolling-updates.html">Rolling update</a> is not supported when changing from one transport to another.</p></div>
<h2><a href="#migrating-from-classic-remoting" name="migrating-from-classic-remoting" class="anchor"><span class="anchor-link"></span></a>Migrating from classic remoting</h2>
<p>See <a href="https://doc.akka.io/docs/akka/2.6/project/migration-guide-2.5.x-2.6.x.html#classic-to-artery">migrating from classic remoting</a></p>
<h2><a href="#canonical-address" name="canonical-address" class="anchor"><span class="anchor-link"></span></a>Canonical address</h2>
<p>In order for remoting to work properly, where each system can send messages to any other system on the same network (for example a system forwards a message to a third system, and the third replies directly to the sender system) it is essential for every system to have a <em>unique, globally reachable</em> address and port. This address is part of the unique name of the system and will be used by other systems to open a connection to it and send messages. This means that if a host has multiple names (different DNS records pointing to the same IP address) then only one of these can be <em>canonical</em>. If a message arrives to a system but it contains a different hostname than the expected canonical name then the message will be dropped. If multiple names for a system would be allowed, then equality checks among <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span> instances would no longer to be trusted and this would violate the fundamental assumption that an actor has a globally unique reference on a given network. As a consequence, this also means that localhost addresses (e.g. <em>127.0.0.1</em>) cannot be used in general (apart from local development) since they are not unique addresses in a real network.</p>
<p>In cases, where Network Address Translation (NAT) is used or other network bridging is involved, it is important to configure the system so that it understands that there is a difference between his externally visible, canonical address and between the host-port pair that is used to listen for connections. See <a href="remoting-artery.html#remote-configuration-nat-artery">Akka behind NAT or in a Docker container</a> for details.</p>
<h2><a href="#acquiring-references-to-remote-actors" name="acquiring-references-to-remote-actors" class="anchor"><span class="anchor-link"></span></a>Acquiring references to remote actors</h2>
<p>In order to communicate with an actor, it is necessary to have its <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span>. In the local case it is usually the creator of the actor (the caller of <code>actorOf()</code>) is who gets the <code>ActorRef</code> for an actor that it can then send to other actors. In other words:</p>
<ul>
  <li>An Actor can get a remote Actor&rsquo;s reference by receiving a message from it (as it&rsquo;s available as <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/Actor.html#sender():akka.actor.ActorRef" title="akka.actor.Actor"><code>sender()</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/AbstractActor.html#getSender()" title="akka.actor.AbstractActor"><code>getSender()</code></a></span> then), or inside of a remote message (e.g. <em>PleaseReply(message: String, remoteActorRef: ActorRef)</em>)</li>
</ul>
<p>Alternatively, an actor can look up another located at a known path using <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSelection.html" title="akka.actor.ActorSelection"><code>ActorSelection</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSelection.html" title="akka.actor.ActorSelection"><code>ActorSelection</code></a></span>. These methods are available even in remoting enabled systems:</p>
<ul>
  <li>Remote Lookup : used to look up an actor on a remote node with <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRefFactory.html#actorSelection(path:String):akka.actor.ActorSelection" title="akka.actor.ActorRefFactory"><code>actorSelection(path)</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRefFactory.html#actorSelection(java.lang.String)" title="akka.actor.ActorRefFactory"><code>actorSelection(path)</code></a></span></li>
  <li>Remote Creation : used to create an actor on a remote node with <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRefFactory.html#actorOf(props:akka.actor.Props,name:String):akka.actor.ActorRef" title="akka.actor.ActorRefFactory"><code>actorOf(Props(...), actorName)</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRefFactory.html#actorOf(akka.actor.Props,java.lang.String)" title="akka.actor.ActorRefFactory"><code>actorOf(Props(...), actorName)</code></a></span></li>
</ul>
<p>In the next sections the two alternatives are described in detail.</p>
<h3><a href="#looking-up-remote-actors" name="looking-up-remote-actors" class="anchor"><span class="anchor-link"></span></a>Looking up Remote Actors</h3>
<p><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRefFactory.html#actorSelection(path:String):akka.actor.ActorSelection" title="akka.actor.ActorRefFactory"><code>actorSelection(path)</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRefFactory.html#actorSelection(java.lang.String)" title="akka.actor.ActorRefFactory"><code>actorSelection(path)</code></a></span> will obtain an <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSelection.html" title="akka.actor.ActorSelection"><code>ActorSelection</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSelection.html" title="akka.actor.ActorSelection"><code>ActorSelection</code></a></span> to an Actor on a remote node, e.g.:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre><code>val selection =
  context.actorSelection(&quot;akka://actorSystemName@10.0.0.1:25520/user/actorName&quot;)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre><code>ActorSelection selection =
  context.actorSelection(&quot;akka://actorSystemName@10.0.0.1:25520/user/actorName&quot;);
</code></pre></dd>
</dl>
<p>As you can see from the example above the following pattern is used to find an actor on a remote node:</p>
<pre><code>akka://&lt;actor system&gt;@&lt;hostname&gt;:&lt;port&gt;/&lt;actor path&gt;
</code></pre><div class="callout note "><div class="callout-title">Note</div>
<p>Unlike with earlier remoting, the protocol field is always <em>akka</em> as pluggable transports are no longer supported.</p></div>
<p>Once you obtained a selection to the actor you can interact with it in the same way you would with a local actor, e.g.:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre><code>selection ! &quot;Pretty awesome feature&quot;
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre><code>selection.tell(&quot;Pretty awesome feature&quot;, getSelf());
</code></pre></dd>
</dl>
<p>To acquire an <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span> for an <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSelection.html" title="akka.actor.ActorSelection"><code>ActorSelection</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSelection.html" title="akka.actor.ActorSelection"><code>ActorSelection</code></a></span> you need to send a message to the selection and use the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/Actor.html#sender():akka.actor.ActorRef" title="akka.actor.Actor"><code>sender()</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/AbstractActor.html#getSender()" title="akka.actor.AbstractActor"><code>getSender()</code></a></span> reference of the reply from the actor. There is a built-in <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/Identify.html" title="akka.actor.Identify"><code>Identify</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/Identify.html" title="akka.actor.Identify"><code>Identify</code></a></span> message that all Actors will understand and automatically reply to with a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorIdentity.html" title="akka.actor.ActorIdentity"><code>ActorIdentity</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorIdentity.html" title="akka.actor.ActorIdentity"><code>ActorIdentity</code></a></span> message containing the <code>ActorRef</code>. This can also be done with the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSelection.html#resolveOne(timeout:scala.concurrent.duration.FiniteDuration):scala.concurrent.Future[akka.actor.ActorRef]" title="akka.actor.ActorSelection"><code>resolveOne</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSelection.html#resolveOne(java.time.Duration)" title="akka.actor.ActorSelection"><code>resolveOne</code></a></span> method of the <code>ActorSelection</code>, which returns a <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.10/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span> of the matching <code>ActorRef</code>.</p>
<p>For more details on how actor addresses and paths are formed and used, please refer to <a href="general/addressing.html">Actor References, Paths and Addresses</a>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Message sends to actors that are actually in the sending actor system do not get delivered via the remote actor ref provider. They&rsquo;re delivered directly, by the local actor ref provider.</p>
<p>Aside from providing better performance, this also means that if the hostname you configure remoting to listen as cannot actually be resolved from within the very same actor system, such messages will (perhaps counterintuitively) be delivered just fine.</p></div>
<a id="remote-tls"></a>
<h2><a href="#remote-security" name="remote-security" class="anchor"><span class="anchor-link"></span></a>Remote Security</h2>
<p>An <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span> should not be exposed via Akka Remote (Artery) over plain Aeron/UDP or TCP to an untrusted network (e.g. Internet). It should be protected by network security, such as a firewall. If that is not considered as enough protection TLS with mutual authentication should be enabled. Read more about <a href="remote-security.html">how to enable remote security</a>.</p>
<h2><a href="#quarantine" name="quarantine" class="anchor"><span class="anchor-link"></span></a>Quarantine</h2>
<p>Akka remoting is using TCP or Aeron as underlying message transport. Aeron is using UDP and adds among other things reliable delivery and session semantics, very similar to TCP. This means that the order of the messages are preserved, which is needed for the <a href="general/message-delivery-reliability.html#message-ordering">Actor message ordering guarantees</a>. Under normal circumstances all messages will be delivered but there are cases when messages may not be delivered to the destination:</p>
<ul>
  <li>during a network partition when the TCP connection or the Aeron session is broken, this automatically recovered once the partition is over</li>
  <li>when sending too many messages without flow control and thereby filling up the outbound send queue (<code>outbound-message-queue-size</code> config)</li>
  <li>if serialization or deserialization of a message fails (only that message will be dropped)</li>
  <li>if an unexpected exception occurs in the remoting infrastructure</li>
</ul>
<p>In short, Actor message delivery is “at-most-once” as described in <a href="general/message-delivery-reliability.html">Message Delivery Reliability</a></p>
<p>Some messages in Akka are called system messages and those cannot be dropped because that would result in an inconsistent state between the systems. Such messages are used for essentially two features; remote death watch and remote deployment. These messages are delivered by Akka remoting with “exactly-once” guarantee by confirming each message and resending unconfirmed messages. If a system message anyway cannot be delivered the association with the destination system is irrecoverable failed, and Terminated is signaled for all watched actors on the remote system. It is placed in a so called quarantined state. Quarantine usually does not happen if remote watch or remote deployment is not used.</p>
<p>Each <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span> instance has an unique identifier (UID), which is important for differentiating between incarnations of a system when it is restarted with the same hostname and port. It is the specific incarnation (UID) that is quarantined. The only way to recover from this state is to restart one of the actor systems.</p>
<p>Messages that are sent to and received from a quarantined system will be dropped. However, it is possible to send messages with <code>actorSelection</code> to the address of a quarantined system, which is useful to probe if the system has been restarted.</p>
<p>An association will be quarantined when:</p>
<ul>
  <li>Cluster node is removed from the cluster membership.</li>
  <li>Remote failure detector triggers, i.e. remote watch is used. This is different when <a href="cluster-usage.html">Akka Cluster</a> is used. The unreachable observation by the cluster failure detector can go back to reachable if the network partition heals. A cluster member is not quarantined when the failure detector triggers.</li>
  <li>Overflow of the system message delivery buffer, e.g. because of too many <code>watch</code> requests at the same time (<code>system-message-buffer-size</code> config).</li>
  <li>Unexpected exception occurs in the control subchannel of the remoting infrastructure.</li>
</ul>
<p>The UID of the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorSystem.html" title="akka.actor.ActorSystem"><code>ActorSystem</code></a></span> is exchanged in a two-way handshake when the first message is sent to a destination. The handshake will be retried until the other system replies and no other messages will pass through until the handshake is completed. If the handshake cannot be established within a timeout (<code>handshake-timeout</code> config) the association is stopped (freeing up resources). Queued messages will be dropped if the handshake cannot be established. It will not be quarantined, because the UID is unknown. New handshake attempt will start when next message is sent to the destination.</p>
<p>Handshake requests are actually also sent periodically to be able to establish a working connection when the destination system has been restarted.</p>
<h3><a href="#watching-remote-actors" name="watching-remote-actors" class="anchor"><span class="anchor-link"></span></a>Watching Remote Actors</h3>
<p>Watching a remote actor is API wise not different than watching a local actor, as described in <a href="actors.html#deathwatch">Lifecycle Monitoring aka DeathWatch</a>. However, it is important to note, that unlike in the local case, remoting has to handle when a remote actor does not terminate in a graceful way sending a system message to notify the watcher actor about the event, but instead being hosted on a system which stopped abruptly (crashed). These situations are handled by the built-in failure detector.</p>
<h3><a href="#failure-detector" name="failure-detector" class="anchor"><span class="anchor-link"></span></a>Failure Detector</h3>
<p>Under the hood remote death watch uses heartbeat messages and a failure detector to generate <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/Terminated.html" title="akka.actor.Terminated"><code>Terminated</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/Terminated.html" title="akka.actor.Terminated"><code>Terminated</code></a></span> message from network failures and JVM crashes, in addition to graceful termination of watched actor.</p>
<p>The heartbeat arrival times is interpreted by an implementation of <a href="http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf">The Phi Accrual Failure Detector</a>.</p>
<p>The suspicion level of failure is given by a value called <em>phi</em>. The basic idea of the phi failure detector is to express the value of <em>phi</em> on a scale that is dynamically adjusted to reflect current network conditions.</p>
<p>The value of <em>phi</em> is calculated as:</p>
<pre><code>phi = -log10(1 - F(timeSinceLastHeartbeat))
</code></pre>
<p>where F is the cumulative distribution function of a normal distribution with mean and standard deviation estimated from historical heartbeat inter-arrival times.</p>
<p>In the <a href="remoting-artery.html#remote-configuration-artery">Remote Configuration</a> you can adjust the <code>akka.remote.watch-failure-detector.threshold</code> to define when a <em>phi</em> value is considered to be a failure.</p>
<p>A low <code>threshold</code> is prone to generate many false positives but ensures a quick detection in the event of a real crash. Conversely, a high <code>threshold</code> generates fewer mistakes but needs more time to detect actual crashes. The default <code>threshold</code> is 10 and is appropriate for most situations. However in cloud environments, such as Amazon EC2, the value could be increased to 12 in order to account for network issues that sometimes occur on such platforms.</p>
<p>The following chart illustrates how <em>phi</em> increase with increasing time since the previous heartbeat.</p>
<p><img src="./images/phi1.png" alt="phi1.png" /></p>
<p>Phi is calculated from the mean and standard deviation of historical inter arrival times. The previous chart is an example for standard deviation of 200 ms. If the heartbeats arrive with less deviation the curve becomes steeper, i.e. it is possible to determine failure more quickly. The curve looks like this for a standard deviation of 100 ms.</p>
<p><img src="./images/phi2.png" alt="phi2.png" /></p>
<p>To be able to survive sudden abnormalities, such as garbage collection pauses and transient network failures the failure detector is configured with a margin, <code>akka.remote.watch-failure-detector.acceptable-heartbeat-pause</code>. You may want to adjust the <a href="remoting-artery.html#remote-configuration-artery">Remote Configuration</a> of this depending on you environment. This is how the curve looks like for <code>acceptable-heartbeat-pause</code> configured to 3 seconds.</p>
<p><img src="./images/phi3.png" alt="phi3.png" /></p>
<h2><a href="#serialization" name="serialization" class="anchor"><span class="anchor-link"></span></a>Serialization</h2>
<p>You need to enable <a href="serialization.html">serialization</a> for your actor messages. <a href="serialization-jackson.html">Serialization with Jackson</a> is a good choice in many cases and our recommendation if you don&rsquo;t have other preference.</p>
<a id="remote-bytebuffer-serialization"></a>
<h3><a href="#bytebuffer-based-serialization" name="bytebuffer-based-serialization" class="anchor"><span class="anchor-link"></span></a>ByteBuffer based serialization</h3>
<p>Artery introduces a new serialization mechanism which allows the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/serialization/ByteBufferSerializer.html" title="akka.serialization.ByteBufferSerializer"><code>ByteBufferSerializer</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/serialization/ByteBufferSerializer.html" title="akka.serialization.ByteBufferSerializer"><code>ByteBufferSerializer</code></a></span> to directly write into a shared <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html" title="java.nio.ByteBuffer"><code>java.nio.ByteBuffer</code></a> instead of being forced to allocate and return an <code>Array[Byte]</code> for each serialized message. For high-throughput messaging this API change can yield significant performance benefits, so we recommend changing your serializers to use this new mechanism.</p>
<p>This new API also plays well with new versions of Google Protocol Buffers and other serialization libraries, which gained the ability to serialize directly into and from ByteBuffers.</p>
<p>As the new feature only changes how bytes are read and written, and the rest of the serialization infrastructure remained the same, we recommend reading the <a href="serialization.html">Serialization</a> documentation first.</p>
<p>Implementing an <code>akka.serialization.ByteBufferSerializer</code> works the same way as any other serializer,</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-actor/src/main/scala/akka/serialization/Serializer.scala#L202-L216" target="_blank" title="Go to snippet source">source</a><code class="language-scala">trait ByteBufferSerializer {

  /**
   * Serializes the given object into the `ByteBuffer`.
   */
  def toBinary(o: AnyRef, buf: ByteBuffer): Unit

  /**
   * Produces an object from a `ByteBuffer`, with an optional type-hint;
   * the class should be loaded using ActorSystem.dynamicAccess.
   */
  @throws(classOf[NotSerializableException])
  def fromBinary(buf: ByteBuffer, manifest: String): AnyRef

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/java/jdocs/actor/ByteBufferSerializerDocTest.java#L63-L72" target="_blank" title="Go to snippet source">source</a><code class="language-java">interface ByteBufferSerializer {
  /** Serializes the given object into the `ByteBuffer`. */
  void toBinary(Object o, ByteBuffer buf);

  /**
   * Produces an object from a `ByteBuffer`, with an optional type-hint; the class should be
   * loaded using ActorSystem.dynamicAccess.
   */
  Object fromBinary(ByteBuffer buf, String manifest);
}</code></pre></dd>
</dl>
<p>Implementing a serializer for Artery is therefore as simple as implementing this interface, and binding the serializer as usual (which is explained in <a href="serialization.html">Serialization</a>).</p>
<p>Implementations should typically extend <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/serialization/SerializerWithStringManifest.html" title="akka.serialization.SerializerWithStringManifest"><code>SerializerWithStringManifest</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/serialization/SerializerWithStringManifest.html" title="akka.serialization.SerializerWithStringManifest"><code>SerializerWithStringManifest</code></a></span> and in addition to the <code>ByteBuffer</code> based <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/serialization/ByteBufferSerializer.html#toBinary(o:AnyRef,buf:java.nio.ByteBuffer):Unit" title="akka.serialization.ByteBufferSerializer"><code>toBinary</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/serialization/ByteBufferSerializer.html#toBinary(java.lang.Object,java.nio.ByteBuffer)" title="akka.serialization.ByteBufferSerializer"><code>toBinary</code></a></span> and <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/serialization/ByteBufferSerializer.html#fromBinary(buf:java.nio.ByteBuffer,manifest:String):AnyRef" title="akka.serialization.ByteBufferSerializer"><code>fromBinary</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/serialization/ByteBufferSerializer.html#fromBinary(java.nio.ByteBuffer,java.lang.String)" title="akka.serialization.ByteBufferSerializer"><code>fromBinary</code></a></span> methods also implement the array based <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/serialization/SerializerWithStringManifest.html#toBinary(o:AnyRef):Array[Byte]" title="akka.serialization.SerializerWithStringManifest"><code>toBinary</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/serialization/SerializerWithStringManifest.html#toBinary(java.lang.Object)" title="akka.serialization.SerializerWithStringManifest"><code>toBinary</code></a></span> and <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/serialization/SerializerWithStringManifest.html#fromBinary(bytes:Array[Byte],manifest:Option[Class[_]]):AnyRef" title="akka.serialization.SerializerWithStringManifest"><code>fromBinary</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/serialization/SerializerWithStringManifest.html#fromBinary(byte[],scala.Option)" title="akka.serialization.SerializerWithStringManifest"><code>fromBinary</code></a></span> methods. The array based methods will be used when <code>ByteBuffer</code> is not used, e.g. in Akka Persistence.</p>
<p>Note that the array based methods can be implemented by delegation like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/scala/docs/actor/ByteBufferSerializerDocSpec.scala#L8-L40" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import java.nio.ByteBuffer
import akka.serialization.ByteBufferSerializer
import akka.serialization.SerializerWithStringManifest

class ExampleByteBufSerializer extends SerializerWithStringManifest with ByteBufferSerializer {
  override def identifier: Int = 1337
  override def manifest(o: AnyRef): String = &quot;naive-toStringImpl&quot;

  // Implement this method for compatibility with `SerializerWithStringManifest`.
  override def toBinary(o: AnyRef): Array[Byte] = {
    // in production code, acquire this from a BufferPool
    val buf = ByteBuffer.allocate(256)

    toBinary(o, buf)
    buf.flip()
    val bytes = new Array[Byte](buf.remaining)
    buf.get(bytes)
    bytes
  }

  // Implement this method for compatibility with `SerializerWithStringManifest`.
  override def fromBinary(bytes: Array[Byte], manifest: String): AnyRef =
    fromBinary(ByteBuffer.wrap(bytes), manifest)

  // Actual implementation in the ByteBuffer versions of to/fromBinary:
  override def toBinary(o: AnyRef, buf: ByteBuffer): Unit = ??? // implement actual logic here
  override def fromBinary(buf: ByteBuffer, manifest: String): AnyRef = ??? // implement actual logic here
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/java/jdocs/actor/ByteBufferSerializerDocTest.java#L8-L57" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.serialization.ByteBufferSerializer;
import akka.serialization.SerializerWithStringManifest;

class ExampleByteBufSerializer extends SerializerWithStringManifest
    implements ByteBufferSerializer {

  @Override
  public int identifier() {
    return 1337;
  }

  @Override
  public String manifest(Object o) {
    return &quot;serialized-&quot; + o.getClass().getSimpleName();
  }

  @Override
  public byte[] toBinary(Object o) {
    // in production code, acquire this from a BufferPool
    final ByteBuffer buf = ByteBuffer.allocate(256);

    toBinary(o, buf);
    buf.flip();
    final byte[] bytes = new byte[buf.remaining()];
    buf.get(bytes);
    return bytes;
  }

  @Override
  public Object fromBinary(byte[] bytes, String manifest) {
    return fromBinary(ByteBuffer.wrap(bytes), manifest);
  }

  @Override
  public void toBinary(Object o, ByteBuffer buf) {
    // Implement actual serialization here
  }

  @Override
  public Object fromBinary(ByteBuffer buf, String manifest) {
    // Implement actual deserialization here
    return null;
  }
}</code></pre></dd>
</dl>
<h2><a href="#routers-with-remote-destinations" name="routers-with-remote-destinations" class="anchor"><span class="anchor-link"></span></a>Routers with Remote Destinations</h2>
<p>It is absolutely feasible to combine remoting with <a href="routing.html">Routing</a>.</p>
<p>A pool of remote deployed routees can be configured as:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L219-L225" target="_blank" title="Go to snippet source">source</a><code class="language-scala">akka.actor.deployment {
  /parent/remotePool {
    router = round-robin-pool
    nr-of-instances = 10
    target.nodes = [&quot;tcp://app@10.0.0.2:2552&quot;, &quot;akka://app@10.0.0.3:2552&quot;]
  }
}</code></pre>
<p>This configuration setting will clone the actor defined in the <code>Props</code> of the <code>remotePool</code> 10 times and deploy it evenly distributed across the two given target nodes.</p>
<p>When using a pool of remote deployed routees you must ensure that all parameters of the <code>Props</code> can be <a href="serialization.html">serialized</a>.</p>
<p>A group of remote actors can be configured as:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L241-L249" target="_blank" title="Go to snippet source">source</a><code class="language-scala">akka.actor.deployment {
  /parent/remoteGroup2 {
    router = round-robin-group
    routees.paths = [
      &quot;akka://app@10.0.0.1:2552/user/workers/w1&quot;,
      &quot;akka://app@10.0.0.2:2552/user/workers/w1&quot;,
      &quot;akka://app@10.0.0.3:2552/user/workers/w1&quot;]
  }
}</code></pre>
<p>This configuration setting will send messages to the defined remote actor paths. It requires that you create the destination actors on the remote nodes with matching paths. That is not done by the router.</p>
<h2><a href="#what-is-new-in-artery" name="what-is-new-in-artery" class="anchor"><span class="anchor-link"></span></a>What is new in Artery</h2>
<p>Artery is a reimplementation of the old remoting module aimed at improving performance and stability. It is mostly source compatible with the old implementation and it is a drop-in replacement in many cases. Main features of Artery compared to the previous implementation:</p>
<ul>
  <li>Based on Akka Streams TCP/TLS or <a href="https://github.com/real-logic/Aeron">Aeron</a> (UDP) instead of Netty TCP</li>
  <li>Focused on high-throughput, low-latency communication</li>
  <li>Isolation of internal control messages from user messages improving stability and reducing false failure detection in case of heavy traffic by using a dedicated subchannel.</li>
  <li>Mostly allocation-free operation</li>
  <li>Support for a separate subchannel for large messages to avoid interference with smaller messages</li>
  <li>Compression of actor paths on the wire to reduce overhead for smaller messages</li>
  <li>Support for faster serialization/deserialization using ByteBuffers directly</li>
  <li>Built-in Java Flight Recorder (JFR) to help debugging implementation issues without polluting users logs with implementation specific events</li>
  <li>Providing protocol stability across major Akka versions to support rolling updates of large-scale systems</li>
</ul>
<p>The main incompatible change from the previous implementation is that the protocol field of the string representation of an <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.8/akka/actor/ActorRef.html" title="akka.actor.ActorRef"><code>ActorRef</code></a></span> is always <em>akka</em> instead of the previously used <em>akka.tcp</em> or <em>akka.ssl.tcp</em>. Configuration properties are also different.</p>
<h2><a href="#performance-tuning" name="performance-tuning" class="anchor"><span class="anchor-link"></span></a>Performance tuning</h2>
<h3><a href="#lanes" name="lanes" class="anchor"><span class="anchor-link"></span></a>Lanes</h3>
<p>Message serialization and deserialization can be a bottleneck for remote communication. Therefore there is support for parallel inbound and outbound lanes to perform serialization and other tasks for different destination actors in parallel. Using multiple lanes is of most value for the inbound messages, since all inbound messages from all remote systems share the same inbound stream. For outbound messages there is already one stream per remote destination system, so multiple outbound lanes only add value when sending to different actors in same destination system.</p>
<p>The selection of lane is based on consistent hashing of the recipient ActorRef to preserve message ordering per receiver.</p>
<p>Note that lowest latency can be achieved with <code>inbound-lanes=1</code> and <code>outbound-lanes=1</code> because multiple lanes introduce an asynchronous boundary. </p>
<p>Also note that the total amount of parallel tasks are bound by the <code>remote-dispatcher</code> and the thread pool size should not exceed the number of CPU cores minus headroom for actually processing the messages in the application, i.e. in practice the the pool size should be less than half of the number of cores.</p>
<p>See <code>inbound-lanes</code> and <code>outbound-lanes</code> in the <a href="general/configuration-reference.html#config-akka-remote-artery">reference configuration</a> for default values.</p>
<h3><a href="#dedicated-subchannel-for-large-messages" name="dedicated-subchannel-for-large-messages" class="anchor"><span class="anchor-link"></span></a>Dedicated subchannel for large messages</h3>
<p>All the communication between user defined remote actors are isolated from the channel of Akka internal messages so a large user message cannot block an urgent system message. While this provides good isolation for Akka services, all user communications by default happen through a shared network connection. When some actors send large messages this can cause other messages to suffer higher latency as they need to wait until the full message has been transported on the shared channel (and hence, shared bottleneck). In these cases it is usually helpful to separate actors that have different QoS requirements: large messages vs. low latency.</p>
<p>Akka remoting provides a dedicated channel for large messages if configured. Since actor message ordering must not be violated the channel is actually dedicated for <em>actors</em> instead of messages, to ensure all of the messages arrive in send order. It is possible to assign actors on given paths to use this dedicated channel by using path patterns that have to be specified in the actor system&rsquo;s configuration on both the sending and the receiving side:</p>
<pre><code>akka.remote.artery.large-message-destinations = [
   &quot;/user/largeMessageActor&quot;,
   &quot;/user/largeMessagesGroup/*&quot;,
   &quot;/user/anotherGroup/*/largeMesssages&quot;,
   &quot;/user/thirdGroup/**&quot;,
   &quot;/temp/session-ask-actor*&quot;
]
</code></pre>
<p>*NOTE: Support for * inside of an actor path (ie. /temp/session-ask-actor*) is only available in 2.6.18+</p>
<p>This means that all messages sent to the following actors will pass through the dedicated, large messages channel:</p>
<ul>
  <li><code>/user/largeMessageActor</code></li>
  <li><code>/user/largeMessageActorGroup/actor1</code></li>
  <li><code>/user/largeMessageActorGroup/actor2</code></li>
  <li><code>/user/anotherGroup/actor1/largeMessages</code></li>
  <li><code>/user/anotherGroup/actor2/largeMessages</code></li>
  <li><code>/user/thirdGroup/actor3/</code></li>
  <li><code>/user/thirdGroup/actor4/actor5</code></li>
  <li><code>/temp/session-ask-actor$abc</code></li>
</ul>
<p>Messages destined for actors not matching any of these patterns are sent using the default channel as before.</p>
<p>To notice large messages you can enable logging of message types with payload size in bytes larger than the configured <code>log-frame-size-exceeding</code>.</p>
<pre><code>akka.remote.artery {
  log-frame-size-exceeding = 10000b
}
</code></pre>
<p>Example log messages:</p>
<pre><code>[INFO] Payload size for [java.lang.String] is [39068] bytes. Sent to Actor[akka://Sys@localhost:53039/user/destination#-1908386800]
[INFO] New maximum payload size for [java.lang.String] is [44068] bytes. Sent to Actor[akka://Sys@localhost:53039/user/destination#-1908386800].
</code></pre>
<p>The large messages channel can still not be used for extremely large messages, a few MB per message at most. An alternative is to use the <a href="typed/reliable-delivery.html">Reliable delivery</a> that has support for automatically <a href="typed/reliable-delivery.html#chunk-large-messages">splitting up large messages</a> and assemble them again on the receiving side.</p>
<h3><a href="#external-shared-aeron-media-driver" name="external-shared-aeron-media-driver" class="anchor"><span class="anchor-link"></span></a>External, shared Aeron media driver</h3>
<p>The Aeron transport is running in a so called <a href="https://github.com/real-logic/Aeron/wiki/Media-Driver-Operation">media driver</a>. By default, Akka starts the media driver embedded in the same JVM process as application. This is convenient and simplifies operational concerns by only having one process to start and monitor.</p>
<p>The media driver may use rather much CPU resources. If you run more than one Akka application JVM on the same machine it can therefore be wise to share the media driver by running it as a separate process.</p>
<p>The media driver has also different resource usage characteristics than a normal application and it can therefore be more efficient and stable to run the media driver as a separate process.</p>
<p>Given that Aeron jar files are in the classpath the standalone media driver can be started with:</p>
<pre><code>java io.aeron.driver.MediaDriver
</code></pre>
<p>The needed classpath:</p>
<pre><code>Agrona-0.5.4.jar:aeron-driver-1.0.1.jar:aeron-client-1.0.1.jar
</code></pre>
<p>You find those jar files on <a href="https://search.maven.org/">Maven Central</a>, or you can create a package with your preferred build tool.</p>
<p>You can pass <a href="https://github.com/real-logic/Aeron/wiki/Configuration-Options">Aeron properties</a> as command line <em>-D</em> system properties:</p>
<pre><code>-Daeron.dir=/dev/shm/aeron
</code></pre>
<p>You can also define Aeron properties in a file:</p>
<pre><code>java io.aeron.driver.MediaDriver config/aeron.properties
</code></pre>
<p>An example of such a properties file:</p>
<pre><code>aeron.mtu.length=16384
aeron.socket.so_sndbuf=2097152
aeron.socket.so_rcvbuf=2097152
aeron.rcv.buffer.length=16384
aeron.rcv.initial.window.length=2097152
agrona.disable.bounds.checks=true

aeron.threading.mode=SHARED_NETWORK

# low latency settings
#aeron.threading.mode=DEDICATED
#aeron.sender.idle.strategy=org.agrona.concurrent.BusySpinIdleStrategy
#aeron.receiver.idle.strategy=org.agrona.concurrent.BusySpinIdleStrategy

# use same director in akka.remote.artery.advanced.aeron-dir config
# of the Akka application
aeron.dir=/dev/shm/aeron
</code></pre>
<p>Read more about the media driver in the <a href="https://github.com/real-logic/Aeron/wiki/Media-Driver-Operation">Aeron documentation</a>.</p>
<p>To use the external media driver from the Akka application you need to define the following two configuration properties:</p>
<pre><code>akka.remote.artery.advanced.aeron {
  embedded-media-driver = off
  aeron-dir = /dev/shm/aeron
}
</code></pre>
<p>The <code>aeron-dir</code> must match the directory you started the media driver with, i.e. the <code>aeron.dir</code> property.</p>
<p>Several Akka applications can then be configured to use the same media driver by pointing to the same directory.</p>
<p>Note that if the media driver process is stopped the Akka applications that are using it will also be stopped.</p>
<h3><a href="#aeron-tuning" name="aeron-tuning" class="anchor"><span class="anchor-link"></span></a>Aeron Tuning</h3>
<p>See Aeron documentation about <a href="https://github.com/real-logic/Aeron/wiki/Performance-Testing">Performance Testing</a>.</p>
<h3><a href="#fine-tuning-cpu-usage-latency-tradeoff" name="fine-tuning-cpu-usage-latency-tradeoff" class="anchor"><span class="anchor-link"></span></a>Fine-tuning CPU usage latency tradeoff</h3>
<p>Artery has been designed for low latency and as a result it can be CPU hungry when the system is mostly idle. This is not always desirable. When using the Aeron transport it is possible to tune the tradeoff between CPU usage and latency with the following configuration:</p>
<pre><code># Values can be from 1 to 10, where 10 strongly prefers low latency
# and 1 strongly prefers less CPU usage
akka.remote.artery.advanced.aeron.idle-cpu-level = 1
</code></pre>
<p>By setting this value to a lower number, it tells Akka to do longer &ldquo;sleeping&rdquo; periods on its thread dedicated for <a href="https://en.wikipedia.org/wiki/Busy_waiting">spin-waiting</a> and hence reducing CPU load when there is no immediate task to execute at the cost of a longer reaction time to an event when it actually happens. It is worth to be noted though that during a continuously high-throughput period this setting makes not much difference as the thread mostly has tasks to execute. This also means that under high throughput (but below maximum capacity) the system might have less latency than at low message rates.</p>
<a id="remote-configuration-artery"></a>
<h2><a href="#remote-configuration" name="remote-configuration" class="anchor"><span class="anchor-link"></span></a>Remote Configuration</h2>
<p>There are lots of configuration properties that are related to remoting in Akka. We refer to the <a href="general/configuration-reference.html#config-akka-remote-artery">reference configuration</a> for more information.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Setting properties like the listening IP and port number programmatically is best done by using something like the following:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L83-L84" target="_blank" title="Go to snippet source">source</a><code class="language-java">ConfigFactory.parseString(&quot;akka.remote.artery.canonical.hostname=\&quot;1.2.3.4\&quot;&quot;)
    .withFallback(ConfigFactory.load());</code></pre></div>
<a id="remote-configuration-nat-artery"></a>
<h3><a href="#akka-behind-nat-or-in-a-docker-container" name="akka-behind-nat-or-in-a-docker-container" class="anchor"><span class="anchor-link"></span></a>Akka behind NAT or in a Docker container</h3>
<p>In setups involving Network Address Translation (NAT), Load Balancers or Docker containers the hostname and port pair that Akka binds to will be different than the &ldquo;logical&rdquo; host name and port pair that is used to connect to the system from the outside. This requires special configuration that sets both the logical and the bind pairs for remoting.</p>
<pre><code>akka {
  remote {
    artery {
      canonical.hostname = my.domain.com      # external (logical) hostname
      canonical.port = 8000                   # external (logical) port

      bind.hostname = local.address # internal (bind) hostname
      bind.port = 25520              # internal (bind) port
    }
 }
}
</code></pre>
<p>You can look at the <span class="group-java"><a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-sample-cluster-docker-compose-java">Cluster with docker-compse example project</a></span> <span class="group-scala"><a href="https://developer.lightbend.com/start/?group=akka&amp;project=akka-sample-cluster-docker-compose-scala">Cluster with docker-compose example project</a></span> to see what this looks like in practice.</p>
<h3><a href="#running-in-docker-kubernetes" name="running-in-docker-kubernetes" class="anchor"><span class="anchor-link"></span></a>Running in Docker/Kubernetes</h3>
<p>When using <code>aeron-udp</code> in a containerized environment special care must be taken that the media driver runs on a ram disk. This by default is located in <code>/dev/shm</code> which on most physical Linux machines will be mounted as half the size of the system memory.</p>
<p>Docker and Kubernetes mount a 64Mb ram disk. This is unlikely to be large enough. For docker this can be overridden with <code>--shm-size=&quot;512mb&quot;</code>.</p>
<p>In Kubernetes there is no direct support (yet) for setting <code>shm</code> size. Instead mount an <code>EmptyDir</code> with type <code>Memory</code> to <code>/dev/shm</code> for example in a deployment.yml:</p>
<pre><code>spec:
  containers:
  - name: artery-udp-cluster
    // rest of container spec...
    volumeMounts:
    - mountPath: /dev/shm
      name: media-driver
  volumes:
  - name: media-driver
    emptyDir:
      medium: Memory
      name: media-driver
</code></pre>
<p>There is currently no way to limit the size of a memory empty dir but there is a <a href="https://github.com/kubernetes/kubernetes/pull/63641">pull request</a> for adding it.</p>
<p>Any space used in the mount will count towards your container&rsquo;s memory usage.</p>
<h3><a href="#flight-recorder" name="flight-recorder" class="anchor"><span class="anchor-link"></span></a>Flight Recorder</h3>
<p>When running on JDK 11 Artery specific flight recording is available through the <a href="https://openjdk.java.net/jeps/328">Java Flight Recorder (JFR)</a>. The flight recorder is automatically enabled by detecting JDK 11 but can be disabled if needed by setting <code>akka.java-flight-recorder.enabled = false</code>.</p>
<p>Low overhead Artery specific events are emitted by default when JFR is enabled, higher overhead events needs a custom settings template and are not enabled automatically with the <code>profiling</code> JFR template. To enable those create a copy of the <code>profiling</code> template and enable all <code>Akka</code> sub category events, for example through the JMC GUI. </p>
<h2><a href="#creating-actors-remotely" name="creating-actors-remotely" class="anchor"><span class="anchor-link"></span></a>Creating Actors Remotely</h2><div class="callout warning "><div class="callout-title">Warning</div>
<p>We recommend against Creating Actors Remotely, also known as remote deployment, but it is documented here for completeness.</p></div>
<p>If you want to use the creation functionality in Akka remoting you have to further amend the <code>application.conf</code> file in the following way (only showing deployment section):</p>
<pre><code>akka {
  actor {
    deployment {
      /sampleActor {
        remote = &quot;akka.tcp://sampleActorSystem@127.0.0.1:2553&quot;
      }
    }
  }
}
</code></pre>
<p>The configuration above instructs Akka to react when an actor with path <code>/sampleActor</code> is created, i.e. using <span class="group-scala"><code>system.actorOf(Props(...), &quot;sampleActor&quot;)</code></span><span class="group-java"><code>system.actorOf(new Props(...), &quot;sampleActor&quot;)</code></span>. This specific actor will not be directly instantiated, but instead the remote daemon of the remote system will be asked to create the actor, which in this sample corresponds to <code>sampleActorSystem@127.0.0.1:2553</code>.</p>
<p>Once you have configured the properties above you would do the following in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L62-L64" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>val actor = system.actorOf(Props[SampleActor](), &quot;sampleActor&quot;)
actor ! &quot;Pretty slick&quot;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L74-L76" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>ActorRef actor = system.actorOf(Props.create(SampleActor.class), &quot;sampleActor&quot;);
actor.tell(&quot;Pretty slick&quot;, ActorRef.noSender());</code></pre></dd>
</dl>
<p>The actor class <code>SampleActor</code> has to be available to the runtimes using it, i.e. the classloader of the actor systems has to have a JAR containing the class.</p>
<p>When using remote deployment of actors you must ensure that all parameters of the <code>Props</code> can be <a href="serialization.html">serialized</a>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>In order to ensure serializability of <code>Props</code> when passing constructor arguments to the actor being created, do not make the factory <span class="group-scala">an</span><span class="group-java">a non-static</span> inner class: this will inherently capture a reference to its enclosing object, which in most cases is not serializable. It is best to <span class="group-scala">create a factory method in the companion object of the actor’s class</span><span class="group-java">make a static inner class which implements <code>Creator&lt;T extends Actor&gt;</code></span>.</p>
<p>Serializability of all Props can be tested by setting the configuration item <code>akka.actor.serialize-creators=on</code>. Only Props whose <code>deploy</code> has <code>LocalScope</code> are exempt from this check.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>You can use asterisks as wildcard matches for the actor path sections, so you could specify: <code>/*/sampleActor</code> and that would match all <code>sampleActor</code> on that level in the hierarchy. You can also use wildcard in the last position to match all actors at a certain level: <code>/someParent/*</code>. Non-wildcard matches always have higher priority to match than wildcards, so: <code>/foo/bar</code> is considered <strong>more specific</strong> than <code>/foo/*</code> and only the highest priority match is used. Please note that it <strong>cannot</strong> be used to partially match section, like this: <code>/foo*/bar</code>, <code>/f*o/bar</code> etc.</p></div>
<h3><a href="#programmatic-remote-deployment" name="programmatic-remote-deployment" class="anchor"><span class="anchor-link"></span></a>Programmatic Remote Deployment</h3><div class="callout warning "><div class="callout-title">Warning</div>
<p>We recommend against Creating Actors Remotely, also known as remote deployment, but it is documented here for completeness. This is only available for the classic Actor API.</p></div>
<p>To allow dynamically deployed systems, it is also possible to include deployment configuration in the <code>Props</code> which are used to create an actor: this information is the equivalent of a deployment section from the configuration file, and if both are given, the external configuration takes precedence.</p>
<p>With these imports:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L10-L11" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import akka.actor.{ Address, AddressFromURIString, Deploy, Props }
import akka.remote.RemoteScope</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L16-L22" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.actor.ActorRef;
import akka.actor.Address;
import akka.actor.AddressFromURIString;
import akka.actor.Deploy;
import akka.actor.Props;
import akka.actor.ActorSystem;
import akka.remote.RemoteScope;</code></pre></dd>
</dl>
<p>and a remote address like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L54-L55" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val one = AddressFromURIString(&quot;akka://sys@host:1234&quot;)
val two = Address(&quot;akka&quot;, &quot;sys&quot;, &quot;host&quot;, 1234) // this gives the same</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L61-L62" target="_blank" title="Go to snippet source">source</a><code class="language-java">Address addr = new Address(&quot;akka&quot;, &quot;sys&quot;, &quot;host&quot;, 1234);
addr = AddressFromURIString.parse(&quot;akka://sys@host:1234&quot;); // the same</code></pre></dd>
</dl>
<p>you can advise the system to create a child on that remote node like so:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L38" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val ref = system.actorOf(Props[SampleActor]().withDeploy(Deploy(scope = RemoteScope(address))))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L65-L66" target="_blank" title="Go to snippet source">source</a><code class="language-java">Props props = Props.create(SampleActor.class).withDeploy(new Deploy(new RemoteScope(addr)));
ActorRef ref = system.actorOf(props);</code></pre></dd>
</dl>
<h3><a href="#remote-deployment-allow-list" name="remote-deployment-allow-list" class="anchor"><span class="anchor-link"></span></a>Remote deployment allow list</h3>
<p>As remote deployment can potentially be abused by both users and even attackers an allow list feature is available to guard the ActorSystem from deploying unexpected actors. Please note that remote deployment is <em>not</em> remote code loading, the Actors class to be deployed onto a remote system needs to be present on that remote system. This still however may pose a security risk, and one may want to restrict remote deployment to only a specific set of known actors by enabling the allow list feature.</p>
<p>To enable remote deployment allow list set the <code>akka.remote.deployment.enable-allow-list</code> value to <code>on</code>. The list of allowed classes has to be configured on the &ldquo;remote&rdquo; system, in other words on the system onto which others will be attempting to remote deploy Actors. That system, locally, knows best which Actors it should or should not allow others to remote deploy onto it. The full settings section may for example look like this:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.8.1/akka-remote/src/test/scala/akka/remote/artery/RemoteDeploymentSpec.scala#L82-L92" target="_blank" title="Go to snippet source">source</a><code class="language-scala">akka.remote.deployment {
  enable-allow-list = on
  
  allowed-actor-classes = [
    &quot;akka.remote.artery.RemoteDeploymentSpec.Echo1&quot;
  ]
}</code></pre>
<p>Actor classes not included in the allow list will not be allowed to be remote deployed onto this system.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="multi-node-testing.html"><i class="icon-prev"></i> <span class="link-prev">Multi Node Testing</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="remote-security.html">Remote Security <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.8.1/akka-docs/src/main/paradox/remoting-artery.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg" />
<section class="copyright">
<div>Akka is available under the <a href="https://www.lightbend.com/akka/license" target="_blank">Business Source License 1.1</a>.</div>
<p class="legal">
&copy; 2011-2023 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/snippets.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>
<script type="text/javascript" src="js/metadata-toggle.js"></script>
<script type="text/javascript" src="js/lbHeader.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
appId: 'XUXZ6LW9B1',
apiKey: '5b6260148e92f7c5e38338fcf7eaa3e0',
indexName: 'akka_docs',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
appId: 'XUXZ6LW9B1',
apiKey: '5b6260148e92f7c5e38338fcf7eaa3e0',
indexName: 'akka_docs',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
