<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Futures &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/futures.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../scala/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../scala/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../scala/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../scala/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../scala/index-actors.html" class="page">Actors</a></li>
  <li><a href="../scala/index-network.html" class="page">Networking</a></li>
  <li><a href="../scala/stream/index.html" class="page">Streams</a></li>
  <li><a href="../scala/index-futures.html" class="page">Futures and Agents</a>
  <ul>
    <li><a href="../scala/futures.html#futures" class="active page">Futures</a>
    <ul>
      <li><a href="../scala/futures.html#introduction" class="header">Introduction</a></li>
      <li><a href="../scala/futures.html#execution-contexts" class="header">Execution Contexts</a></li>
      <li><a href="../scala/futures.html#use-with-actors" class="header">Use With Actors</a></li>
      <li><a href="../scala/futures.html#use-directly" class="header">Use Directly</a></li>
      <li><a href="../scala/futures.html#functional-futures" class="header">Functional Futures</a></li>
      <li><a href="../scala/futures.html#callbacks" class="header">Callbacks</a></li>
      <li><a href="../scala/futures.html#define-ordering" class="header">Define Ordering</a></li>
      <li><a href="../scala/futures.html#auxiliary-methods" class="header">Auxiliary Methods</a></li>
      <li><a href="../scala/futures.html#exceptions" class="header">Exceptions</a></li>
      <li><a href="../scala/futures.html#after" class="header">After</a></li>
    </ul></li>
    <li><a href="../scala/agents.html" class="page">Agents</a></li>
  </ul></li>
  <li><a href="../scala/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../scala/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../scala/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../scala/project/index.html" class="page">Project Information</a></li>
  <li><a href="../scala/additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../scala/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../scala/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../scala/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../scala/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../scala/index-actors.html" class="page">Actors</a></li>
  <li><a href="../scala/index-network.html" class="page">Networking</a></li>
  <li><a href="../scala/stream/index.html" class="page">Streams</a></li>
  <li><a href="../scala/index-futures.html" class="page">Futures and Agents</a>
  <ul>
    <li><a href="../scala/futures.html#futures" class="active page">Futures</a>
    <ul>
      <li><a href="../scala/futures.html#introduction" class="header">Introduction</a></li>
      <li><a href="../scala/futures.html#execution-contexts" class="header">Execution Contexts</a></li>
      <li><a href="../scala/futures.html#use-with-actors" class="header">Use With Actors</a></li>
      <li><a href="../scala/futures.html#use-directly" class="header">Use Directly</a></li>
      <li><a href="../scala/futures.html#functional-futures" class="header">Functional Futures</a></li>
      <li><a href="../scala/futures.html#callbacks" class="header">Callbacks</a></li>
      <li><a href="../scala/futures.html#define-ordering" class="header">Define Ordering</a></li>
      <li><a href="../scala/futures.html#auxiliary-methods" class="header">Auxiliary Methods</a></li>
      <li><a href="../scala/futures.html#exceptions" class="header">Exceptions</a></li>
      <li><a href="../scala/futures.html#after" class="header">After</a></li>
    </ul></li>
    <li><a href="../scala/agents.html" class="page">Agents</a></li>
  </ul></li>
  <li><a href="../scala/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../scala/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../scala/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../scala/project/index.html" class="page">Project Information</a></li>
  <li><a href="../scala/additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#futures" name="futures" class="anchor"><span class="anchor-link"></span></a>Futures</h1>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>In the Scala Standard Library, a <a href="http://en.wikipedia.org/wiki/Futures_and_promises">Future</a> is a data structure used to retrieve the result of some concurrent operation. This result can be accessed synchronously (blocking) or asynchronously (non-blocking).</p>
<h2><a href="#execution-contexts" name="execution-contexts" class="anchor"><span class="anchor-link"></span></a>Execution Contexts</h2>
<p>In order to execute callbacks and operations, Futures need something called an <code>ExecutionContext</code>, which is very similar to a <code>java.util.concurrent.Executor</code>. if you have an <code>ActorSystem</code> in scope, it will use its default dispatcher as the <code>ExecutionContext</code>, or you can use the factory methods provided by the <code>ExecutionContext</code> companion object to wrap <code>Executors</code> and <code>ExecutorServices</code>, or even create your own.</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.{ ExecutionContext, Promise }

implicit val ec = ExecutionContext.fromExecutorService(yourExecutorServiceGoesHere)

// Do stuff with your brand new shiny ExecutionContext
val f = Promise.successful(&quot;foo&quot;)

// Then shut your ExecutionContext down at some
// appropriate place in your program/application
ec.shutdown()</code></pre>
<h3><a href="#within-actors" name="within-actors" class="anchor"><span class="anchor-link"></span></a>Within Actors</h3>
<p>Each actor is configured to be run on a <code>MessageDispatcher</code>, and that dispatcher doubles as an <code>ExecutionContext</code>. If the nature of the Future calls invoked by the actor matches or is compatible with the activities of that actor (e.g. all CPU bound and no latency requirements), then it may be easiest to reuse the dispatcher for running the Futures by importing <code>context.dispatcher</code>.</p>
<pre class="prettyprint"><code class="language-scala">class A extends Actor {
  import context.dispatcher
  val f = Future(&quot;hello&quot;)
  def receive = {
    case _ =&gt;
  }
}</code></pre>
<h2><a href="#use-with-actors" name="use-with-actors" class="anchor"><span class="anchor-link"></span></a>Use With Actors</h2>
<p>There are generally two ways of getting a reply from an <code>Actor</code>: the first is by a sent message (<code>actor ! msg</code>), which only works if the original sender was an <code>Actor</code>) and the second is through a <code>Future</code>.</p>
<p>Using an <code>Actor</code>&rsquo;s <code>?</code> method to send a message will return a <code>Future</code>:</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.Await
import akka.pattern.ask
import akka.util.Timeout
import scala.concurrent.duration._

implicit val timeout = Timeout(5 seconds)
val future = actor ? msg // enabled by the “ask” import
val result = Await.result(future, timeout.duration).asInstanceOf[String]</code></pre>
<p>This will cause the current thread to block and wait for the <code>Actor</code> to &lsquo;complete&rsquo; the <code>Future</code> with it&rsquo;s reply. Blocking is discouraged though as it will cause performance problems. The blocking operations are located in <code>Await.result</code> and <code>Await.ready</code> to make it easy to spot where blocking occurs. Alternatives to blocking are discussed further within this documentation. Also note that the <code>Future</code> returned by an <code>Actor</code> is a <code>Future[Any]</code> since an <code>Actor</code> is dynamic. That is why the <code>asInstanceOf</code> is used in the above sample. When using non-blocking it is better to use the <code>mapTo</code> method to safely try to cast a <code>Future</code> to an expected type:</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.Future
import akka.pattern.ask

val future: Future[String] = ask(actor, msg).mapTo[String]</code></pre>
<p>The <code>mapTo</code> method will return a new <code>Future</code> that contains the result if the cast was successful, or a <code>ClassCastException</code> if not. Handling <code>Exception</code>s will be discussed further within this documentation.</p>
<p>To send the result of a <code>Future</code> to an <code>Actor</code>, you can use the <code>pipe</code> construct:</p>
<pre class="prettyprint"><code class="language-scala">import akka.pattern.pipe
future pipeTo actor</code></pre>
<h2><a href="#use-directly" name="use-directly" class="anchor"><span class="anchor-link"></span></a>Use Directly</h2>
<p>A common use case within Akka is to have some computation performed concurrently without needing the extra utility of an <code>Actor</code>. If you find yourself creating a pool of <code>Actor</code>s for the sole reason of performing a calculation in parallel, there is an easier (and faster) way:</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.Await
import scala.concurrent.Future
import scala.concurrent.duration._

val future = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
future foreach println</code></pre>
<p>In the above code the block passed to <code>Future</code> will be executed by the default <code>Dispatcher</code>, with the return value of the block used to complete the <code>Future</code> (in this case, the result would be the string: &ldquo;HelloWorld&rdquo;). Unlike a <code>Future</code> that is returned from an <code>Actor</code>, this <code>Future</code> is properly typed, and we also avoid the overhead of managing an <code>Actor</code>.</p>
<p>You can also create already completed Futures using the <code>Future</code> companion, which can be either successes:</p>
<pre class="prettyprint"><code class="language-scala">val future = Future.successful(&quot;Yay!&quot;)</code></pre>
<p>Or failures:</p>
<pre class="prettyprint"><code class="language-scala">val otherFuture = Future.failed[String](new IllegalArgumentException(&quot;Bang!&quot;))</code></pre>
<p>It is also possible to create an empty <code>Promise</code>, to be filled later, and obtain the corresponding <code>Future</code>:</p>
<pre class="prettyprint"><code class="language-scala">val promise = Promise[String]()
val theFuture = promise.future
promise.success(&quot;hello&quot;)</code></pre>
<h2><a href="#functional-futures" name="functional-futures" class="anchor"><span class="anchor-link"></span></a>Functional Futures</h2>
<p>Scala&rsquo;s <code>Future</code> has several monadic methods that are very similar to the ones used by Scala&rsquo;s collections. These allow you to create &lsquo;pipelines&rsquo; or &lsquo;streams&rsquo; that the result will travel through.</p>
<h3><a href="#future-is-a-monad" name="future-is-a-monad" class="anchor"><span class="anchor-link"></span></a>Future is a Monad</h3>
<p>The first method for working with <code>Future</code> functionally is <code>map</code>. This method takes a <code>Function</code> which performs some operation on the result of the <code>Future</code>, and returning a new result. The return value of the <code>map</code> method is another <code>Future</code> that will contain the new result:</p>
<pre class="prettyprint"><code class="language-scala">val f1 = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
val f2 = f1 map { x =&gt;
  x.length
}
f2 foreach println</code></pre>
<p>In this example we are joining two strings together within a <code>Future</code>. Instead of waiting for this to complete, we apply our function that calculates the length of the string using the <code>map</code> method. Now we have a second <code>Future</code> that will eventually contain an <code>Int</code>. When our original <code>Future</code> completes, it will also apply our function and complete the second <code>Future</code> with its result. When we finally get the result, it will contain the number 10. Our original <code>Future</code> still contains the string &ldquo;HelloWorld&rdquo; and is unaffected by the <code>map</code>.</p>
<p>The <code>map</code> method is fine if we are modifying a single <code>Future</code>, but if 2 or more <code>Future</code>s are involved <code>map</code> will not allow you to combine them together:</p>
<pre class="prettyprint"><code class="language-scala">val f1 = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
val f2 = Future.successful(3)
val f3 = f1 map { x =&gt;
  f2 map { y =&gt;
    x.length * y
  }
}
f3 foreach println</code></pre>
<p><code>f3</code> is a <code>Future[Future[Int]]</code> instead of the desired <code>Future[Int]</code>. Instead, the <code>flatMap</code> method should be used:</p>
<pre class="prettyprint"><code class="language-scala">val f1 = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
val f2 = Future.successful(3)
val f3 = f1 flatMap { x =&gt;
  f2 map { y =&gt;
    x.length * y
  }
}
f3 foreach println</code></pre>
<p>Composing futures using nested combinators it can sometimes become quite complicated and hard to read, in these cases using Scala&rsquo;s &lsquo;for comprehensions&rsquo; usually yields more readable code. See next section for examples.</p>
<p>If you need to do conditional propagation, you can use <code>filter</code>:</p>
<pre class="prettyprint"><code class="language-scala">val future1 = Future.successful(4)
val future2 = future1.filter(_ % 2 == 0)

future2 foreach println

val failedFilter = future1.filter(_ % 2 == 1).recover {
  // When filter fails, it will have a java.util.NoSuchElementException
  case m: NoSuchElementException =&gt; 0
}

failedFilter foreach println</code></pre>
<h3><a href="#for-comprehensions" name="for-comprehensions" class="anchor"><span class="anchor-link"></span></a>For Comprehensions</h3>
<p>Since <code>Future</code> has a <code>map</code>, <code>filter</code> and <code>flatMap</code> method it can be easily used in a &lsquo;for comprehension&rsquo;:</p>
<pre class="prettyprint"><code class="language-scala">val f = for {
  a &lt;- Future(10 / 2) // 10 / 2 = 5
  b &lt;- Future(a + 1) //  5 + 1 = 6
  c &lt;- Future(a - 1) //  5 - 1 = 4
  if c &gt; 3 // Future.filter
} yield b * c //  6 * 4 = 24

// Note that the execution of futures a, b, and c
// are not done in parallel.

f foreach println</code></pre>
<p>Something to keep in mind when doing this is even though it looks like parts of the above example can run in parallel, each step of the for comprehension is run sequentially. This will happen on separate threads for each step but there isn&rsquo;t much benefit over running the calculations all within a single <code>Future</code>. The real benefit comes when the <code>Future</code>s are created first, and then combining them together.</p>
<h3><a href="#composing-futures" name="composing-futures" class="anchor"><span class="anchor-link"></span></a>Composing Futures</h3>
<p>The example for comprehension above is an example of composing <code>Future</code>s. A common use case for this is combining the replies of several <code>Actor</code>s into a single calculation without resorting to calling <code>Await.result</code> or <code>Await.ready</code> to block for each result. First an example of using <code>Await.result</code>:</p>
<pre class="prettyprint"><code class="language-scala"><br/>val f1 = ask(actor1, msg1)
val f2 = ask(actor2, msg2)

val a = Await.result(f1, 3 seconds).asInstanceOf[Int]
val b = Await.result(f2, 3 seconds).asInstanceOf[Int]

val f3 = ask(actor3, (a + b))

val result = Await.result(f3, 3 seconds).asInstanceOf[Int]</code></pre><div class="callout warning "><div class="callout-title">Warning</div>
<p><code>Await.result</code> and <code>Await.ready</code> are provided for exceptional situations where you <strong>must</strong> block, a good rule of thumb is to only use them if you know why you <strong>must</strong> block. For all other cases, use asynchronous composition as described below.</p></div>
<p>Here we wait for the results from the first 2 <code>Actor</code>s before sending that result to the third <code>Actor</code>. We called <code>Await.result</code> 3 times, which caused our little program to block 3 times before getting our final result. Now compare that to this example:</p>
<pre class="prettyprint"><code class="language-scala"><br/>val f1 = ask(actor1, msg1)
val f2 = ask(actor2, msg2)

val f3 = for {
  a &lt;- f1.mapTo[Int]
  b &lt;- f2.mapTo[Int]
  c &lt;- ask(actor3, (a + b)).mapTo[Int]
} yield c

f3 foreach println</code></pre>
<p>Here we have 2 actors processing a single message each. Once the 2 results are available (note that we don&rsquo;t block to get these results!), they are being added together and sent to a third <code>Actor</code>, which replies with a string, which we assign to &lsquo;result&rsquo;.</p>
<p>This is fine when dealing with a known amount of Actors, but can grow unwieldy if we have more than a handful. The <code>sequence</code> and <code>traverse</code> helper methods can make it easier to handle more complex use cases. Both of these methods are ways of turning, for a subclass <code>T</code> of <code>Traversable</code>, <code>T[Future[A]]</code> into a <code>Future[T[A]]</code>. For example:</p>
<pre class="prettyprint"><code class="language-scala">// oddActor returns odd numbers sequentially from 1 as a List[Future[Int]]
val listOfFutures = List.fill(100)(akka.pattern.ask(oddActor, GetNext).mapTo[Int])

// now we have a Future[List[Int]]
val futureList = Future.sequence(listOfFutures)

// Find the sum of the odd numbers
val oddSum = futureList.map(_.sum)
oddSum foreach println</code></pre>
<p>To better explain what happened in the example, <code>Future.sequence</code> is taking the <code>List[Future[Int]]</code> and turning it into a <code>Future[List[Int]]</code>. We can then use <code>map</code> to work with the <code>List[Int]</code> directly, and we find the sum of the <code>List</code>.</p>
<p>The <code>traverse</code> method is similar to <code>sequence</code>, but it takes a <code>T[A]</code> and a function <code>A =&gt; Future[B]</code> to return a <code>Future[T[B]]</code>, where <code>T</code> is again a subclass of Traversable. For example, to use <code>traverse</code> to sum the first 100 odd numbers:</p>
<pre class="prettyprint"><code class="language-scala">val futureList = Future.traverse((1 to 100).toList)(x =&gt; Future(x * 2 - 1))
val oddSum = futureList.map(_.sum)
oddSum foreach println</code></pre>
<p>This is the same result as this example:</p>
<pre class="prettyprint"><code class="language-scala">val futureList = Future.sequence((1 to 100).toList.map(x =&gt; Future(x * 2 - 1)))
val oddSum = futureList.map(_.sum)
oddSum foreach println</code></pre>
<p>But it may be faster to use <code>traverse</code> as it doesn&rsquo;t have to create an intermediate <code>List[Future[Int]]</code>.</p>
<p>Then there&rsquo;s a method that&rsquo;s called <code>fold</code> that takes a start-value, a sequence of <code>Future</code>s and a function from the type of the start-value and the type of the futures and returns something with the same type as the start-value, and then applies the function to all elements in the sequence of futures, asynchronously, the execution will start when the last of the Futures is completed.</p>
<pre class="prettyprint"><code class="language-scala">// Create a sequence of Futures
val futures = for (i &lt;- 1 to 1000) yield Future(i * 2)
val futureSum = Future.fold(futures)(0)(_ + _)
futureSum foreach println</code></pre>
<p>That&rsquo;s all it takes!</p>
<p>If the sequence passed to <code>fold</code> is empty, it will return the start-value, in the case above, that will be 0. In some cases you don&rsquo;t have a start-value and you&rsquo;re able to use the value of the first completing <code>Future</code> in the sequence as the start-value, you can use <code>reduce</code>, it works like this:</p>
<pre class="prettyprint"><code class="language-scala">// Create a sequence of Futures
val futures = for (i &lt;- 1 to 1000) yield Future(i * 2)
val futureSum = Future.reduce(futures)(_ + _)
futureSum foreach println</code></pre>
<p>Same as with <code>fold</code>, the execution will be done asynchronously when the last of the <code>Future</code> is completed, you can also parallelize it by chunking your futures into sub-sequences and reduce them, and then reduce the reduced results again.</p>
<h2><a href="#callbacks" name="callbacks" class="anchor"><span class="anchor-link"></span></a>Callbacks</h2>
<p>Sometimes you just want to listen to a <code>Future</code> being completed, and react to that not by creating a new <code>Future</code>, but by side-effecting. For this Scala supports <code>onComplete</code>, <code>onSuccess</code> and <code>onFailure</code>, of which the last two are specializations of the first.</p>
<pre class="prettyprint"><code class="language-scala">future onSuccess {
  case &quot;bar&quot;     =&gt; println(&quot;Got my bar alright!&quot;)
  case x: String =&gt; println(&quot;Got some random string: &quot; + x)
}</code></pre>
<pre class="prettyprint"><code class="language-scala">future onFailure {
  case ise: IllegalStateException if ise.getMessage == &quot;OHNOES&quot; =&gt;
  //OHNOES! We are in deep trouble, do something!
  case e: Exception =&gt;
  //Do something else
}</code></pre>
<pre class="prettyprint"><code class="language-scala">future onComplete {
  case Success(result)  =&gt; doSomethingOnSuccess(result)
  case Failure(failure) =&gt; doSomethingOnFailure(failure)
}</code></pre>
<h2><a href="#define-ordering" name="define-ordering" class="anchor"><span class="anchor-link"></span></a>Define Ordering</h2>
<p>Since callbacks are executed in any order and potentially in parallel, it can be tricky at the times when you need sequential ordering of operations. But there&rsquo;s a solution and it&rsquo;s name is <code>andThen</code>. It creates a new <code>Future</code> with the specified callback, a <code>Future</code> that will have the same result as the <code>Future</code> it&rsquo;s called on, which allows for ordering like in the following sample:</p>
<pre class="prettyprint"><code class="language-scala">val result = Future { loadPage(url) } andThen {
  case Failure(exception) =&gt; log(exception)
} andThen {
  case _ =&gt; watchSomeTV()
}
result foreach println</code></pre>
<h2><a href="#auxiliary-methods" name="auxiliary-methods" class="anchor"><span class="anchor-link"></span></a>Auxiliary Methods</h2>
<p><code>Future</code> <code>fallbackTo</code> combines 2 Futures into a new <code>Future</code>, and will hold the successful value of the second <code>Future</code> if the first <code>Future</code> fails.</p>
<pre class="prettyprint"><code class="language-scala">val future4 = future1 fallbackTo future2 fallbackTo future3
future4 foreach println</code></pre>
<p>You can also combine two Futures into a new <code>Future</code> that will hold a tuple of the two Futures successful results, using the <code>zip</code> operation.</p>
<pre class="prettyprint"><code class="language-scala">val future3 = future1 zip future2 map { case (a, b) =&gt; a + &quot; &quot; + b }
future3 foreach println</code></pre>
<h2><a href="#exceptions" name="exceptions" class="anchor"><span class="anchor-link"></span></a>Exceptions</h2>
<p>Since the result of a <code>Future</code> is created concurrently to the rest of the program, exceptions must be handled differently. It doesn&rsquo;t matter if an <code>Actor</code> or the dispatcher is completing the <code>Future</code>, if an <code>Exception</code> is caught the <code>Future</code> will contain it instead of a valid result. If a <code>Future</code> does contain an <code>Exception</code>, calling <code>Await.result</code> will cause it to be thrown again so it can be handled properly.</p>
<p>It is also possible to handle an <code>Exception</code> by returning a different result. This is done with the <code>recover</code> method. For example:</p>
<pre class="prettyprint"><code class="language-scala">val future = akka.pattern.ask(actor, msg1) recover {
  case e: ArithmeticException =&gt; 0
}
future foreach println</code></pre>
<p>In this example, if the actor replied with a <code>akka.actor.Status.Failure</code> containing the <code>ArithmeticException</code>, our <code>Future</code> would have a result of 0. The <code>recover</code> method works very similarly to the standard try/catch blocks, so multiple <code>Exception</code>s can be handled in this manner, and if an <code>Exception</code> is not handled this way it will behave as if we hadn&rsquo;t used the <code>recover</code> method.</p>
<p>You can also use the <code>recoverWith</code> method, which has the same relationship to <code>recover</code> as <code>flatMap</code> has to <code>map</code>, and is use like this:</p>
<pre class="prettyprint"><code class="language-scala">val future = akka.pattern.ask(actor, msg1) recoverWith {
  case e: ArithmeticException =&gt; Future.successful(0)
  case foo: IllegalArgumentException =&gt;
    Future.failed[Int](new IllegalStateException(&quot;All br0ken!&quot;))
}
future foreach println</code></pre>
<h2><a href="#after" name="after" class="anchor"><span class="anchor-link"></span></a>After</h2>
<p><code>akka.pattern.after</code> makes it easy to complete a <code>Future</code> with a value or exception after a timeout.</p>
<pre class="prettyprint"><code class="language-scala">// import akka.pattern.after

val delayed = akka.pattern.after(200 millis, using = system.scheduler)(Future.failed(
  new IllegalStateException(&quot;OHNOES&quot;)))
val future = Future { Thread.sleep(1000); &quot;foo&quot; }
val result = Future firstCompletedOf Seq(future, delayed)</code></pre>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../scala/index-futures.html"><i class="icon-prev"></i> <span class="link-prev">Futures and Agents</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../scala/agents.html">Agents <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="https://github.com/akka/akka/tree/master/akka-docs/src/main/paradox/scala/futures.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
