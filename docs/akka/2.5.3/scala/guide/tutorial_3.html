<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Part 3: Device Groups and Manager &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/guide/tutorial_3.html"/>
<script type="text/javascript" src="../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../css/page.css"/>
<link rel="shortcut icon" href="../../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
<link rel="manifest" href="../../images/manifest.json">
<meta name="msapplication-TileImage" content="../../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../scala/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../scala/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../scala/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../../scala/guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../../scala/guide/actors-intro.html" class="page">What problems does the actor model solve?</a></li>
    <li><a href="../../scala/guide/modules.html" class="page">Akka Libraries and Modules</a></li>
    <li><a href="../../scala/guide/quickstart.html" class="page">Quickstart</a></li>
    <li><a href="../../scala/guide/tutorial_1.html" class="page">Part 1: Top-level Architecture</a></li>
    <li><a href="../../scala/guide/tutorial_2.html" class="page">Part 2: The Device Actor</a></li>
    <li><a href="../../scala/guide/tutorial_3.html#part-3-device-groups-and-manager" class="active page">Part 3: Device Groups and Manager</a>
    <ul>
      <li><a href="../../scala/guide/tutorial_3.html#the-registration-protocol" class="header">The Registration Protocol</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#add-registration-support-to-device-actor" class="header">Add Registration Support to Device Actor</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#device-group" class="header">Device Group</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#device-manager" class="header">Device Manager</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#what-is-next-" class="header">What is Next?</a></li>
    </ul></li>
    <li><a href="../../scala/guide/tutorial_4.html" class="page">Part 4: Querying a Group of Devices</a></li>
  </ul></li>
  <li><a href="../../scala/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../scala/index-actors.html" class="page">Actors</a></li>
  <li><a href="../../scala/index-network.html" class="page">Networking</a></li>
  <li><a href="../../scala/stream/index.html" class="page">Streams</a></li>
  <li><a href="../../scala/index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../scala/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../scala/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../scala/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../scala/project/index.html" class="page">Project Information</a></li>
  <li><a href="../../scala/additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../scala/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../scala/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../scala/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../../scala/guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../../scala/guide/actors-intro.html" class="page">What problems does the actor model solve?</a></li>
    <li><a href="../../scala/guide/modules.html" class="page">Akka Libraries and Modules</a></li>
    <li><a href="../../scala/guide/quickstart.html" class="page">Quickstart</a></li>
    <li><a href="../../scala/guide/tutorial_1.html" class="page">Part 1: Top-level Architecture</a></li>
    <li><a href="../../scala/guide/tutorial_2.html" class="page">Part 2: The Device Actor</a></li>
    <li><a href="../../scala/guide/tutorial_3.html#part-3-device-groups-and-manager" class="active page">Part 3: Device Groups and Manager</a>
    <ul>
      <li><a href="../../scala/guide/tutorial_3.html#the-registration-protocol" class="header">The Registration Protocol</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#add-registration-support-to-device-actor" class="header">Add Registration Support to Device Actor</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#device-group" class="header">Device Group</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#device-manager" class="header">Device Manager</a></li>
      <li><a href="../../scala/guide/tutorial_3.html#what-is-next-" class="header">What is Next?</a></li>
    </ul></li>
    <li><a href="../../scala/guide/tutorial_4.html" class="page">Part 4: Querying a Group of Devices</a></li>
  </ul></li>
  <li><a href="../../scala/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../scala/index-actors.html" class="page">Actors</a></li>
  <li><a href="../../scala/index-network.html" class="page">Networking</a></li>
  <li><a href="../../scala/stream/index.html" class="page">Streams</a></li>
  <li><a href="../../scala/index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../scala/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../scala/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../scala/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../scala/project/index.html" class="page">Project Information</a></li>
  <li><a href="../../scala/additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#part-3-device-groups-and-manager" name="part-3-device-groups-and-manager" class="anchor"><span class="anchor-link"></span></a>Part 3: Device Groups and Manager</h1>
<p>In this chapter, we will integrate our device actors into a component that manages devices. When a new device comes online, there is no actor representing it. We need to be able to ask the device manager component to create a new device actor for us if necessary, in the required group (or return a reference to an already existing one).</p>
<p>Since we keep our tutorial system to the bare minimum, we have no actual component that interfaces with the external world via some networking protocol. For our exercise, we will just create the API necessary to integrate with such a component in the future. In a final system, the steps for connecting a device would look like this:</p>
<ol>
  <li>The device connects through some protocol to our system.</li>
  <li>The component managing network connections accept the connection.</li>
  <li>The ID of the device and the ID of the group that it belongs is acquired.</li>
  <li>The device manager component is asked to create a group and device actor for the given IDs (or return an existing one).</li>
  <li>The device actor (just been created or located) responds with an acknowledgment, at the same time exposing its ActorRef directly (by being the sender of the acknowledgment).</li>
  <li>The networking component now uses the ActorRef of the device directly, avoiding going through the component.</li>
</ol>
<p>We are only concerned with steps 4 and 5 now. We will model the device manager component as an actor tree with three levels:</p>
<p><img src="diagrams/device_manager_tree.png" alt="device manager tree" /></p>
<ul>
  <li>The top level is the supervisor actor representing the component. It is also the entry point to look up or create  group and device actors.</li>
  <li>Device group actors are supervisors of the devices belonging to the group. Apart from supervising the device actors they  also provide extra services, like querying the temperature readings from all the devices available.</li>
  <li>Device actors manage all the interactions with the actual devices, storing temperature readings for example.</li>
</ul>
<p>When designing actor systems one of the main challenges is to decide on the granularity of the actors. For example, it would be perfectly possible to have only a single actor maintaining all the groups and devices in <code>HashMap</code>s for example. It would be also reasonable to keep the groups as separate actors, but keep device state simply inside the group actor.</p>
<p>We chose this three-layered architecture for the following reasons:</p>
<ul>
  <li>Having groups as individual actors:</li>
  <li>Allows us to isolate failures happening in a group. If a programmer error would  happen in the single actor that keeps all state, it would be all wiped out once that actor is restarted affecting groups that are otherwise non-faulty.</li>
  <li>Simplifies the problem of querying all the devices belonging to a group (since it only contains state related  to the given group).</li>
  <li>Increases the parallelism of the system by allowing to query multiple groups concurrently. Since groups have  dedicated actors, all of them can run concurrently.</li>
  <li>Having devices as individual actors:</li>
  <li>Allows us to isolate failures happening in a device actor from the rest of the devices.</li>
  <li>Increases the parallelism of collecting temperature readings as actual network connections from different devices  can talk to the individual device actors directly, reducing contention points.</li>
</ul>
<p>In practice, a system can be organized in multiple ways, all depending on the characteristics of the interactions between actors.</p>
<p>The following guidelines help to arrive at the right granularity:</p>
<ul>
  <li>Prefer larger granularity to smaller. Introducing more fine-grained actors than needed causes more problems than  it solves.</li>
  <li>Prefer finer granularity if it enables higher concurrency in the system.</li>
  <li>Prefer finer granularity if actors need to handle complex conversations with other actors and hence have many  states. We will see a very good example for this in the next chapter.</li>
  <li>Prefer finer granularity if there is too much state to keep around in one place compared to dividing into smaller  actors.</li>
  <li>Prefer finer granularity if the current actor has multiple unrelated responsibilities that can fail and restored  individually.</li>
</ul>
<h2><a href="#the-registration-protocol" name="the-registration-protocol" class="anchor"><span class="anchor-link"></span></a>The Registration Protocol</h2>
<p>As the first step, we need to design the protocol for registering a device and create an actor that will be responsible for it. This protocol will be provided by the <code>DeviceManager</code> component itself because that is the only actor that is known up front: device groups and device actors are created on-demand. The steps of registering a device are the following:</p>
<ol>
  <li>DeviceManager receives the request to track a device for a given group and device.</li>
  <li>If the manager already has an actor for the device group, it forwards the request to it. Otherwise, it first creates a new one and then forwards the request.</li>
  <li>The DeviceGroup receives the request to register an actor for the given device.</li>
  <li>If the group already has an actor for the device, it forwards the request to it. Otherwise, it first creates a new one and then forwards the request.</li>
  <li>The device actor receives the request and acknowledges it to the original sender. Since the device actor is the sender of the acknowledgment, the receiver, i.e. the device, will be able to learn its <code>ActorRef</code> and send direct messages to its device actor in the future.</li>
</ol>
<p>Now that the steps are defined, we only need to define the messages that we will use to communicate requests and their acknowledgement:</p>
<pre class="prettyprint"><code class="language-scala">final case class RequestTrackDevice(groupId: String, deviceId: String)
case object DeviceRegistered</code></pre>
<p>As you see, in this case, we have not included a request ID field in the messages. Since registration is usually happening once, at the component that connects the system to some network protocol, we will usually have no use for the ID. Nevertheless, it is a good exercise to add this ID.</p>
<h2><a href="#add-registration-support-to-device-actor" name="add-registration-support-to-device-actor" class="anchor"><span class="anchor-link"></span></a>Add Registration Support to Device Actor</h2>
<p>We start implementing the protocol from the bottom first. In practice, both a top-down and bottom-up approach can work, but in our case, we benefit from the bottom-up approach as it allows us to immediately write tests for the new features without mocking out parts.</p>
<p>At the bottom of our hierarchy are the <code>Device</code> actors. Their job in this registration process is rather simple, just reply to the registration request with an acknowledgment to the sender. <em>We will assume that the sender of the registration message is preserved in the upper layers.</em> We will show you in the next section how this can be achieved.</p>
<p>We also add a safeguard against requests that come with a mismatched group or device ID. This is how the resulting the code looks like:</p><div class="callout note group-scala"><div class="callout-title">Note</div>
<p>We used a feature of scala pattern matching where we can match if a certain field equals to an expected value. This is achieved by variables included in backticks, like <code>`variable`</code>, and it means that the pattern only match if it contains the value of <code>variable</code> in that position.</p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object Device {
  def props(groupId: String, deviceId: String): Props = Props(new Device(groupId, deviceId))

  final case class RecordTemperature(requestId: Long, value: Double)
  final case class TemperatureRecorded(requestId: Long)

  final case class ReadTemperature(requestId: Long)
  final case class RespondTemperature(requestId: Long, value: Option[Double])
}

class Device(groupId: String, deviceId: String) extends Actor with ActorLogging {
  var lastTemperatureReading: Option[Double] = None

  override def preStart(): Unit = log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId)

  override def postStop(): Unit = log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId)

  override def receive: Receive = {
    case RequestTrackDevice(`groupId`, `deviceId`) =&gt;
      sender() ! DeviceRegistered

    case RequestTrackDevice(groupId, deviceId) =&gt;
      log.warning(
        &quot;Ignoring TrackDevice request for {}-{}.This actor is responsible for {}-{}.&quot;,
        groupId, deviceId, this.groupId, this.deviceId
      )

    case RecordTemperature(id, value) =&gt;
      log.info(&quot;Recorded temperature reading {} with {}&quot;, value, id)
      lastTemperatureReading = Some(value)
      sender() ! TemperatureRecorded(id)

    case ReadTemperature(id) =&gt;
      sender() ! RespondTemperature(id, lastTemperatureReading)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>import akka.actor.AbstractActor;
import akka.actor.Props;
import akka.event.Logging;
import akka.event.LoggingAdapter;

import jdocs.tutorial_3.DeviceManager.DeviceRegistered;
import jdocs.tutorial_3.DeviceManager.RequestTrackDevice;

import java.util.Optional;

public class Device extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  final String deviceId;

  public Device(String groupId, String deviceId) {
    this.groupId = groupId;
    this.deviceId = deviceId;
  }

  public static Props props(String groupId, String deviceId) {
    return Props.create(Device.class, groupId, deviceId);
  }

  public static final class RecordTemperature {
    final long requestId;
    final double value;

    public RecordTemperature(long requestId, double value) {
      this.requestId = requestId;
      this.value = value;
    }
  }

  public static final class TemperatureRecorded {
    final long requestId;

    public TemperatureRecorded(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class ReadTemperature {
    final long requestId;

    public ReadTemperature(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class RespondTemperature {
    final long requestId;
    final Optional&lt;Double&gt; value;

    public RespondTemperature(long requestId, Optional&lt;Double&gt; value) {
      this.requestId = requestId;
      this.value = value;
    }
  }

  Optional&lt;Double&gt; lastTemperatureReading = Optional.empty();

  @Override
  public void preStart() {
    log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId);
  }

  @Override
  public void postStop() {
    log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
            .match(RequestTrackDevice.class, r -&gt; {
              if (this.groupId.equals(r.groupId) &amp;&amp; this.deviceId.equals(r.deviceId)) {
                getSender().tell(new DeviceRegistered(), getSelf());
              } else {
                log.warning(
                        &quot;Ignoring TrackDevice request for {}-{}.This actor is responsible for {}-{}.&quot;,
                        r.groupId, r.deviceId, this.groupId, this.deviceId
                );
              }
            })
            .match(RecordTemperature.class, r -&gt; {
              log.info(&quot;Recorded temperature reading {} with {}&quot;, r.value, r.requestId);
              lastTemperatureReading = Optional.of(r.value);
              getSender().tell(new TemperatureRecorded(r.requestId), getSelf());
            })
            .match(ReadTemperature.class, r -&gt; {
              getSender().tell(new RespondTemperature(r.requestId, lastTemperatureReading), getSelf());
            })
            .build();
  }
}</code></pre></dd>
</dl>
<p>We should not leave features untested, so we immediately write two new test cases, one exercising successful registration, the other testing the case when IDs don&rsquo;t match:</p><div class="callout note "><div class="callout-title">Note</div>
<p>We used the <code>expectNoMsg()</code> helper method from <span class="group-scala"><code>TestProbe</code></span> <span class="group-java"><code>TestKit</code></span>. This assertion waits until the defined time-limit and fails if it receives any messages during this period. If no messages are received during the waiting period the assertion passes. It is usually a good idea to keep these timeouts low (but not too low) because they add significant test execution time otherwise.</p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">&quot;reply to registration requests&quot; in {
  val probe = TestProbe()
  val deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;))

  deviceActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  probe.lastSender should ===(deviceActor)
}

&quot;ignore wrong registration requests&quot; in {
  val probe = TestProbe()
  val deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;))

  deviceActor.tell(DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device&quot;), probe.ref)
  probe.expectNoMsg(500.milliseconds)

  deviceActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;Wrongdevice&quot;), probe.ref)
  probe.expectNoMsg(500.milliseconds)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Test
public void testReplyToRegistrationRequests() {
  TestKit probe = new TestKit(system);
  ActorRef deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;));

  deviceActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  assertEquals(deviceActor, probe.getLastSender());
}

@Test
public void testIgnoreWrongRegistrationRequests() {
  TestKit probe = new TestKit(system);
  ActorRef deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;));

  deviceActor.tell(new DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device&quot;), probe.getRef());
  probe.expectNoMsg();

  deviceActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;wrongDevice&quot;), probe.getRef());
  probe.expectNoMsg();
}</code></pre></dd>
</dl>
<h2><a href="#device-group" name="device-group" class="anchor"><span class="anchor-link"></span></a>Device Group</h2>
<p>We are done with the registration support at the device level, now we have to implement it at the group level. A group has more work to do when it comes to registrations. It must either forward the request to an existing child, or it should create one. To be able to look up child actors by their device IDs we will use a <span class="group-scala"><code>Map[String, ActorRef]</code></span> <span class="group-java"><code>Map&lt;String, ActorRef&gt;</code></span>.</p>
<p>We also want to keep the original sender of the request so that our device actor can reply directly. This is possible by using <code>forward</code> instead of the <span class="group-scala"><code>!</code></span> <span class="group-java"><code>tell</code></span> operator. The only difference between the two is that <code>forward</code> keeps the original sender while <span class="group-scala"><code>!</code></span> <span class="group-java"><code>tell</code></span> always sets the sender to be the current actor. Just like with our device actor, we ensure that we don&rsquo;t respond to wrong group IDs:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object DeviceGroup {
  def props(groupId: String): Props = Props(new DeviceGroup(groupId))
}

class DeviceGroup(groupId: String) extends Actor with ActorLogging {
  var deviceIdToActor = Map.empty[String, ActorRef]

  override def preStart(): Unit = log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def postStop(): Unit = log.info(&quot;DeviceGroup {} stopped&quot;, groupId)

  override def receive: Receive = {
    case trackMsg @ RequestTrackDevice(`groupId`, _) =&gt;
      deviceIdToActor.get(trackMsg.deviceId) match {
        case Some(deviceActor) =&gt;
          deviceActor forward trackMsg
        case None =&gt;
          log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
          val deviceActor = context.actorOf(Device.props(groupId, trackMsg.deviceId), s&quot;device-${trackMsg.deviceId}&quot;)
          deviceIdToActor += trackMsg.deviceId -&gt; deviceActor
          deviceActor forward trackMsg
      }

    case RequestTrackDevice(groupId, deviceId) =&gt;
      log.warning(
        &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
        groupId, this.groupId
      )
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">  public static Props props(String groupId) {
    return Props.create(DeviceGroup.class, groupId);
  }

  final Map&lt;String, ActorRef&gt; deviceIdToActor = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceGroup {} stopped&quot;, groupId);
  }

  private void onTrackDevice(DeviceManager.RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        deviceActor.forward(trackMsg, getContext());
      } else {
        log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor = getContext().actorOf(Device.props(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        deviceActor.forward(trackMsg, getContext());
      }
    } else {
      log.warning(
              &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
              groupId, this.groupId
      );
    }
  }

  private void onDeviceList(RequestDeviceList r) {
    getSender().tell(new ReplyDeviceList(r.requestId, deviceIdToActor.keySet()), getSelf());
  }

  private void onTerminated(Terminated t) {
    ActorRef deviceActor = t.getActor();
    String deviceId = actorToDeviceId.get(deviceActor);
    log.info(&quot;Device actor for {} has been terminated&quot;, deviceId);
    actorToDeviceId.remove(deviceActor);
    deviceIdToActor.remove(deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
            .match(DeviceManager.RequestTrackDevice.class, this::onTrackDevice)
            .match(RequestDeviceList.class, this::onDeviceList)
            .match(Terminated.class, this::onTerminated)
            .build();
  }
}</code></pre></dd>
</dl>
<p>Just as we did with the device, we test this new functionality. We also test that the actors returned for the two different IDs are actually different, and we also attempt to record a temperature reading for each of the devices to see if the actors are responding.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">&quot;be able to register a device actor&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor1 = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor2 = probe.lastSender
  deviceActor1 should !==(deviceActor2)

  // Check that the device actors are working
  deviceActor1.tell(Device.RecordTemperature(requestId = 0, 1.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 0))
  deviceActor2.tell(Device.RecordTemperature(requestId = 1, 2.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 1))
}

&quot;ignore requests for wrong groupId&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device1&quot;), probe.ref)
  probe.expectNoMsg(500.milliseconds)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Test
public void testRegisterDeviceActor() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor1 = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor2 = probe.getLastSender();
  assertNotEquals(deviceActor1, deviceActor2);

  // Check that the device actors are workingl
  deviceActor1.tell(new Device.RecordTemperature(0L, 1.0), probe.getRef());
  assertEquals(0L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);
  deviceActor2.tell(new Device.RecordTemperature(1L, 2.0), probe.getRef());
  assertEquals(1L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);
}

@Test
public void testIgnoreRequestsForWrongGroupId() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectNoMsg();
}</code></pre></dd>
</dl>
<p>It might be, that a device actor already exists for the registration request. In this case, we would like to use the existing actor instead of a new one. We have not tested this yet, so we need to fix this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">&quot;return same actor for same deviceId&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor1 = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor2 = probe.lastSender

  deviceActor1 should ===(deviceActor2)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Test
public void testReturnSameActorForSameDeviceId() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor1 = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor2 = probe.getLastSender();
  assertEquals(deviceActor1, deviceActor2);
}</code></pre></dd>
</dl>
<p>So far, we have implemented everything for registering device actors in the group. Devices come and go, however, so we will need a way to remove those from the <span class="group-scala"><code>Map[String, ActorRef]</code></span> <span class="group-java"><code>Map&lt;String, ActorRef&gt;</code></span>. We will assume that when a device is removed, its corresponding device actor is simply stopped. We need some way for the parent to be notified when one of the device actors are stopped. Unfortunately, supervision will not help because it is used for error scenarios, not graceful stopping.</p>
<p>There is a feature in Akka that is exactly what we need here. It is possible for an actor to <em>watch</em> another actor and be notified if the other actor is stopped. This feature is called <em>Death Watch</em> and it is an important tool for any Akka application. Unlike supervision, watching is not limited to parent-child relationships, any actor can watch any other actor given its <code>ActorRef</code>. After a watched actor stops, the watcher receives a <code>Terminated(ref)</code> message which also contains the reference to the watched actor. The watcher can either handle this message explicitly or, if it does not handle it directly it will fail with a <code>DeathPactException</code>. This latter is useful if the actor cannot longer perform its duties after its collaborator actor has been stopped. In our case, the group should still function after one device have been stopped, so we need to handle this message. The steps we need to follow are the following:</p>
<ol>
  <li>Whenever we create a new device actor, we must also watch it.</li>
  <li>When we are notified that a device actor has been stopped we also need to remove it from the <span class="group-scala"><code>Map[String, ActorRef]</code></span> <span class="group-java"><code>Map&lt;String, ActorRef&gt;</code></span> which maps devices to device actors.</li>
</ol>
<p>Unfortunately, the <code>Terminated</code> message contains only contains the <code>ActorRef</code> of the child actor but we do not know its ID, which we need to remove it from the map of existing device to device actor mappings. To be able to do this removal, we need to introduce another placeholder, <span class="group-scala"><code>Map[String, ActorRef]</code></span> <span class="group-java"><code>Map&lt;String, ActorRef&gt;</code></span>, that allow us to find out the device ID corresponding to a given <code>ActorRef</code>. Putting this together the result is:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>class DeviceGroup(groupId: String) extends Actor with ActorLogging {
  var deviceIdToActor = Map.empty[String, ActorRef]
  var actorToDeviceId = Map.empty[ActorRef, String]

  override def preStart(): Unit = log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def postStop(): Unit = log.info(&quot;DeviceGroup {} stopped&quot;, groupId)

  override def receive: Receive = {
    case trackMsg @ RequestTrackDevice(`groupId`, _) =&gt;
      deviceIdToActor.get(trackMsg.deviceId) match {
        case Some(deviceActor) =&gt;
          deviceActor forward trackMsg
        case None =&gt;
          log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
          val deviceActor = context.actorOf(Device.props(groupId, trackMsg.deviceId), s&quot;device-${trackMsg.deviceId}&quot;)
          context.watch(deviceActor)
          actorToDeviceId += deviceActor -&gt; trackMsg.deviceId
          deviceIdToActor += trackMsg.deviceId -&gt; deviceActor
          deviceActor forward trackMsg
      }

    case RequestTrackDevice(groupId, deviceId) =&gt;
      log.warning(
        &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
        groupId, this.groupId
      )

    case Terminated(deviceActor) =&gt;
      val deviceId = actorToDeviceId(deviceActor)
      log.info(&quot;Device actor for {} has been terminated&quot;, deviceId)
      actorToDeviceId -= deviceActor
      deviceIdToActor -= deviceId

  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>  final Map&lt;String, ActorRef&gt; deviceIdToActor = new HashMap&lt;&gt;();
  final Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceGroup {} stopped&quot;, groupId);
  }

  private void onTrackDevice(DeviceManager.RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        deviceActor.forward(trackMsg, getContext());
      } else {
        log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor = getContext().actorOf(Device.props(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        getContext().watch(deviceActor);
        actorToDeviceId.put(deviceActor, trackMsg.deviceId);
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        deviceActor.forward(trackMsg, getContext());
      }
    } else {
      log.warning(
              &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
              groupId, this.groupId
      );
    }
  }

  private void onDeviceList(RequestDeviceList r) {
    getSender().tell(new ReplyDeviceList(r.requestId, deviceIdToActor.keySet()), getSelf());
  }

  private void onTerminated(Terminated t) {
    ActorRef deviceActor = t.getActor();
    String deviceId = actorToDeviceId.get(deviceActor);
    log.info(&quot;Device actor for {} has been terminated&quot;, deviceId);
    actorToDeviceId.remove(deviceActor);
    deviceIdToActor.remove(deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
            .match(DeviceManager.RequestTrackDevice.class, this::onTrackDevice)
            .match(RequestDeviceList.class, this::onDeviceList)
            .match(Terminated.class, this::onTerminated)
            .build();
  }
}</code></pre></dd>
</dl>
<p>So far we have no means to get what devices the group device actor keeps track of and, therefore, we cannot test our new functionality yet. To make it testable, we add a new query capability (message <span class="group-scala"><code>RequestDeviceList(requestId: Long)</code></span> <span class="group-java"><code>RequestDeviceList</code></span>) that simply lists the currently active device IDs:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object DeviceGroup {
  def props(groupId: String): Props = Props(new DeviceGroup(groupId))

  final case class RequestDeviceList(requestId: Long)
  final case class ReplyDeviceList(requestId: Long, ids: Set[String])
}

class DeviceGroup(groupId: String) extends Actor with ActorLogging {
  var deviceIdToActor = Map.empty[String, ActorRef]
  var actorToDeviceId = Map.empty[ActorRef, String]

  override def preStart(): Unit = log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def postStop(): Unit = log.info(&quot;DeviceGroup {} stopped&quot;, groupId)

  override def receive: Receive = {
    case trackMsg @ RequestTrackDevice(`groupId`, _) =&gt;
      deviceIdToActor.get(trackMsg.deviceId) match {
        case Some(deviceActor) =&gt;
          deviceActor forward trackMsg
        case None =&gt;
          log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
          val deviceActor = context.actorOf(Device.props(groupId, trackMsg.deviceId), s&quot;device-${trackMsg.deviceId}&quot;)
          context.watch(deviceActor)
          actorToDeviceId += deviceActor -&gt; trackMsg.deviceId
          deviceIdToActor += trackMsg.deviceId -&gt; deviceActor
          deviceActor forward trackMsg
      }

    case RequestTrackDevice(groupId, deviceId) =&gt;
      log.warning(
        &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
        groupId, this.groupId
      )

    case RequestDeviceList(requestId) =&gt;
      sender() ! ReplyDeviceList(requestId, deviceIdToActor.keySet)

    case Terminated(deviceActor) =&gt;
      val deviceId = actorToDeviceId(deviceActor)
      log.info(&quot;Device actor for {} has been terminated&quot;, deviceId)
      actorToDeviceId -= deviceActor
      deviceIdToActor -= deviceId

  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public class DeviceGroup extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  public DeviceGroup(String groupId) {
    this.groupId = groupId;
  }

  public static Props props(String groupId) {
    return Props.create(DeviceGroup.class, groupId);
  }

  public static final class RequestDeviceList {
    final long requestId;

    public RequestDeviceList(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class ReplyDeviceList {
    final long requestId;
    final Set&lt;String&gt; ids;

    public ReplyDeviceList(long requestId, Set&lt;String&gt; ids) {
      this.requestId = requestId;
      this.ids = ids;
    }
  }

  final Map&lt;String, ActorRef&gt; deviceIdToActor = new HashMap&lt;&gt;();
  final Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceGroup {} stopped&quot;, groupId);
  }

  private void onTrackDevice(DeviceManager.RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        deviceActor.forward(trackMsg, getContext());
      } else {
        log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor = getContext().actorOf(Device.props(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        getContext().watch(deviceActor);
        actorToDeviceId.put(deviceActor, trackMsg.deviceId);
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        deviceActor.forward(trackMsg, getContext());
      }
    } else {
      log.warning(
              &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
              groupId, this.groupId
      );
    }
  }

  private void onDeviceList(RequestDeviceList r) {
    getSender().tell(new ReplyDeviceList(r.requestId, deviceIdToActor.keySet()), getSelf());
  }

  private void onTerminated(Terminated t) {
    ActorRef deviceActor = t.getActor();
    String deviceId = actorToDeviceId.get(deviceActor);
    log.info(&quot;Device actor for {} has been terminated&quot;, deviceId);
    actorToDeviceId.remove(deviceActor);
    deviceIdToActor.remove(deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
            .match(DeviceManager.RequestTrackDevice.class, this::onTrackDevice)
            .match(RequestDeviceList.class, this::onDeviceList)
            .match(Terminated.class, this::onTerminated)
            .build();
  }
}</code></pre></dd>
</dl>
<p>We almost have everything to test the removal of devices. What is missing is:</p>
<ul>
  <li>Stopping a device actor from our test case, from the outside: any actor can be stopped by simply sending a special  the built-in message, <code>PoisonPill</code>, which instructs the actor to stop.</li>
  <li>Be notified once the device actor is stopped: we can use the <em>Death Watch</em> facility for this purpose, too. Thankfully  the <span class="group-scala"><code>TestProbe</code></span> <span class="group-java"><code>TestKit</code></span> has two messages that we can easily use, <code>watch()</code> to watch a specific actor, and <code>expectTerminated</code>  to assert that the watched actor has been terminated.</li>
</ul>
<p>We add two more test cases now. In the first, we just test that we get back the list of proper IDs once we have added a few devices. The second test case makes sure that the device ID is properly removed after the device actor has  been stopped:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">&quot;be able to list active devices&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)

  groupActor.tell(DeviceGroup.RequestDeviceList(requestId = 0), probe.ref)
  probe.expectMsg(DeviceGroup.ReplyDeviceList(requestId = 0, Set(&quot;device1&quot;, &quot;device2&quot;)))
}

&quot;be able to list active devices after one shuts down&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val toShutDown = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)

  groupActor.tell(DeviceGroup.RequestDeviceList(requestId = 0), probe.ref)
  probe.expectMsg(DeviceGroup.ReplyDeviceList(requestId = 0, Set(&quot;device1&quot;, &quot;device2&quot;)))

  probe.watch(toShutDown)
  toShutDown ! PoisonPill
  probe.expectTerminated(toShutDown)

  // using awaitAssert to retry because it might take longer for the groupActor
  // to see the Terminated, that order is undefined
  probe.awaitAssert {
    groupActor.tell(DeviceGroup.RequestDeviceList(requestId = 1), probe.ref)
    probe.expectMsg(DeviceGroup.ReplyDeviceList(requestId = 1, Set(&quot;device2&quot;)))
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Test
public void testListActiveDevices() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);

  groupActor.tell(new DeviceGroup.RequestDeviceList(0L), probe.getRef());
  DeviceGroup.ReplyDeviceList reply = probe.expectMsgClass(DeviceGroup.ReplyDeviceList.class);
  assertEquals(0L, reply.requestId);
  assertEquals(Stream.of(&quot;device1&quot;, &quot;device2&quot;).collect(Collectors.toSet()), reply.ids);
}

@Test
public void testListActiveDevicesAfterOneShutsDown() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef toShutDown = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);

  groupActor.tell(new DeviceGroup.RequestDeviceList(0L), probe.getRef());
  DeviceGroup.ReplyDeviceList reply = probe.expectMsgClass(DeviceGroup.ReplyDeviceList.class);
  assertEquals(0L, reply.requestId);
  assertEquals(Stream.of(&quot;device1&quot;, &quot;device2&quot;).collect(Collectors.toSet()), reply.ids);

  probe.watch(toShutDown);
  toShutDown.tell(PoisonPill.getInstance(), ActorRef.noSender());
  probe.expectTerminated(toShutDown);

  // using awaitAssert to retry because it might take longer for the groupActor
  // to see the Terminated, that order is undefined
  probe.awaitAssert(() -&gt; {
    groupActor.tell(new DeviceGroup.RequestDeviceList(1L), probe.getRef());
    DeviceGroup.ReplyDeviceList r = 
      probe.expectMsgClass(DeviceGroup.ReplyDeviceList.class);
    assertEquals(1L, r.requestId);
    assertEquals(Stream.of(&quot;device2&quot;).collect(Collectors.toSet()), r.ids);
    return null;
  });
}</code></pre></dd>
</dl>
<h2><a href="#device-manager" name="device-manager" class="anchor"><span class="anchor-link"></span></a>Device Manager</h2>
<p>The only part that remains now is the entry point for our device manager component. This actor is very similar to the device group actor, with the only difference that it creates device group actors instead of device actors:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">object DeviceManager {
  def props(): Props = Props(new DeviceManager)

  final case class RequestTrackDevice(groupId: String, deviceId: String)
  case object DeviceRegistered
}

class DeviceManager extends Actor with ActorLogging {
  var groupIdToActor = Map.empty[String, ActorRef]
  var actorToGroupId = Map.empty[ActorRef, String]

  override def preStart(): Unit = log.info(&quot;DeviceManager started&quot;)

  override def postStop(): Unit = log.info(&quot;DeviceManager stopped&quot;)

  override def receive = {
    case trackMsg @ RequestTrackDevice(groupId, _) =&gt;
      groupIdToActor.get(groupId) match {
        case Some(ref) =&gt;
          ref forward trackMsg
        case None =&gt;
          log.info(&quot;Creating device group actor for {}&quot;, groupId)
          val groupActor = context.actorOf(DeviceGroup.props(groupId), &quot;group-&quot; + groupId)
          context.watch(groupActor)
          groupActor forward trackMsg
          groupIdToActor += groupId -&gt; groupActor
          actorToGroupId += groupActor -&gt; groupId
      }

    case Terminated(groupActor) =&gt;
      val groupId = actorToGroupId(groupActor)
      log.info(&quot;Device group actor for {} has been terminated&quot;, groupId)
      actorToGroupId -= groupActor
      groupIdToActor -= groupId

  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public class DeviceManager extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  public static Props props() {
    return Props.create(DeviceManager.class);
  }

  public static final class RequestTrackDevice {
    public final String groupId;
    public final String deviceId;

    public RequestTrackDevice(String groupId, String deviceId) {
      this.groupId = groupId;
      this.deviceId = deviceId;
    }
  }

  public static final class DeviceRegistered {
  }

  final Map&lt;String, ActorRef&gt; groupIdToActor = new HashMap&lt;&gt;();
  final Map&lt;ActorRef, String&gt; actorToGroupId = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceManager started&quot;);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceManager stopped&quot;);
  }

  private void onTrackDevice(RequestTrackDevice trackMsg) {
    String groupId = trackMsg.groupId;
    ActorRef ref = groupIdToActor.get(groupId);
    if (ref != null) {
      ref.forward(trackMsg, getContext());
    } else {
      log.info(&quot;Creating device group actor for {}&quot;, groupId);
      ActorRef groupActor = getContext().actorOf(DeviceGroup.props(groupId), &quot;group-&quot; + groupId);
      getContext().watch(groupActor);
      groupActor.forward(trackMsg, getContext());
      groupIdToActor.put(groupId, groupActor);
      actorToGroupId.put(groupActor, groupId);
    }
  }

  private void onTerminated(Terminated t) {
    ActorRef groupActor = t.getActor();
    String groupId = actorToGroupId.get(groupActor);
    log.info(&quot;Device group actor for {} has been terminated&quot;, groupId);
    actorToGroupId.remove(groupActor);
    groupIdToActor.remove(groupId);
  }

  public Receive createReceive() {
    return receiveBuilder()
            .match(RequestTrackDevice.class, this::onTrackDevice)
            .match(Terminated.class, this::onTerminated)
            .build();
  }

}</code></pre></dd>
</dl>
<p>We leave tests of the device manager as an exercise as it is very similar to the tests we have written for the group actor.</p>
<h2><a href="#what-is-next-" name="what-is-next-" class="anchor"><span class="anchor-link"></span></a>What is Next?</h2>
<p>We have now a hierarchical component for registering and tracking devices and recording measurements. We have seen some conversation patterns like:</p>
<ul>
  <li>Request-respond (for temperature recordings).</li>
  <li>Delegate-respond (for registration of devices).</li>
  <li>Create-watch-terminate (for creating the group and device actor as children).</li>
</ul>
<p>In the next chapter, we will introduce group query capabilities, which will establish a new conversation pattern of scatter-gather. In particular, we will implement the functionality that allows users to query the status of all the devices belonging to a group.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../scala/guide/tutorial_2.html"><i class="icon-prev"></i> <span class="link-prev">Part 2: The Device Actor</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../scala/guide/tutorial_4.html">Part 4: Querying a Group of Devices <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="https://github.com/akka/akka/tree/master/akka-docs/src/main/paradox/scala/guide/tutorial_3.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../js/groups.js"></script>
<script type="text/javascript" src="../../js/page.js"></script>
<script type="text/javascript" src="../../js/magellan.js"></script>

<style type="text/css">@import "../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
