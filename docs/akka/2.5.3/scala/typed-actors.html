<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Typed Actors &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/project/migration-guide-2.5.x-2.6.x.html#typedactor"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../scala/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../scala/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../scala/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../scala/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../scala/index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="../scala/actors.html" class="page">Actors</a></li>
    <li><a href="../scala/typed.html" class="page">Akka Typed</a></li>
    <li><a href="../scala/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../scala/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../scala/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../scala/routing.html" class="page">Routing</a></li>
    <li><a href="../scala/fsm.html" class="page">FSM</a></li>
    <li><a href="../scala/persistence.html" class="page">Persistence</a></li>
    <li><a href="../scala/persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="../scala/persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="../scala/persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="../scala/testing.html" class="page">Testing Actor Systems</a></li>
    <li><a href="../scala/actordsl.html" class="page">Actor DSL</a></li>
    <li><a href="../scala/typed-actors.html#typed-actors" class="active page">Typed Actors</a>
    <ul>
      <li><a href="../scala/typed-actors.html#when-to-use-typed-actors" class="header">When to use Typed Actors</a></li>
      <li><a href="../scala/typed-actors.html#the-tools-of-the-trade" class="header">The tools of the trade</a></li>
      <li><a href="../scala/typed-actors.html#creating-typed-actors" class="header">Creating Typed Actors</a></li>
      <li><a href="../scala/typed-actors.html#method-dispatch-semantics" class="header">Method dispatch semantics</a></li>
      <li><a href="../scala/typed-actors.html#messages-and-immutability" class="header">Messages and immutability</a></li>
      <li><a href="../scala/typed-actors.html#stopping-typed-actors" class="header">Stopping Typed Actors</a></li>
      <li><a href="../scala/typed-actors.html#typed-actor-hierarchies" class="header">Typed Actor Hierarchies</a></li>
      <li><a href="../scala/typed-actors.html#supervisor-strategy" class="header">Supervisor Strategy</a></li>
      <li><a href="../scala/typed-actors.html#lifecycle-callbacks" class="header">Lifecycle callbacks</a></li>
      <li><a href="../scala/typed-actors.html#receive-arbitrary-messages" class="header">Receive arbitrary messages</a></li>
      <li><a href="../scala/typed-actors.html#proxying" class="header">Proxying</a></li>
      <li><a href="../scala/typed-actors.html#lookup-remoting" class="header">Lookup &amp; Remoting</a></li>
      <li><a href="../scala/typed-actors.html#supercharging" class="header">Supercharging</a></li>
      <li><a href="../scala/typed-actors.html#typed-router-pattern" class="header">Typed Router pattern</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../scala/index-network.html" class="page">Networking</a></li>
  <li><a href="../scala/stream/index.html" class="page">Streams</a></li>
  <li><a href="../scala/index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../scala/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../scala/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../scala/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../scala/project/index.html" class="page">Project Information</a></li>
  <li><a href="../scala/additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../scala/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.3
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../scala/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../scala/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../scala/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../scala/index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="../scala/actors.html" class="page">Actors</a></li>
    <li><a href="../scala/typed.html" class="page">Akka Typed</a></li>
    <li><a href="../scala/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../scala/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../scala/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../scala/routing.html" class="page">Routing</a></li>
    <li><a href="../scala/fsm.html" class="page">FSM</a></li>
    <li><a href="../scala/persistence.html" class="page">Persistence</a></li>
    <li><a href="../scala/persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="../scala/persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="../scala/persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="../scala/testing.html" class="page">Testing Actor Systems</a></li>
    <li><a href="../scala/actordsl.html" class="page">Actor DSL</a></li>
    <li><a href="../scala/typed-actors.html#typed-actors" class="active page">Typed Actors</a>
    <ul>
      <li><a href="../scala/typed-actors.html#when-to-use-typed-actors" class="header">When to use Typed Actors</a></li>
      <li><a href="../scala/typed-actors.html#the-tools-of-the-trade" class="header">The tools of the trade</a></li>
      <li><a href="../scala/typed-actors.html#creating-typed-actors" class="header">Creating Typed Actors</a></li>
      <li><a href="../scala/typed-actors.html#method-dispatch-semantics" class="header">Method dispatch semantics</a></li>
      <li><a href="../scala/typed-actors.html#messages-and-immutability" class="header">Messages and immutability</a></li>
      <li><a href="../scala/typed-actors.html#stopping-typed-actors" class="header">Stopping Typed Actors</a></li>
      <li><a href="../scala/typed-actors.html#typed-actor-hierarchies" class="header">Typed Actor Hierarchies</a></li>
      <li><a href="../scala/typed-actors.html#supervisor-strategy" class="header">Supervisor Strategy</a></li>
      <li><a href="../scala/typed-actors.html#lifecycle-callbacks" class="header">Lifecycle callbacks</a></li>
      <li><a href="../scala/typed-actors.html#receive-arbitrary-messages" class="header">Receive arbitrary messages</a></li>
      <li><a href="../scala/typed-actors.html#proxying" class="header">Proxying</a></li>
      <li><a href="../scala/typed-actors.html#lookup-remoting" class="header">Lookup &amp; Remoting</a></li>
      <li><a href="../scala/typed-actors.html#supercharging" class="header">Supercharging</a></li>
      <li><a href="../scala/typed-actors.html#typed-router-pattern" class="header">Typed Router pattern</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../scala/index-network.html" class="page">Networking</a></li>
  <li><a href="../scala/stream/index.html" class="page">Streams</a></li>
  <li><a href="../scala/index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../scala/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../scala/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../scala/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../scala/project/index.html" class="page">Project Information</a></li>
  <li><a href="../scala/additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#typed-actors" name="typed-actors" class="anchor"><span class="anchor-link"></span></a>Typed Actors</h1><div class="callout note "><div class="callout-title">Note</div>
<p>This module will be deprecated as it will be superseded by the <a href="typed.html">Akka Typed</a> project which is currently being developed in open preview mode.</p></div>
<p>Akka Typed Actors is an implementation of the <a href="http://en.wikipedia.org/wiki/Active_object">Active Objects</a> pattern. Essentially turning method invocations into asynchronous dispatch instead of synchronous that has been the default way since Smalltalk came out.</p>
<p>Typed Actors consist of 2 &ldquo;parts&rdquo;, a public interface and an implementation, and if you&rsquo;ve done any work in &ldquo;enterprise&rdquo; Java, this will be very familiar to you. As with normal Actors you have an external API (the public interface instance) that will delegate method calls asynchronously to a private instance of the implementation.</p>
<p>The advantage of Typed Actors vs. Actors is that with TypedActors you have a static contract, and don&rsquo;t need to define your own messages, the downside is that it places some limitations on what you can do and what you can&rsquo;t, i.e. you cannot use <code>become</code>/<code>unbecome</code>.</p>
<p>Typed Actors are implemented using <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Proxy.html">JDK Proxies</a> which provide a pretty easy-worked API to intercept method calls.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Just as with regular Akka Actors, Typed Actors process one call at a time.</p></div>
<h2><a href="#when-to-use-typed-actors" name="when-to-use-typed-actors" class="anchor"><span class="anchor-link"></span></a>When to use Typed Actors</h2>
<p>Typed actors are nice for bridging between actor systems (the “inside”) and non-actor code (the “outside”), because they allow you to write normal OO-looking code on the outside. Think of them like doors: their practicality lies in interfacing between private sphere and the public, but you don’t want that many doors inside your house, do you? For a longer discussion see <a href="http://letitcrash.com/post/19074284309/when-to-use-typedactors">this blog post</a>.</p>
<p>A bit more background: TypedActors can easily be abused as RPC, and that is an abstraction which is <a href="https://doc.akka.io/docs/misc/smli_tr-94-29.pdf">well-known</a> to be leaky. Hence TypedActors are not what we think of first when we talk about making highly scalable concurrent software easier to write correctly. They have their niche, use them sparingly.</p>
<h2><a href="#the-tools-of-the-trade" name="the-tools-of-the-trade" class="anchor"><span class="anchor-link"></span></a>The tools of the trade</h2>
<p>Before we create our first Typed Actor we should first go through the tools that we have at our disposal, it&rsquo;s located in <code>akka.actor.TypedActor</code>.</p>
<pre class="prettyprint"><code class="language-scala"><br/>import akka.actor.TypedActor

//Returns the Typed Actor Extension
val extension = TypedActor(system) //system is an instance of ActorSystem

//Returns whether the reference is a Typed Actor Proxy or not
TypedActor(system).isTypedActor(someReference)

//Returns the backing Akka Actor behind an external Typed Actor Proxy
TypedActor(system).getActorRefFor(someReference)

//Returns the current ActorContext,
// method only valid within methods of a TypedActor implementation
val c: ActorContext = TypedActor.context

//Returns the external proxy of the current Typed Actor,
// method only valid within methods of a TypedActor implementation
val s: Squarer = TypedActor.self[Squarer]

//Returns a contextual instance of the Typed Actor Extension
//this means that if you create other Typed Actors with this,
//they will become children to the current Typed Actor.
TypedActor(TypedActor.context)
</code></pre><div class="callout warning "><div class="callout-title">Warning</div>
<p>Same as not exposing <code>this</code> of an Akka Actor, it&rsquo;s important not to expose <code>this</code> of a Typed Actor, instead you should pass the external proxy reference, which is obtained from within your Typed Actor as <code>TypedActor.self</code>, this is your external identity, as the <code>ActorRef</code> is the external identity of an Akka Actor.</p></div>
<h2><a href="#creating-typed-actors" name="creating-typed-actors" class="anchor"><span class="anchor-link"></span></a>Creating Typed Actors</h2>
<p>To create a Typed Actor you need to have one or more interfaces, and one implementation.</p>
<p>The following imports are assumed:</p>
<pre class="prettyprint"><code class="language-scala">import java.lang.String.{ valueOf =&gt; println }

import akka.actor.{ ActorContext, ActorRef, TypedActor, TypedProps }
import akka.routing.RoundRobinGroup
import akka.testkit._

import scala.concurrent.{ Future, Await }
import scala.concurrent.duration._</code></pre>
<p>Our example interface:</p>
<pre class="prettyprint"><code class="language-scala">trait Squarer {
  def squareDontCare(i: Int): Unit //fire-forget

  def square(i: Int): Future[Int] //non-blocking send-request-reply

  def squareNowPlease(i: Int): Option[Int] //blocking send-request-reply

  def squareNow(i: Int): Int //blocking send-request-reply

  @throws(classOf[Exception]) //declare it or you will get an UndeclaredThrowableException
  def squareTry(i: Int): Int //blocking send-request-reply with possible exception
}</code></pre>
<p>Our example implementation of that interface:</p>
<pre class="prettyprint"><code class="language-scala">class SquarerImpl(val name: String) extends Squarer {

  def this() = this(&quot;default&quot;)
  def squareDontCare(i: Int): Unit = i * i //Nobody cares :(

  def square(i: Int): Future[Int] = Future.successful(i * i)

  def squareNowPlease(i: Int): Option[Int] = Some(i * i)

  def squareNow(i: Int): Int = i * i

  def squareTry(i: Int): Int = throw new Exception(&quot;Catch me!&quot;)
}</code></pre>
<p>The most trivial way of creating a Typed Actor instance of our <code>Squarer</code>:</p>
<pre class="prettyprint"><code class="language-scala">val mySquarer: Squarer =
  TypedActor(system).typedActorOf(TypedProps[SquarerImpl]())</code></pre>
<p>First type is the type of the proxy, the second type is the type of the implementation. If you need to call a specific constructor you do it like this:</p>
<pre class="prettyprint"><code class="language-scala">val otherSquarer: Squarer =
  TypedActor(system).typedActorOf(TypedProps(
    classOf[Squarer],
    new SquarerImpl(&quot;foo&quot;)), &quot;name&quot;)</code></pre>
<p>Since you supply a <code>Props</code>, you can specify which dispatcher to use, what the default timeout should be used and more. Now, our <code>Squarer</code> doesn&rsquo;t have any methods, so we&rsquo;d better add those.</p>
<pre class="prettyprint"><code class="language-scala">trait Squarer {
  def squareDontCare(i: Int): Unit //fire-forget

  def square(i: Int): Future[Int] //non-blocking send-request-reply

  def squareNowPlease(i: Int): Option[Int] //blocking send-request-reply

  def squareNow(i: Int): Int //blocking send-request-reply

  @throws(classOf[Exception]) //declare it or you will get an UndeclaredThrowableException
  def squareTry(i: Int): Int //blocking send-request-reply with possible exception
}</code></pre>
<p>Alright, now we&rsquo;ve got some methods we can call, but we need to implement those in SquarerImpl.</p>
<pre class="prettyprint"><code class="language-scala">class SquarerImpl(val name: String) extends Squarer {

  def this() = this(&quot;default&quot;)
  def squareDontCare(i: Int): Unit = i * i //Nobody cares :(

  def square(i: Int): Future[Int] = Future.successful(i * i)

  def squareNowPlease(i: Int): Option[Int] = Some(i * i)

  def squareNow(i: Int): Int = i * i

  def squareTry(i: Int): Int = throw new Exception(&quot;Catch me!&quot;)
}</code></pre>
<p>Excellent, now we have an interface and an implementation of that interface, and we know how to create a Typed Actor from that, so let&rsquo;s look at calling these methods.</p>
<h2><a href="#method-dispatch-semantics" name="method-dispatch-semantics" class="anchor"><span class="anchor-link"></span></a>Method dispatch semantics</h2>
<p>Methods returning:</p>
<ul>
  <li><code>Unit</code> will be dispatched with <code>fire-and-forget</code> semantics, exactly like <code>ActorRef.tell</code></li>
  <li><code>scala.concurrent.Future[_]</code> will use <code>send-request-reply</code> semantics, exactly like <code>ActorRef.ask</code></li>
  <li><code>scala.Option[_]</code> will use <code>send-request-reply</code> semantics, but <em>will</em> block to wait for an answer, and return <code>scala.None</code> if no answer was produced within the timeout, or <code>scala.Some[_]</code> containing the result otherwise. Any exception that was thrown during this call will be rethrown.</li>
  <li>Any other type of value will use <code>send-request-reply</code> semantics, but <em>will</em> block to wait for an answer, throwing <code>java.util.concurrent.TimeoutException</code> if there was a timeout or rethrow any exception that was thrown during this call.</li>
</ul>
<h2><a href="#messages-and-immutability" name="messages-and-immutability" class="anchor"><span class="anchor-link"></span></a>Messages and immutability</h2>
<p>While Akka cannot enforce that the parameters to the methods of your Typed Actors are immutable, we <em>strongly</em> recommend that parameters passed are immutable.</p>
<h3><a href="#one-way-message-send" name="one-way-message-send" class="anchor"><span class="anchor-link"></span></a>One-way message send</h3>
<pre class="prettyprint"><code class="language-scala">mySquarer.squareDontCare(10)</code></pre>
<p>As simple as that! The method will be executed on another thread; asynchronously.</p>
<h3><a href="#request-reply-message-send" name="request-reply-message-send" class="anchor"><span class="anchor-link"></span></a>Request-reply message send</h3>
<pre class="prettyprint"><code class="language-scala">val oSquare = mySquarer.squareNowPlease(10) //Option[Int]</code></pre>
<p>This will block for as long as the timeout that was set in the Props of the Typed Actor, if needed. It will return <code>None</code> if a timeout occurs.</p>
<pre class="prettyprint"><code class="language-scala">val iSquare = mySquarer.squareNow(10) //Int</code></pre>
<p>This will block for as long as the timeout that was set in the Props of the Typed Actor, if needed. It will throw a <code>java.util.concurrent.TimeoutException</code> if a timeout occurs.</p>
<h3><a href="#request-reply-with-future-message-send" name="request-reply-with-future-message-send" class="anchor"><span class="anchor-link"></span></a>Request-reply-with-future message send</h3>
<pre class="prettyprint"><code class="language-scala">val fSquare = mySquarer.square(10) //A Future[Int]</code></pre>
<p>This call is asynchronous, and the Future returned can be used for asynchronous composition.</p>
<h2><a href="#stopping-typed-actors" name="stopping-typed-actors" class="anchor"><span class="anchor-link"></span></a>Stopping Typed Actors</h2>
<p>Since Akka&rsquo;s Typed Actors are backed by Akka Actors they must be stopped when they aren&rsquo;t needed anymore.</p>
<pre class="prettyprint"><code class="language-scala">TypedActor(system).stop(mySquarer)</code></pre>
<p>This asynchronously stops the Typed Actor associated with the specified proxy ASAP.</p>
<pre class="prettyprint"><code class="language-scala">TypedActor(system).poisonPill(otherSquarer)</code></pre>
<p>This asynchronously stops the Typed Actor associated with the specified proxy after it&rsquo;s done with all calls that were made prior to this call.</p>
<h2><a href="#typed-actor-hierarchies" name="typed-actor-hierarchies" class="anchor"><span class="anchor-link"></span></a>Typed Actor Hierarchies</h2>
<p>Since you can obtain a contextual Typed Actor Extension by passing in an <code>ActorContext</code> you can create child Typed Actors by invoking <code>typedActorOf(..)</code> on that:</p>
<pre class="prettyprint"><code class="language-scala">//Inside your Typed Actor
val childSquarer: Squarer =
  TypedActor(TypedActor.context).typedActorOf(TypedProps[SquarerImpl]())
//Use &quot;childSquarer&quot; as a Squarer</code></pre>
<p>You can also create a child Typed Actor in regular Akka Actors by giving the <code>ActorContext</code> as an input parameter to TypedActor.get(…).</p>
<h2><a href="#supervisor-strategy" name="supervisor-strategy" class="anchor"><span class="anchor-link"></span></a>Supervisor Strategy</h2>
<p>By having your Typed Actor implementation class implement <code>TypedActor.Supervisor</code> you can define the strategy to use for supervising child actors, as described in <a href="general/supervision.html">supervision</a> and <a href="fault-tolerance.html">Fault Tolerance</a>.</p>
<h2><a href="#lifecycle-callbacks" name="lifecycle-callbacks" class="anchor"><span class="anchor-link"></span></a>Lifecycle callbacks</h2>
<p>By having your Typed Actor implementation class implement any and all of the following:</p>
<ul>
  <li><code>TypedActor.PreStart</code></li>
  <li><code>TypedActor.PostStop</code></li>
  <li><code>TypedActor.PreRestart</code></li>
  <li><code>TypedActor.PostRestart</code></li>
</ul>
<p>You can hook into the lifecycle of your Typed Actor.</p>
<h2><a href="#receive-arbitrary-messages" name="receive-arbitrary-messages" class="anchor"><span class="anchor-link"></span></a>Receive arbitrary messages</h2>
<p>If your implementation class of your TypedActor extends <code>akka.actor.TypedActor.Receiver</code>, all messages that are not <code>MethodCall</code> instances will be passed into the <code>onReceive</code>-method.</p>
<p>This allows you to react to DeathWatch <code>Terminated</code>-messages and other types of messages, e.g. when interfacing with untyped actors.</p>
<h2><a href="#proxying" name="proxying" class="anchor"><span class="anchor-link"></span></a>Proxying</h2>
<p>You can use the <code>typedActorOf</code> that takes a TypedProps and an ActorRef to proxy the given ActorRef as a TypedActor. This is usable if you want to communicate remotely with TypedActors on other machines, just pass the <code>ActorRef</code> to <code>typedActorOf</code>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>The ActorRef needs to accept <code>MethodCall</code> messages.</p></div>
<h2><a href="#lookup-remoting" name="lookup-remoting" class="anchor"><span class="anchor-link"></span></a>Lookup &amp; Remoting</h2>
<p>Since <code>TypedActors</code> are backed by <code>Akka Actors</code>, you can use <code>typedActorOf</code> to proxy <code>ActorRefs</code> potentially residing on remote nodes.</p>
<pre class="prettyprint"><code class="language-scala">val typedActor: Foo with Bar =
  TypedActor(system).
    typedActorOf(
      TypedProps[FooBar],
      actorRefToRemoteActor)
//Use &quot;typedActor&quot; as a FooBar</code></pre>
<h2><a href="#supercharging" name="supercharging" class="anchor"><span class="anchor-link"></span></a>Supercharging</h2>
<p>Here&rsquo;s an example on how you can use traits to mix in behavior in your Typed Actors.</p>
<pre class="prettyprint"><code class="language-scala">trait Foo {
  def doFoo(times: Int): Unit = println(&quot;doFoo(&quot; + times + &quot;)&quot;)
}

trait Bar {
  def doBar(str: String): Future[String] =
    Future.successful(str.toUpperCase)
}

class FooBar extends Foo with Bar</code></pre>
<pre class="prettyprint"><code class="language-scala">val awesomeFooBar: Foo with Bar =
  TypedActor(system).typedActorOf(TypedProps[FooBar]())

awesomeFooBar.doFoo(10)
val f = awesomeFooBar.doBar(&quot;yes&quot;)

TypedActor(system).poisonPill(awesomeFooBar)</code></pre>
<h2><a href="#typed-router-pattern" name="typed-router-pattern" class="anchor"><span class="anchor-link"></span></a>Typed Router pattern</h2>
<p>Sometimes you want to spread messages between multiple actors. The easiest way to achieve this in Akka is to use a <a href="routing.html">Router</a>, which can implement a specific routing logic, such as <code>smallest-mailbox</code> or <code>consistent-hashing</code> etc.</p>
<p>Routers are not provided directly for typed actors, but it is really easy to leverage an untyped router and use a typed proxy in front of it. To showcase this let&rsquo;s create typed actors that assign themselves some random <code>id</code>, so we know that in fact, the router has sent the message to different actors:</p>
<pre class="prettyprint"><code class="language-scala">trait HasName {
  def name(): String
}

class Named extends HasName {
  import scala.util.Random
  private val id = Random.nextInt(1024)

  def name(): String = &quot;name-&quot; + id
}</code></pre>
<p>In order to round robin among a few instances of such actors, you can simply create a plain untyped router, and then facade it with a <code>TypedActor</code> like shown in the example below. This works because typed actors of course communicate using the same mechanisms as normal actors, and methods calls on them get transformed into message sends of <code>MethodCall</code> messages.</p>
<pre class="prettyprint"><code class="language-scala">def namedActor(): HasName = TypedActor(system).typedActorOf(TypedProps[Named]())

// prepare routees
val routees: List[HasName] = List.fill(5) { namedActor() }
val routeePaths = routees map { r =&gt;
  TypedActor(system).getActorRefFor(r).path.toStringWithoutAddress
}

// prepare untyped router
val router: ActorRef = system.actorOf(RoundRobinGroup(routeePaths).props())

// prepare typed proxy, forwarding MethodCall messages to `router`
val typedRouter: HasName =
  TypedActor(system).typedActorOf(TypedProps[Named](), actorRef = router)

println(&quot;actor was: &quot; + typedRouter.name()) // name-184
println(&quot;actor was: &quot; + typedRouter.name()) // name-753
println(&quot;actor was: &quot; + typedRouter.name()) // name-320
println(&quot;actor was: &quot; + typedRouter.name()) // name-164</code></pre>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../scala/actordsl.html"><i class="icon-prev"></i> <span class="link-prev">Actor DSL</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../scala/index-network.html">Networking <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="https://github.com/akka/akka/tree/master/akka-docs/src/main/paradox/scala/typed-actors.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
