<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Classic Remoting (Deprecated) &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/remoting.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page-8.css"/>
<link rel="stylesheet" type="text/css" href="css/banner-2.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png"/>
<link rel="manifest" href="images/manifest.json"/>
<meta name="msapplication-TileImage" content="images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"  type="text/javascript" charset="UTF-8" data-domain-script="28b912e7-09e9-43d5-91e4-3d1897044004" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="oss-wrapper">
<div class="oss-brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com">
<img class="lightbend-logo" src="images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="oss-ad no-drop-down">
<nav id="lightbendRotator" class="lightbend-rotator">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Promo Rotator - Akka Serverless - Keep the data. Lose the database. Try now for free. [Learn More] - Akka Banner" href="https://www.lightbend.com/akka-serverless">
<strong>Akka Serverless</strong> - Keep the data. Lose the database. Try now for free. <span class="akka-btn">Learn More</span>
</a>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Promo Rotator - Meet Akka Insights! A stand alone telemetry & observability offering. [Learn More] - Akka Banner" href="https://www.lightbend.com/akka-insights">
<strong>Meet Akka Insights!</strong>&nbsp;&nbsp;A stand alone telemetry & observability offering. <span class="akka-btn">Learn More</span>
</a>
</nav>
</div>
</div>
</div>

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.19
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="remoting.html#classic-remoting-deprecated-" class="active page">Classic Remoting (Deprecated)</a>
    <ul>
      <li><a href="remoting.html#module-info" class="header">Module info</a></li>
      <li><a href="remoting.html#configuration" class="header">Configuration</a></li>
      <li><a href="remoting.html#introduction" class="header">Introduction</a></li>
      <li><a href="remoting.html#types-of-remote-interaction" class="header">Types of Remote Interaction</a></li>
      <li><a href="remoting.html#looking-up-remote-actors" class="header">Looking up Remote Actors</a></li>
      <li><a href="remoting.html#creating-actors-remotely" class="header">Creating Actors Remotely</a></li>
      <li><a href="remoting.html#lifecycle-and-failure-recovery-model" class="header">Lifecycle and Failure Recovery Model</a></li>
      <li><a href="remoting.html#watching-remote-actors" class="header">Watching Remote Actors</a></li>
      <li><a href="remoting.html#serialization" class="header">Serialization</a></li>
      <li><a href="remoting.html#routers-with-remote-destinations" class="header">Routers with Remote Destinations</a></li>
      <li><a href="remoting.html#remote-security" class="header">Remote Security</a></li>
      <li><a href="remoting.html#remote-configuration" class="header">Remote Configuration</a></li>
    </ul></li>
    <li><a href="split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="coordination.html" class="page">Coordination</a></li>
    <li><a href="typed/choosing-cluster.html" class="page">Choosing Akka Cluster</a></li>
  </ul></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.19
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="typed/index.html" class="page">Actors</a></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="remoting.html#classic-remoting-deprecated-" class="active page">Classic Remoting (Deprecated)</a>
    <ul>
      <li><a href="remoting.html#module-info" class="header">Module info</a></li>
      <li><a href="remoting.html#configuration" class="header">Configuration</a></li>
      <li><a href="remoting.html#introduction" class="header">Introduction</a></li>
      <li><a href="remoting.html#types-of-remote-interaction" class="header">Types of Remote Interaction</a></li>
      <li><a href="remoting.html#looking-up-remote-actors" class="header">Looking up Remote Actors</a></li>
      <li><a href="remoting.html#creating-actors-remotely" class="header">Creating Actors Remotely</a></li>
      <li><a href="remoting.html#lifecycle-and-failure-recovery-model" class="header">Lifecycle and Failure Recovery Model</a></li>
      <li><a href="remoting.html#watching-remote-actors" class="header">Watching Remote Actors</a></li>
      <li><a href="remoting.html#serialization" class="header">Serialization</a></li>
      <li><a href="remoting.html#routers-with-remote-destinations" class="header">Routers with Remote Destinations</a></li>
      <li><a href="remoting.html#remote-security" class="header">Remote Security</a></li>
      <li><a href="remoting.html#remote-configuration" class="header">Remote Configuration</a></li>
    </ul></li>
    <li><a href="split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="coordination.html" class="page">Coordination</a></li>
    <li><a href="typed/choosing-cluster.html" class="page">Choosing Akka Cluster</a></li>
  </ul></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#classic-remoting-deprecated-" name="classic-remoting-deprecated-" class="anchor"><span class="anchor-link"></span></a>Classic Remoting (Deprecated)</h1><div class="callout warning "><div class="callout-title">Warning</div>
<p>Classic remoting has been deprecated and will be removed in Akka 2.7.0. Please use <a href="remoting-artery.html">Artery</a> instead.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>Remoting is the mechanism by which Actors on different nodes talk to each other internally.</p>
<p>When building an Akka application, you would usually not use the Remoting concepts directly, but instead use the more high-level <a href="index-cluster.html">Akka Cluster</a> utilities or technology-agnostic protocols such as <a href="https://doc.akka.io/docs/akka-http/current/">HTTP</a>, <a href="https://doc.akka.io/docs/akka-grpc/current/">gRPC</a> etc.</p></div>
<h2><a href="#module-info" name="module-info" class="anchor"><span class="anchor-link"></span></a>Module info</h2>
<p>To use Akka Remoting, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val AkkaVersion = "2.6.19"
libraryDependencies += "com.typesafe.akka" %% "akka-remote" % AkkaVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
      &lt;artifactId&gt;akka-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;2.6.19&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
    &lt;artifactId&gt;akka-remote_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("com.typesafe.akka:akka-bom_${versions.ScalaBinary}:2.6.19")

  implementation "com.typesafe.akka:akka-remote_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<table class="project-info">
<tr><th colspan="2">Project Info: Akka Remoting</th></tr>
  <tr><th>Artifact</th><td><div>com.typesafe.akka</div>
  <div>akka-remote</div>
  <div>2.6.19</div>
  <div><a href="project/links.html#snapshots-repository">Snapshots are available</a></div>
  </td></tr>
  <tr><th>JDK versions</th><td><div>Adopt OpenJDK 8</div><div>Adopt OpenJDK 11</div></td></tr>
  <tr><th>Scala versions</th><td>2.13.8, 2.12.15, 3.1.1</td></tr>
  <tr><th>JPMS module name</th><td>akka.remote</td></tr>
  <tr><th>License</th><td><div><a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache-2.0</a></div>
  </td></tr>
  <tr><th>Readiness level</th><td><div class="readiness-level"><a href="https://developer.lightbend.com/docs/introduction/getting-help/support-terminology.html#supported" target="_blank" rel="noopener">Supported</a>, <a href="https://www.lightbend.com/lightbend-subscription" target="_blank" rel="noopener">Lightbend Subscription</a> provides support</div>
  <div>Since 2.6.0, 2019-11-06</div>
  <div>Note: Classic remoting is deprecated and will be removed in Akka 2.7.0.</div>
  </td></tr>
  <tr><th>Home page</th><td><a href="https://akka.io/">https://akka.io/</a></td></tr>
  <tr><th>API documentation</th><td>
  <div><a href="https://doc.akka.io/api/akka/2.6.19/akka/remote/index.html" target="_blank" rel="noopener noreferrer">API (Scaladoc)</a></div>
  <div><a href="https://doc.akka.io/japi/akka/2.6.19/akka/remote/package-summary.html" target="_blank" rel="noopener noreferrer">API (Javadoc)</a></div>
  </td></tr>
  <tr><th>Forums</th><td>
  <div><a href="https://discuss.akka.io" target="_blank" rel="noopener noreferrer">Lightbend Discuss</a></div>
  <div><a href="https://gitter.im/akka/akka" target="_blank" rel="noopener noreferrer">akka/akka Gitter channel</a></div>
  </td></tr>
  <tr><th>Release notes</th><td><a href="https://akka.io/blog/news-archive.html">akka.io blog</a></td></tr>
  <tr><th>Issues</th><td><a href="https://github.com/akka/akka/issues" target="_blank" rel="noopener noreferrer">Github issues</a></td></tr>
  <tr><th>Sources</th><td><a href="https://github.com/akka/akka" target="_blank" rel="noopener noreferrer">https://github.com/akka/akka</a></td></tr>
</table>

<p>Classic remoting depends on Netty. This needs to be explicitly added as a dependency so that users not using classic remoting do not have to have Netty on the classpath:</p>
<dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "io.netty" % "netty" % "3.10.6.Final"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;io.netty&lt;/groupId&gt;
    &lt;artifactId&gt;netty&lt;/artifactId&gt;
    &lt;version&gt;3.10.6.Final&lt;/version&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  implementation "io.netty:netty:3.10.6.Final"
}</code></pre></dd></dl>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>To enable classic remoting in your Akka project you should, at a minimum, add the following changes to your <code>application.conf</code> file:</p>
<pre><code>akka {
  actor {
    # provider=remote is possible, but prefer cluster
    provider = cluster
  }
  remote.artery.enabled = false
  remote.classic {
    enabled-transports = [&quot;akka.remote.classic.netty.tcp&quot;]
    netty.tcp {
      hostname = &quot;127.0.0.1&quot;
      port = 2552
    }
 }
}
</code></pre>
<p>As you can see in the example above there are four things you need to add to get started:</p>
<ul>
  <li>Change provider from <code>local</code>. We recommend using <a href="cluster-usage.html">Akka Cluster</a> over using remoting directly.</li>
  <li>Disable artery remoting. Artery is the default remoting implementation since <code>2.6.0</code></li>
  <li>Add host name - the machine you want to run the actor system on; this host name is exactly what is passed to remote systems in order to identify this system and consequently used for connecting back to this system if need be, hence set it to a reachable IP address or resolvable name in case you want to communicate across the network.</li>
  <li>Add port number - the port the actor system should listen on, set to 0 to have it chosen automatically</li>
</ul><div class="callout note "><div class="callout-title">Note</div>
<p>The port number needs to be unique for each actor system on the same machine even if the actor systems have different names. This is because each actor system has its own networking subsystem listening for connections and handling messages as not to interfere with other actor systems.</p></div>
<p>The example above only illustrates the bare minimum of properties you have to add to enable remoting. All settings are described in <a href="remoting.html#remote-configuration">Remote Configuration</a>.</p>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>We recommend <a href="cluster-usage.html">Akka Cluster</a> over using remoting directly. As remoting is the underlying module that allows for Cluster, it is still useful to understand details about it though.</p>
<p>For an introduction of remoting capabilities of Akka please see <a href="general/remoting.html">Location Transparency</a>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>As explained in that chapter Akka remoting is designed for communication in a peer-to-peer fashion and it is not a good fit for client-server setups. In particular Akka Remoting does not work transparently with Network Address Translation, Load Balancers, or in Docker containers. For symmetric communication in these situations network and/or Akka configuration will have to be changed as described in <a href="#remote-configuration-nat">Akka behind NAT or in a Docker container</a>.</p></div>
<p>You need to enable <a href="serialization.html">serialization</a> for your actor messages. <a href="serialization-jackson.html">Serialization with Jackson</a> is a good choice in many cases and our recommendation if you don&rsquo;t have other preference.</p>
<h2><a href="#types-of-remote-interaction" name="types-of-remote-interaction" class="anchor"><span class="anchor-link"></span></a>Types of Remote Interaction</h2>
<p>Akka has two ways of using remoting:</p>
<ul>
  <li>Lookup : used to look up an actor on a remote node with <code>actorSelection(path)</code></li>
  <li>Creation : used to create an actor on a remote node with <code>actorOf(Props(...), actorName)</code></li>
</ul>
<p>In the next sections the two alternatives are described in detail.</p>
<h2><a href="#looking-up-remote-actors" name="looking-up-remote-actors" class="anchor"><span class="anchor-link"></span></a>Looking up Remote Actors</h2>
<p><code>actorSelection(path)</code> will obtain an <code>ActorSelection</code> to an Actor on a remote node, e.g.:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre><code>val selection =
  context.actorSelection(&quot;akka.tcp://actorSystemName@10.0.0.1:2552/user/actorName&quot;)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre><code>ActorSelection selection =
  context.actorSelection(&quot;akka.tcp://app@10.0.0.1:2552/user/serviceA/worker&quot;);
</code></pre></dd>
</dl>
<p>As you can see from the example above the following pattern is used to find an actor on a remote node:</p>
<pre><code>akka.&lt;protocol&gt;://&lt;actor system name&gt;@&lt;hostname&gt;:&lt;port&gt;/&lt;actor path&gt;
</code></pre>
<p>Once you obtained a selection to the actor you can interact with it in the same way you would with a local actor, e.g.:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre><code>selection ! &quot;Pretty awesome feature&quot;
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre><code>selection.tell(&quot;Pretty awesome feature&quot;, getSelf());
</code></pre></dd>
</dl>
<p>To acquire an <code>ActorRef</code> for an <code>ActorSelection</code> you need to send a message to the selection and use the <code>sender</code> reference of the reply from the actor. There is a built-in <code>Identify</code> message that all Actors will understand and automatically reply to with a <code>ActorIdentity</code> message containing the <code>ActorRef</code>. This can also be done with the <code>resolveOne</code> method of the <code>ActorSelection</code>, which returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the matching <code>ActorRef</code>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>For more details on how actor addresses and paths are formed and used, please refer to <a href="general/addressing.html">Actor References, Paths and Addresses</a>.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>Message sends to actors that are actually in the sending actor system do not get delivered via the remote actor ref provider. They&rsquo;re delivered directly, by the local actor ref provider.</p>
<p>Aside from providing better performance, this also means that if the hostname you configure remoting to listen as cannot actually be resolved from within the very same actor system, such messages will (perhaps counterintuitively) be delivered just fine.</p></div>
<h2><a href="#creating-actors-remotely" name="creating-actors-remotely" class="anchor"><span class="anchor-link"></span></a>Creating Actors Remotely</h2>
<p>If you want to use the creation functionality in Akka remoting you have to further amend the <code>application.conf</code> file in the following way (only showing deployment section):</p>
<pre><code>akka {
  actor {
    deployment {
      /sampleActor {
        remote = &quot;akka.tcp://sampleActorSystem@127.0.0.1:2553&quot;
      }
    }
  }
}
</code></pre>
<p>The configuration above instructs Akka to react when an actor with path <code>/sampleActor</code> is created, i.e. using <span class="group-scala"><code>system.actorOf(Props(...), &quot;sampleActor&quot;)</code></span><span class="group-java"><code>system.actorOf(new Props(...), &quot;sampleActor&quot;)</code></span>. This specific actor will not be directly instantiated, but instead the remote daemon of the remote system will be asked to create the actor, which in this sample corresponds to <code>sampleActorSystem@127.0.0.1:2553</code>.</p>
<p>Once you have configured the properties above you would do the following in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L63-L65" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>val actor = system.actorOf(Props[SampleActor](), &quot;sampleActor&quot;)
actor ! &quot;Pretty slick&quot;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L66-L68" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>ActorRef actor = system.actorOf(Props.create(SampleActor.class), &quot;sampleActor&quot;);
actor.tell(&quot;Pretty slick&quot;, ActorRef.noSender());</code></pre></dd>
</dl>
<p>The actor class <code>SampleActor</code> has to be available to the runtimes using it, i.e. the classloader of the actor systems has to have a JAR containing the class.</p>
<p>When using remote deployment of actors you must ensure that all parameters of the <code>Props</code> can be <a href="serialization.html">serialized</a>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>In order to ensure serializability of <code>Props</code> when passing constructor arguments to the actor being created, do not make the factory <span class="group-scala">an</span><span class="group-java">a non-static</span> inner class: this will inherently capture a reference to its enclosing object, which in most cases is not serializable. It is best to <span class="group-scala">create a factory method in the companion object of the actor’s class</span><span class="group-java">make a static inner class which implements <code>Creator&lt;T extends Actor&gt;</code></span>.</p>
<p>Serializability of all Props can be tested by setting the configuration item <code>akka.actor.serialize-creators=on</code>. Only Props whose <code>deploy</code> has <code>LocalScope</code> are exempt from this check.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>You can use asterisks as wildcard matches for the actor path sections, so you could specify: <code>/*/sampleActor</code> and that would match all <code>sampleActor</code> on that level in the hierarchy. You can also use wildcard in the last position to match all actors at a certain level: <code>/someParent/*</code>. Non-wildcard matches always have higher priority to match than wildcards, so: <code>/foo/bar</code> is considered <strong>more specific</strong> than <code>/foo/*</code> and only the highest priority match is used. Please note that it <strong>cannot</strong> be used to partially match section, like this: <code>/foo*/bar</code>, <code>/f*o/bar</code> etc.</p></div>
<h3><a href="#programmatic-remote-deployment" name="programmatic-remote-deployment" class="anchor"><span class="anchor-link"></span></a>Programmatic Remote Deployment</h3>
<p>To allow dynamically deployed systems, it is also possible to include deployment configuration in the <code>Props</code> which are used to create an actor: this information is the equivalent of a deployment section from the configuration file, and if both are given, the external configuration takes precedence.</p>
<p>With these imports:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L10-L11" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import akka.actor.{ Address, AddressFromURIString, Deploy, Props }
import akka.remote.RemoteScope</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L15-L21" target="_blank" title="Go to snippet source">source</a><code class="language-java">import akka.actor.ActorRef;
import akka.actor.Address;
import akka.actor.AddressFromURIString;
import akka.actor.Deploy;
import akka.actor.Props;
import akka.actor.ActorSystem;
import akka.remote.RemoteScope;</code></pre></dd>
</dl>
<p>and a remote address like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L55-L56" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val one = AddressFromURIString(&quot;akka://sys@host:1234&quot;)
val two = Address(&quot;akka&quot;, &quot;sys&quot;, &quot;host&quot;, 1234) // this gives the same</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L52-L53" target="_blank" title="Go to snippet source">source</a><code class="language-java">Address addr = new Address(&quot;akka&quot;, &quot;sys&quot;, &quot;host&quot;, 1234);
addr = AddressFromURIString.parse(&quot;akka://sys@host:1234&quot;); // the same</code></pre></dd>
</dl>
<p>you can advise the system to create a child on that remote node like so:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/scala/docs/remoting/RemoteDeploymentDocSpec.scala#L39" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val ref = system.actorOf(Props[SampleActor]().withDeploy(Deploy(scope = RemoteScope(address))))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L56-L58" target="_blank" title="Go to snippet source">source</a><code class="language-java">ActorRef ref =
    system.actorOf(
        Props.create(SampleActor.class).withDeploy(new Deploy(new RemoteScope(addr))));</code></pre></dd>
</dl>
<h3><a href="#remote-deployment-allow-list" name="remote-deployment-allow-list" class="anchor"><span class="anchor-link"></span></a>Remote deployment allow list</h3>
<p>As remote deployment can potentially be abused by both users and even attackers an allow list feature is available to guard the ActorSystem from deploying unexpected actors. Please note that remote deployment is <em>not</em> remote code loading, the Actors class to be deployed onto a remote system needs to be present on that remote system. This still however may pose a security risk, and one may want to restrict remote deployment to only a specific set of known actors by enabling the allow list feature.</p>
<p>To enable remote deployment allow list set the <code>akka.remote.deployment.enable-allow-list</code> value to <code>on</code>. The list of allowed classes has to be configured on the &ldquo;remote&rdquo; system, in other words on the system onto which others will be attempting to remote deploy Actors. That system, locally, knows best which Actors it should or should not allow others to remote deploy onto it. The full settings section may for example look like this:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-remote/src/test/scala/akka/remote/classic/RemoteDeploymentAllowListSpec.scala#L123-L130" target="_blank" title="Go to snippet source">source</a><code class="language-scala">akka.remote.deployment {
  enable-allow-list = on
  
  allowed-actor-classes = [
    &quot;NOT_ON_CLASSPATH&quot;, # verify we don&#39;t throw if a class not on classpath is listed here
    &quot;akka.remote.classic.RemoteDeploymentAllowListSpec.EchoAllowed&quot;
  ]
}</code></pre>
<p>Actor classes not included in the allow list will not be allowed to be remote deployed onto this system.</p>
<h2><a href="#lifecycle-and-failure-recovery-model" name="lifecycle-and-failure-recovery-model" class="anchor"><span class="anchor-link"></span></a>Lifecycle and Failure Recovery Model</h2>
<p><img src="./images/association_lifecycle.png" alt="association_lifecycle.png" /></p>
<p>Each link with a remote system can be in one of the four states as illustrated above. Before any communication happens with a remote system at a given <code>Address</code> the state of the association is <code>Idle</code>. The first time a message is attempted to be sent to the remote system or an inbound connection is accepted the state of the link transitions to <code>Active</code> denoting that the two systems has messages to send or receive and no failures were encountered so far. When a communication failure happens and the connection is lost between the two systems the link becomes <code>Gated</code>.</p>
<p>In this state the system will not attempt to connect to the remote host and all outbound messages will be dropped. The time while the link is in the <code>Gated</code> state is controlled by the setting <code>akka.remote.retry-gate-closed-for</code>: after this time elapses the link state transitions to <code>Idle</code> again. <code>Gate</code> is one-sided in the sense that whenever a successful <em>inbound</em> connection is accepted from a remote system during <code>Gate</code> it automatically transitions to <code>Active</code> and communication resumes immediately.</p>
<p>In the face of communication failures that are unrecoverable because the state of the participating systems are inconsistent, the remote system becomes <code>Quarantined</code>. Unlike <code>Gate</code>, quarantining is permanent and lasts until one of the systems is restarted. After a restart communication can be resumed again and the link can become <code>Active</code> again.</p>
<h2><a href="#watching-remote-actors" name="watching-remote-actors" class="anchor"><span class="anchor-link"></span></a>Watching Remote Actors</h2>
<p>Watching a remote actor is not different than watching a local actor, as described in <a href="actors.html#deathwatch">Lifecycle Monitoring aka DeathWatch</a>.</p>
<h3><a href="#failure-detector" name="failure-detector" class="anchor"><span class="anchor-link"></span></a>Failure Detector</h3>
<p>Please see:</p>
<ul>
  <li><a href="typed/failure-detector.html">Phi Accrual Failure Detector</a> implementation for details</li>
  <li><a href="remoting.html#using-the-failure-detector">Using the Failure Detector</a> below for usage</li>
</ul>
<h3><a href="#using-the-failure-detector" name="using-the-failure-detector" class="anchor"><span class="anchor-link"></span></a>Using the Failure Detector</h3>
<p>Remoting uses the <code>akka.remote.PhiAccrualFailureDetector</code> failure detector by default, or you can provide your by implementing the <code>akka.remote.FailureDetector</code> and configuring it:</p>
<pre><code>akka.remote.watch-failure-detector.implementation-class = &quot;com.example.CustomFailureDetector&quot;
</code></pre>
<p>In the <a href="remoting.html#remote-configuration">Remote Configuration</a> you may want to adjust these depending on you environment:</p>
<ul>
  <li>When a <em>phi</em> value is considered to be a failure <code>akka.remote.watch-failure-detector.threshold</code></li>
  <li>Margin of error for sudden abnormalities <code>akka.remote.watch-failure-detector.acceptable-heartbeat-pause</code></li>
</ul>
<h2><a href="#serialization" name="serialization" class="anchor"><span class="anchor-link"></span></a>Serialization</h2>
<p>You need to enable <a href="serialization.html">serialization</a> for your actor messages. <a href="serialization-jackson.html">Serialization with Jackson</a> is a good choice in many cases and our recommendation if you don&rsquo;t have other preference.</p>
<h2><a href="#routers-with-remote-destinations" name="routers-with-remote-destinations" class="anchor"><span class="anchor-link"></span></a>Routers with Remote Destinations</h2>
<p>It is absolutely feasible to combine remoting with <a href="routing.html">Routing</a>.</p>
<p>A pool of remote deployed routees can be configured as:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L209-L215" target="_blank" title="Go to snippet source">source</a><code class="language-scala">akka.actor.deployment {
  /parent/remotePool {
    router = round-robin-pool
    nr-of-instances = 10
    target.nodes = [&quot;akka://app@10.0.0.2:2552&quot;, &quot;akka://app@10.0.0.3:2552&quot;]
  }
}</code></pre>
<p>This configuration setting will clone the actor defined in the <code>Props</code> of the <code>remotePool</code> 10 times and deploy it evenly distributed across the two given target nodes.</p>
<p>When using a pool of remote deployed routees you must ensure that all parameters of the <code>Props</code> can be <a href="serialization.html">serialized</a>.</p>
<p>A group of remote actors can be configured as:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L229-L237" target="_blank" title="Go to snippet source">source</a><code class="language-scala">akka.actor.deployment {
  /parent/remoteGroup {
    router = round-robin-group
    routees.paths = [
      &quot;akka://app@10.0.0.1:2552/user/workers/w1&quot;,
      &quot;akka://app@10.0.0.2:2552/user/workers/w1&quot;,
      &quot;akka://app@10.0.0.3:2552/user/workers/w1&quot;]
  }
}</code></pre>
<p>This configuration setting will send messages to the defined remote actor paths. It requires that you create the destination actors on the remote nodes with matching paths. That is not done by the router.</p>
<h3><a href="#remote-events" name="remote-events" class="anchor"><span class="anchor-link"></span></a>Remote Events</h3>
<p>It is possible to listen to events that occur in Akka Remote, and to subscribe/unsubscribe to these events you register as listener to the below described types in on the <code>ActorSystem.eventStream</code>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>To subscribe to any remote event, subscribe to <code>RemotingLifecycleEvent</code>. To subscribe to events related only to the lifecycle of associations, subscribe to <code>akka.remote.AssociationEvent</code>.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>The use of term &ldquo;Association&rdquo; instead of &ldquo;Connection&rdquo; reflects that the remoting subsystem may use connectionless transports, but an association similar to transport layer connections is maintained between endpoints by the Akka protocol.</p></div>
<p>By default an event listener is registered which logs all of the events described below. This default was chosen to help setting up a system, but it is quite common to switch this logging off once that phase of the project is finished.</p><div class="callout note "><div class="callout-title">Note</div>
<p>In order to disable the logging, set <code>akka.remote.classic.log-remote-lifecycle-events = off</code> in your <code>application.conf</code>.</p></div>
<p>To be notified when an association is over (&ldquo;disconnected&rdquo;) listen to <code>DisassociatedEvent</code> which holds the direction of the association (inbound or outbound) and the addresses of the involved parties.</p>
<p>To be notified when an association is successfully established (&ldquo;connected&rdquo;) listen to <code>AssociatedEvent</code> which holds the direction of the association (inbound or outbound) and the addresses of the involved parties.</p>
<p>To intercept errors directly related to associations, listen to <code>AssociationErrorEvent</code> which holds the direction of the association (inbound or outbound), the addresses of the involved parties and the <code>Throwable</code> cause.</p>
<p>To be notified when the remoting subsystem is ready to accept associations, listen to <code>RemotingListenEvent</code> which contains the addresses the remoting listens on.</p>
<p>To be notified when the current system is quarantined by the remote system, listen to <code>ThisActorSystemQuarantinedEvent</code>, which includes the addresses of local and remote ActorSystems.</p>
<p>To be notified when the remoting subsystem has been shut down, listen to <code>RemotingShutdownEvent</code>.</p>
<p>To intercept generic remoting related errors, listen to <code>RemotingErrorEvent</code> which holds the <code>Throwable</code> cause.</p>
<h2><a href="#remote-security" name="remote-security" class="anchor"><span class="anchor-link"></span></a>Remote Security</h2>
<p>An <code>ActorSystem</code> should not be exposed via Akka Remote over plain TCP to an untrusted network (e.g. Internet). It should be protected by network security, such as a firewall. If that is not considered as enough protection <a href="#remote-tls">TLS with mutual authentication</a> should be enabled.</p>
<p>Best practice is that Akka remoting nodes should only be accessible from the adjacent network. Note that if TLS is enabled with mutual authentication there is still a risk that an attacker can gain access to a valid certificate by compromising any node with certificates issued by the same internal PKI tree.</p>
<p>By default, <a href="serialization.html#java-serialization">Java serialization</a> is disabled in Akka. That is also security best-practice because of its multiple <a href="https://community.microfocus.com/cyberres/fortify/f/fortify-discussions/317555/the-perils-of-java-deserialization">known attack surfaces</a>.</p>
<a id="remote-tls"></a>
<h3><a href="#configuring-ssl-tls-for-akka-remoting" name="configuring-ssl-tls-for-akka-remoting" class="anchor"><span class="anchor-link"></span></a>Configuring SSL/TLS for Akka Remoting</h3>
<p>SSL can be used as the remote transport by adding <code>akka.remote.classic.netty.ssl</code> to the <code>enabled-transport</code> configuration section. An example of setting up the default Netty based SSL driver as default:</p>
<pre><code>akka {
  remote.classic {
    enabled-transports = [akka.remote.classic.netty.ssl]
  }
}
</code></pre>
<p>Next the actual SSL/TLS parameters have to be configured:</p>
<pre><code>akka {
  remote.classic {
    netty.ssl {
      hostname = &quot;127.0.0.1&quot;
      port = &quot;3553&quot;

      security {
        key-store = &quot;/example/path/to/mykeystore.jks&quot;
        trust-store = &quot;/example/path/to/mytruststore.jks&quot;

        key-store-password = ${SSL_KEY_STORE_PASSWORD}
        key-password = ${SSL_KEY_PASSWORD}
        trust-store-password = ${SSL_TRUST_STORE_PASSWORD}

        protocol = &quot;TLSv1.2&quot;

        enabled-algorithms = [TLS_DHE_RSA_WITH_AES_128_GCM_SHA256]
      }
    }
  }
}
</code></pre>
<p>Always use <a href="https://github.com/lightbend/config#optional-system-or-env-variable-overrides">substitution from environment variables</a> for passwords. Don&rsquo;t define real passwords in config files.</p>
<p>According to <a href="https://www.rfc-editor.org/rfc/rfc7525.html">RFC 7525</a> the recommended algorithms to use with TLS 1.2 (as of writing this document) are:</p>
<ul>
  <li>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</li>
  <li>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li>
  <li>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</li>
  <li>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</li>
</ul>
<p>You should always check the latest information about security and algorithm recommendations though before you configure your system.</p>
<p>Creating and working with keystores and certificates is well documented in the <a href="https://lightbend.github.io/ssl-config/CertificateGeneration.html#using-keytool">Generating X.509 Certificates</a> section of Lightbend&rsquo;s SSL-Config library.</p>
<p>Since an Akka remoting is inherently <a href="general/remoting.html#symmetric-communication">peer-to-peer</a> both the key-store as well as trust-store need to be configured on each remoting node participating in the cluster.</p>
<p>The official <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html">Java Secure Socket Extension documentation</a> as well as the <a href="https://docs.oracle.com/cd/E19509-01/820-3503/6nf1il6er/index.html">Oracle documentation on creating KeyStore and TrustStores</a> are both great resources to research when setting up security on the JVM. Please consult those resources when troubleshooting and configuring SSL.</p>
<p>Since Akka 2.5.0 mutual authentication between TLS peers is enabled by default.</p>
<p>Mutual authentication means that the the passive side (the TLS server side) of a connection will also request and verify a certificate from the connecting peer. Without this mode only the client side is requesting and verifying certificates. While Akka is a peer-to-peer technology, each connection between nodes starts out from one side (the &ldquo;client&rdquo;) towards the other (the &ldquo;server&rdquo;).</p>
<p>Note that if TLS is enabled with mutual authentication there is still a risk that an attacker can gain access to a valid certificate by compromising any node with certificates issued by the same internal PKI tree.</p>
<p>See also a description of the settings in the <a href="remoting.html#remote-configuration">Remote Configuration</a> section.</p><div class="callout note "><div class="callout-title">Note</div>
<p>When using SHA1PRNG on Linux it&rsquo;s recommended specify <code>-Djava.security.egd=file:/dev/urandom</code> as argument to the JVM to prevent blocking. It is NOT as secure because it reuses the seed.</p></div>
<h3><a href="#untrusted-mode" name="untrusted-mode" class="anchor"><span class="anchor-link"></span></a>Untrusted Mode</h3>
<p>As soon as an actor system can connect to another remotely, it may in principle send any possible message to any actor contained within that remote system. One example may be sending a <code>PoisonPill</code> to the system guardian, shutting that system down. This is not always desired, and it can be disabled with the following setting:</p>
<pre><code>akka.remote.classic.untrusted-mode = on
</code></pre>
<p>This disallows sending of system messages (actor life-cycle commands, DeathWatch, etc.) and any message extending <code>PossiblyHarmful</code> to the system on which this flag is set. Should a client send them nonetheless they are dropped and logged (at DEBUG level in order to reduce the possibilities for a denial of service attack). <code>PossiblyHarmful</code> covers the predefined messages like <code>PoisonPill</code> and <code>Kill</code>, but it can also be added as a marker trait to user-defined messages.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Untrusted mode does not give full protection against attacks by itself. It makes it slightly harder to perform malicious or unintended actions but it should be noted that <a href="serialization.html#java-serialization">Java serialization</a> should still not be enabled. Additional protection can be achieved when running in an untrusted network by network security (e.g. firewalls) and/or enabling <a href="remoting.html#remote-tls">TLS with mutual authentication</a>.</p></div>
<p>Messages sent with actor selection are by default discarded in untrusted mode, but permission to receive actor selection messages can be granted to specific actors defined in configuration:</p>
<pre><code>akka.remote.classic.trusted-selection-paths = [&quot;/user/receptionist&quot;, &quot;/user/namingService&quot;]
</code></pre>
<p>The actual message must still not be of type <code>PossiblyHarmful</code>.</p>
<p>In summary, the following operations are ignored by a system configured in untrusted mode when incoming via the remoting layer:</p>
<ul>
  <li>remote deployment (which also means no remote supervision)</li>
  <li>remote DeathWatch</li>
  <li><code>system.stop()</code>, <code>PoisonPill</code>, <code>Kill</code></li>
  <li>sending any message which extends from the <code>PossiblyHarmful</code> marker interface, which includes <code>Terminated</code></li>
  <li>messages sent with actor selection, unless destination defined in <code>trusted-selection-paths</code>.</li>
</ul><div class="callout note "><div class="callout-title">Note</div>
<p>Enabling the untrusted mode does not remove the capability of the client to freely choose the target of its message sends, which means that messages not prohibited by the above rules can be sent to any actor in the remote system. It is good practice for a client-facing system to only contain a well-defined set of entry point actors, which then forward requests (possibly after performing validation) to another actor system containing the actual worker actors. If messaging between these two server-side systems is done using local <code>ActorRef</code> (they can be exchanged safely between actor systems within the same JVM), you can restrict the messages on this interface by marking them <code>PossiblyHarmful</code> so that a client cannot forge them.</p></div>
<h2><a href="#remote-configuration" name="remote-configuration" class="anchor"><span class="anchor-link"></span></a>Remote Configuration</h2>
<p>There are lots of configuration properties that are related to remoting in Akka. We refer to the <a href="general/configuration-reference.html#config-akka-remote">reference configuration</a> for more information.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Setting properties like the listening IP and port number programmatically is best done by using something like the following:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/test/java/jdocs/remoting/RemoteDeploymentDocTest.java#L75-L76" target="_blank" title="Go to snippet source">source</a><code class="language-java">ConfigFactory.parseString(&quot;akka.remote.classic.netty.tcp.hostname=\&quot;1.2.3.4\&quot;&quot;)
    .withFallback(ConfigFactory.load());</code></pre></div>
<a id="remote-configuration-nat"></a>
<h3><a href="#akka-behind-nat-or-in-a-docker-container" name="akka-behind-nat-or-in-a-docker-container" class="anchor"><span class="anchor-link"></span></a>Akka behind NAT or in a Docker container</h3>
<p>In setups involving Network Address Translation (NAT), Load Balancers or Docker containers the hostname and port pair that Akka binds to will be different than the &ldquo;logical&rdquo; host name and port pair that is used to connect to the system from the outside. This requires special configuration that sets both the logical and the bind pairs for remoting.</p>
<pre><code>akka.remote.classic.netty.tcp {
      hostname = my.domain.com      # external (logical) hostname
      port = 8000                   # external (logical) port

      bind-hostname = local.address # internal (bind) hostname
      bind-port = 2552              # internal (bind) port
}
</code></pre>
<p>Keep in mind that local.address will most likely be in one of private network ranges:</p>
<ul>
  <li><em>10.0.0.0 - 10.255.255.255</em> (network class A)</li>
  <li><em>172.16.0.0 - 172.31.255.255</em> (network class B)</li>
  <li><em>192.168.0.0 - 192.168.255.255</em> (network class C)</li>
</ul>
<p>For further details see <a href="https://www.rfc-editor.org/rfc/rfc1597.html">RFC 1597</a> and <a href="https://www.rfc-editor.org/rfc/rfc1918.html">RFC 1918</a>.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="remoting-artery.html"><i class="icon-prev"></i> <span class="link-prev">Artery Remoting</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="split-brain-resolver.html">Split Brain Resolver <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.6.19/akka-docs/src/main/paradox/remoting.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg" />
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2022 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/snippets.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>
<script type="text/javascript" src="js/metadata-toggle.js"></script>
<script type="text/javascript" src="js/lbHeader.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
