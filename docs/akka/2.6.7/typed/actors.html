<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Introduction to Actors &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="The Actor model, managing internal state and changing behavior in Akka Actors."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/typed/actors.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-7.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner-1.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-2">
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KBJGH35');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">
<div id="lightbend-banner" class="lightbend-banner akka full-width" data-category="OSS Lightbend Banner Impression" data-label="Akka Banner Impression">
<div class="wrapper">
<div class="brand">
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lightbend Logo - Akka Banner" href="https://www.lightbend.com?r=oss-banner-akka" target="_blank">
<img class="lightbend-logo" src="../images/banner-logos/lightbend-reverse.svg" alt="Lightbend" title="Lightbend">
</a>
</div>
<div class="nav">
<a class="banner-btn oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Enhance your Akka systems with Akka Platform [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">
<span>Enhance your Akka systems with</span>
<img class="akka-platform-reverse-logo" src="../images/banner-logos/akka-platform-reverse.svg" alt="Akka Platform" title="Akka Platform">
</a>
<div class="drop-down">
<svg class="svg-chevon-circle-down" version="1.1" id="Chevron_circled_down" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve">
<path fill="#ffffff" d="M12.505,8.698L10,11L7.494,8.698c-0.198-0.196-0.518-0.196-0.718,0c-0.197,0.196-0.197,0.515,0,0.71l2.864,2.807
c0.199,0.196,0.52,0.196,0.717,0l2.864-2.807c0.199-0.195,0.198-0.514,0-0.71C13.024,8.502,12.704,8.502,12.505,8.698z M10,0.4
c-5.302,0-9.6,4.298-9.6,9.6c0,5.303,4.298,9.6,9.6,9.6s9.6-4.297,9.6-9.6C19.6,4.698,15.302,0.4,10,0.4z M10,18.354
c-4.615,0-8.354-3.74-8.354-8.354c0-4.614,3.739-8.354,8.354-8.354c4.613,0,8.354,3.74,8.354,8.354
C18.354,14.614,14.613,18.354,10,18.354z" />
</svg>
<div class="drop-down-content">
<div class="lightbend-family">
<a href="https://cloudflow.io" class="cloudflow oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudflow - Logo Tag Line - Akka Banner">
<img class="cloudflow-full-color-logo" src="../images/banner-logos/cloudflow-full-color.svg" alt="Cloudflow by Lightbend" title="Cloudflow by Lightbend">
</a>
<a href="https://cloudstate.io" class="cloudstate oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Cloudstate - Logo Tag Line - Akka Banner">
<img class="cloudstate-full-color-logo" src="../images/banner-logos/cloudstate-full-color.svg" alt="Cloudstate by Lightbend" title="Cloudstate by Lightbend">
</a>
<a href="https://www.lagomframework.com" class="lagom oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Lagom - Logo Tag Line - Akka Banner">
<img class="lagom-full-color-logo" src="../images/banner-logos/lagom-full-color.svg" alt="Lagom Framework by Lightbend" title="Lagom Framework by Lightbend">
</a>
<a href="https://www.playframework.com" class="play oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Play - Logo Tag Line - Akka Banner">
<img class="play-full-color-logo" src="../images/banner-logos/play-full-color.svg" alt="Play Framework by Lightbend" title="Play Framework by Lightbend">
</a>
<a href="https://www.scala-lang.org" class="scala oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Scala - Logo Tag Line - Akka Banner">
<img class="scala-full-color-logo" src="../images/banner-logos/scala-full-color.svg" alt="Scala by Lightbend" title="Scala by Lightbend">
</a>
<div class="akka current">
<img class="akka-full-color-logo" src="../images/banner-logos/akka-full-color.svg" alt="Akka by Lightbend" title="Akka by Lightbend">
<span>From the creators of <strong>Akka</strong>, get technology enhancements, monitoring, and expert support with Akka Platform from Lightbend.</span>
<a class="oss-track-link-label" data-category="OSS Lightbend Banner Clicks" data-label="Learn More [Button] - Akka Banner" href="https://www.lightbend.com/akka-core-of-lightbend?r=oss-banner-akka" target="_blank">Learn More</a>
</div>
</div>
<div class="title">The Lightbend Family</div>
</div>      
</div>
</div>
</div>
</div>
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.7
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html#introduction-to-actors" class="active page">Introduction to Actors</a>
    <ul>
      <li><a href="../typed/actors.html#module-info" class="header">Module info</a></li>
      <li><a href="../typed/actors.html#akka-actors" class="header">Akka Actors</a></li>
      <li><a href="../typed/actors.html#first-example" class="header">First example</a></li>
      <li><a href="../typed/actors.html#a-more-complex-example" class="header">A More Complex Example</a></li>
    </ul></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html" class="page">Learning Akka Typed from Classic</a></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.6.7
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search" />
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="../typed/actors.html#introduction-to-actors" class="active page">Introduction to Actors</a>
    <ul>
      <li><a href="../typed/actors.html#module-info" class="header">Module info</a></li>
      <li><a href="../typed/actors.html#akka-actors" class="header">Akka Actors</a></li>
      <li><a href="../typed/actors.html#first-example" class="header">First example</a></li>
      <li><a href="../typed/actors.html#a-more-complex-example" class="header">A More Complex Example</a></li>
    </ul></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/routers.html" class="page">Routers</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="../coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="../typed/from-classic.html" class="page">Learning Akka Typed from Classic</a></li>
  </ul></li>
  <li><a href="../typed/index-cluster.html" class="page">Cluster</a></li>
  <li><a href="../typed/index-persistence.html" class="page">Persistence</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../additional/deploy.html" class="page">Package, Deploy and Run</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../index-classic.html" class="page">Akka Classic</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#introduction-to-actors" name="introduction-to-actors" class="anchor"><span class="anchor-link"></span></a>Introduction to Actors</h1>
<p>You are viewing the documentation for the new actor APIs, to view the Akka Classic documentation, see <a href="../actors.html">Classic Actors</a>.</p>
<h2><a href="#module-info" name="module-info" class="anchor"><span class="anchor-link"></span></a>Module info</h2>
<p>To use Akka Actors, add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val AkkaVersion = "2.6.7"
libraryDependencies += "com.typesafe.akka" %% "akka-actor-typed" % AkkaVersion</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;akka.version&gt;2.6.7&lt;/akka.version&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor-typed_${scala.binary.version}&lt;/artifactId&gt;
  &lt;version&gt;${akka.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">versions += [
  AkkaVersion: "2.6.7",
  ScalaBinary: "2.13"
]
dependencies {
  compile group: 'com.typesafe.akka', name: "akka-actor-typed_${versions.ScalaBinary}", version: versions.AkkaVersion
}</code></pre></dd></dl>
<p>Both the Java and Scala DSLs of Akka modules are bundled in the same JAR. For a smooth development experience, when using an IDE such as Eclipse or IntelliJ, you can disable the auto-importer from suggesting <code>javadsl</code> imports when working in Scala, or viceversa. See <a href="../additional/ide.html">IDE Tips</a>. </p>
<table class="project-info">
<tr><th colspan="2">Project Info: Akka Actors (typed)</th></tr>
  <tr><th>Artifact</th><td><div>com.typesafe.akka</div>
  <div>akka-actor-typed</div>
  <div>2.6.7</div></td></tr>
  <tr><th>JDK versions</th><td><div>Adopt OpenJDK 8</div><div>Adopt OpenJDK 11</div></td></tr>
  <tr><th>Scala versions</th><td>2.12.11, 2.13.1</td></tr>
  <tr><th>JPMS module name</th><td>akka.actor.typed</td></tr>
  <tr><th>License</th><td><div><a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache-2.0</a></div>
  </td></tr>
  <tr><th>Readiness level</th><td><div class="readiness-level"><a href="https://developer.lightbend.com/docs/introduction/getting-help/support-terminology.html#supported" target="_blank" rel="noopener">Supported</a>, <a href="https://www.lightbend.com/lightbend-subscription" target="_blank" rel="noopener">Lightbend Subscription</a> provides support</div>
  <div>Since 2.6.0, 2019-11-06</div>
  </td></tr>
  <tr><th>Home page</th><td><a href="https://akka.io/">https://akka.io/</a></td></tr>
  <tr><th>API documentation</th><td>
  <div><a href="https://doc.akka.io/api/akka/2.6.7/akka/actor/typed/index.html" target="_blank" rel="noopener noreferrer">API (Scaladoc)</a></div>
  <div><a href="https://doc.akka.io/japi/akka/2.6.7/akka/actor/typed/package-summary.html" target="_blank" rel="noopener noreferrer">API (Javadoc)</a></div>
  </td></tr>
  <tr><th>Forums</th><td>
  <div><a href="https://discuss.akka.io" target="_blank" rel="noopener noreferrer">Lightbend Discuss</a></div>
  <div><a href="https://gitter.im/akka/akka" target="_blank" rel="noopener noreferrer">akka/akka Gitter channel</a></div>
  </td></tr>
  <tr><th>Release notes</th><td><a href="https://akka.io/blog/news-archive.html">akka.io blog</a></td></tr>
  <tr><th>Issues</th><td><a href="https://github.com/akka/akka/issues" target="_blank" rel="noopener noreferrer">Github issues</a></td></tr>
  <tr><th>Sources</th><td><a href="https://github.com/akka/akka" target="_blank" rel="noopener noreferrer">https://github.com/akka/akka</a></td></tr>
</table>

<h2><a href="#akka-actors" name="akka-actors" class="anchor"><span class="anchor-link"></span></a>Akka Actors</h2>

<p>The <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> provides a higher level of abstraction for writing concurrent and distributed systems. It alleviates the developer from having to deal with explicit locking and thread management, making it easier to write correct concurrent and parallel systems. Actors were defined in the 1973 paper by Carl Hewitt but have been popularized by the Erlang language, and used for example at Ericsson with great success to build highly concurrent and reliable telecom systems. The API of Akka’s Actors has borrowed some of its syntax from Erlang.</p>

<h2><a href="#first-example" name="first-example" class="anchor"><span class="anchor-link"></span></a>First example</h2>

<p>If you are new to Akka you might want to start with reading the <a href="guide/introduction.html">Getting Started Guide</a> and then come back here to learn more. We also recommend watching the short <a href="https://akka.io/blog/news/2019/12/03/akka-typed-actor-intro-video">introduction video to Akka actors</a>. </p>

<p>It is helpful to become familiar with the foundational, external and internal ecosystem of your Actors, to see what you can leverage and customize as needed, see <a href="../general/actor-systems.html">Actor Systems</a> and <a href="../general/addressing.html">Actor References, Paths and Addresses</a>.</p>

<p>As discussed in <a href="../general/actor-systems.html">Actor Systems</a> Actors are about sending messages between independent units of computation, but what does that look like?</p>

<p>In all of the following these imports are assumed:</p>

<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L9-L11" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl.LoggerOps
import akka.actor.typed.{ ActorRef, ActorSystem, Behavior }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L8-L15" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;
</code></pre></dd>
</dl>
<p>With these in place we can define our first Actor, and it will say hello!</p>
<p><img src="./images/hello-world1.png" alt="hello-world1.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L31-L45" target="_blank" title="Go to snippet source"></a><code class="language-scala">object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =&gt;
    context.log.info(&quot;Hello {}!&quot;, message.whom)
    message.replyTo ! Greeted(message.whom, context.self)
    Behaviors.same
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L31-L71" target="_blank" title="Go to snippet source"></a><code class="language-java">public class HelloWorld extends AbstractBehavior&lt;HelloWorld.Greet&gt; {

  public static final class Greet {
    public final String whom;
    public final ActorRef&lt;Greeted&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeted&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  public static final class Greeted {
    public final String whom;
    public final ActorRef&lt;Greet&gt; from;

    public Greeted(String whom, ActorRef&lt;Greet&gt; from) {
      this.whom = whom;
      this.from = from;
    }
  }

  public static Behavior&lt;Greet&gt; create() {
    return Behaviors.setup(HelloWorld::new);
  }

  private HelloWorld(ActorContext&lt;Greet&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Greet&gt; createReceive() {
    return newReceiveBuilder().onMessage(Greet.class, this::onGreet).build();
  }

  private Behavior&lt;Greet&gt; onGreet(Greet command) {
    getContext().getLog().info(&quot;Hello {}!&quot;, command.whom);
    command.replyTo.tell(new Greeted(command.whom, getContext().getSelf()));
    return this;
  }
}</code></pre></dd>
</dl>
<p>This small piece of code defines two message types, one for commanding the Actor to greet someone and one that the Actor will use to confirm that it has done so. The <code>Greet</code> type contains not only the information of whom to greet, it also holds an <code>ActorRef</code> that the sender of the message supplies so that the <code>HelloWorld</code> Actor can send back the confirmation message.</p>
<p>The behavior of the Actor is defined as the <code>Greeter</code> with the help of the <code>receive</code> behavior factory. Processing the next message then results in a new behavior that can potentially be different from this one. State is updated by returning a new behavior that holds the new immutable state. In this case we don&rsquo;t need to update any state, so we return <span class="group-scala"><code>same</code></span><span class="group-java"><code>this</code></span>, which means the next behavior is &ldquo;the same as the current one&rdquo;.</p>
<p>The type of the messages handled by this behavior is declared to be of class <code>Greet</code><span class="group-java">.</span><span class="group-scala">, meaning that <code>message</code> argument is also typed as such. This is why we can access the <code>whom</code> and <code>replyTo</code> members without needing to use a pattern match.</span> Typically, an actor handles more than one specific message type where all of them directly or indirectly <span class="group-scala"><code>extend</code></span><span class="group-java"><code>implement</code></span> a common <span class="group-scala"><code>trait</code></span><span class="group-java"><code>interface</code></span>.</p>
<p>On the last line we see the <code>HelloWorld</code> Actor send a message to another Actor, which is done using the <span class="group-scala"><code>!</code> operator (pronounced “bang” or “tell”)</span><span class="group-java"><code>tell</code> method</span>. It is an asynchronous operation that doesn&rsquo;t block the caller&rsquo;s thread.</p>
<p>Since the <code>replyTo</code> address is declared to be of type <span class="group-scala"><code>ActorRef[Greeted]</code></span><span class="group-java"><code>ActorRef&lt;Greeted&gt;</code></span>, the compiler will only permit us to send messages of this type, other usage will be a compiler error.</p>
<p>The accepted message types of an Actor together with all reply types defines the protocol spoken by this Actor; in this case it is a simple request–reply protocol but Actors can model arbitrarily complex protocols when needed. The protocol is bundled together with the behavior that implements it in a nicely wrapped scope—the <code>HelloWorld</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>As Carl Hewitt said, one Actor is no Actor — it would be quite lonely with nobody to talk to. We need another Actor that interacts with the <code>Greeter</code>. Let&rsquo;s make a <code>HelloWorldBot</code> that receives the reply from the <code>Greeter</code> and sends a number of additional greeting messages and collect the replies until a given max number of messages have been reached.</p>
<p><img src="./images/hello-world2.png" alt="hello-world2.png" /></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L49-L71" target="_blank" title="Go to snippet source"></a><code class="language-scala">object HelloWorldBot {

  def apply(max: Int): Behavior[HelloWorld.Greeted] = {
    bot(0, max)
  }

  private def bot(greetingCounter: Int, max: Int): Behavior[HelloWorld.Greeted] =
    Behaviors.receive { (context, message) =&gt;
      val n = greetingCounter + 1
      context.log.info2(&quot;Greeting {} for {}&quot;, n, message.whom)
      if (n == max) {
        Behaviors.stopped
      } else {
        message.from ! HelloWorld.Greet(message.whom, context.self)
        bot(n, max)
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L75-L104" target="_blank" title="Go to snippet source"></a><code class="language-java">public class HelloWorldBot extends AbstractBehavior&lt;HelloWorld.Greeted&gt; {

  public static Behavior&lt;HelloWorld.Greeted&gt; create(int max) {
    return Behaviors.setup(context -&gt; new HelloWorldBot(context, max));
  }

  private final int max;
  private int greetingCounter;

  private HelloWorldBot(ActorContext&lt;HelloWorld.Greeted&gt; context, int max) {
    super(context);
    this.max = max;
  }

  @Override
  public Receive&lt;HelloWorld.Greeted&gt; createReceive() {
    return newReceiveBuilder().onMessage(HelloWorld.Greeted.class, this::onGreeted).build();
  }

  private Behavior&lt;HelloWorld.Greeted&gt; onGreeted(HelloWorld.Greeted message) {
    greetingCounter++;
    getContext().getLog().info(&quot;Greeting {} for {}&quot;, greetingCounter, message.whom);
    if (greetingCounter == max) {
      return Behaviors.stopped();
    } else {
      message.from.tell(new HelloWorld.Greet(message.whom, getContext().getSelf()));
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p><span class="group-scala">Note how this Actor manages the counter by changing the behavior for each <code>Greeted</code> reply rather than using any variables.</span><span class="group-java">Note how this Actor manages the counter with an instance variable.</span> No concurrency guards such as <code>synchronized</code> or <code>AtomicInteger</code> are needed since an actor instance processes one message at a time.</p>
<p>A third actor spawns the <code>Greeter</code> and the <code>HelloWorldBot</code> and starts the interaction between those.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L75-L99" target="_blank" title="Go to snippet source"></a><code class="language-scala">object HelloWorldMain {

  final case class SayHello(name: String)

  def apply(): Behavior[SayHello] =
    Behaviors.setup { context =&gt;
      val greeter = context.spawn(HelloWorld(), &quot;greeter&quot;)

      Behaviors.receiveMessage { message =&gt;
        val replyTo = context.spawn(HelloWorldBot(max = 3), message.name)
        greeter ! HelloWorld.Greet(message.name, replyTo)
        Behaviors.same
      }
    }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L109-L145" target="_blank" title="Go to snippet source"></a><code class="language-java">public class HelloWorldMain extends AbstractBehavior&lt;HelloWorldMain.SayHello&gt; {

  public static class SayHello {
    public final String name;

    public SayHello(String name) {
      this.name = name;
    }
  }

  public static Behavior&lt;SayHello&gt; create() {
    return Behaviors.setup(HelloWorldMain::new);
  }

  private final ActorRef&lt;HelloWorld.Greet&gt; greeter;

  private HelloWorldMain(ActorContext&lt;SayHello&gt; context) {
    super(context);
    greeter = context.spawn(HelloWorld.create(), &quot;greeter&quot;);
  }

  @Override
  public Receive&lt;SayHello&gt; createReceive() {
    return newReceiveBuilder().onMessage(SayHello.class, this::onStart).build();
  }

  private Behavior&lt;SayHello&gt; onStart(SayHello command) {
    ActorRef&lt;HelloWorld.Greeted&gt; replyTo =
        getContext().spawn(HelloWorldBot.create(3), command.name);
    greeter.tell(new HelloWorld.Greet(command.name, replyTo));
    return this;
  }
}</code></pre></dd>
</dl>
<p>Now we want to try out this Actor, so we must start an ActorSystem to host it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L246-L252" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>val system: ActorSystem[HelloWorldMain.SayHello] =
  ActorSystem(HelloWorldMain(), &quot;hello&quot;)

system ! HelloWorldMain.SayHello(&quot;World&quot;)
system ! HelloWorldMain.SayHello(&quot;Akka&quot;)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L200-L204" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem&lt;HelloWorldMain.SayHello&gt; system =
    ActorSystem.create(HelloWorldMain.create(), &quot;hello&quot;);

system.tell(new HelloWorldMain.SayHello(&quot;World&quot;));
system.tell(new HelloWorldMain.SayHello(&quot;Akka&quot;));</code></pre></dd>
</dl>
<p>We start an Actor system from the defined <code>HelloWorldMain</code> behavior and send two <code>SayHello</code> messages that will kick-off the interaction between two separate <code>HelloWorldBot</code> actors and the single <code>Greeter</code> actor.</p>
<p>An application normally consists of a single <code>ActorSystem</code>, running many actors, per JVM. </p>
<p>The console output may look like this:</p>
<pre><code>[INFO] [03/13/2018 15:50:05.814] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/greeter] Hello World!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/greeter] Hello Akka!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-2] [akka://hello/user/World] Greeting 1 for World
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/Akka] Greeting 1 for Akka
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello World!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello Akka!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/World] Greeting 2 for World
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello World!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/Akka] Greeting 2 for Akka
[INFO] [03/13/2018 15:50:05.816] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello Akka!
[INFO] [03/13/2018 15:50:05.816] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/World] Greeting 3 for World
[INFO] [03/13/2018 15:50:05.816] [hello-akka.actor.default-dispatcher-6] [akka://hello/user/Akka] Greeting 3 for Akka
</code></pre>
<p>You will also need to add a <a href="logging.html">logging dependency</a> to see that output when running.</p><div class="group-scala">
<h4><a href="#here-is-another-example-that-you-can-edit-and-run-in-the-browser-" name="here-is-another-example-that-you-can-edit-and-run-in-the-browser-" class="anchor"><span class="anchor-link"></span></a>Here is another example that you can edit and run in the browser:</h4>

        <div data-scalafiddle="true"    data-template="Akka"   data-minheight="400px"  data-layout="v75" >
          <pre class="prettyprint"><code class="language-scala">import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl.LoggerOps
import akka.actor.typed.{ ActorRef, ActorSystem, Behavior }

object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>
    println(s"Hello ${message.whom}!")
    message.replyTo ! Greeted(message.whom, context.self)
    Behaviors.same
  }
}

object HelloWorldBot {

  def apply(max: Int): Behavior[HelloWorld.Greeted] = {
    bot(0, max)
  }

  private def bot(greetingCounter: Int, max: Int): Behavior[HelloWorld.Greeted] =
    Behaviors.receive { (context, message) =>
      val n = greetingCounter + 1
      println(s"Greeting $n for ${message.whom}")
      if (n == max) {
        Behaviors.stopped
      } else {
        message.from ! HelloWorld.Greet(message.whom, context.self)
        bot(n, max)
      }
    }
}

object HelloWorldMain {

  final case class SayHello(name: String)

  def apply(): Behavior[SayHello] =
    Behaviors.setup { context =>
      val greeter = context.spawn(HelloWorld(), "greeter")

      Behaviors.receiveMessage { message =>
        val replyTo = context.spawn(HelloWorldBot(max = 3), message.name)
        greeter ! HelloWorld.Greet(message.name, replyTo)
        Behaviors.same
      }
    }

  def main(args: Array[String]): Unit = {
    val system: ActorSystem[HelloWorldMain.SayHello] =
      ActorSystem(HelloWorldMain(), "hello")

    system ! HelloWorldMain.SayHello("World")
    system ! HelloWorldMain.SayHello("Akka")
  }
}

// This is run by ScalaFiddle
HelloWorldMain.main(Array.empty)</code></pre>
        </div>
        <script defer="true" src="https://embed.scalafiddle.io/integration.js"></script>
        </div>
<h2><a href="#a-more-complex-example" name="a-more-complex-example" class="anchor"><span class="anchor-link"></span></a>A More Complex Example</h2>
<p>The next example is more realistic and demonstrates some important patterns:</p>
<ul>
  <li>Using <span class="group-scala">a sealed trait and case class/objects</span><span class="group-java">an interface and classes implementing that interface</span> to represent multiple messages an actor can receive</li>
  <li>Handle sessions by using child actors</li>
  <li>Handling state by changing behavior</li>
  <li>Using multiple actors to represent different parts of a protocol in a type safe way</li>
</ul>
<p><img src="./images/chat-room.png" alt="chat-room.png" /></p>
<h3><a href="#functional-style" name="functional-style" class="anchor"><span class="anchor-link"></span></a>Functional Style</h3>
<p>First we will show this example in a functional style, and then the same example is shown with an <a href="actors.html#object-oriented-style">Object-oriented style</a>. Which style you choose to use is a matter of taste and both styles can be mixed depending on which is best for a specific actor. Considerations for the choice is provided in the <a href="style-guide.html#functional-versus-object-oriented-style">Style Guide</a>.</p>
<p>Consider an Actor that runs a chat room: client Actors may connect by sending a message that contains their screen name and then they can post messages. The chat room Actor will disseminate all posted messages to all currently connected client Actors. The protocol definition could look like the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L135-L150" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait RoomCommand
final case class GetSession(screenName: String, replyTo: ActorRef[SessionEvent]) extends RoomCommand

sealed trait SessionEvent
final case class SessionGranted(handle: ActorRef[PostMessage]) extends SessionEvent
final case class SessionDenied(reason: String) extends SessionEvent
final case class MessagePosted(screenName: String, message: String) extends SessionEvent

trait SessionCommand
final case class PostMessage(message: String) extends SessionCommand
private final case class NotifyClient(message: MessagePosted) extends SessionCommand</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L216-L285" target="_blank" title="Go to snippet source"></a><code class="language-java">static interface RoomCommand {}

public static final class GetSession implements RoomCommand {
  public final String screenName;
  public final ActorRef&lt;SessionEvent&gt; replyTo;

  public GetSession(String screenName, ActorRef&lt;SessionEvent&gt; replyTo) {
    this.screenName = screenName;
    this.replyTo = replyTo;
  }
}

interface SessionEvent {}

public static final class SessionGranted implements SessionEvent {
  public final ActorRef&lt;PostMessage&gt; handle;

  public SessionGranted(ActorRef&lt;PostMessage&gt; handle) {
    this.handle = handle;
  }
}

public static final class SessionDenied implements SessionEvent {
  public final String reason;

  public SessionDenied(String reason) {
    this.reason = reason;
  }
}

public static final class MessagePosted implements SessionEvent {
  public final String screenName;
  public final String message;

  public MessagePosted(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

interface SessionCommand {}

public static final class PostMessage implements SessionCommand {
  public final String message;

  public PostMessage(String message) {
    this.message = message;
  }
}

private static final class NotifyClient implements SessionCommand {
  final MessagePosted message;

  NotifyClient(MessagePosted message) {
    this.message = message;
  }
}</code></pre></dd>
</dl>
<p>Initially the client Actors only get access to an <span class="group-scala"><code>ActorRef[GetSession]</code></span><span class="group-java"><code>ActorRef&lt;GetSession&gt;</code></span> which allows them to make the first step. Once a client’s session has been established it gets a <code>SessionGranted</code> message that contains a <code>handle</code> to unlock the next protocol step, posting messages. The <code>PostMessage</code> command will need to be sent to this particular address that represents the session that has been added to the chat room. The other aspect of a session is that the client has revealed its own address, via the <code>replyTo</code> argument, so that subsequent <code>MessagePosted</code> events can be sent to it.</p>
<p>This illustrates how Actors can express more than just the equivalent of method calls on Java objects. The declared message types and their contents describe a full protocol that can involve multiple Actors and that can evolve over multiple steps. Here&rsquo;s the implementation of the chat room protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L132-L188" target="_blank" title="Go to snippet source"></a><code class="language-scala">object ChatRoom {
  private final case class PublishSessionMessage(screenName: String, message: String) extends RoomCommand

  def apply(): Behavior[RoomCommand] =
    chatRoom(List.empty)

  private def chatRoom(sessions: List[ActorRef[SessionCommand]]): Behavior[RoomCommand] =
    Behaviors.receive { (context, message) =&gt;
      message match {
        case GetSession(screenName, client) =&gt;
          // create a child actor for further interaction with the client
          val ses = context.spawn(
            session(context.self, screenName, client),
            name = URLEncoder.encode(screenName, StandardCharsets.UTF_8.name))
          client ! SessionGranted(ses)
          chatRoom(ses :: sessions)
        case PublishSessionMessage(screenName, message) =&gt;
          val notification = NotifyClient(MessagePosted(screenName, message))
          sessions.foreach(_ ! notification)
          Behaviors.same
      }
    }

  private def session(
      room: ActorRef[PublishSessionMessage],
      screenName: String,
      client: ActorRef[SessionEvent]): Behavior[SessionCommand] =
    Behaviors.receiveMessage {
      case PostMessage(message) =&gt;
        // from client, publish to others via the room
        room ! PublishSessionMessage(screenName, message)
        Behaviors.same
      case NotifyClient(message) =&gt;
        // published from the room
        client ! message
        Behaviors.same
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L212-L353" target="_blank" title="Go to snippet source"></a><code class="language-java">public class ChatRoom {
  private static final class PublishSessionMessage implements RoomCommand {
    public final String screenName;
    public final String message;

    public PublishSessionMessage(String screenName, String message) {
      this.screenName = screenName;
      this.message = message;
    }
  }

  public static Behavior&lt;RoomCommand&gt; create() {
    return Behaviors.setup(
        ctx -&gt; new ChatRoom(ctx).chatRoom(new ArrayList&lt;ActorRef&lt;SessionCommand&gt;&gt;()));
  }

  private final ActorContext&lt;RoomCommand&gt; context;

  private ChatRoom(ActorContext&lt;RoomCommand&gt; context) {
    this.context = context;
  }

  private Behavior&lt;RoomCommand&gt; chatRoom(List&lt;ActorRef&lt;SessionCommand&gt;&gt; sessions) {
    return Behaviors.receive(RoomCommand.class)
        .onMessage(GetSession.class, getSession -&gt; onGetSession(sessions, getSession))
        .onMessage(PublishSessionMessage.class, pub -&gt; onPublishSessionMessage(sessions, pub))
        .build();
  }

  private Behavior&lt;RoomCommand&gt; onGetSession(
      List&lt;ActorRef&lt;SessionCommand&gt;&gt; sessions, GetSession getSession)
      throws UnsupportedEncodingException {
    ActorRef&lt;SessionEvent&gt; client = getSession.replyTo;
    ActorRef&lt;SessionCommand&gt; ses =
        context.spawn(
            Session.create(context.getSelf(), getSession.screenName, client),
            URLEncoder.encode(getSession.screenName, StandardCharsets.UTF_8.name()));
    // narrow to only expose PostMessage
    client.tell(new SessionGranted(ses.narrow()));
    List&lt;ActorRef&lt;SessionCommand&gt;&gt; newSessions = new ArrayList&lt;&gt;(sessions);
    newSessions.add(ses);
    return chatRoom(newSessions);
  }

  private Behavior&lt;RoomCommand&gt; onPublishSessionMessage(
      List&lt;ActorRef&lt;SessionCommand&gt;&gt; sessions, PublishSessionMessage pub) {
    NotifyClient notification =
        new NotifyClient((new MessagePosted(pub.screenName, pub.message)));
    sessions.forEach(s -&gt; s.tell(notification));
    return Behaviors.same();
  }

  static class Session {
    static Behavior&lt;ChatRoom.SessionCommand&gt; create(
        ActorRef&lt;RoomCommand&gt; room, String screenName, ActorRef&lt;SessionEvent&gt; client) {
      return Behaviors.receive(ChatRoom.SessionCommand.class)
          .onMessage(PostMessage.class, post -&gt; onPostMessage(room, screenName, post))
          .onMessage(NotifyClient.class, notification -&gt; onNotifyClient(client, notification))
          .build();
    }

    private static Behavior&lt;SessionCommand&gt; onPostMessage(
        ActorRef&lt;RoomCommand&gt; room, String screenName, PostMessage post) {
      // from client, publish to others via the room
      room.tell(new PublishSessionMessage(screenName, post.message));
      return Behaviors.same();
    }

    private static Behavior&lt;SessionCommand&gt; onNotifyClient(
        ActorRef&lt;SessionEvent&gt; client, NotifyClient notification) {
      // published from the room
      client.tell(notification.message);
      return Behaviors.same();
    }
  }
}</code></pre></dd>
</dl>
<p>The state is managed by changing behavior rather than using any variables.</p>
<p>When a new <code>GetSession</code> command comes in we add that client to the list that is in the returned behavior. Then we also need to create the session’s <code>ActorRef</code> that will be used to post messages. In this case we want to create a very simple Actor that repackages the <code>PostMessage</code> command into a <code>PublishSessionMessage</code> command which also includes the screen name.</p>
<p>The behavior that we declare here can handle both subtypes of <code>RoomCommand</code>. <code>GetSession</code> has been explained already and the <code>PublishSessionMessage</code> commands coming from the session Actors will trigger the dissemination of the contained chat room message to all connected clients. But we do not want to give the ability to send <code>PublishSessionMessage</code> commands to arbitrary clients, we reserve that right to the internal session actors we create—otherwise clients could pose as completely different screen names (imagine the <code>GetSession</code> protocol to include authentication information to further secure this). Therefore <code>PublishSessionMessage</code> has <code>private</code> visibility and can&rsquo;t be created outside the <code>ChatRoom</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>If we did not care about securing the correspondence between a session and a screen name then we could change the protocol such that <code>PostMessage</code> is removed and all clients just get an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> to send to. In this case no session actor would be needed and we could use <span class="group-scala"><code>context.self</code></span><span class="group-java"><code>context.getSelf()</code></span>. The type-checks work out in that case because <span class="group-scala"><code>ActorRef[-T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> is contravariant in its type parameter, meaning that we can use a <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> wherever an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> is needed—this makes sense because the former simply speaks more languages than the latter. The opposite would be problematic, so passing an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> where <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> is required will lead to a type error.</p>
<h4><a href="#trying-it-out" name="trying-it-out" class="anchor"><span class="anchor-link"></span></a>Trying it out</h4>
<p>In order to see this chat room in action we need to write a client Actor that can use it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L192-L212" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Gabbler {
  import ChatRoom._

  def apply(): Behavior[SessionEvent] =
    Behaviors.setup { context =&gt;
      Behaviors.receiveMessage {
        case SessionGranted(handle) =&gt;
          handle ! PostMessage(&quot;Hello World!&quot;)
          Behaviors.same
        case MessagePosted(screenName, message) =&gt;
          context.log.info2(&quot;message has been posted by &#39;{}&#39;: {}&quot;, screenName, message)
          Behaviors.stopped
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L357-L392" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Gabbler {
  public static Behavior&lt;ChatRoom.SessionEvent&gt; create() {
    return Behaviors.setup(ctx -&gt; new Gabbler(ctx).behavior());
  }

  private final ActorContext&lt;ChatRoom.SessionEvent&gt; context;

  private Gabbler(ActorContext&lt;ChatRoom.SessionEvent&gt; context) {
    this.context = context;
  }

  private Behavior&lt;ChatRoom.SessionEvent&gt; behavior() {
    return Behaviors.receive(ChatRoom.SessionEvent.class)
        .onMessage(ChatRoom.SessionDenied.class, this::onSessionDenied)
        .onMessage(ChatRoom.SessionGranted.class, this::onSessionGranted)
        .onMessage(ChatRoom.MessagePosted.class, this::onMessagePosted)
        .build();
  }

  private Behavior&lt;ChatRoom.SessionEvent&gt; onSessionDenied(ChatRoom.SessionDenied message) {
    context.getLog().info(&quot;cannot start chat room session: {}&quot;, message.reason);
    return Behaviors.stopped();
  }

  private Behavior&lt;ChatRoom.SessionEvent&gt; onSessionGranted(ChatRoom.SessionGranted message) {
    message.handle.tell(new ChatRoom.PostMessage(&quot;Hello World!&quot;));
    return Behaviors.same();
  }

  private Behavior&lt;ChatRoom.SessionEvent&gt; onMessagePosted(ChatRoom.MessagePosted message) {
    context
        .getLog()
        .info(&quot;message has been posted by &#39;{}&#39;: {}&quot;, message.screenName, message.message);
    return Behaviors.stopped();
  }
}</code></pre></dd>
</dl>
<p>From this behavior we can create an Actor that will accept a chat room session, post a message, wait to see it published, and then terminate. The last step requires the ability to change behavior, we need to transition from the normal running behavior into the terminated state. This is why here we do not return <code>same</code>, as above, but another special value <code>stopped</code>.</p><div class="group-scala">
<p>Since <code>SessionEvent</code> is a sealed trait the Scala compiler will warn us if we forget to handle one of the subtypes; in this case it reminded us that alternatively to <code>SessionGranted</code> we may also receive a <code>SessionDenied</code> event.</p></div>
<p>Now to try things out we must start both a chat room and a gabbler and of course we do this inside an Actor system. Since there can be only one user guardian we could either start the chat room from the gabbler (which we don’t want—it complicates its logic) or the gabbler from the chat room (which is nonsensical) or we start both of them from a third Actor—our only sensible choice:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L216-L234" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Main {
  def apply(): Behavior[NotUsed] =
    Behaviors.setup { context =&gt;
      val chatRoom = context.spawn(ChatRoom(), &quot;chatroom&quot;)
      val gabblerRef = context.spawn(Gabbler(), &quot;gabbler&quot;)
      context.watch(gabblerRef)
      chatRoom ! ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabblerRef)

      Behaviors.receiveSignal {
        case (_, Terminated(_)) =&gt;
          Behaviors.stopped
      }
    }

  def main(args: Array[String]): Unit = {
    ActorSystem(Main(), &quot;ChatRoomDemo&quot;)
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L396-L414" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Main {
  public static Behavior&lt;Void&gt; create() {
    return Behaviors.setup(
        context -&gt; {
          ActorRef&lt;ChatRoom.RoomCommand&gt; chatRoom = context.spawn(ChatRoom.create(), &quot;chatRoom&quot;);
          ActorRef&lt;ChatRoom.SessionEvent&gt; gabbler = context.spawn(Gabbler.create(), &quot;gabbler&quot;);
          context.watch(gabbler);
          chatRoom.tell(new ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabbler));

          return Behaviors.receive(Void.class)
              .onSignal(Terminated.class, sig -&gt; Behaviors.stopped())
              .build();
        });
  }

  public static void main(String[] args) {
    ActorSystem.create(Main.create(), &quot;ChatRoomDemo&quot;);
  }
}</code></pre></dd>
</dl>
<p>In good tradition we call the <code>Main</code> Actor what it is, it directly corresponds to the <code>main</code> method in a traditional Java application. This Actor will perform its job on its own accord, we do not need to send messages from the outside, so we declare it to be of type <span class="group-scala"><code>NotUsed</code></span><span class="group-java"><code>Void</code></span>. Actors receive not only external messages, they also are notified of certain system events, so-called Signals. In order to get access to those we choose to implement this particular one using the <code>receive</code> behavior decorator. The provided <code>onSignal</code> function will be invoked for signals (subclasses of <code>Signal</code>) or the <code>onMessage</code> function for user messages.</p>
<p>This particular <code>Main</code> Actor is created using <code>Behaviors.setup</code>, which is like a factory for a behavior. Creation of the behavior instance is deferred until the actor is started, as opposed to <code>Behaviors.receive</code> that creates the behavior instance immediately before the actor is running. The factory function in <code>setup</code> is passed the <code>ActorContext</code> as parameter and that can for example be used for spawning child actors. This <code>Main</code> Actor creates the chat room and the gabbler and the session between them is initiated, and when the gabbler is finished we will receive the <code>Terminated</code> event due to having called <code>context.watch</code> for it. This allows us to shut down the Actor system: when the <code>Main</code> Actor terminates there is nothing more to do.</p>
<p>Therefore after creating the Actor system with the <code>Main</code> Actor’s <code>Behavior</code> we can let the <code>main</code> method return, the <code>ActorSystem</code> will continue running and the JVM alive until the root actor stops.</p>
<h3><a href="#object-oriented-style" name="object-oriented-style" class="anchor"><span class="anchor-link"></span></a>Object-oriented style</h3>
<p>The above sample used the functional programming style where you pass a function to a factory which then constructs a behavior, for stateful actors this means passing immutable state around as parameters and switching to a new behavior whenever you need to act on a changed state. An alternative way to express the same is a more object oriented style where a concrete class for the actor behavior is defined and mutable state is kept inside of it as fields.</p>
<p>Which style you choose to use is a matter of taste and both styles can be mixed depending on which is best for a specific actor. Considerations for the choice is provided in the <a href="style-guide.html#functional-versus-object-oriented-style">Style Guide</a>.</p>
<h4><a href="#abstractbehavior-api" name="abstractbehavior-api" class="anchor"><span class="anchor-link"></span></a>AbstractBehavior API</h4>
<p>Defining a class based actor behavior starts with extending <span class="group-scala"><code>akka.actor.typed.scaladsl.AbstractBehavior[T]</code></span> <span class="group-java"><code>akka.actor.typed.javadsl.AbstractBehavior&lt;T&gt;</code></span> where <code>T</code> is the type of messages the behavior will accept.</p>
<p>Let&rsquo;s repeat the chat room sample from <a href="actors.html#a-more-complex-example">A more complex example above</a> but implemented using <code>AbstractBehavior</code>. The protocol for interacting with the actor looks the same:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L29-L44" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait RoomCommand
final case class GetSession(screenName: String, replyTo: ActorRef[SessionEvent]) extends RoomCommand

sealed trait SessionEvent
final case class SessionGranted(handle: ActorRef[PostMessage]) extends SessionEvent
final case class SessionDenied(reason: String) extends SessionEvent
final case class MessagePosted(screenName: String, message: String) extends SessionEvent

trait SessionCommand
final case class PostMessage(message: String) extends SessionCommand
private final case class NotifyClient(message: MessagePosted) extends SessionCommand</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L33-L102" target="_blank" title="Go to snippet source"></a><code class="language-java">static interface RoomCommand {}

public static final class GetSession implements RoomCommand {
  public final String screenName;
  public final ActorRef&lt;SessionEvent&gt; replyTo;

  public GetSession(String screenName, ActorRef&lt;SessionEvent&gt; replyTo) {
    this.screenName = screenName;
    this.replyTo = replyTo;
  }
}

static interface SessionEvent {}

public static final class SessionGranted implements SessionEvent {
  public final ActorRef&lt;PostMessage&gt; handle;

  public SessionGranted(ActorRef&lt;PostMessage&gt; handle) {
    this.handle = handle;
  }
}

public static final class SessionDenied implements SessionEvent {
  public final String reason;

  public SessionDenied(String reason) {
    this.reason = reason;
  }
}

public static final class MessagePosted implements SessionEvent {
  public final String screenName;
  public final String message;

  public MessagePosted(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

static interface SessionCommand {}

public static final class PostMessage implements SessionCommand {
  public final String message;

  public PostMessage(String message) {
    this.message = message;
  }
}

private static final class NotifyClient implements SessionCommand {
  final MessagePosted message;

  NotifyClient(MessagePosted message) {
    this.message = message;
  }
}</code></pre></dd>
</dl>
<p>Initially the client Actors only get access to an <span class="group-scala"><code>ActorRef[GetSession]</code></span><span class="group-java"><code>ActorRef&lt;GetSession&gt;</code></span> which allows them to make the first step. Once a client’s session has been established it gets a <code>SessionGranted</code> message that contains a <code>handle</code> to unlock the next protocol step, posting messages. The <code>PostMessage</code> command will need to be sent to this particular address that represents the session that has been added to the chat room. The other aspect of a session is that the client has revealed its own address, via the <code>replyTo</code> argument, so that subsequent <code>MessagePosted</code> events can be sent to it.</p>
<p>This illustrates how Actors can express more than just the equivalent of method calls on Java objects. The declared message types and their contents describe a full protocol that can involve multiple Actors and that can evolve over multiple steps. Here&rsquo;s the <code>AbstractBehavior</code> implementation of the chat room protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L26-L100" target="_blank" title="Go to snippet source"></a><code class="language-scala">object ChatRoom {
  private final case class PublishSessionMessage(screenName: String, message: String) extends RoomCommand

  def apply(): Behavior[RoomCommand] =
    Behaviors.setup(context =&gt; new ChatRoomBehavior(context))

  class ChatRoomBehavior(context: ActorContext[RoomCommand]) extends AbstractBehavior[RoomCommand](context) {
    private var sessions: List[ActorRef[SessionCommand]] = List.empty

    override def onMessage(message: RoomCommand): Behavior[RoomCommand] = {
      message match {
        case GetSession(screenName, client) =&gt;
          // create a child actor for further interaction with the client
          val ses = context.spawn(
            SessionBehavior(context.self, screenName, client),
            name = URLEncoder.encode(screenName, StandardCharsets.UTF_8.name))
          client ! SessionGranted(ses)
          sessions = ses :: sessions
          this
        case PublishSessionMessage(screenName, message) =&gt;
          val notification = NotifyClient(MessagePosted(screenName, message))
          sessions.foreach(_ ! notification)
          this
      }
    }
  }

  object SessionBehavior {
    def apply(
        room: ActorRef[PublishSessionMessage],
        screenName: String,
        client: ActorRef[SessionEvent]): Behavior[SessionCommand] =
      Behaviors.setup(ctx =&gt; new SessionBehavior(ctx, room, screenName, client))
  }

  private class SessionBehavior(
      context: ActorContext[SessionCommand],
      room: ActorRef[PublishSessionMessage],
      screenName: String,
      client: ActorRef[SessionEvent])
      extends AbstractBehavior[SessionCommand](context) {

    override def onMessage(msg: SessionCommand): Behavior[SessionCommand] = {
      msg match {
        case PostMessage(message) =&gt;
          // from client, publish to others via the room
          room ! PublishSessionMessage(screenName, message)
          Behaviors.same
        case NotifyClient(message) =&gt;
          // published from the room
          client ! message
          Behaviors.same
      }
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L30-L190" target="_blank" title="Go to snippet source"></a><code class="language-java">public class ChatRoom {
  private static final class PublishSessionMessage implements RoomCommand {
    public final String screenName;
    public final String message;

    public PublishSessionMessage(String screenName, String message) {
      this.screenName = screenName;
      this.message = message;
    }
  }

  public static Behavior&lt;RoomCommand&gt; create() {
    return Behaviors.setup(ChatRoomBehavior::new);
  }

  public static class ChatRoomBehavior extends AbstractBehavior&lt;RoomCommand&gt; {
    final List&lt;ActorRef&lt;SessionCommand&gt;&gt; sessions = new ArrayList&lt;&gt;();

    private ChatRoomBehavior(ActorContext&lt;RoomCommand&gt; context) {
      super(context);
    }

    @Override
    public Receive&lt;RoomCommand&gt; createReceive() {
      ReceiveBuilder&lt;RoomCommand&gt; builder = newReceiveBuilder();

      builder.onMessage(GetSession.class, this::onGetSession);
      builder.onMessage(PublishSessionMessage.class, this::onPublishSessionMessage);

      return builder.build();
    }

    private Behavior&lt;RoomCommand&gt; onGetSession(GetSession getSession)
        throws UnsupportedEncodingException {
      ActorRef&lt;SessionEvent&gt; client = getSession.replyTo;
      ActorRef&lt;SessionCommand&gt; ses =
          getContext()
              .spawn(
                  SessionBehavior.create(getContext().getSelf(), getSession.screenName, client),
                  URLEncoder.encode(getSession.screenName, StandardCharsets.UTF_8.name()));
      // narrow to only expose PostMessage
      client.tell(new SessionGranted(ses.narrow()));
      sessions.add(ses);
      return this;
    }

    private Behavior&lt;RoomCommand&gt; onPublishSessionMessage(PublishSessionMessage pub) {
      NotifyClient notification =
          new NotifyClient((new MessagePosted(pub.screenName, pub.message)));
      sessions.forEach(s -&gt; s.tell(notification));
      return this;
    }
  }

  static class SessionBehavior extends AbstractBehavior&lt;ChatRoom.SessionCommand&gt; {
    private final ActorRef&lt;RoomCommand&gt; room;
    private final String screenName;
    private final ActorRef&lt;SessionEvent&gt; client;

    public static Behavior&lt;ChatRoom.SessionCommand&gt; create(
        ActorRef&lt;RoomCommand&gt; room, String screenName, ActorRef&lt;SessionEvent&gt; client) {
      return Behaviors.setup(context -&gt; new SessionBehavior(context, room, screenName, client));
    }

    private SessionBehavior(
        ActorContext&lt;ChatRoom.SessionCommand&gt; context,
        ActorRef&lt;RoomCommand&gt; room,
        String screenName,
        ActorRef&lt;SessionEvent&gt; client) {
      super(context);
      this.room = room;
      this.screenName = screenName;
      this.client = client;
    }

    @Override
    public Receive&lt;SessionCommand&gt; createReceive() {
      return newReceiveBuilder()
          .onMessage(PostMessage.class, this::onPostMessage)
          .onMessage(NotifyClient.class, this::onNotifyClient)
          .build();
    }

    private Behavior&lt;SessionCommand&gt; onPostMessage(PostMessage post) {
      // from client, publish to others via the room
      room.tell(new PublishSessionMessage(screenName, post.message));
      return Behaviors.same();
    }

    private Behavior&lt;SessionCommand&gt; onNotifyClient(NotifyClient notification) {
      // published from the room
      client.tell(notification.message);
      return Behaviors.same();
    }
  }
}</code></pre></dd>
</dl>
<p>The state is managed through fields in the class, just like with a regular object oriented class. As the state is mutable, we never return a different behavior from the message logic, but can return the <code>AbstractBehavior</code> instance itself (<code>this</code>) as a behavior to use for processing the next message coming in. We could also return <code>Behavior.same</code> to achieve the same.</p>
<p><span class="group-java">In this sample we make separate statements for creating the behavior builder, but it also returns the builder itself from each step so a more fluent behavior definition style is also possible. What you should prefer depends on how big the set of messages the actor accepts is.</span></p>
<p>It is also possible to return a new different <code>AbstractBehavior</code>, for example to represent a different state in a finite state machine (FSM), or use one of the functional behavior factories to combine the object oriented with the functional style for different parts of the lifecycle of the same Actor behavior.</p>
<p>When a new <code>GetSession</code> command comes in we add that client to the list of current sessions. Then we also need to create the session’s <code>ActorRef</code> that will be used to post messages. In this case we want to create a very simple Actor that repackages the <code>PostMessage</code> command into a <code>PublishSessionMessage</code> command which also includes the screen name.</p>
<p>To implement the logic where we spawn a child for the session we need access to the <code>ActorContext</code>. This is injected as a constructor parameter upon creation of the behavior, note how we combine the <code>AbstractBehavior</code> with <code>Behaviors.setup</code> to do this in the <span class="group-scala"><code>apply</code></span><span class="group-java"><code>create</code></span> factory method.</p>
<p>The behavior that we declare here can handle both subtypes of <code>RoomCommand</code>. <code>GetSession</code> has been explained already and the <code>PublishSessionMessage</code> commands coming from the session Actors will trigger the dissemination of the contained chat room message to all connected clients. But we do not want to give the ability to send <code>PublishSessionMessage</code> commands to arbitrary clients, we reserve that right to the internal session actors we create—otherwise clients could pose as completely different screen names (imagine the <code>GetSession</code> protocol to include authentication information to further secure this). Therefore <code>PublishSessionMessage</code> has <code>private</code> visibility and can&rsquo;t be created outside the <code>ChatRoom</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>If we did not care about securing the correspondence between a session and a screen name then we could change the protocol such that <code>PostMessage</code> is removed and all clients just get an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> to send to. In this case no session actor would be needed and we could use <span class="group-scala"><code>context.self</code></span><span class="group-java"><code>context.getSelf()</code></span>. The type-checks work out in that case because <span class="group-scala"><code>ActorRef[-T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> is contravariant in its type parameter, meaning that we can use a <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> wherever an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> is needed—this makes sense because the former simply speaks more languages than the latter. The opposite would be problematic, so passing an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> where <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> is required will lead to a type error.</p>
<h4><a href="#try-it-out" name="try-it-out" class="anchor"><span class="anchor-link"></span></a>Try it out</h4>
<p>In order to see this chat room in action we need to write a client Actor that can use it <span class="group-scala">, for this stateless actor it doesn&rsquo;t make much sense to use the <code>AbstractBehavior</code> so let&rsquo;s just reuse the functional style gabbler from the sample above</span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L104-L120" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Gabbler {
  import ChatRoom._

  def apply(): Behavior[SessionEvent] =
    Behaviors.setup { context =&gt;
      Behaviors.receiveMessage {
        case SessionDenied(reason) =&gt;
          context.log.info(&quot;cannot start chat room session: {}&quot;, reason)
          Behaviors.stopped
        case SessionGranted(handle) =&gt;
          handle ! PostMessage(&quot;Hello World!&quot;)
          Behaviors.same
        case MessagePosted(screenName, message) =&gt;
          context.log.info2(&quot;message has been posted by &#39;{}&#39;: {}&quot;, screenName, message)
          Behaviors.stopped
      }
    }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L194-L229" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Gabbler extends AbstractBehavior&lt;ChatRoom.SessionEvent&gt; {
  public static Behavior&lt;ChatRoom.SessionEvent&gt; create() {
    return Behaviors.setup(Gabbler::new);
  }

  private Gabbler(ActorContext&lt;ChatRoom.SessionEvent&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;ChatRoom.SessionEvent&gt; createReceive() {
    ReceiveBuilder&lt;ChatRoom.SessionEvent&gt; builder = newReceiveBuilder();
    return builder
        .onMessage(ChatRoom.SessionDenied.class, this::onSessionDenied)
        .onMessage(ChatRoom.SessionGranted.class, this::onSessionGranted)
        .onMessage(ChatRoom.MessagePosted.class, this::onMessagePosted)
        .build();
  }

  private Behavior&lt;ChatRoom.SessionEvent&gt; onSessionDenied(ChatRoom.SessionDenied message) {
    getContext().getLog().info(&quot;cannot start chat room session: {}&quot;, message.reason);
    return Behaviors.stopped();
  }

  private Behavior&lt;ChatRoom.SessionEvent&gt; onSessionGranted(ChatRoom.SessionGranted message) {
    message.handle.tell(new ChatRoom.PostMessage(&quot;Hello World!&quot;));
    return Behaviors.same();
  }

  private Behavior&lt;ChatRoom.SessionEvent&gt; onMessagePosted(ChatRoom.MessagePosted message) {
    getContext()
        .getLog()
        .info(&quot;message has been posted by &#39;{}&#39;: {}&quot;, message.screenName, message.message);
    return Behaviors.stopped();
  }
}</code></pre></dd>
</dl>
<p>Now to try things out we must start both a chat room and a gabbler and of course we do this inside an Actor system. Since there can be only one user guardian we could either start the chat room from the gabbler (which we don’t want—it complicates its logic) or the gabbler from the chat room (which is nonsensical) or we start both of them from a third Actor—our only sensible choice:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L125-L143" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Main {
  def apply(): Behavior[NotUsed] =
    Behaviors.setup { context =&gt;
      val chatRoom = context.spawn(ChatRoom(), &quot;chatroom&quot;)
      val gabblerRef = context.spawn(Gabbler(), &quot;gabbler&quot;)
      context.watch(gabblerRef)
      chatRoom ! ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabblerRef)

      Behaviors.receiveSignal {
        case (_, Terminated(_)) =&gt;
          Behaviors.stopped
      }
    }

  def main(args: Array[String]): Unit = {
    ActorSystem(Main(), &quot;ChatRoomDemo&quot;)
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/akka/akka/tree/v2.6.7/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L233-L251" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Main {
  public static Behavior&lt;Void&gt; create() {
    return Behaviors.setup(
        context -&gt; {
          ActorRef&lt;ChatRoom.RoomCommand&gt; chatRoom = context.spawn(ChatRoom.create(), &quot;chatRoom&quot;);
          ActorRef&lt;ChatRoom.SessionEvent&gt; gabbler = context.spawn(Gabbler.create(), &quot;gabbler&quot;);
          context.watch(gabbler);
          chatRoom.tell(new ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabbler));

          return Behaviors.receive(Void.class)
              .onSignal(Terminated.class, sig -&gt; Behaviors.stopped())
              .build();
        });
  }

  public static void main(String[] args) {
    ActorSystem.create(Main.create(), &quot;ChatRoomDemo&quot;);
  }
}</code></pre></dd>
</dl>
<p>In good tradition we call the <code>Main</code> Actor what it is, it directly corresponds to the <code>main</code> method in a traditional Java application. This Actor will perform its job on its own accord, we do not need to send messages from the outside, so we declare it to be of type <span class="group-scala"><code>NotUsed</code></span><span class="group-java"><code>Void</code></span>. Actors receive not only external messages, they also are notified of certain system events, so-called Signals. In order to get access to those we choose to implement this particular one using the <code>receive</code> behavior decorator. The provided <code>onSignal</code> function will be invoked for signals (subclasses of <code>Signal</code>) or the <code>onMessage</code> function for user messages.</p>
<p>This particular <code>Main</code> Actor is created using <code>Behaviors.setup</code>, which is like a factory for a behavior. Creation of the behavior instance is deferred until the actor is started, as opposed to <code>Behaviors.receive</code> that creates the behavior instance immediately before the actor is running. The factory function in <code>setup</code> is passed the <code>ActorContext</code> as parameter and that can for example be used for spawning child actors. This <code>Main</code> Actor creates the chat room and the gabbler and the session between them is initiated, and when the gabbler is finished we will receive the <code>Terminated</code> event due to having called <code>context.watch</code> for it. This allows us to shut down the Actor system: when the <code>Main</code> Actor terminates there is nothing more to do.</p>
<p>Therefore after creating the Actor system with the <code>Main</code> Actor’s <code>Behavior</code> we can let the <code>main</code> method return, the <code>ActorSystem</code> will continue running and the JVM alive until the root actor stops.</p>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/index.html"><i class="icon-prev"></i> <span class="link-prev">Actors</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/actor-lifecycle.html">Actor lifecycle <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/akka/akka/tree/v2.6.7/akka-docs/src/main/paradox/typed/actors.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2020 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> |
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> |
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> |
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> |
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> |
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>

</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
