<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Part 2: The Device Actor &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/guide/tutorial_2.html"/>
<script type="text/javascript" src="../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../css/page.css"/>
<link rel="shortcut icon" href="../../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
<link rel="manifest" href="../../images/manifest.json">
<meta name="msapplication-TileImage" content="../../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../java/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.2
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../java/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../java/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../../java/guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../../java/guide/actors-intro.html" class="page">What problems does the actor model solve?</a></li>
    <li><a href="../../java/guide/modules.html" class="page">Akka Libraries and Modules</a></li>
    <li><a href="../../java/guide/quickstart.html" class="page">Quickstart</a></li>
    <li><a href="../../java/guide/tutorial_1.html" class="page">Part 1: Top-level Architecture</a></li>
    <li><a href="../../java/guide/tutorial_2.html#part-2-the-device-actor" class="active page">Part 2: The Device Actor</a>
    <ul>
      <li><a href="../../java/guide/tutorial_2.html#the-query-protocol" class="header">The Query Protocol</a></li>
      <li><a href="../../java/guide/tutorial_2.html#message-ordering-delivery-guarantees" class="header">Message Ordering, Delivery Guarantees</a></li>
      <li><a href="../../java/guide/tutorial_2.html#the-write-protocol" class="header">The Write Protocol</a></li>
      <li><a href="../../java/guide/tutorial_2.html#what-is-next-" class="header">What is Next?</a></li>
    </ul></li>
    <li><a href="../../java/guide/tutorial_3.html" class="page">Part 3: Device Groups and Manager</a></li>
    <li><a href="../../java/guide/tutorial_4.html" class="page">Part 4: Querying a Group of Devices</a></li>
  </ul></li>
  <li><a href="../../java/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../java/index-actors.html" class="page">Actors</a></li>
  <li><a href="../../java/index-network.html" class="page">Networking</a></li>
  <li><a href="../../java/stream/index.html" class="page">Streams</a></li>
  <li><a href="../../java/index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../java/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../java/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../java/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../java/scala-compat.html" class="page">Java 8 and Scala Compatibility</a></li>
  <li><a href="../../java/project/index.html" class="page">Project Information</a></li>
  <li><a href="../../java/additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../java/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.2
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../java/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../java/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../../java/guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../../java/guide/actors-intro.html" class="page">What problems does the actor model solve?</a></li>
    <li><a href="../../java/guide/modules.html" class="page">Akka Libraries and Modules</a></li>
    <li><a href="../../java/guide/quickstart.html" class="page">Quickstart</a></li>
    <li><a href="../../java/guide/tutorial_1.html" class="page">Part 1: Top-level Architecture</a></li>
    <li><a href="../../java/guide/tutorial_2.html#part-2-the-device-actor" class="active page">Part 2: The Device Actor</a>
    <ul>
      <li><a href="../../java/guide/tutorial_2.html#the-query-protocol" class="header">The Query Protocol</a></li>
      <li><a href="../../java/guide/tutorial_2.html#message-ordering-delivery-guarantees" class="header">Message Ordering, Delivery Guarantees</a></li>
      <li><a href="../../java/guide/tutorial_2.html#the-write-protocol" class="header">The Write Protocol</a></li>
      <li><a href="../../java/guide/tutorial_2.html#what-is-next-" class="header">What is Next?</a></li>
    </ul></li>
    <li><a href="../../java/guide/tutorial_3.html" class="page">Part 3: Device Groups and Manager</a></li>
    <li><a href="../../java/guide/tutorial_4.html" class="page">Part 4: Querying a Group of Devices</a></li>
  </ul></li>
  <li><a href="../../java/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../java/index-actors.html" class="page">Actors</a></li>
  <li><a href="../../java/index-network.html" class="page">Networking</a></li>
  <li><a href="../../java/stream/index.html" class="page">Streams</a></li>
  <li><a href="../../java/index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../java/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../java/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../java/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../java/scala-compat.html" class="page">Java 8 and Scala Compatibility</a></li>
  <li><a href="../../java/project/index.html" class="page">Project Information</a></li>
  <li><a href="../../java/additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#part-2-the-device-actor" name="part-2-the-device-actor" class="anchor"><span class="anchor-link"></span></a>Part 2: The Device Actor</h1>
<p>In part 1 we explained how to view actor systems <em>in the large</em>, i.e. how components should be represented, how actors should be arranged in the hierarchy. In this part, we will look at actors <em>in the small</em> by implementing an actor with the most common conversational patterns.</p>
<p>In particular, leaving the components aside for a while, we will implement an actor that represents a device. The tasks of this actor will be rather simple:</p>
<ul>
  <li>Collect temperature measurements</li>
  <li>Report the last measured temperature if asked</li>
</ul>
<p>When working with objects we usually design our API as <em>interfaces</em>, which are basically a collection of abstract methods to be filled out by the actual implementation. In the world of actors, the counterpart of interfaces is protocols. While it is not possible to formalize general protocols in the programming language, we can formalize its most basic elements: the messages.</p>
<h2><a href="#the-query-protocol" name="the-query-protocol" class="anchor"><span class="anchor-link"></span></a>The Query Protocol</h2>
<p>Just because a device have been started it does not mean that it has immediately a temperature measurement. Hence, we need to account for the case where a temperature is not present in our protocol. This, fortunately, means that we can test the query part of the actor without the write part present, as it can simply report an empty result.</p>
<p>The protocol for obtaining the current temperature from the device actor is rather simple:</p>
<ol>
  <li>Wait for a request for the current temperature.</li>
  <li>Respond to the request with a reply containing the current temperature or an indication that it is not yet available.</li>
</ol>
<p>We need two messages, one for the request, and one for the reply. A first attempt could look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">final case object ReadTemperature
final case class RespondTemperature(value: Option[Double])</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static final class ReadTemperature {
}

public static final class RespondTemperature {
  final Optional&lt;Double&gt; value;

  public RespondTemperature(Optional&lt;Double&gt; value) {
    this.value = value;
  }
}</code></pre></dd>
</dl>
<p>This is a fine approach, but it limits the flexibility of the protocol. To understand why we need to talk about message ordering and message delivery guarantees in general.</p>
<h2><a href="#message-ordering-delivery-guarantees" name="message-ordering-delivery-guarantees" class="anchor"><span class="anchor-link"></span></a>Message Ordering, Delivery Guarantees</h2>
<p>In order to give some context to the discussion below, consider an application which spans multiple network hosts. The basic mechanism for communication is the same whether sending to an actor on the local JVM or to a remote actor, but of course, there will be observable differences in the latency of delivery (possibly also depending on the bandwidth of the network link and the message size) and the reliability. In the case of a remote message send there are more steps involved which means that more can go wrong. Another aspect is that a local send will just pass a reference to the message inside the same JVM, without any restrictions on the underlying object which is sent, whereas a remote transport will place a limit on the message size.</p>
<p>It is also important to keep in mind, that while sending inside the same JVM is significantly more reliable, if an actor fails due to a programmer error while processing the message, the effect is basically the same as if a remote, network request fails due to the remote host crashing while processing the message. Even though in both cases the service is recovered after a while (the actor is restarted by its supervisor, the host is restarted by an operator or by a monitoring system) individual requests are lost during the crash. <strong>Writing your actors such that every message could possibly be lost is the safe, pessimistic bet.</strong></p>
<p>These are the rules in Akka for message sends:</p>
<ul>
  <li>At-most-once delivery, i.e. no guaranteed delivery.</li>
  <li>Message ordering is maintained per sender, receiver pair.</li>
</ul>
<h3><a href="#what-does-mean-" name="what-does-mean-" class="anchor"><span class="anchor-link"></span></a>What Does &ldquo;at-most-once&rdquo; Mean?</h3>
<p>When it comes to describing the semantics of a delivery mechanism, there are three basic categories:</p>
<ul>
  <li><strong>At-most-once delivery</strong> means that for each message handed to the mechanism, that message is delivered zero or  one time; in more casual terms it means that messages may be lost, but never duplicated.</li>
  <li><strong>At-least-once delivery</strong> means that for each message handed to the mechanism potentially multiple attempts are made  at delivering it, such that at least one succeeds; again, in more casual terms this means that messages may be duplicated but not lost.</li>
  <li><strong>Exactly-once delivery</strong> means that for each message handed to the mechanism exactly one delivery is made to  the recipient; the message can neither be lost nor duplicated.</li>
</ul>
<p>The first one is the cheapest, highest performance, least implementation overhead because it can be done in a fire-and-forget fashion without keeping the state at the sending end or in the transport mechanism. The second one requires retries to counter transport losses, which means keeping the state at the sending end and having an acknowledgment mechanism at the receiving end. The third is most expensive, and has consequently worst performance: in addition to the second, it requires the state to be kept at the receiving end in order to filter out duplicate deliveries.</p>
<h3><a href="#why-no-guaranteed-delivery-" name="why-no-guaranteed-delivery-" class="anchor"><span class="anchor-link"></span></a>Why No Guaranteed Delivery?</h3>
<p>At the core of the problem lies the question what exactly this guarantee shall mean, i.e. at which point does the delivery considered to be guaranteed:</p>
<ol>
  <li>When the message is sent out on the network?</li>
  <li>When the message is received by the other host?</li>
  <li>When the message is put into the target actor&rsquo;s mailbox?</li>
  <li>When the message is starting to be processed by the target actor?</li>
  <li>When the message is processed successfully by the target actor?</li>
</ol>
<p>Most frameworks/protocols claiming guaranteed delivery actually provide something similar to point 4 and 5. While this sounds fair, <strong>is this actually useful?</strong> To understand the implications, consider a simple, practical example: a user attempts to place an order and we only want to claim that it has successfully processed once it is actually on disk in the database containing orders.</p>
<p>If we rely on the guarantees of such system it will report success as soon as the order has been submitted to the internal API that has the responsibility to validate it, process it and put it into the database. Unfortunately, immediately after the API has been invoked the following may happen:</p>
<ul>
  <li>The host can immediately crash.</li>
  <li>Deserialization can fail.</li>
  <li>Validation can fail.</li>
  <li>The database might be unavailable.</li>
  <li>A programming error might occur.</li>
</ul>
<p>The problem is that the <strong>guarantee of delivery</strong> does not translate to the <strong>domain level guarantee</strong>. We only want to report success once the order has been actually fully processed and persisted. <strong>The only entity that can report success is the application itself, since only it has any understanding of the domain guarantees required. No generalized framework can figure out the specifics of a particular domain and what is considered a success in that domain</strong>. In this particular example, we only want to signal success after a successful database write, where the database acknowledged that the order is now safely stored. <strong>For these reasons Akka lifts the responsibilities of guarantees to the application itself, i.e. you have to implement them yourself. On the other hand, you are in full control of the guarantees that you want to provide</strong>.</p>
<h3><a href="#message-ordering" name="message-ordering" class="anchor"><span class="anchor-link"></span></a>Message Ordering</h3>
<p>The rule is that for a given pair of actors, messages sent directly from the first to the second will not be received out-of-order. The word directly emphasizes that this guarantee only applies when sending with the tell operator directly to the final destination, but not when employing mediators.</p>
<p>If:</p>
<ul>
  <li>Actor <code>A1</code> sends messages <code>M1</code>, <code>M2</code>, <code>M3</code> to <code>A2</code>.</li>
  <li>Actor <code>A3</code> sends messages <code>M4</code>, <code>M5</code>, <code>M6</code> to <code>A2</code>.</li>
</ul>
<p>This means that:</p>
<ul>
  <li>If <code>M1</code> is delivered it must be delivered before <code>M2</code> and <code>M3</code>.</li>
  <li>If <code>M2</code> is delivered it must be delivered before <code>M3</code>.</li>
  <li>If <code>M4</code> is delivered it must be delivered before <code>M5</code> and <code>M6</code>.</li>
  <li>If <code>M5</code> is delivered it must be delivered before <code>M6</code>.</li>
  <li><code>A2</code> can see messages from <code>A1</code> interleaved with messages from <code>A3</code>.</li>
  <li>Since there is no guaranteed delivery, any of the messages may be dropped, i.e. not arrive at <code>A2</code>.</li>
</ul>
<p>For the full details on delivery guarantees please refer to the <a href="https://doc.akka.io/docs/akka/current/general/message-delivery-reliability.html">reference page</a>.</p>
<h3><a href="#revisiting-the-query-protocol" name="revisiting-the-query-protocol" class="anchor"><span class="anchor-link"></span></a>Revisiting the Query Protocol</h3>
<p>There is nothing wrong with our first query protocol but it limits our flexibility. If we want to implement resends in the actor that queries our device actor (because of timed out requests) or want to query multiple actors it can be helpful to put an additional query ID field in the message which helps us correlate requests with responses.</p>
<p>Hence, we add one more field to our messages, so that an ID can be provided by the requester:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">final case class ReadTemperature(requestId: Long)
final case class RespondTemperature(requestId: Long, value: Option[Double])</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static final class ReadTemperature {
  long requestId;

  public ReadTemperature(long requestId) {
    this.requestId = requestId;
  }
}

public static final class RespondTemperature {
  long requestId;
  Optional&lt;Double&gt; value;

  public RespondTemperature(long requestId, Optional&lt;Double&gt; value) {
    this.requestId = requestId;
    this.value = value;
  }
}</code></pre></dd>
</dl>
<p>Our device actor has the responsibility to use the same ID for the response of a given query. Now we can sketch our device actor:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import akka.actor.{ Actor, ActorLogging, Props }

object Device {
  def props(groupId: String, deviceId: String): Props = Props(new Device(groupId, deviceId))

  final case class ReadTemperature(requestId: Long)
  final case class RespondTemperature(requestId: Long, value: Option[Double])
}

class Device(groupId: String, deviceId: String) extends Actor with ActorLogging {
  var lastTemperatureReading: Option[Double] = None

  override def preStart(): Unit = log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId)
  override def postStop(): Unit = log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId)

  override def receive: Receive = {
    case ReadTemperature(id) =&gt;
      sender() ! RespondTemperature(id, lastTemperatureReading)
  }

}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>import java.util.Optional;

import akka.actor.AbstractActor;
import akka.actor.Props;
import akka.event.Logging;
import akka.event.LoggingAdapter;

class Device extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  final String deviceId;

  public Device(String groupId, String deviceId) {
    this.groupId = groupId;
    this.deviceId = deviceId;
  }

  public static Props props(String groupId, String deviceId) {
    return Props.create(Device.class, groupId, deviceId);
  }

  public static final class ReadTemperature {
    long requestId;

    public ReadTemperature(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class RespondTemperature {
    long requestId;
    Optional&lt;Double&gt; value;

    public RespondTemperature(long requestId, Optional&lt;Double&gt; value) {
      this.requestId = requestId;
      this.value = value;
    }
  }

  Optional&lt;Double&gt; lastTemperatureReading = Optional.empty();

  @Override
  public void preStart() {
    log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId);
  }

  @Override
  public void postStop() {
    log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
            .match(ReadTemperature.class, r -&gt; {
              getSender().tell(new RespondTemperature(r.requestId, lastTemperatureReading), getSelf());
            })
            .build();
  }

}
</code></pre></dd>
</dl>
<p>We maintain the current temperature, initially set to <span class="group-scala"><code>None</code></span> <span class="group-java"><code>Optional.empty()</code></span>, and we simply report it back if queried. We also added fields for the ID of the device and the group it belongs to, which we will use later.</p>
<p>We can already write a simple test for this functionality <span class="group-scala">(we use ScalaTest but any other test framework can be used with the Akka Testkit)</span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">&quot;reply with empty reading if no temperature is known&quot; in {
  val probe = TestProbe()
  val deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;))

  deviceActor.tell(Device.ReadTemperature(requestId = 42), probe.ref)
  val response = probe.expectMsgType[Device.RespondTemperature]
  response.requestId should ===(42)
  response.value should ===(None)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Test
public void testReplyWithEmptyReadingIfNoTemperatureIsKnown() {
  TestKit probe = new TestKit(system);
  ActorRef deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;));
  deviceActor.tell(new Device.ReadTemperature(42L), probe.getRef());
  Device.RespondTemperature response = probe.expectMsgClass(Device.RespondTemperature.class);
  assertEquals(42L, response.requestId);
  assertEquals(Optional.empty(), response.value);
}</code></pre></dd>
</dl>
<h2><a href="#the-write-protocol" name="the-write-protocol" class="anchor"><span class="anchor-link"></span></a>The Write Protocol</h2>
<p>As a first attempt, we could model recording the current temperature in the device actor as a single message:</p>
<ul>
  <li>When a temperature record request is received, update the <code>currentTemperature</code> field.</li>
</ul>
<p>Such a message could possibly look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">final case class RecordTemperature(value: Double)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">public static final class RecordTemperature {
  final double value;

  public RecordTemperature(double value) {
    this.value = value;
  }
}</code></pre></dd>
</dl>
<p>The problem with this approach is that the sender of the record temperature message can never be sure if the message was processed or not. We have seen that Akka does not guarantee delivery of these messages and leaves it to the application to provide success notifications. In our case, we would like to send an acknowledgment to the sender once we have updated our last temperature recording, e.g. <span class="group-scala"><code>final case class TemperatureRecorded(requestId: Long)</code></span> <span class="group-java"><code>TemperatureRecorded</code></span>. Just like in the case of temperature queries and responses, it is a good idea to include an ID field to provide maximum flexibility.</p>
<p>Putting read and write protocol together, the device actor will look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">import akka.actor.{ Actor, ActorLogging, Props }

object Device {
  def props(groupId: String, deviceId: String): Props = Props(new Device(groupId, deviceId))

  final case class RecordTemperature(requestId: Long, value: Double)
  final case class TemperatureRecorded(requestId: Long)

  final case class ReadTemperature(requestId: Long)
  final case class RespondTemperature(requestId: Long, value: Option[Double])
}

class Device(groupId: String, deviceId: String) extends Actor with ActorLogging {
  import Device._
  var lastTemperatureReading: Option[Double] = None

  override def preStart(): Unit = log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId)
  override def postStop(): Unit = log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId)

  override def receive: Receive = {
    case RecordTemperature(id, value) =&gt;
      log.info(&quot;Recorded temperature reading {} with {}&quot;, value, id)
      lastTemperatureReading = Some(value)
      sender() ! TemperatureRecorded(id)

    case ReadTemperature(id) =&gt;
      sender() ! RespondTemperature(id, lastTemperatureReading)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>import java.util.Optional;

import akka.actor.AbstractActor;
import akka.actor.AbstractActor.Receive;
import akka.actor.Props;
import akka.event.Logging;
import akka.event.LoggingAdapter;

public class Device extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  final String deviceId;

  public Device(String groupId, String deviceId) {
    this.groupId = groupId;
    this.deviceId = deviceId;
  }

  public static Props props(String groupId, String deviceId) {
    return Props.create(Device.class, groupId, deviceId);
  }

  public static final class RecordTemperature {
    final long requestId;
    final double value;

    public RecordTemperature(long requestId, double value) {
      this.requestId = requestId;
      this.value = value;
    }
  }

  public static final class TemperatureRecorded {
    final long requestId;

    public TemperatureRecorded(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class ReadTemperature {
    final long requestId;

    public ReadTemperature(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class RespondTemperature {
    final long requestId;
    final Optional&lt;Double&gt; value;

    public RespondTemperature(long requestId, Optional&lt;Double&gt; value) {
      this.requestId = requestId;
      this.value = value;
    }
  }

  Optional&lt;Double&gt; lastTemperatureReading = Optional.empty();

  @Override
  public void preStart() {
    log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId);
  }

  @Override
  public void postStop() {
    log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
            .match(RecordTemperature.class, r -&gt; {
              log.info(&quot;Recorded temperature reading {} with {}&quot;, r.value, r.requestId);
              lastTemperatureReading = Optional.of(r.value);
              getSender().tell(new TemperatureRecorded(r.requestId), getSelf());
            })
            .match(ReadTemperature.class, r -&gt; {
              getSender().tell(new RespondTemperature(r.requestId, lastTemperatureReading), getSelf());
            })
            .build();
  }
}</code></pre></dd>
</dl>
<p>We are also responsible for writing a new test case now, exercising both the read/query and write/record functionality together:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">&quot;reply with latest temperature reading&quot; in {
  val probe = TestProbe()
  val deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;))

  deviceActor.tell(Device.RecordTemperature(requestId = 1, 24.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 1))

  deviceActor.tell(Device.ReadTemperature(requestId = 2), probe.ref)
  val response1 = probe.expectMsgType[Device.RespondTemperature]
  response1.requestId should ===(2)
  response1.value should ===(Some(24.0))

  deviceActor.tell(Device.RecordTemperature(requestId = 3, 55.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 3))

  deviceActor.tell(Device.ReadTemperature(requestId = 4), probe.ref)
  val response2 = probe.expectMsgType[Device.RespondTemperature]
  response2.requestId should ===(4)
  response2.value should ===(Some(55.0))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">@Test
public void testReplyWithLatestTemperatureReading() {
  TestKit probe = new TestKit(system);
  ActorRef deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;));

  deviceActor.tell(new Device.RecordTemperature(1L, 24.0), probe.getRef());
  assertEquals(1L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);

  deviceActor.tell(new Device.ReadTemperature(2L), probe.getRef());
  Device.RespondTemperature response1 = probe.expectMsgClass(Device.RespondTemperature.class);
  assertEquals(2L, response1.requestId);
  assertEquals(Optional.of(24.0), response1.value);

  deviceActor.tell(new Device.RecordTemperature(3L, 55.0), probe.getRef());
  assertEquals(3L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);

  deviceActor.tell(new Device.ReadTemperature(4L), probe.getRef());
  Device.RespondTemperature response2 = probe.expectMsgClass(Device.RespondTemperature.class);
  assertEquals(4L, response2.requestId);
  assertEquals(Optional.of(55.0), response2.value);
}</code></pre></dd>
</dl>
<h2><a href="#what-is-next-" name="what-is-next-" class="anchor"><span class="anchor-link"></span></a>What is Next?</h2>
<p>So far, we have started designing our overall architecture, and we wrote our first actor directly corresponding to the domain. We now have to create the component that is responsible for maintaining groups of devices and the device actors themselves.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../java/guide/tutorial_1.html"><i class="icon-prev"></i> <span class="link-prev">Part 1: Top-level Architecture</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../java/guide/tutorial_3.html">Part 3: Device Groups and Manager <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="http://github.com/akka/akka/tree/master/akka-docs/src/main/paradox/java/guide/tutorial_2.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../js/groups.js"></script>
<script type="text/javascript" src="../../js/page.js"></script>
<script type="text/javascript" src="../../js/magellan.js"></script>

<style type="text/css">@import "../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
