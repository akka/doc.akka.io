<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Futures &bull; Akka Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala."/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/current/futures.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!--Google Analytics-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<!--Google Analytics & Marketo-->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702');
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>

</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../java/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.2
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../java/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../java/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../java/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../java/index-actors.html" class="page">Actors</a></li>
  <li><a href="../java/index-network.html" class="page">Networking</a></li>
  <li><a href="../java/stream/index.html" class="page">Streams</a></li>
  <li><a href="../java/index-futures.html" class="page">Futures and Agents</a>
  <ul>
    <li><a href="../java/futures.html#futures" class="active page">Futures</a>
    <ul>
      <li><a href="../java/futures.html#introduction" class="header">Introduction</a></li>
      <li><a href="../java/futures.html#execution-contexts" class="header">Execution Contexts</a></li>
      <li><a href="../java/futures.html#use-with-actors" class="header">Use with Actors</a></li>
      <li><a href="../java/futures.html#use-directly" class="header">Use Directly</a></li>
      <li><a href="../java/futures.html#functional-futures" class="header">Functional Futures</a></li>
      <li><a href="../java/futures.html#callbacks" class="header">Callbacks</a></li>
      <li><a href="../java/futures.html#ordering" class="header">Ordering</a></li>
      <li><a href="../java/futures.html#auxiliary-methods" class="header">Auxiliary methods</a></li>
      <li><a href="../java/futures.html#exceptions" class="header">Exceptions</a></li>
      <li><a href="../java/futures.html#after" class="header">After</a></li>
      <li><a href="../java/futures.html#java-8-completionstage-and-completablefuture" class="header">Java 8, CompletionStage and CompletableFuture</a></li>
    </ul></li>
    <li><a href="../java/agents.html" class="page">Agents</a></li>
  </ul></li>
  <li><a href="../java/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../java/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../java/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../java/scala-compat.html" class="page">Java 8 and Scala Compatibility</a></li>
  <li><a href="../java/project/index.html" class="page">Project Information</a></li>
  <li><a href="../java/additional/index.html" class="page">Additional Information</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../java/index.html">Akka Documentation</a></h1>
</div>
<div class="nav-header-version">
Version 2.5.2
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Languages"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../java/security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../java/guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../java/general/index.html" class="page">General Concepts</a></li>
  <li><a href="../java/index-actors.html" class="page">Actors</a></li>
  <li><a href="../java/index-network.html" class="page">Networking</a></li>
  <li><a href="../java/stream/index.html" class="page">Streams</a></li>
  <li><a href="../java/index-futures.html" class="page">Futures and Agents</a>
  <ul>
    <li><a href="../java/futures.html#futures" class="active page">Futures</a>
    <ul>
      <li><a href="../java/futures.html#introduction" class="header">Introduction</a></li>
      <li><a href="../java/futures.html#execution-contexts" class="header">Execution Contexts</a></li>
      <li><a href="../java/futures.html#use-with-actors" class="header">Use with Actors</a></li>
      <li><a href="../java/futures.html#use-directly" class="header">Use Directly</a></li>
      <li><a href="../java/futures.html#functional-futures" class="header">Functional Futures</a></li>
      <li><a href="../java/futures.html#callbacks" class="header">Callbacks</a></li>
      <li><a href="../java/futures.html#ordering" class="header">Ordering</a></li>
      <li><a href="../java/futures.html#auxiliary-methods" class="header">Auxiliary methods</a></li>
      <li><a href="../java/futures.html#exceptions" class="header">Exceptions</a></li>
      <li><a href="../java/futures.html#after" class="header">After</a></li>
      <li><a href="../java/futures.html#java-8-completionstage-and-completablefuture" class="header">Java 8, CompletionStage and CompletableFuture</a></li>
    </ul></li>
    <li><a href="../java/agents.html" class="page">Agents</a></li>
  </ul></li>
  <li><a href="../java/index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../java/common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../java/howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../java/scala-compat.html" class="page">Java 8 and Scala Compatibility</a></li>
  <li><a href="../java/project/index.html" class="page">Project Information</a></li>
  <li><a href="../java/additional/index.html" class="page">Additional Information</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#futures" name="futures" class="anchor"><span class="anchor-link"></span></a>Futures</h1>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>In the Scala Standard Library, a <a href="http://en.wikipedia.org/wiki/Futures_and_promises">Future</a> is a data structure used to retrieve the result of some concurrent operation. This result can be accessed synchronously (blocking) or asynchronously (non-blocking). To be able to use this from Java, Akka provides a java friendly interface in <code>akka.dispatch.Futures</code>.</p>
<p>See also <a href="scala-compat.html">Java 8 and Scala Compatibility</a> for Java compatibility.</p>
<h2><a href="#execution-contexts" name="execution-contexts" class="anchor"><span class="anchor-link"></span></a>Execution Contexts</h2>
<p>In order to execute callbacks and operations, Futures need something called an <code>ExecutionContext</code>, which is very similar to a <code>java.util.concurrent.Executor</code>. if you have an <code>ActorSystem</code> in scope, it will use its default dispatcher as the <code>ExecutionContext</code>, or you can use the factory methods provided by the <code>ExecutionContexts</code> class to wrap <code>Executors</code> and <code>ExecutorServices</code>, or even create your own.</p>
<pre class="prettyprint"><code class="language-java">import akka.dispatch.*;
import jdocs.AbstractJavaTest;
import scala.concurrent.ExecutionContext;
import scala.concurrent.Future;
import scala.concurrent.Await;
import scala.concurrent.Promise;
import akka.util.Timeout;</code></pre>
<pre class="prettyprint"><code class="language-java">ExecutionContext ec =
  ExecutionContexts.fromExecutorService(yourExecutorServiceGoesHere);

//Use ec with your Futures
Future&lt;String&gt; f1 = Futures.successful(&quot;foo&quot;);

// Then you shut down the ExecutorService at the end of your application.
yourExecutorServiceGoesHere.shutdown();</code></pre>
<h2><a href="#use-with-actors" name="use-with-actors" class="anchor"><span class="anchor-link"></span></a>Use with Actors</h2>
<p>There are generally two ways of getting a reply from an <code>AbstractActor</code>: the first is by a sent message (<code>actorRef.tell(msg, sender)</code>), which only works if the original sender was an <code>AbstractActor</code>) and the second is through a <code>Future</code>.</p>
<p>Using the <code>ActorRef</code>&rsquo;s <code>ask</code> method to send a message will return a <code>Future</code>. To wait for and retrieve the actual result the simplest method is:</p>
<pre class="prettyprint"><code class="language-java">import akka.dispatch.*;
import jdocs.AbstractJavaTest;
import scala.concurrent.ExecutionContext;
import scala.concurrent.Future;
import scala.concurrent.Await;
import scala.concurrent.Promise;
import akka.util.Timeout;</code></pre>
<pre class="prettyprint"><code class="language-java">Timeout timeout = new Timeout(Duration.create(5, &quot;seconds&quot;));
Future&lt;Object&gt; future = Patterns.ask(actor, msg, timeout);
String result = (String) Await.result(future, timeout.duration());</code></pre>
<p>This will cause the current thread to block and wait for the <code>AbstractActor</code> to &lsquo;complete&rsquo; the <code>Future</code> with it&rsquo;s reply. Blocking is discouraged though as it can cause performance problem. The blocking operations are located in <code>Await.result</code> and <code>Await.ready</code> to make it easy to spot where blocking occurs. Alternatives to blocking are discussed further within this documentation. Also note that the <code>Future</code> returned by an <code>AbstractActor</code> is a <code>Future&lt;Object&gt;</code> since an <code>AbstractActor</code> is dynamic. That is why the cast to <code>String</code> is used in the above sample.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p><code>Await.result</code> and <code>Await.ready</code> are provided for exceptional situations where you <strong>must</strong> block, a good rule of thumb is to only use them if you know why you <strong>must</strong> block. For all other cases, use asynchronous composition as described below.</p></div>
<p>To send the result of a <code>Future</code> to an <code>Actor</code>, you can use the <code>pipe</code> construct:</p>
<pre class="prettyprint"><code class="language-java">akka.pattern.Patterns.pipe(future, system.dispatcher()).to(actor);</code></pre>
<h2><a href="#use-directly" name="use-directly" class="anchor"><span class="anchor-link"></span></a>Use Directly</h2>
<p>A common use case within Akka is to have some computation performed concurrently without needing the extra utility of an <code>AbstractActor</code>. If you find yourself creating a pool of <code>AbstractActor</code>s for the sole reason of performing a calculation in parallel, there is an easier (and faster) way:</p>
<pre class="prettyprint"><code class="language-java">import scala.concurrent.duration.Duration;
import akka.japi.Function;
import java.util.concurrent.Callable;
import static akka.dispatch.Futures.future;
import static java.util.concurrent.TimeUnit.SECONDS;</code></pre>
<pre class="prettyprint"><code class="language-java">Future&lt;String&gt; f = future(new Callable&lt;String&gt;() {
  public String call() {
    return &quot;Hello&quot; + &quot;World&quot;;
  }
}, system.dispatcher());

f.onSuccess(new PrintResult&lt;String&gt;(), system.dispatcher());</code></pre>
<p>In the above code the block passed to <code>future</code> will be executed by the default <code>Dispatcher</code>, with the return value of the block used to complete the <code>Future</code> (in this case, the result would be the string: &ldquo;HelloWorld&rdquo;). Unlike a <code>Future</code> that is returned from an <code>AbstractActor</code>, this <code>Future</code> is properly typed, and we also avoid the overhead of managing an <code>AbstractActor</code>.</p>
<p>You can also create already completed Futures using the <code>Futures</code> class, which can be either successes:</p>
<pre class="prettyprint"><code class="language-java">Future&lt;String&gt; future = Futures.successful(&quot;Yay!&quot;);</code></pre>
<p>Or failures:</p>
<pre class="prettyprint"><code class="language-java">Future&lt;String&gt; otherFuture = Futures.failed(
  new IllegalArgumentException(&quot;Bang!&quot;));</code></pre>
<p>It is also possible to create an empty <code>Promise</code>, to be filled later, and obtain the corresponding <code>Future</code>:</p>
<pre class="prettyprint"><code class="language-java">Promise&lt;String&gt; promise = Futures.promise();
Future&lt;String&gt; theFuture = promise.future();
promise.success(&quot;hello&quot;);</code></pre>
<p>For these examples <code>PrintResult</code> is defined as follows:</p>
<pre class="prettyprint"><code class="language-java">public final static class PrintResult&lt;T&gt; extends OnSuccess&lt;T&gt; {
  @Override public final void onSuccess(T t) {
    System.out.println(t);
  }
}</code></pre>
<h2><a href="#functional-futures" name="functional-futures" class="anchor"><span class="anchor-link"></span></a>Functional Futures</h2>
<p>Scala&rsquo;s <code>Future</code> has several monadic methods that are very similar to the ones used by <code>Scala</code>&rsquo;s collections. These allow you to create &lsquo;pipelines&rsquo; or &lsquo;streams&rsquo; that the result will travel through.</p>
<h3><a href="#future-is-a-monad" name="future-is-a-monad" class="anchor"><span class="anchor-link"></span></a>Future is a Monad</h3>
<p>The first method for working with <code>Future</code> functionally is <code>map</code>. This method takes a <code>Mapper</code> which performs some operation on the result of the <code>Future</code>, and returning a new result. The return value of the <code>map</code> method is another <code>Future</code> that will contain the new result:</p>
<pre class="prettyprint"><code class="language-java">import scala.concurrent.duration.Duration;
import akka.japi.Function;
import java.util.concurrent.Callable;
import static akka.dispatch.Futures.future;
import static java.util.concurrent.TimeUnit.SECONDS;</code></pre>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();

Future&lt;String&gt; f1 = future(new Callable&lt;String&gt;() {
  public String call() {
    return &quot;Hello&quot; + &quot;World&quot;;
  }
}, ec);

Future&lt;Integer&gt; f2 = f1.map(new Mapper&lt;String, Integer&gt;() {
  public Integer apply(String s) {
    return s.length();
  }
}, ec);

f2.onSuccess(new PrintResult&lt;Integer&gt;(), system.dispatcher());</code></pre>
<p>In this example we are joining two strings together within a <code>Future</code>. Instead of waiting for f1 to complete, we apply our function that calculates the length of the string using the <code>map</code> method. Now we have a second <code>Future</code>, f2, that will eventually contain an <code>Integer</code>. When our original <code>Future</code>, f1, completes, it will also apply our function and complete the second <code>Future</code> with its result. When we finally <code>get</code> the result, it will contain the number 10. Our original <code>Future</code> still contains the string &ldquo;HelloWorld&rdquo; and is unaffected by the <code>map</code>.</p>
<p>Something to note when using these methods: passed work is always dispatched on the provided <code>ExecutionContext</code>. Even if the <code>Future</code> has already been completed, when one of these methods is called.</p>
<h3><a href="#composing-futures" name="composing-futures" class="anchor"><span class="anchor-link"></span></a>Composing Futures</h3>
<p>It is very often desirable to be able to combine different Futures with each other, below are some examples on how that can be done in a non-blocking fashion.</p>
<pre class="prettyprint"><code class="language-java">import static akka.dispatch.Futures.sequence;</code></pre>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();
//Some source generating a sequence of Future&lt;Integer&gt;:s
Iterable&lt;Future&lt;Integer&gt;&gt; listOfFutureInts = source;

// now we have a Future[Iterable[Integer]]
Future&lt;Iterable&lt;Integer&gt;&gt; futureListOfInts = sequence(listOfFutureInts, ec);

// Find the sum of the odd numbers
Future&lt;Long&gt; futureSum = futureListOfInts.map(
  new Mapper&lt;Iterable&lt;Integer&gt;, Long&gt;() {
    public Long apply(Iterable&lt;Integer&gt; ints) {
      long sum = 0;
      for (Integer i : ints)
        sum += i;
      return sum;
    }
  }, ec);

futureSum.onSuccess(new PrintResult&lt;Long&gt;(), system.dispatcher());</code></pre>
<p>To better explain what happened in the example, <code>Future.sequence</code> is taking the <code>Iterable&lt;Future&lt;Integer&gt;&gt;</code> and turning it into a <code>Future&lt;Iterable&lt;Integer&gt;&gt;</code>. We can then use <code>map</code> to work with the <code>Iterable&lt;Integer&gt;</code> directly, and we aggregate the sum of the <code>Iterable</code>.</p>
<p>The <code>traverse</code> method is similar to <code>sequence</code>, but it takes a sequence of <code>A</code> and applies a function from <code>A</code> to <code>Future&lt;B&gt;</code> and returns a <code>Future&lt;Iterable&lt;B&gt;&gt;</code>, enabling parallel <code>map</code> over the sequence, if you use <code>Futures.future</code> to create the <code>Future</code>.</p>
<pre class="prettyprint"><code class="language-java">import static akka.dispatch.Futures.traverse;</code></pre>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();
//Just a sequence of Strings
Iterable&lt;String&gt; listStrings = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);

Future&lt;Iterable&lt;String&gt;&gt; futureResult = traverse(listStrings,
  new Function&lt;String, Future&lt;String&gt;&gt;() {
    public Future&lt;String&gt; apply(final String r) {
      return future(new Callable&lt;String&gt;() {
        public String call() {
          return r.toUpperCase();
        }
      }, ec);
    }
  }, ec);

//Returns the sequence of strings as upper case
futureResult.onSuccess(new PrintResult&lt;Iterable&lt;String&gt;&gt;(), system.dispatcher());</code></pre>
<p>It&rsquo;s as simple as that!</p>
<p>Then there&rsquo;s a method that&rsquo;s called <code>fold</code> that takes a start-value, a sequence of <code>Future</code>:s and a function from the type of the start-value, a timeout, and the type of the futures and returns something with the same type as the start-value, and then applies the function to all elements in the sequence of futures, non-blockingly, the execution will be started when the last of the Futures is completed.</p>
<pre class="prettyprint"><code class="language-java">import akka.japi.Function2;
import static akka.dispatch.Futures.fold;</code></pre>
<pre class="prettyprint"><code class="language-java"><br/>final ExecutionContext ec = system.dispatcher();

//A sequence of Futures, in this case Strings
Iterable&lt;Future&lt;String&gt;&gt; futures = source;

//Start value is the empty string
Future&lt;String&gt; resultFuture = fold(&quot;&quot;, futures,
  new Function2&lt;String, String, String&gt;() {
    public String apply(String r, String t) {
      return r + t; //Just concatenate
    }
  }, ec);

resultFuture.onSuccess(new PrintResult&lt;String&gt;(), system.dispatcher());</code></pre>
<p>That&rsquo;s all it takes!</p>
<p>If the sequence passed to <code>fold</code> is empty, it will return the start-value, in the case above, that will be empty String. In some cases you don&rsquo;t have a start-value and you&rsquo;re able to use the value of the first completing <code>Future</code> in the sequence as the start-value, you can use <code>reduce</code>, it works like this:</p>
<pre class="prettyprint"><code class="language-java">import static akka.dispatch.Futures.reduce;</code></pre>
<pre class="prettyprint"><code class="language-java"><br/>final ExecutionContext ec = system.dispatcher();
//A sequence of Futures, in this case Strings
Iterable&lt;Future&lt;String&gt;&gt; futures = source;

Future&lt;Object&gt; resultFuture = reduce(futures,
  new Function2&lt;Object, String, Object&gt;() {
    public Object apply(Object r, String t) {
      return r + t; //Just concatenate
    }
  }, ec);

resultFuture.onSuccess(new PrintResult&lt;Object&gt;(), system.dispatcher());</code></pre>
<p>Same as with <code>fold</code>, the execution will be started when the last of the Futures is completed, you can also parallelize it by chunking your futures into sub-sequences and reduce them, and then reduce the reduced results again.</p>
<p>This is just a sample of what can be done.</p>
<h2><a href="#callbacks" name="callbacks" class="anchor"><span class="anchor-link"></span></a>Callbacks</h2>
<p>Sometimes you just want to listen to a <code>Future</code> being completed, and react to that not by creating a new Future, but by side-effecting. For this Scala supports <code>onComplete</code>, <code>onSuccess</code> and <code>onFailure</code>, of which the last two are specializations of the first.</p>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();

future.onSuccess(new OnSuccess&lt;String&gt;() {
  public void onSuccess(String result) {
    if (&quot;bar&quot; == result) {
      //Do something if it resulted in &quot;bar&quot;
    } else {
      //Do something if it was some other String
    }
  }
}, ec);</code></pre>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();

future.onFailure(new OnFailure() {
  public void onFailure(Throwable failure) {
    if (failure instanceof IllegalStateException) {
      //Do something if it was this particular failure
    } else {
      //Do something if it was some other failure
    }
  }
}, ec);</code></pre>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();

future.onComplete(new OnComplete&lt;String&gt;() {
  public void onComplete(Throwable failure, String result) {
    if (failure != null) {
      //We got a failure, handle it here
    } else {
      // We got a result, do something with it
    }
  }
}, ec);</code></pre>
<h2><a href="#ordering" name="ordering" class="anchor"><span class="anchor-link"></span></a>Ordering</h2>
<p>Since callbacks are executed in any order and potentially in parallel, it can be tricky at the times when you need sequential ordering of operations. But there&rsquo;s a solution! And it&rsquo;s name is <code>andThen</code>, and it creates a new <code>Future</code> with the specified callback, a <code>Future</code> that will have the same result as the <code>Future</code> it&rsquo;s called on, which allows for ordering like in the following sample:</p>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();
Future&lt;String&gt; future1 = Futures.successful(&quot;value&quot;).andThen(
  new OnComplete&lt;String&gt;() {
    public void onComplete(Throwable failure, String result) {
      if (failure != null)
        sendToIssueTracker(failure);
    }
  }, ec).andThen(new OnComplete&lt;String&gt;() {
  public void onComplete(Throwable failure, String result) {
    if (result != null)
      sendToTheInternetz(result);
  }
}, ec);</code></pre>
<h2><a href="#auxiliary-methods" name="auxiliary-methods" class="anchor"><span class="anchor-link"></span></a>Auxiliary methods</h2>
<p><code>Future</code> <code>fallbackTo</code> combines 2 Futures into a new <code>Future</code>, and will hold the successful value of the second <code>Future</code> if the first <code>Future</code> fails.</p>
<pre class="prettyprint"><code class="language-java">Future&lt;String&gt; future1 = Futures.failed(new IllegalStateException(&quot;OHNOES1&quot;));
Future&lt;String&gt; future2 = Futures.failed(new IllegalStateException(&quot;OHNOES2&quot;));
Future&lt;String&gt; future3 = Futures.successful(&quot;bar&quot;);
// Will have &quot;bar&quot; in this case
Future&lt;String&gt; future4 = future1.fallbackTo(future2).fallbackTo(future3);
future4.onSuccess(new PrintResult&lt;String&gt;(), system.dispatcher());</code></pre>
<p>You can also combine two Futures into a new <code>Future</code> that will hold a tuple of the two Futures successful results, using the <code>zip</code> operation.</p>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();
Future&lt;String&gt; future1 = Futures.successful(&quot;foo&quot;);
Future&lt;String&gt; future2 = Futures.successful(&quot;bar&quot;);
Future&lt;String&gt; future3 = future1.zip(future2).map(
  new Mapper&lt;scala.Tuple2&lt;String, String&gt;, String&gt;() {
    public String apply(scala.Tuple2&lt;String, String&gt; zipped) {
      return zipped._1() + &quot; &quot; + zipped._2();
    }
  }, ec);

future3.onSuccess(new PrintResult&lt;String&gt;(), system.dispatcher());</code></pre>
<h2><a href="#exceptions" name="exceptions" class="anchor"><span class="anchor-link"></span></a>Exceptions</h2>
<p>Since the result of a <code>Future</code> is created concurrently to the rest of the program, exceptions must be handled differently. It doesn&rsquo;t matter if an <code>AbstractActor</code> or the dispatcher is completing the <code>Future</code>, if an <code>Exception</code> is caught the <code>Future</code> will contain it instead of a valid result. If a <code>Future</code> does contain an <code>Exception</code>, calling <code>Await.result</code> will cause it to be thrown again so it can be handled properly.</p>
<p>It is also possible to handle an <code>Exception</code> by returning a different result. This is done with the <code>recover</code> method. For example:</p>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();

Future&lt;Integer&gt; future = future(new Callable&lt;Integer&gt;() {
  public Integer call() {
    return 1 / 0;
  }
}, ec).recover(new Recover&lt;Integer&gt;() {
  public Integer recover(Throwable problem) throws Throwable {
    if (problem instanceof ArithmeticException)
      return 0;
    else
      throw problem;
  }
}, ec);

future.onSuccess(new PrintResult&lt;Integer&gt;(), system.dispatcher());</code></pre>
<p>In this example, if the actor replied with a <code>akka.actor.Status.Failure</code> containing the <code>ArithmeticException</code>, our <code>Future</code> would have a result of 0. The <code>recover</code> method works very similarly to the standard try/catch blocks, so multiple <code>Exception</code>s can be handled in this manner, and if an <code>Exception</code> is not handled this way it will behave as if we hadn&rsquo;t used the <code>recover</code> method.</p>
<p>You can also use the <code>recoverWith</code> method, which has the same relationship to <code>recover</code> as <code>flatMap</code> has to <code>map</code>, and is use like this:</p>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();

Future&lt;Integer&gt; future = future(new Callable&lt;Integer&gt;() {
  public Integer call() {
    return 1 / 0;
  }
}, ec).recoverWith(new Recover&lt;Future&lt;Integer&gt;&gt;() {
  public Future&lt;Integer&gt; recover(Throwable problem) throws Throwable {
    if (problem instanceof ArithmeticException) {
      return future(new Callable&lt;Integer&gt;() {
        public Integer call() {
          return 0;
        }
      }, ec);
    } else
      throw problem;
  }
}, ec);

future.onSuccess(new PrintResult&lt;Integer&gt;(), system.dispatcher());</code></pre>
<h2><a href="#after" name="after" class="anchor"><span class="anchor-link"></span></a>After</h2>
<p><code>akka.pattern.Patterns.after</code> makes it easy to complete a <code>Future</code> with a value or exception after a timeout.</p>
<pre class="prettyprint"><code class="language-java">import static akka.pattern.Patterns.after;
import java.util.Arrays;</code></pre>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();
Future&lt;String&gt; failExc = Futures.failed(new IllegalStateException(&quot;OHNOES1&quot;));
Future&lt;String&gt; delayed = Patterns.after(Duration.create(200, &quot;millis&quot;),
  system.scheduler(), ec,  failExc);
Future&lt;String&gt; future = future(new Callable&lt;String&gt;() {
  public String call() throws InterruptedException {
    Thread.sleep(1000);
    return &quot;foo&quot;;
  }
}, ec);
Future&lt;String&gt; result = Futures.firstCompletedOf(
  Arrays.&lt;Future&lt;String&gt;&gt;asList(future, delayed), ec);</code></pre>
<h2><a href="#java-8-completionstage-and-completablefuture" name="java-8-completionstage-and-completablefuture" class="anchor"><span class="anchor-link"></span></a>Java 8, CompletionStage and CompletableFuture</h2>
<p>Starting with Akka 2.4.2 we have begun to introduce Java 8 <code>java.util.concurrent.CompletionStage</code> in Java APIs. It&rsquo;s a <code>scala.concurrent.Future</code> counterpart in Java; conversion from <code>scala.concurrent.Future</code> is done using <code>scala-java8-compat</code> library.</p>
<p>Unlike <code>scala.concurrent.Future</code> which has async methods only, <code>CompletionStage</code> has <em>async</em> and <em>non-async</em> methods.</p>
<p>The <code>scala-java8-compat</code> library returns its own implementation of <code>CompletionStage</code> which delegates all <em>non-async</em> methods to their <em>async</em> counterparts. The implementation extends standard Java <code>CompletableFuture</code>. Java 8 <code>CompletableFuture</code> creates a new instance of <code>CompletableFuture</code> for any new stage, which means <code>scala-java8-compat</code> implementation is not used after the first mapping method.</p><div class="callout note "><div class="callout-title">Note</div>
<p>After adding any additional computation stage to <code>CompletionStage</code> returned by <code>scala-java8-compat</code> (e.g. <code>CompletionStage</code> instances returned by Akka) it falls back to standard behaviour of Java <code>CompletableFuture</code>.</p></div>
<p>Actions supplied for dependent completions of <em>non-async</em> methods may be performed by the thread that completes the current <code>CompletableFuture</code>, or by any other caller of a completion method.</p>
<p>All <em>async</em> methods without an explicit Executor are performed using the <code>ForkJoinPool.commonPool()</code> executor.</p>
<h3><a href="#non-async-methods" name="non-async-methods" class="anchor"><span class="anchor-link"></span></a>Non-async methods</h3>
<p>When non-async methods are applied on a not yet completed <code>CompletionStage</code>, they are completed by the thread which completes initial <code>CompletionStage</code>:</p>
<pre class="prettyprint"><code class="language-java">final ExecutionContext ec = system.dispatcher();
final CountDownLatch countDownLatch = new CountDownLatch(1);

Future&lt;String&gt; scalaFuture = Futures.future(() -&gt; {
  assertThat(Thread.currentThread().getName(), containsString(&quot;akka.actor.default-dispatcher&quot;));
  countDownLatch.await(); // do not complete yet
  return &quot;hello&quot;;
}, ec);

CompletionStage&lt;String&gt; fromScalaFuture = FutureConverters.toJava(scalaFuture)
  .thenApply(s -&gt; { // 1
    assertThat(Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
    return s;
  })
  .thenApply(s -&gt; { // 2
    assertThat(Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
    return s;
  })
  .thenApply(s -&gt; { // 3
    assertThat(Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
    return s;
  });

countDownLatch.countDown(); // complete scalaFuture</code></pre>
<p>In this example Scala <code>Future</code> is converted to <code>CompletionStage</code> just like Akka does. The completion is delayed: we are calling <code>thenApply</code> multiple times on a not yet complete <code>CompletionStage</code>, then complete the <code>Future</code>.</p>
<p>First <code>thenApply</code> is actually performed on <code>scala-java8-compat</code> instance and computational stage (lambda) execution is delegated to default Java <code>thenApplyAsync</code> which is executed on <code>ForkJoinPool.commonPool()</code>.</p>
<p>Second and third <code>thenApply</code> methods are executed on Java 8 <code>CompletableFuture</code> instance which executes computational stages on the thread which completed the first stage. It is never executed on a thread of Scala <code>Future</code> because default <code>thenApply</code> breaks the chain and executes on <code>ForkJoinPool.commonPool()</code>.</p>
<p>In the next example <code>thenApply</code> methods are executed on an already completed <code>Future</code>/<code>CompletionStage</code>:</p>
<pre class="prettyprint"><code class="language-java">Future&lt;String&gt; scalaFuture = Futures.future(() -&gt; {
  assertThat(Thread.currentThread().getName(), containsString(&quot;akka.actor.default-dispatcher&quot;));
  return &quot;hello&quot;;
}, ec);

CompletionStage&lt;String&gt; completedStage = FutureConverters.toJava(scalaFuture)
  .thenApply(s -&gt; { // 1
    assertThat(Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
    return s;
  });

completedStage.toCompletableFuture().get(2, SECONDS); // complete current CompletionStage
final String currentThread = Thread.currentThread().getName();

CompletionStage&lt;String&gt; stage2 = completedStage
  .thenApply(s -&gt; { // 2
    assertThat(Thread.currentThread().getName(), is(currentThread));
    return s;
  })
  .thenApply(s -&gt; { // 3
    assertThat(Thread.currentThread().getName(), is(currentThread));
    return s;
  });</code></pre>
<p>First <code>thenApply</code> is still executed on <code>ForkJoinPool.commonPool()</code> (because it is actually <code>thenApplyAsync</code> which is always executed on global Java pool).</p>
<p>Then we wait for stages to complete so second and third <code>thenApply</code> are executed on completed <code>CompletionStage</code>, and stages are executed on the current thread - the thread which called second and third <code>thenApply</code>.</p>
<h3><a href="#async-methods" name="async-methods" class="anchor"><span class="anchor-link"></span></a>Async methods</h3>
<p>As mentioned above, default <em>async</em> methods are always executed on <code>ForkJoinPool.commonPool()</code>:</p>
<pre class="prettyprint"><code class="language-java">CompletionStage&lt;String&gt; fromScalaFuture = FutureConverters.toJava(scalaFuture)
  .thenApplyAsync(s -&gt; { // 1
    assertThat(Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
    return s;
  })
  .thenApplyAsync(s -&gt; { // 2
    assertThat(Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
    return s;
  })
  .thenApplyAsync(s -&gt; { // 3
    assertThat(Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
    return s;
  });</code></pre>
<p><code>CompletionStage</code> also has <em>async</em> methods which take <code>Executor</code> as a second parameter, just like <code>Future</code>:</p>
<pre class="prettyprint"><code class="language-java">final Executor ex = system.dispatcher();

CompletionStage&lt;String&gt; fromScalaFuture = FutureConverters.toJava(scalaFuture)
  .thenApplyAsync(s -&gt; {
    assertThat(Thread.currentThread().getName(), containsString(&quot;akka.actor.default-dispatcher&quot;));
    return s;
  }, ex)
  .thenApplyAsync(s -&gt; {
    assertThat(Thread.currentThread().getName(), containsString(&quot;akka.actor.default-dispatcher&quot;));
    return s;
  }, ex)
  .thenApplyAsync(s -&gt; {
    assertThat(Thread.currentThread().getName(), containsString(&quot;akka.actor.default-dispatcher&quot;));
    return s;
  }, ex);</code></pre>
<p>This example is behaving like <code>Future</code>: every stage is executed on an explicitly specified <code>Executor</code>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>When in doubt, async methods with explicit executor should be used. Always async methods with a dedicated executor/dispatcher for long-running or blocking computations, such as IO operations.</p></div>
<p>See also:</p>
<ul>
  <li><a href="https://docs.oracle.com/javase/8/jdocs/api/java/util/concurrent/CompletionStage.html">CompletionStage</a></li>
  <li><a href="https://docs.oracle.com/javase/8/jdocs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a></li>
  <li><a href="https://github.com/scala/scala-java8-compat">scala-java8-compat</a></li>
</ul>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../java/index-futures.html"><i class="icon-prev"></i> <span class="link-prev">Futures and Agents</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../java/agents.html">Agents <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
The source code for this page can be found <a href="http://github.com/akka/akka/tree/master/akka-docs/src/main/paradox/java/futures.md">here</a>.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>&copy; 2011-2017 <a href="https://www.lightbend.com">Lightbend</a></div>
<div>Akka is Open Source and available under the Apache 2 License.</div>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
var lang = "scala";
var path = window.location.pathname;
if (path.includes("/java/") || path.includes("java.html")) {
lang = "java";
}

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5,
facetFilters: ["language:" + lang]
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>


</body>
</html>
