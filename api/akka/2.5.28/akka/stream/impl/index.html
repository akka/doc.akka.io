<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Akka 2.5.28 - akka.stream.impl</title>
          <meta name="description" content="Akka 2.5.28 - akka.stream.impl" />
          <meta name="keywords" content="Akka 2.5.28 akka.stream.impl" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      <script type="text/javascript" src="../../../lib/modernizr.custom.js"></script><script type="text/javascript" src="../../../lib/diagrams.js" id="diagrams-js"></script>
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Akka<span id="doc-version">2.5.28</span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.akka" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="akka"></a><a id="akka:akka"></a>
      <span class="permalink">
      <a href="index.html#akka" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">akka</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="akka.stream" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stream"></a><a id="stream:stream"></a>
      <span class="permalink">
      <a href="../akka/index.html#stream" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">stream</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="akka">akka</a></dd></dl></div>
    </li><li name="akka.stream.actor" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="actor"></a><a id="actor:actor"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#actor" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../actor/index.html"><span class="name">actor</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.extra" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="extra"></a><a id="extra:extra"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#extra" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../extra/index.html"><span class="name">extra</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.impl" visbl="pub" class="indented3 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="impl"></a><a id="impl:impl"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#impl" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">impl</span>
      </span>
      
      <p class="shortcomment cmt">The architecture of Akka Streams internally consists of several distinct layers:</p><div class="fullcomment"><div class="comment cmt"><p>The architecture of Akka Streams internally consists of several distinct layers:</p><p> * The DSLs like <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">akka.stream.scaladsl.Flow</a>, <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">akka.stream.scaladsl.Source</a> etc. are the user facing API
   for composing streams. These DSLs are a thin wrappers around the internal <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span>
   builder classes. There are Java alternatives of these DSLs in <a href="../javadsl/index.html" class="extype" name="akka.stream.javadsl">javadsl</a> which basically wrap their scala
   counterpart, delegating method calls.
 * The <a href="../stage/GraphStage.html" class="extype" name="akka.stream.stage.GraphStage">akka.stream.stage.GraphStage</a> API is the user facing API for creating new stream operators. These
   classes are used by the <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span> which executes islands (subgraphs) of these
   operators
 * The high level DSLs use the <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span> classes to build instances of
   <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> which are the representation of a materializable stream description. These builders
   are immutable and safely shareable. Unlike the top-level DSLs, these are untyped, i.e. elements are treated as
   Any.
 * The <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> is the immutable, efficient representation of a stream processing graph that
   can be materialized. The builders exists solely for the purpose of producing a traversal in the end.
 * The <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span> is the class that is responsible for traversing and
   interpreting a <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span>. It delegates the actual task of creating executable entities
   and Publishers/Producers to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>s which are plugins that understand atomic operators
   in the graph and able to turn them into executable entities.
 * The <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span> and its actor backed wrapper <span class="extype" name="akka.stream.impl.fusing.ActorGraphInterpreter">akka.stream.impl.fusing.ActorGraphInterpreter</span>
   are used to execute synchronous islands (subgraphs) of <a href="../stage/GraphStage.html" class="extype" name="akka.stream.stage.GraphStage">akka.stream.stage.GraphStage</a>s.</p><p>For the execution layer, refer to <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span>.</p><h4> Design goals </h4><p>The central piece for both the DSLs and materialization is the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span>. This is the
representation of an Akka Stream, basically a <a href="../scaladsl/RunnableGraph.html" class="extype" name="akka.stream.scaladsl.RunnableGraph">akka.stream.scaladsl.RunnableGraph</a>. The design goals
for <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> are:</p><p>  * Be able to materialize a graph in one pass over the traversal
  * Unify materialization and fusing. The materializer should be able to construct all the necessary data structures
    for the interpreters and for connecting them in one go.
  * Avoid allocations as much as possible.
  * Biased implementation for the 90% case. Common cases should be as fast as possible:
    * wiring linear chains should be very fast.
    * assume that most graphs are mostly linear, with only a few generalized graph constructs thrown in.
    * materialization should not pay the price of island tracking if there is only a single island
    * assume that the number of islands is low in general
    * avoid &quot;copiedModule&quot; i.e. wrappers that exist solely for the purpose of establishing new port identities
      for operators that are used multiple times in the same graph.
  * Avoid hashmaps and prefer direct array lookup wherever possible</p><p>Semantically, a traversal is a list of commands that the materializer must execute to turn the description to a
running stream. In fact, the traversal is nothing more than an immutable list, that is expressed as a tree. A
tree is used to make immutable appends fast (immutable lists only have prepend as O(1) operation, append is O(N)).
The materializer &quot;recovers&quot; the original sequence by using a local, mutable stack to properly traverse the tree
structure. This is way cheaper than to immutably append to the traversal at each addition.</p><p>The &quot;tree-ness&quot; is expressed by explicit <span class="extype" name="akka.stream.impl.Concat">akka.stream.impl.Concat</span> nodes that express that two traversals
need to be traversed in a certain sequence, stashing away the second on a local stack until the first is fully
traversed.</p><p>While traversing the traversal (basically following Concat nodes), the materializer will visit the following
command types:</p><p> * <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>: An atomic module needs to be materialized. This node also contains
   wiring information which we discuss later.
 * Materialized value computation. This is a stack based &quot;sublanguage&quot; to compute the final materialized value
   on a stack, maintained by the materializer
   * <span class="extype" name="akka.stream.impl.PushNotUsed">akka.stream.impl.PushNotUsed</span> push a NotUsed value on the stack
   * <span class="extype" name="akka.stream.impl.Pop">akka.stream.impl.Pop</span> pop the top of the stack and throw away
   * <span class="extype" name="akka.stream.impl.Transform">akka.stream.impl.Transform</span> take the top of the stack, transform it with the provided function and put
     the result back on the top of the stack
   * <span class="extype" name="akka.stream.impl.Compose">akka.stream.impl.Compose</span> take the top two values of the stack, invoke the provided function with these
     values as arguments, then put the calculated value on the top of the stack
   * Materialized values of atomic operators when visiting a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> must be
     pushed to the stack automatically. There are no explicit PUSH commands for this
 * Attributes calculation. These also are a stack language, although much simpler than the materialized value
    commands. For any materialized operator, the top of the attributes stack should be provided as the current
    effective attributes.
   * <span class="extype" name="akka.stream.impl.PushAttributes">akka.stream.impl.PushAttributes</span> combines the attributes on the top of the stack with the given ones and
     puts the result on the attributes stack
   * <span class="extype" name="akka.stream.impl.PopAttributes">akka.stream.impl.PopAttributes</span> removes the top of the attributes stack.
 * Island tracking. Islands serve two purposes. First, they allow a large graph to be cut into parts that execute
   concurrently with each other, using asynchronous message passing between themselves. Second, they are an
   extension point where &quot;plugins&quot; (<span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>) can be used to specially handle subgraphs.
   Islands can be nested in each other. This makes &quot;holes&quot; in the parent island. Islands also need a stack
   as exiting a &quot;hole&quot; means returning to the parent, enclosing island and continuing where left.
    * <span class="extype" name="akka.stream.impl.EnterIsland">akka.stream.impl.EnterIsland</span> instructs the materializer that the following commands will belong to
      the materialization of a new island (a subgraph). The <span class="extype" name="akka.stream.impl.IslandTag">akka.stream.impl.IslandTag</span> signals to
      the materializer which <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> should be used to turn operators of this island into
      executable entities.
    * <span class="extype" name="akka.stream.impl.ExitIsland">akka.stream.impl.ExitIsland</span> instructs the materializer that the current island is done and the parent
      island is now the active one again.</p><p> Please note that the stack based materialized value computation eliminates the issues present in the older
 materializer which expressed these computations as an AST. We had to use optimizations for this tree so that
 long Keep.left chains don't explode the stack visiting a large AST. The stack based language sidesteps this issue
 completely as the number of these commands don't increase the stack space required to execute them, unless the
 computation itself requires it (which is not the case in any sane stream combination).</p><h4> Graph model, offsets, slots </h4><p> As a mental model, the wiring part of the Traversal (i.e. excluding the stack based sub-commands tracking
 materialized values, attributes, islands, i.e. things that don't contribute to the wiring structure of the graph)
 translates everything to a single, global, contiguous Array. Every input and output port of each operator is mapped
 to exactly one slot of this &quot;mental array&quot;. Input and output ports that are considered wired together simply map
 to the same slot. (In practice, these slots might not be mapped to an actual global array, but multiple local arrays
 using some translation logic, but we will explain this later)</p><p> Input ports are mapped simply to contiguous numbers in the order they are visited. Take for example a simple
 traversal:</p><p>   Operator1[in1, in2, out] - Operator2[out] - Operator3[in]</p><p> This results in the following slot assignments:</p><p>   * Operator1.in1 -&gt; 0
   * Operator1.in2 -&gt; 1
   * Operator3.in  -&gt; 2</p><p> The materializer simply visits Stage1, Stage2, Stage3 in order, visiting the input ports of each operator in order.
 It then simply assigns numbers from a counter that is incremented after visiting an input port.
 (Please note that all <span class="extype" name="akka.stream.impl.StreamLayout.AtomicModule">akka.stream.impl.StreamLayout.AtomicModule</span>s maintain a stable order of their ports, so
 this global ordering is well defined)</p><p> Before explaining how output wiring works, it is important to settle some terminology. When we talk about ports
 we refer to their location in the &quot;mental array&quot; as slots. However, there are other entities that needs to
 reference various positions in this &quot;mental array&quot;, but in these cases we use the term _offset_ to signify that
 these are only used for bookkeeping, they have no &quot;place&quot; in the &quot;array&quot; themselves. In particular:</p><p>  * offset of a module: The offset of an <span class="extype" name="akka.stream.impl.StreamLayout.AtomicModule">akka.stream.impl.StreamLayout.AtomicModule</span> is defined as the value of
    the input port counter when visiting the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node to materialize that module.
    In other words, the offset of a module is the slot of its first input port (if there is any). Since modules
    might not have any input ports it can be that different modules share the same offset, simply because the
    the first one visited does not increase the input port counter.
  * offset of segments, islands: Defined similarly to module. The offset of an island or a segment is simply the
    value of the input port counter (or the first unallocated slot).</p><p> For example:</p><p>   Module1[in1 = 0, in2 = 1] - Module2[out] - Module3[in = 2]</p><p> The offset of Module1 is 0, while Module2 and Module3 share the same offset of 2. Note that only input ports (slots)
 contribute to the offset of a module in a traversal.</p><p> Output ports are wired relative to the offset of the module they are contained in. When the materializer visits
 a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node, it contains an Array that maps ports to a relative offset. To
 calculate the slot that is assigned to an output port the following formula is used:</p><p>   slot = offsetOfModule + outToSlots(out.id)</p><p> Where outToSlots is the array contained in the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node.</p><h4> Relative addressing </h4><p> The power of this structure comes from the fact that slots are assigned in a relative manner:</p><p>  * input ports are assigned in sequence so the slots assigned to the input ports of a subgraph depend on the
    subgraph's position in the traversal
  * output ports are assigned relative to the offset of their owner module, which is in turn relative to its first
    (potential) input port (which is relative, too, because of the previous point)</p><p> This setup allows combining subgraphs without touching their internal wirings as all their internal wirings will
 properly resolve due to everything being relative:</p><p>      +---------------+                     +----+
      |               |                     |    |
   |---------Graph1---------|--- .... ---|----Graph2----|</p><p> It is important to note that due to reusability, an Akka Stream graph may contain the same atomic or composite
 multiple times in the same graph. Since these must be distinguished from each other somehow, they need port mapping
 (i.e. a new set of ports) to ensure that the ports of one graph are distinguishable from another. Because how
 the traversal relative addressing works, these are _temporary_ though, once all internal wirings are ready, these
 mappings can be effectively dropped as the global slot assignments uniquely identify what is wired to what. For
 example since Graph1 is visited before Graph2 all of the slots or offsets it uses are different from Graph2 leaving
 no room for misinterpretation.</p><h4> Port mapping </h4><p> Port mapping is the way how the DSL can distinguish between multiple instances of the same graph included multiple
 times. For example in the Graph DSL:</p><p>   val merge1 = builder.add(Merge)
   val merge2 = builder.add(Merge)</p><p> the port merge1.out must be different from merge2.out.</p><p> For efficiency reasons, the linear and graph DSLs use different <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span> types to
 build the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> (we will discuss these next). One of the differences between the two
 builders are their approach to port mapping.</p><p> The simpler case is the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span>. This builder only allows building linear
 chains of operators, hence, it can only have at most one <a href="../OutPort.html" class="extype" name="akka.stream.OutPort">OutPort</a> and <a href="../InPort.html" class="extype" name="akka.stream.InPort">InPort</a> unwired. Since there is no
 possible ambiguity between these two port types, there is no need for port mapping for these. Conversely,
 for those internal ports that are already wired, there is no need for port mapping as their relative wiring
 is not ambiguous (see previous section). As a result, the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> does not
 use any port mapping.</p><p> The generic graph builder class <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> needs port mapping as it allows
 adding any kind of builders in any order. When adding a module (encoded as another <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span>)
 there are two entities in play:</p><p>  * The module (builder) to be added. This builder has a few ports unwired which are usually packaged in a <a href="../Shape.html" class="extype" name="akka.stream.Shape">Shape</a>
    which is stored alongside with the builder in the <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a> of the DSL. When invoking methods on this builder
    these set of ports must be used.
  * The module that we are growing. This module needs a new set of ports to be used as it might add this module
    multiple times and needs to disambiguate these ports.</p><p> Adding to the <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> involves the following steps (pseudocode):</p><p>    val newShape = shape.deepCopy() // Copy the shape of the module we want to add
    val newBuilder = builder.add(submodule, newShape) // Add the module, and register it with the new shape
    newBuilder.wire(newShape.in, ...) // Use the new ports to wire</p><p> What happens in the background is that <span class="extype" name="Shape.deepCopy()">Shape.deepCopy()</span> creates copies of the ports, and fills their
 mappedTo field to point to their original port counterpart. Whenever we call wire in the outer module, it
 delegates calls to the submodule, but using the original port (as the submodule builder has no knowledge of
 the external mapping):</p><p>     submodule.assign(port.mappedTo, ...) // enclosing module delegating to submodule, translating ports back</p><p> Visualizing this relationship:</p><p>   +----------------------------------+
   | in', in&quot; ---------+              | in' and in&quot; both resolve to in
   |   | .mappedTo     v .mappedTo    | but they will be used on _different_ builders
   | +-------------+ +-------------+  |
   | | in          | | in          |  | (delegation happens recursively in AddedModule)
   | | AddedModule | | AddedModule |  |</p><p> It is worth to note that the submodule might also continue this map-and-delegate chain to further submodules until
 a builder is reached that can directly perform the operation. In other words, the depth of nesting is equal to
 the length of mappedTo chaining.</p><p> IMPORTANT: When wiring in the enclosing module the new ports/shape MUST be used, using the original ports/shape
 will lead to incorrect state.</p><h4> TraversalBuilders </h4><p> In order to understand why builders are needed, consider wiring two ports together. Actually, we don't need to
 wire input ports anywhere. Their slot is implicitly assigned by their position in the traversal, there is no
 additional state we need to track. On the other hand, we cannot build a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>
 node until the mapping array outToSlots is fully calculated. In other words, in reality, we don't wire input ports
 anywhere, we only assign output ports to slots. The builders exist mainly to keep track all the necessary
 information to be able to assign output ports, build the outToSlots array and finally the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>
 node. The consequence of this that a <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> can be constructed as soon as all output ports
 are wired (&quot;unwired&quot; inputs don't matter).</p><p> There is a specific builder that is used for the cases where all outputs have been wired:
 <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>. This builder type simply contains the completed traversal plus
 some additional data. The reason why this builder type exists is to keep auxiliary data structures required for
 output port mapping only while they are needed, and shed them as soon as they are not needed anymore. Since builders
 may recursively contain other builders, as soon as internals are completed those contained builders transition
 to completed state and drop all additional data structures. This is very GC friendly as many intermediate graphs
 exist only in a method call, and hence most of the additional data structures are dropped before method return and
 can be efficiently collected by the GC.</p><p> The most generic builder is <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span>. There are two main considerations
 this builder needs to consider:</p><p>  * Enclosed modules (builders) must have a stable position in the final traversal for relative addressing to work.
    Since module offsets are calculated by traversal position, and outputs are wired relative to module offset, this
    is critical.
  * Enclosed builders might not be complete yet (i.e. have unwired outputs) and hence they cannot immediately give
    a Traversal.</p><p> The composite builder keeps a temporary list of traversal steps (in reverse order because of immutable lists)
 it needs to create once it is completed (all outputs wired). These steps refer to the traversal of submodules
 as a <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span> which is just a placeholder where the traversal of the submodule will be
 stitched in. This <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span> is also a key to a map which contains the evolving builder.
 The importance of this &quot;preimage&quot; traversal is that it keeps position of submodules stable, making relative
 addressing possible.</p><p> Once the composite is completed, it takes these steps (now reversing it back to normal), and builds the traversal
 using the submodule traversals referred to by <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span>. Note that at this point all the
 submodules are <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>s because there are no unwired outputs and hence the
 Traversal can be assembled. As the builder evolves over time, more and more of its <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span>s
 will refer to <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>s, shedding much of the temporary data structures.</p><p> Refer to <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> for more details.</p><p> The <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> is a much simpler beast. For efficiency, it tries to work as much
 as possible directly on the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> avoiding auxiliary structures. The two main considerations
 for this builder are:</p><p>  * <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">akka.stream.scaladsl.Source</a> and <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">akka.stream.scaladsl.Flow</a> contain an unwired output port. Yet, we would
    like to build the traversal directly as much as possible, even though the builder is not yet completed
  * <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span>s might be included in a linear chain. These cannot provide a
    traversal before they are fully completed.</p><p> The linear builder, although it is one class, comes in basically two flavors:</p><p>  * Purely linear builder: this contains only other linear builders, or all the composites that it includes
    have been fully wired before and hence their traversal is now fully incorporated. Basically this kind
    of builder only contains the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> and only a couple of extra fields.
  * Linear builder with an incomplete composite at the end (output): In this case, we have an incomplete composite.
    It can only be at the end, since this is the only position where an output port can be unwired. We need to
    carry this builder with us until the output port is finally wired, in which case we incorporate its traversal
    into the already complete one, and hopefully transition to a purely linear builder.</p><p> If we consider the purely linear case, we still need to figure out how can we provide a traversal even though
 the last output port is unwired. The trick that is used is to wire this output port optimistically to the
 relative address -1 which is almost always correct (why -1? explained a bit later). If it turns out to be incorrect
 later, we fix it by the helper method <span class="extype" name="akka.stream.impl.Traversal.rewireFirstTo()">akka.stream.impl.Traversal.rewireFirstTo()</span> which tears down the traversal
 until the wrong module is found, then fixes the port assignment. This is only possible on purely linear layouts though.
 Again, this is an example of the 90% rule. Most appends will not need this rewiring and hence be as fast as possible
 while the rarer cases suffering a minor penalty.</p><p> In the case where the last module is a composite, the above trick would not work as nothing guarantees that the
 module that exposed its output port is at an expected position in the traversal. Instead, we simply keep around
 this composite and delay construction of its part of the traversal. For details see <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span>
 as these cases are heavily commented and explained in the code.</p><p> There is another peculiarity of the linear builder we need to explain. Namely, it builds the traversal in reverse
 order, i.e. from Sinks towards Sources. THIS CAN BE SUPER CONFUSING AT TIMES SO PAY ATTENTION! There are two
 important reasons why this is needed:</p><p>  * Prepending to immutable lists is more efficient. Even though we encode our traversal list as a tree, we would
    need stack space at materialization time as much as the length of the list if we would append to it instead of
    prepending.
  * Prepending means that most output ports refer to slots visited before, i.e. output relative offsets are negative.
    This means that during materialization, output ports will be wired to slots that the materializer visited before
    which enables an efficient one-pass materialization design. The importance of this is discussed later below.</p><p> To visualize this, imagine a simple stream:</p><p>   [Source.out] -&gt; [Map.in, Map.out] -&gt; [Sink.in]</p><p> The traversal:</p><p>    offs = 0         offs = 1                      offs = 1
   [Sink.in = 0] &lt;- [Map.in = 1, Map.out = -1] &lt;- [Source.out = -1]</p><p> Since the traversal steps are reversed compared to the DSL order, it is important to reverse materialized value
 computation, too.</p><h4> Islands and local slots </h4><p> All what we have discussed so far referred to the &quot;mental array&quot;, the global address space in which slots
 are assigned to ports. This model describes the wiring of the graph perfectly, but it does not map to the local
 data structures needed by materialization when there are islands present. One of the important goals of this
 layout data structure is to be able to produce the data structures used by the <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span>
 directly, without much translation. Unfortunately if there is an island inside a traversal, it might leave gaps
 in the address space:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> Since we visit Island2 before returning to Island1, the naive approach would leave a large gap between the last
 input port visited before entering Island2 and the first input port visited when returning to Island1. What
 we would like to have instead is a contiguous slot assignment from the viewpoint of Island1. This is where
 <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span> and its <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> helper comes into
 the picture. These classes do the heavy-lifting of traversing the traversal and then mapping global slots to
 slots local to the island, delegating then the local wiring to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> implementations.
 For example the <span class="extype" name="akka.stream.impl.GraphStageIsland">akka.stream.impl.GraphStageIsland</span> sees only a contigous slot-space and hence it can directly
 construct the array for the interpreter. It is not aware of the presence of other islands or how it is represented
 in the global slot-space.</p><h4> Materialization </h4><p> Materialzation is orchestrated by the <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span>. It basically decodes the
 traversal and handles islands. This top-level materializer does not really handle the wiring _inside_ an island,
 it only handles wiring of Publishers and Subscribers that connect islands. Instead it delegates in-island wiring
 to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>s. For example a default fused island will be actually wired by
 <span class="extype" name="akka.stream.impl.GraphStageIsland">akka.stream.impl.GraphStageIsland</span>.</p><p> First, look at a traversal that has two islands:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this traversal, we have two islands, and three, so called _segments_. Segments are simply contiguous range of
 slots between <span class="extype" name="akka.stream.impl.EnterIsland">akka.stream.impl.EnterIsland</span> or <span class="extype" name="akka.stream.impl.ExitIsland">akka.stream.impl.ExitIsland</span> tags (in any combination). When
 the materializer encounters either an enter or exit command, it saves various information about the segment it
 just completed (what is its offset, how long it is measured in input slots, etc.). This information is later
 used to figure out if a wiring crosses island boundaries or is it local to the island.</p><p> It is important to note that the data structure for this is only allocated when there are islands. This is again
 the 90% rule in action. In addition, these data structures are <a href="https://docs.oracle.com/javase/11/docs/api/java/util/ArrayList.html" class="extype" name="java.util.ArrayList">java.util.ArrayList</a> instances, where lookups
 according to some value are implemented as simple linear scans. Since in 90% of the cases these structures are
 very short, this is the most efficient approach. Cases where this can be a performance problem are very-very special
 and likely not happen in practice (no graph should contain more than a dozen of islands for example).</p><p> When it comes to deciding whether a wiring is cross-island or local, there are two cases possible:</p><p>  * we encountered an output port that is wired backwards (relative address is negative). In this case we already
    have all the data necessary to resolve the question.
  * we encountered an output port that is wired forward (relative address is positive). In this case we have not
    yet visited that part of the traversal where the assignment points.</p><p> If we want to keep the one-pass design of the materializer, we need to delay forward wirings until we have all
 the information needed, i.e. we visit the target in port. The <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span>
 has a data structure for tracking forward wires which it consults whenever it visits an input port. Again, this
 is only allocated if needed, and it is again an array with linear scan lookup. Once the target input port have
 been found, the rules of the wiring are the same as for backwards wiring.</p><p>       backward wire (to the visited part) &lt;------+ +------&gt; forward wire (into the unknown)
                                                  | |
  |----Island1-----|----Island2(enclosed)-------- ... (this is where we are now)</p><p> Remember, the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> builds its <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> in backwards
 order, so since most of the graphs are constructed by the linear DSLs almost all wirings will be backwards
 (90% rule in action again).</p><h5> Backward wirings </h5><p> When it comes to resolving wirings and calculating the local slots for all the islands involved there are three
 distinct cases.</p><p> A wiring can be in-segment:</p><p>                        +--------------+
                        |              |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means that the slot assigned to the output port still belongs to the current segment. This is easy to detect
 as the <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> class tracks the offset of the current segment. If the target input
 slot is larger or equal than this offset, and the wiring is backwards, then the wiring is strictly local to the
 island. The materializer will simply delegate to the <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> to do the internal wiring.
 Since we know the offset of the segment in the local space of this island, calculating the local slot for the
 <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> is simple. (This is fully documented with diagrams
 in <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>)</p><p> A wiring can be cross-segment, in-island:</p><p>               +---------------------------------+
               |                                 |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this case, the target slot is in another, but already visited segment. The <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>
 class needs to first find the segment in which the target slot is. Since each segment keeps a reference to its
 <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> instance that handles the internal wiring a simple reference equality check
 will tell us if the target segment is in the same island or not. In this case it is, so all we need is to
 compensate for any possible holes (punched by enclosed islands) to calculate the local slot for the island
 and call the appropriate callback on the <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>. (This is fully documented with diagrams
 in <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>)</p><p> Finally a wiring can be cross-segment, cross-island:</p><p>                        +------------------------+
                        |                        |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means, that the steps were similar as in the previous case until that point where we check the reference
 equality of the current <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> with that of the target segment (we have already found
 the target segment). In this case, we need to calculate the local slot in the target island (similar to the
 previous case) and try to wire the two islands together. Now, instead of delegating the wiring to the phases, we
 ask the output <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> to provide a Publisher and then we ask the target island to
 take this Publisher.</p><p> Refer to <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> for all the nasty details of local slot resolution. It is also
 recommended to try out a few examples with <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer.Debug">akka.stream.impl.PhasedFusingActorMaterializer.Debug</span> turned on, it
 will detail every step of the island tracking and slot resolution steps.</p><h4> Utilities </h4><p> Useful utilities are:</p><p>  * <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer.Debug">akka.stream.impl.PhasedFusingActorMaterializer.Debug</span>: if this flag is turned on, the materializer will
    log the steps it takes
  * <span class="extype" name="akka.stream.impl.TraversalBuilder.printTraversal()">akka.stream.impl.TraversalBuilder.printTraversal()</span>: Prints the Traversal in a readable format
  * <span class="extype" name="akka.stream.impl.TraversalBuilder.printWiring()">akka.stream.impl.TraversalBuilder.printWiring()</span>: Prints the calculated port assignments. Useful for
    debugging if everything is wired to the right thing.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.impl.streamref" visbl="pub" class="indented4 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="streamref"></a><a id="streamref:streamref"></a>
      <span class="permalink">
      <a href="../../../akka/stream/impl/index.html#streamref" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="streamref/index.html"><span class="name">streamref</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="javadsl"></a><a id="javadsl:javadsl"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#javadsl" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../javadsl/index.html"><span class="name">javadsl</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.scaladsl" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scaladsl"></a><a id="scaladsl:scaladsl"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#scaladsl" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Scala API: The flow DSL allows the formulation of stream transformations based on some input." href="../scaladsl/index.html"><span class="name">scaladsl</span></a>
      </span>
      
      <p class="shortcomment cmt">Scala API: The flow DSL allows the formulation of stream transformations based on some
input.</p><div class="fullcomment"><div class="comment cmt"><p>Scala API: The flow DSL allows the formulation of stream transformations based on some
input. The starting point is called <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">Source</a> and can be a collection, an iterator,
a block of code which is evaluated repeatedly or a <span class="extype" name="org.reactivestreams.Publisher">org.reactivestreams.Publisher</span>.
A flow with an attached input and open output is also a <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">Source</a>.</p><p>A flow may also be defined without an attached input or output and that is then
a <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">Flow</a>. The <code>Flow</code> can be connected to the <code>Source</code> later by using <a href="../scaladsl/Source.html#via[T,Mat2](flow:akka.stream.Graph[akka.stream.FlowShape[Out,T],Mat2]):Source.this.Repr[T]" class="extmbr" name="akka.stream.scaladsl.Source#via">Source#via</a> with
the flow as argument, and it remains a <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">Source</a>.</p><p>Transformations can be appended to <code>Source</code> and <code>Flow</code> with the operations
defined in <a href="../scaladsl/FlowOps.html" class="extype" name="akka.stream.scaladsl.FlowOps">FlowOps</a>. Each DSL element produces a new flow that can be further transformed,
building up a description of the complete transformation pipeline.</p><p>The termination point of a flow is called <a href="../scaladsl/Sink.html" class="extype" name="akka.stream.scaladsl.Sink">Sink</a> and can for example be a <code>Future</code> or
<span class="extype" name="org.reactivestreams.Subscriber">org.reactivestreams.Subscriber</span>. A flow with an attached output and open input
is also a <a href="../scaladsl/Sink.html" class="extype" name="akka.stream.scaladsl.Sink">Sink</a>.</p><p>If a flow has both an attached input and an attached output it becomes a <a href="../scaladsl/RunnableGraph.html" class="extype" name="akka.stream.scaladsl.RunnableGraph">RunnableGraph</a>.
In order to execute this pipeline the flow must be materialized by calling <a href="../scaladsl/RunnableGraph.html#run()(implicitmaterializer:akka.stream.Materializer):Mat" class="extmbr" name="akka.stream.scaladsl.RunnableGraph#run">RunnableGraph#run</a> on it.</p><p>You can create your <code>Source</code>, <code>Flow</code> and <code>Sink</code> in any order and then wire them together before
they are materialized by connecting them using <a href="../scaladsl/Flow.html#via[T,Mat2](flow:akka.stream.Graph[akka.stream.FlowShape[Out,T],Mat2]):Flow.this.Repr[T]" class="extmbr" name="akka.stream.scaladsl.Flow#via">Flow#via</a> and <a href="../scaladsl/Flow.html#to[Mat2](sink:akka.stream.Graph[akka.stream.SinkShape[Out],Mat2]):akka.stream.scaladsl.Sink[In,Mat]" class="extmbr" name="akka.stream.scaladsl.Flow#to">Flow#to</a>, or connecting them into a
<a href="../scaladsl/GraphDSL$.html" class="extype" name="akka.stream.scaladsl.GraphDSL">GraphDSL</a> with fan-in and fan-out elements.</p><p>See <a href="https://github.com/reactive-streams/reactive-streams/">Reactive Streams</a> for
details on <span class="extype" name="org.reactivestreams.Publisher">org.reactivestreams.Publisher</span> and <span class="extype" name="org.reactivestreams.Subscriber">org.reactivestreams.Subscriber</span>.</p><p>It should be noted that the streams modeled by this library are “hot”,
meaning that they asynchronously flow through a series of processors without
detailed control by the user. In particular it is not predictable how many
elements a given transformation step might buffer before handing elements
downstream, which means that transformation functions may be invoked more
often than for corresponding transformations on strict collections like
<span class="extype" name="List">List</span>. *An important consequence* is that elements that were produced
into a stream may be discarded by later processors, e.g. when using the
<span class="extype" name="#take">#take</span> operator.</p><p>By default every operation is executed within its own <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">akka.actor.Actor</a>
to enable full pipelining of the chained set of computations. This behavior
is determined by the <a href="../Materializer.html" class="extype" name="akka.stream.Materializer">akka.stream.Materializer</a> which is required
by those methods that materialize the Flow into a series of
<span class="extype" name="org.reactivestreams.Processor">org.reactivestreams.Processor</span> instances. The returned reactive stream
is fully started and active.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.snapshot" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="snapshot"></a><a id="snapshot:snapshot"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#snapshot" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../snapshot/index.html"><span class="name">snapshot</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.stage" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stage"></a><a id="stage:stage"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#stage" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../stage/index.html"><span class="name">stage</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.testkit" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="testkit"></a><a id="testkit:testkit"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#testkit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../testkit/index.html"><span class="name">testkit</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.typed" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="typed"></a><a id="typed:typed"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#typed" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../typed/index.html"><span class="name">typed</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../../index.html" class="extype" name="akka">akka</a>.<a href="../index.html" class="extype" name="akka.stream">stream</a></p>
        <h1>impl<span class="permalink">
      <a href="../../../akka/stream/impl/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">impl</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>The architecture of Akka Streams internally consists of several distinct layers:</p><p> * The DSLs like <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">akka.stream.scaladsl.Flow</a>, <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">akka.stream.scaladsl.Source</a> etc. are the user facing API
   for composing streams. These DSLs are a thin wrappers around the internal <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span>
   builder classes. There are Java alternatives of these DSLs in <a href="../javadsl/index.html" class="extype" name="akka.stream.javadsl">javadsl</a> which basically wrap their scala
   counterpart, delegating method calls.
 * The <a href="../stage/GraphStage.html" class="extype" name="akka.stream.stage.GraphStage">akka.stream.stage.GraphStage</a> API is the user facing API for creating new stream operators. These
   classes are used by the <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span> which executes islands (subgraphs) of these
   operators
 * The high level DSLs use the <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span> classes to build instances of
   <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> which are the representation of a materializable stream description. These builders
   are immutable and safely shareable. Unlike the top-level DSLs, these are untyped, i.e. elements are treated as
   Any.
 * The <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> is the immutable, efficient representation of a stream processing graph that
   can be materialized. The builders exists solely for the purpose of producing a traversal in the end.
 * The <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span> is the class that is responsible for traversing and
   interpreting a <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span>. It delegates the actual task of creating executable entities
   and Publishers/Producers to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>s which are plugins that understand atomic operators
   in the graph and able to turn them into executable entities.
 * The <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span> and its actor backed wrapper <span class="extype" name="akka.stream.impl.fusing.ActorGraphInterpreter">akka.stream.impl.fusing.ActorGraphInterpreter</span>
   are used to execute synchronous islands (subgraphs) of <a href="../stage/GraphStage.html" class="extype" name="akka.stream.stage.GraphStage">akka.stream.stage.GraphStage</a>s.</p><p>For the execution layer, refer to <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span>.</p><h4> Design goals </h4><p>The central piece for both the DSLs and materialization is the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span>. This is the
representation of an Akka Stream, basically a <a href="../scaladsl/RunnableGraph.html" class="extype" name="akka.stream.scaladsl.RunnableGraph">akka.stream.scaladsl.RunnableGraph</a>. The design goals
for <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> are:</p><p>  * Be able to materialize a graph in one pass over the traversal
  * Unify materialization and fusing. The materializer should be able to construct all the necessary data structures
    for the interpreters and for connecting them in one go.
  * Avoid allocations as much as possible.
  * Biased implementation for the 90% case. Common cases should be as fast as possible:
    * wiring linear chains should be very fast.
    * assume that most graphs are mostly linear, with only a few generalized graph constructs thrown in.
    * materialization should not pay the price of island tracking if there is only a single island
    * assume that the number of islands is low in general
    * avoid &quot;copiedModule&quot; i.e. wrappers that exist solely for the purpose of establishing new port identities
      for operators that are used multiple times in the same graph.
  * Avoid hashmaps and prefer direct array lookup wherever possible</p><p>Semantically, a traversal is a list of commands that the materializer must execute to turn the description to a
running stream. In fact, the traversal is nothing more than an immutable list, that is expressed as a tree. A
tree is used to make immutable appends fast (immutable lists only have prepend as O(1) operation, append is O(N)).
The materializer &quot;recovers&quot; the original sequence by using a local, mutable stack to properly traverse the tree
structure. This is way cheaper than to immutably append to the traversal at each addition.</p><p>The &quot;tree-ness&quot; is expressed by explicit <span class="extype" name="akka.stream.impl.Concat">akka.stream.impl.Concat</span> nodes that express that two traversals
need to be traversed in a certain sequence, stashing away the second on a local stack until the first is fully
traversed.</p><p>While traversing the traversal (basically following Concat nodes), the materializer will visit the following
command types:</p><p> * <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>: An atomic module needs to be materialized. This node also contains
   wiring information which we discuss later.
 * Materialized value computation. This is a stack based &quot;sublanguage&quot; to compute the final materialized value
   on a stack, maintained by the materializer
   * <span class="extype" name="akka.stream.impl.PushNotUsed">akka.stream.impl.PushNotUsed</span> push a NotUsed value on the stack
   * <span class="extype" name="akka.stream.impl.Pop">akka.stream.impl.Pop</span> pop the top of the stack and throw away
   * <span class="extype" name="akka.stream.impl.Transform">akka.stream.impl.Transform</span> take the top of the stack, transform it with the provided function and put
     the result back on the top of the stack
   * <span class="extype" name="akka.stream.impl.Compose">akka.stream.impl.Compose</span> take the top two values of the stack, invoke the provided function with these
     values as arguments, then put the calculated value on the top of the stack
   * Materialized values of atomic operators when visiting a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> must be
     pushed to the stack automatically. There are no explicit PUSH commands for this
 * Attributes calculation. These also are a stack language, although much simpler than the materialized value
    commands. For any materialized operator, the top of the attributes stack should be provided as the current
    effective attributes.
   * <span class="extype" name="akka.stream.impl.PushAttributes">akka.stream.impl.PushAttributes</span> combines the attributes on the top of the stack with the given ones and
     puts the result on the attributes stack
   * <span class="extype" name="akka.stream.impl.PopAttributes">akka.stream.impl.PopAttributes</span> removes the top of the attributes stack.
 * Island tracking. Islands serve two purposes. First, they allow a large graph to be cut into parts that execute
   concurrently with each other, using asynchronous message passing between themselves. Second, they are an
   extension point where &quot;plugins&quot; (<span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>) can be used to specially handle subgraphs.
   Islands can be nested in each other. This makes &quot;holes&quot; in the parent island. Islands also need a stack
   as exiting a &quot;hole&quot; means returning to the parent, enclosing island and continuing where left.
    * <span class="extype" name="akka.stream.impl.EnterIsland">akka.stream.impl.EnterIsland</span> instructs the materializer that the following commands will belong to
      the materialization of a new island (a subgraph). The <span class="extype" name="akka.stream.impl.IslandTag">akka.stream.impl.IslandTag</span> signals to
      the materializer which <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> should be used to turn operators of this island into
      executable entities.
    * <span class="extype" name="akka.stream.impl.ExitIsland">akka.stream.impl.ExitIsland</span> instructs the materializer that the current island is done and the parent
      island is now the active one again.</p><p> Please note that the stack based materialized value computation eliminates the issues present in the older
 materializer which expressed these computations as an AST. We had to use optimizations for this tree so that
 long Keep.left chains don't explode the stack visiting a large AST. The stack based language sidesteps this issue
 completely as the number of these commands don't increase the stack space required to execute them, unless the
 computation itself requires it (which is not the case in any sane stream combination).</p><h4> Graph model, offsets, slots </h4><p> As a mental model, the wiring part of the Traversal (i.e. excluding the stack based sub-commands tracking
 materialized values, attributes, islands, i.e. things that don't contribute to the wiring structure of the graph)
 translates everything to a single, global, contiguous Array. Every input and output port of each operator is mapped
 to exactly one slot of this &quot;mental array&quot;. Input and output ports that are considered wired together simply map
 to the same slot. (In practice, these slots might not be mapped to an actual global array, but multiple local arrays
 using some translation logic, but we will explain this later)</p><p> Input ports are mapped simply to contiguous numbers in the order they are visited. Take for example a simple
 traversal:</p><p>   Operator1[in1, in2, out] - Operator2[out] - Operator3[in]</p><p> This results in the following slot assignments:</p><p>   * Operator1.in1 -&gt; 0
   * Operator1.in2 -&gt; 1
   * Operator3.in  -&gt; 2</p><p> The materializer simply visits Stage1, Stage2, Stage3 in order, visiting the input ports of each operator in order.
 It then simply assigns numbers from a counter that is incremented after visiting an input port.
 (Please note that all <span class="extype" name="akka.stream.impl.StreamLayout.AtomicModule">akka.stream.impl.StreamLayout.AtomicModule</span>s maintain a stable order of their ports, so
 this global ordering is well defined)</p><p> Before explaining how output wiring works, it is important to settle some terminology. When we talk about ports
 we refer to their location in the &quot;mental array&quot; as slots. However, there are other entities that needs to
 reference various positions in this &quot;mental array&quot;, but in these cases we use the term _offset_ to signify that
 these are only used for bookkeeping, they have no &quot;place&quot; in the &quot;array&quot; themselves. In particular:</p><p>  * offset of a module: The offset of an <span class="extype" name="akka.stream.impl.StreamLayout.AtomicModule">akka.stream.impl.StreamLayout.AtomicModule</span> is defined as the value of
    the input port counter when visiting the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node to materialize that module.
    In other words, the offset of a module is the slot of its first input port (if there is any). Since modules
    might not have any input ports it can be that different modules share the same offset, simply because the
    the first one visited does not increase the input port counter.
  * offset of segments, islands: Defined similarly to module. The offset of an island or a segment is simply the
    value of the input port counter (or the first unallocated slot).</p><p> For example:</p><p>   Module1[in1 = 0, in2 = 1] - Module2[out] - Module3[in = 2]</p><p> The offset of Module1 is 0, while Module2 and Module3 share the same offset of 2. Note that only input ports (slots)
 contribute to the offset of a module in a traversal.</p><p> Output ports are wired relative to the offset of the module they are contained in. When the materializer visits
 a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node, it contains an Array that maps ports to a relative offset. To
 calculate the slot that is assigned to an output port the following formula is used:</p><p>   slot = offsetOfModule + outToSlots(out.id)</p><p> Where outToSlots is the array contained in the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node.</p><h4> Relative addressing </h4><p> The power of this structure comes from the fact that slots are assigned in a relative manner:</p><p>  * input ports are assigned in sequence so the slots assigned to the input ports of a subgraph depend on the
    subgraph's position in the traversal
  * output ports are assigned relative to the offset of their owner module, which is in turn relative to its first
    (potential) input port (which is relative, too, because of the previous point)</p><p> This setup allows combining subgraphs without touching their internal wirings as all their internal wirings will
 properly resolve due to everything being relative:</p><p>      +---------------+                     +----+
      |               |                     |    |
   |---------Graph1---------|--- .... ---|----Graph2----|</p><p> It is important to note that due to reusability, an Akka Stream graph may contain the same atomic or composite
 multiple times in the same graph. Since these must be distinguished from each other somehow, they need port mapping
 (i.e. a new set of ports) to ensure that the ports of one graph are distinguishable from another. Because how
 the traversal relative addressing works, these are _temporary_ though, once all internal wirings are ready, these
 mappings can be effectively dropped as the global slot assignments uniquely identify what is wired to what. For
 example since Graph1 is visited before Graph2 all of the slots or offsets it uses are different from Graph2 leaving
 no room for misinterpretation.</p><h4> Port mapping </h4><p> Port mapping is the way how the DSL can distinguish between multiple instances of the same graph included multiple
 times. For example in the Graph DSL:</p><p>   val merge1 = builder.add(Merge)
   val merge2 = builder.add(Merge)</p><p> the port merge1.out must be different from merge2.out.</p><p> For efficiency reasons, the linear and graph DSLs use different <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span> types to
 build the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> (we will discuss these next). One of the differences between the two
 builders are their approach to port mapping.</p><p> The simpler case is the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span>. This builder only allows building linear
 chains of operators, hence, it can only have at most one <a href="../OutPort.html" class="extype" name="akka.stream.OutPort">OutPort</a> and <a href="../InPort.html" class="extype" name="akka.stream.InPort">InPort</a> unwired. Since there is no
 possible ambiguity between these two port types, there is no need for port mapping for these. Conversely,
 for those internal ports that are already wired, there is no need for port mapping as their relative wiring
 is not ambiguous (see previous section). As a result, the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> does not
 use any port mapping.</p><p> The generic graph builder class <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> needs port mapping as it allows
 adding any kind of builders in any order. When adding a module (encoded as another <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span>)
 there are two entities in play:</p><p>  * The module (builder) to be added. This builder has a few ports unwired which are usually packaged in a <a href="../Shape.html" class="extype" name="akka.stream.Shape">Shape</a>
    which is stored alongside with the builder in the <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a> of the DSL. When invoking methods on this builder
    these set of ports must be used.
  * The module that we are growing. This module needs a new set of ports to be used as it might add this module
    multiple times and needs to disambiguate these ports.</p><p> Adding to the <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> involves the following steps (pseudocode):</p><p>    val newShape = shape.deepCopy() // Copy the shape of the module we want to add
    val newBuilder = builder.add(submodule, newShape) // Add the module, and register it with the new shape
    newBuilder.wire(newShape.in, ...) // Use the new ports to wire</p><p> What happens in the background is that <span class="extype" name="Shape.deepCopy()">Shape.deepCopy()</span> creates copies of the ports, and fills their
 mappedTo field to point to their original port counterpart. Whenever we call wire in the outer module, it
 delegates calls to the submodule, but using the original port (as the submodule builder has no knowledge of
 the external mapping):</p><p>     submodule.assign(port.mappedTo, ...) // enclosing module delegating to submodule, translating ports back</p><p> Visualizing this relationship:</p><p>   +----------------------------------+
   | in', in&quot; ---------+              | in' and in&quot; both resolve to in
   |   | .mappedTo     v .mappedTo    | but they will be used on _different_ builders
   | +-------------+ +-------------+  |
   | | in          | | in          |  | (delegation happens recursively in AddedModule)
   | | AddedModule | | AddedModule |  |</p><p> It is worth to note that the submodule might also continue this map-and-delegate chain to further submodules until
 a builder is reached that can directly perform the operation. In other words, the depth of nesting is equal to
 the length of mappedTo chaining.</p><p> IMPORTANT: When wiring in the enclosing module the new ports/shape MUST be used, using the original ports/shape
 will lead to incorrect state.</p><h4> TraversalBuilders </h4><p> In order to understand why builders are needed, consider wiring two ports together. Actually, we don't need to
 wire input ports anywhere. Their slot is implicitly assigned by their position in the traversal, there is no
 additional state we need to track. On the other hand, we cannot build a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>
 node until the mapping array outToSlots is fully calculated. In other words, in reality, we don't wire input ports
 anywhere, we only assign output ports to slots. The builders exist mainly to keep track all the necessary
 information to be able to assign output ports, build the outToSlots array and finally the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>
 node. The consequence of this that a <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> can be constructed as soon as all output ports
 are wired (&quot;unwired&quot; inputs don't matter).</p><p> There is a specific builder that is used for the cases where all outputs have been wired:
 <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>. This builder type simply contains the completed traversal plus
 some additional data. The reason why this builder type exists is to keep auxiliary data structures required for
 output port mapping only while they are needed, and shed them as soon as they are not needed anymore. Since builders
 may recursively contain other builders, as soon as internals are completed those contained builders transition
 to completed state and drop all additional data structures. This is very GC friendly as many intermediate graphs
 exist only in a method call, and hence most of the additional data structures are dropped before method return and
 can be efficiently collected by the GC.</p><p> The most generic builder is <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span>. There are two main considerations
 this builder needs to consider:</p><p>  * Enclosed modules (builders) must have a stable position in the final traversal for relative addressing to work.
    Since module offsets are calculated by traversal position, and outputs are wired relative to module offset, this
    is critical.
  * Enclosed builders might not be complete yet (i.e. have unwired outputs) and hence they cannot immediately give
    a Traversal.</p><p> The composite builder keeps a temporary list of traversal steps (in reverse order because of immutable lists)
 it needs to create once it is completed (all outputs wired). These steps refer to the traversal of submodules
 as a <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span> which is just a placeholder where the traversal of the submodule will be
 stitched in. This <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span> is also a key to a map which contains the evolving builder.
 The importance of this &quot;preimage&quot; traversal is that it keeps position of submodules stable, making relative
 addressing possible.</p><p> Once the composite is completed, it takes these steps (now reversing it back to normal), and builds the traversal
 using the submodule traversals referred to by <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span>. Note that at this point all the
 submodules are <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>s because there are no unwired outputs and hence the
 Traversal can be assembled. As the builder evolves over time, more and more of its <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span>s
 will refer to <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>s, shedding much of the temporary data structures.</p><p> Refer to <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> for more details.</p><p> The <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> is a much simpler beast. For efficiency, it tries to work as much
 as possible directly on the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> avoiding auxiliary structures. The two main considerations
 for this builder are:</p><p>  * <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">akka.stream.scaladsl.Source</a> and <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">akka.stream.scaladsl.Flow</a> contain an unwired output port. Yet, we would
    like to build the traversal directly as much as possible, even though the builder is not yet completed
  * <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span>s might be included in a linear chain. These cannot provide a
    traversal before they are fully completed.</p><p> The linear builder, although it is one class, comes in basically two flavors:</p><p>  * Purely linear builder: this contains only other linear builders, or all the composites that it includes
    have been fully wired before and hence their traversal is now fully incorporated. Basically this kind
    of builder only contains the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> and only a couple of extra fields.
  * Linear builder with an incomplete composite at the end (output): In this case, we have an incomplete composite.
    It can only be at the end, since this is the only position where an output port can be unwired. We need to
    carry this builder with us until the output port is finally wired, in which case we incorporate its traversal
    into the already complete one, and hopefully transition to a purely linear builder.</p><p> If we consider the purely linear case, we still need to figure out how can we provide a traversal even though
 the last output port is unwired. The trick that is used is to wire this output port optimistically to the
 relative address -1 which is almost always correct (why -1? explained a bit later). If it turns out to be incorrect
 later, we fix it by the helper method <span class="extype" name="akka.stream.impl.Traversal.rewireFirstTo()">akka.stream.impl.Traversal.rewireFirstTo()</span> which tears down the traversal
 until the wrong module is found, then fixes the port assignment. This is only possible on purely linear layouts though.
 Again, this is an example of the 90% rule. Most appends will not need this rewiring and hence be as fast as possible
 while the rarer cases suffering a minor penalty.</p><p> In the case where the last module is a composite, the above trick would not work as nothing guarantees that the
 module that exposed its output port is at an expected position in the traversal. Instead, we simply keep around
 this composite and delay construction of its part of the traversal. For details see <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span>
 as these cases are heavily commented and explained in the code.</p><p> There is another peculiarity of the linear builder we need to explain. Namely, it builds the traversal in reverse
 order, i.e. from Sinks towards Sources. THIS CAN BE SUPER CONFUSING AT TIMES SO PAY ATTENTION! There are two
 important reasons why this is needed:</p><p>  * Prepending to immutable lists is more efficient. Even though we encode our traversal list as a tree, we would
    need stack space at materialization time as much as the length of the list if we would append to it instead of
    prepending.
  * Prepending means that most output ports refer to slots visited before, i.e. output relative offsets are negative.
    This means that during materialization, output ports will be wired to slots that the materializer visited before
    which enables an efficient one-pass materialization design. The importance of this is discussed later below.</p><p> To visualize this, imagine a simple stream:</p><p>   [Source.out] -&gt; [Map.in, Map.out] -&gt; [Sink.in]</p><p> The traversal:</p><p>    offs = 0         offs = 1                      offs = 1
   [Sink.in = 0] &lt;- [Map.in = 1, Map.out = -1] &lt;- [Source.out = -1]</p><p> Since the traversal steps are reversed compared to the DSL order, it is important to reverse materialized value
 computation, too.</p><h4> Islands and local slots </h4><p> All what we have discussed so far referred to the &quot;mental array&quot;, the global address space in which slots
 are assigned to ports. This model describes the wiring of the graph perfectly, but it does not map to the local
 data structures needed by materialization when there are islands present. One of the important goals of this
 layout data structure is to be able to produce the data structures used by the <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span>
 directly, without much translation. Unfortunately if there is an island inside a traversal, it might leave gaps
 in the address space:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> Since we visit Island2 before returning to Island1, the naive approach would leave a large gap between the last
 input port visited before entering Island2 and the first input port visited when returning to Island1. What
 we would like to have instead is a contiguous slot assignment from the viewpoint of Island1. This is where
 <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span> and its <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> helper comes into
 the picture. These classes do the heavy-lifting of traversing the traversal and then mapping global slots to
 slots local to the island, delegating then the local wiring to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> implementations.
 For example the <span class="extype" name="akka.stream.impl.GraphStageIsland">akka.stream.impl.GraphStageIsland</span> sees only a contigous slot-space and hence it can directly
 construct the array for the interpreter. It is not aware of the presence of other islands or how it is represented
 in the global slot-space.</p><h4> Materialization </h4><p> Materialzation is orchestrated by the <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span>. It basically decodes the
 traversal and handles islands. This top-level materializer does not really handle the wiring _inside_ an island,
 it only handles wiring of Publishers and Subscribers that connect islands. Instead it delegates in-island wiring
 to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>s. For example a default fused island will be actually wired by
 <span class="extype" name="akka.stream.impl.GraphStageIsland">akka.stream.impl.GraphStageIsland</span>.</p><p> First, look at a traversal that has two islands:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this traversal, we have two islands, and three, so called _segments_. Segments are simply contiguous range of
 slots between <span class="extype" name="akka.stream.impl.EnterIsland">akka.stream.impl.EnterIsland</span> or <span class="extype" name="akka.stream.impl.ExitIsland">akka.stream.impl.ExitIsland</span> tags (in any combination). When
 the materializer encounters either an enter or exit command, it saves various information about the segment it
 just completed (what is its offset, how long it is measured in input slots, etc.). This information is later
 used to figure out if a wiring crosses island boundaries or is it local to the island.</p><p> It is important to note that the data structure for this is only allocated when there are islands. This is again
 the 90% rule in action. In addition, these data structures are <a href="https://docs.oracle.com/javase/11/docs/api/java/util/ArrayList.html" class="extype" name="java.util.ArrayList">java.util.ArrayList</a> instances, where lookups
 according to some value are implemented as simple linear scans. Since in 90% of the cases these structures are
 very short, this is the most efficient approach. Cases where this can be a performance problem are very-very special
 and likely not happen in practice (no graph should contain more than a dozen of islands for example).</p><p> When it comes to deciding whether a wiring is cross-island or local, there are two cases possible:</p><p>  * we encountered an output port that is wired backwards (relative address is negative). In this case we already
    have all the data necessary to resolve the question.
  * we encountered an output port that is wired forward (relative address is positive). In this case we have not
    yet visited that part of the traversal where the assignment points.</p><p> If we want to keep the one-pass design of the materializer, we need to delay forward wirings until we have all
 the information needed, i.e. we visit the target in port. The <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span>
 has a data structure for tracking forward wires which it consults whenever it visits an input port. Again, this
 is only allocated if needed, and it is again an array with linear scan lookup. Once the target input port have
 been found, the rules of the wiring are the same as for backwards wiring.</p><p>       backward wire (to the visited part) &lt;------+ +------&gt; forward wire (into the unknown)
                                                  | |
  |----Island1-----|----Island2(enclosed)-------- ... (this is where we are now)</p><p> Remember, the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> builds its <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> in backwards
 order, so since most of the graphs are constructed by the linear DSLs almost all wirings will be backwards
 (90% rule in action again).</p><h5> Backward wirings </h5><p> When it comes to resolving wirings and calculating the local slots for all the islands involved there are three
 distinct cases.</p><p> A wiring can be in-segment:</p><p>                        +--------------+
                        |              |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means that the slot assigned to the output port still belongs to the current segment. This is easy to detect
 as the <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> class tracks the offset of the current segment. If the target input
 slot is larger or equal than this offset, and the wiring is backwards, then the wiring is strictly local to the
 island. The materializer will simply delegate to the <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> to do the internal wiring.
 Since we know the offset of the segment in the local space of this island, calculating the local slot for the
 <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> is simple. (This is fully documented with diagrams
 in <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>)</p><p> A wiring can be cross-segment, in-island:</p><p>               +---------------------------------+
               |                                 |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this case, the target slot is in another, but already visited segment. The <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>
 class needs to first find the segment in which the target slot is. Since each segment keeps a reference to its
 <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> instance that handles the internal wiring a simple reference equality check
 will tell us if the target segment is in the same island or not. In this case it is, so all we need is to
 compensate for any possible holes (punched by enclosed islands) to calculate the local slot for the island
 and call the appropriate callback on the <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>. (This is fully documented with diagrams
 in <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>)</p><p> Finally a wiring can be cross-segment, cross-island:</p><p>                        +------------------------+
                        |                        |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means, that the steps were similar as in the previous case until that point where we check the reference
 equality of the current <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> with that of the target segment (we have already found
 the target segment). In this case, we need to calculate the local slot in the target island (similar to the
 previous case) and try to wire the two islands together. Now, instead of delegating the wiring to the phases, we
 ask the output <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> to provide a Publisher and then we ask the target island to
 take this Publisher.</p><p> Refer to <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> for all the nasty details of local slot resolution. It is also
 recommended to try out a few examples with <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer.Debug">akka.stream.impl.PhasedFusingActorMaterializer.Debug</span> turned on, it
 will detail every step of the island tracking and slot resolution steps.</p><h4> Utilities </h4><p> Useful utilities are:</p><p>  * <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer.Debug">akka.stream.impl.PhasedFusingActorMaterializer.Debug</span>: if this flag is turned on, the materializer will
    log the steps it takes
  * <span class="extype" name="akka.stream.impl.TraversalBuilder.printTraversal()">akka.stream.impl.TraversalBuilder.printTraversal()</span>: Prints the Traversal in a readable format
  * <span class="extype" name="akka.stream.impl.TraversalBuilder.printWiring()">akka.stream.impl.TraversalBuilder.printWiring()</span>: Prints the calculated port assignments. Useful for
    debugging if everything is wired to the right thing.</p></div><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/akka/akka/tree/v2.5.28//akka-stream/src/main/scala/akka/stream/impl/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a>, <a href="http://www.scala-lang.org/api/2.12.8/scala/Any.html#scala.Any" class="extype" name="scala.Any">Any</a></div>
        </div></div>
        

      

      <div id="template">
        <div id="allMembers">
        

        

        

        

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.8/scala/Any.html#scala.Any" class="extype" name="scala.Any">Any</a></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
