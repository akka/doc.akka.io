<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Akka 2.5.30 - akka.stream.javadsl</title>
          <meta name="description" content="Akka 2.5.30 - akka.stream.javadsl" />
          <meta name="keywords" content="Akka 2.5.30 akka.stream.javadsl" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      <script type="text/javascript" src="../../../lib/modernizr.custom.js"></script><script type="text/javascript" src="../../../lib/diagrams.js" id="diagrams-js"></script>
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Akka<span id="doc-version">2.5.30</span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.akka" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="akka"></a><a id="akka:akka"></a>
      <span class="permalink">
      <a href="index.html#akka" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">akka</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="akka.stream" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stream"></a><a id="stream:stream"></a>
      <span class="permalink">
      <a href="../akka/index.html#stream" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">stream</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="akka">akka</a></dd></dl></div>
    </li><li name="akka.stream.actor" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="actor"></a><a id="actor:actor"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#actor" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../actor/index.html"><span class="name">actor</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.extra" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="extra"></a><a id="extra:extra"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#extra" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../extra/index.html"><span class="name">extra</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.impl" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="impl"></a><a id="impl:impl"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#impl" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="The architecture of Akka Streams internally consists of several distinct layers:" href="../impl/index.html"><span class="name">impl</span></a>
      </span>
      
      <p class="shortcomment cmt">The architecture of Akka Streams internally consists of several distinct layers:</p><div class="fullcomment"><div class="comment cmt"><p>The architecture of Akka Streams internally consists of several distinct layers:</p><p> * The DSLs like <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">akka.stream.scaladsl.Flow</a>, <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">akka.stream.scaladsl.Source</a> etc. are the user facing API
   for composing streams. These DSLs are a thin wrappers around the internal <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span>
   builder classes. There are Java alternatives of these DSLs in <a href="" class="extype" name="akka.stream.javadsl">javadsl</a> which basically wrap their scala
   counterpart, delegating method calls.
 * The <a href="../stage/GraphStage.html" class="extype" name="akka.stream.stage.GraphStage">akka.stream.stage.GraphStage</a> API is the user facing API for creating new stream operators. These
   classes are used by the <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span> which executes islands (subgraphs) of these
   operators
 * The high level DSLs use the <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span> classes to build instances of
   <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> which are the representation of a materializable stream description. These builders
   are immutable and safely shareable. Unlike the top-level DSLs, these are untyped, i.e. elements are treated as
   Any.
 * The <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> is the immutable, efficient representation of a stream processing graph that
   can be materialized. The builders exists solely for the purpose of producing a traversal in the end.
 * The <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span> is the class that is responsible for traversing and
   interpreting a <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span>. It delegates the actual task of creating executable entities
   and Publishers/Producers to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>s which are plugins that understand atomic operators
   in the graph and able to turn them into executable entities.
 * The <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span> and its actor backed wrapper <span class="extype" name="akka.stream.impl.fusing.ActorGraphInterpreter">akka.stream.impl.fusing.ActorGraphInterpreter</span>
   are used to execute synchronous islands (subgraphs) of <a href="../stage/GraphStage.html" class="extype" name="akka.stream.stage.GraphStage">akka.stream.stage.GraphStage</a>s.</p><p>For the execution layer, refer to <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span>.</p><h4> Design goals </h4><p>The central piece for both the DSLs and materialization is the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span>. This is the
representation of an Akka Stream, basically a <a href="../scaladsl/RunnableGraph.html" class="extype" name="akka.stream.scaladsl.RunnableGraph">akka.stream.scaladsl.RunnableGraph</a>. The design goals
for <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> are:</p><p>  * Be able to materialize a graph in one pass over the traversal
  * Unify materialization and fusing. The materializer should be able to construct all the necessary data structures
    for the interpreters and for connecting them in one go.
  * Avoid allocations as much as possible.
  * Biased implementation for the 90% case. Common cases should be as fast as possible:
    * wiring linear chains should be very fast.
    * assume that most graphs are mostly linear, with only a few generalized graph constructs thrown in.
    * materialization should not pay the price of island tracking if there is only a single island
    * assume that the number of islands is low in general
    * avoid &quot;copiedModule&quot; i.e. wrappers that exist solely for the purpose of establishing new port identities
      for operators that are used multiple times in the same graph.
  * Avoid hashmaps and prefer direct array lookup wherever possible</p><p>Semantically, a traversal is a list of commands that the materializer must execute to turn the description to a
running stream. In fact, the traversal is nothing more than an immutable list, that is expressed as a tree. A
tree is used to make immutable appends fast (immutable lists only have prepend as O(1) operation, append is O(N)).
The materializer &quot;recovers&quot; the original sequence by using a local, mutable stack to properly traverse the tree
structure. This is way cheaper than to immutably append to the traversal at each addition.</p><p>The &quot;tree-ness&quot; is expressed by explicit <span class="extype" name="akka.stream.impl.Concat">akka.stream.impl.Concat</span> nodes that express that two traversals
need to be traversed in a certain sequence, stashing away the second on a local stack until the first is fully
traversed.</p><p>While traversing the traversal (basically following Concat nodes), the materializer will visit the following
command types:</p><p> * <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>: An atomic module needs to be materialized. This node also contains
   wiring information which we discuss later.
 * Materialized value computation. This is a stack based &quot;sublanguage&quot; to compute the final materialized value
   on a stack, maintained by the materializer
   * <span class="extype" name="akka.stream.impl.PushNotUsed">akka.stream.impl.PushNotUsed</span> push a NotUsed value on the stack
   * <span class="extype" name="akka.stream.impl.Pop">akka.stream.impl.Pop</span> pop the top of the stack and throw away
   * <span class="extype" name="akka.stream.impl.Transform">akka.stream.impl.Transform</span> take the top of the stack, transform it with the provided function and put
     the result back on the top of the stack
   * <span class="extype" name="akka.stream.impl.Compose">akka.stream.impl.Compose</span> take the top two values of the stack, invoke the provided function with these
     values as arguments, then put the calculated value on the top of the stack
   * Materialized values of atomic operators when visiting a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> must be
     pushed to the stack automatically. There are no explicit PUSH commands for this
 * Attributes calculation. These also are a stack language, although much simpler than the materialized value
    commands. For any materialized operator, the top of the attributes stack should be provided as the current
    effective attributes.
   * <span class="extype" name="akka.stream.impl.PushAttributes">akka.stream.impl.PushAttributes</span> combines the attributes on the top of the stack with the given ones and
     puts the result on the attributes stack
   * <span class="extype" name="akka.stream.impl.PopAttributes">akka.stream.impl.PopAttributes</span> removes the top of the attributes stack.
 * Island tracking. Islands serve two purposes. First, they allow a large graph to be cut into parts that execute
   concurrently with each other, using asynchronous message passing between themselves. Second, they are an
   extension point where &quot;plugins&quot; (<span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>) can be used to specially handle subgraphs.
   Islands can be nested in each other. This makes &quot;holes&quot; in the parent island. Islands also need a stack
   as exiting a &quot;hole&quot; means returning to the parent, enclosing island and continuing where left.
    * <span class="extype" name="akka.stream.impl.EnterIsland">akka.stream.impl.EnterIsland</span> instructs the materializer that the following commands will belong to
      the materialization of a new island (a subgraph). The <span class="extype" name="akka.stream.impl.IslandTag">akka.stream.impl.IslandTag</span> signals to
      the materializer which <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> should be used to turn operators of this island into
      executable entities.
    * <span class="extype" name="akka.stream.impl.ExitIsland">akka.stream.impl.ExitIsland</span> instructs the materializer that the current island is done and the parent
      island is now the active one again.</p><p> Please note that the stack based materialized value computation eliminates the issues present in the older
 materializer which expressed these computations as an AST. We had to use optimizations for this tree so that
 long Keep.left chains don't explode the stack visiting a large AST. The stack based language sidesteps this issue
 completely as the number of these commands don't increase the stack space required to execute them, unless the
 computation itself requires it (which is not the case in any sane stream combination).</p><h4> Graph model, offsets, slots </h4><p> As a mental model, the wiring part of the Traversal (i.e. excluding the stack based sub-commands tracking
 materialized values, attributes, islands, i.e. things that don't contribute to the wiring structure of the graph)
 translates everything to a single, global, contiguous Array. Every input and output port of each operator is mapped
 to exactly one slot of this &quot;mental array&quot;. Input and output ports that are considered wired together simply map
 to the same slot. (In practice, these slots might not be mapped to an actual global array, but multiple local arrays
 using some translation logic, but we will explain this later)</p><p> Input ports are mapped simply to contiguous numbers in the order they are visited. Take for example a simple
 traversal:</p><p>   Operator1[in1, in2, out] - Operator2[out] - Operator3[in]</p><p> This results in the following slot assignments:</p><p>   * Operator1.in1 -&gt; 0
   * Operator1.in2 -&gt; 1
   * Operator3.in  -&gt; 2</p><p> The materializer simply visits Stage1, Stage2, Stage3 in order, visiting the input ports of each operator in order.
 It then simply assigns numbers from a counter that is incremented after visiting an input port.
 (Please note that all <span class="extype" name="akka.stream.impl.StreamLayout.AtomicModule">akka.stream.impl.StreamLayout.AtomicModule</span>s maintain a stable order of their ports, so
 this global ordering is well defined)</p><p> Before explaining how output wiring works, it is important to settle some terminology. When we talk about ports
 we refer to their location in the &quot;mental array&quot; as slots. However, there are other entities that needs to
 reference various positions in this &quot;mental array&quot;, but in these cases we use the term _offset_ to signify that
 these are only used for bookkeeping, they have no &quot;place&quot; in the &quot;array&quot; themselves. In particular:</p><p>  * offset of a module: The offset of an <span class="extype" name="akka.stream.impl.StreamLayout.AtomicModule">akka.stream.impl.StreamLayout.AtomicModule</span> is defined as the value of
    the input port counter when visiting the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node to materialize that module.
    In other words, the offset of a module is the slot of its first input port (if there is any). Since modules
    might not have any input ports it can be that different modules share the same offset, simply because the
    the first one visited does not increase the input port counter.
  * offset of segments, islands: Defined similarly to module. The offset of an island or a segment is simply the
    value of the input port counter (or the first unallocated slot).</p><p> For example:</p><p>   Module1[in1 = 0, in2 = 1] - Module2[out] - Module3[in = 2]</p><p> The offset of Module1 is 0, while Module2 and Module3 share the same offset of 2. Note that only input ports (slots)
 contribute to the offset of a module in a traversal.</p><p> Output ports are wired relative to the offset of the module they are contained in. When the materializer visits
 a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node, it contains an Array that maps ports to a relative offset. To
 calculate the slot that is assigned to an output port the following formula is used:</p><p>   slot = offsetOfModule + outToSlots(out.id)</p><p> Where outToSlots is the array contained in the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span> node.</p><h4> Relative addressing </h4><p> The power of this structure comes from the fact that slots are assigned in a relative manner:</p><p>  * input ports are assigned in sequence so the slots assigned to the input ports of a subgraph depend on the
    subgraph's position in the traversal
  * output ports are assigned relative to the offset of their owner module, which is in turn relative to its first
    (potential) input port (which is relative, too, because of the previous point)</p><p> This setup allows combining subgraphs without touching their internal wirings as all their internal wirings will
 properly resolve due to everything being relative:</p><p>      +---------------+                     +----+
      |               |                     |    |
   |---------Graph1---------|--- .... ---|----Graph2----|</p><p> It is important to note that due to reusability, an Akka Stream graph may contain the same atomic or composite
 multiple times in the same graph. Since these must be distinguished from each other somehow, they need port mapping
 (i.e. a new set of ports) to ensure that the ports of one graph are distinguishable from another. Because how
 the traversal relative addressing works, these are _temporary_ though, once all internal wirings are ready, these
 mappings can be effectively dropped as the global slot assignments uniquely identify what is wired to what. For
 example since Graph1 is visited before Graph2 all of the slots or offsets it uses are different from Graph2 leaving
 no room for misinterpretation.</p><h4> Port mapping </h4><p> Port mapping is the way how the DSL can distinguish between multiple instances of the same graph included multiple
 times. For example in the Graph DSL:</p><p>   val merge1 = builder.add(Merge)
   val merge2 = builder.add(Merge)</p><p> the port merge1.out must be different from merge2.out.</p><p> For efficiency reasons, the linear and graph DSLs use different <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span> types to
 build the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> (we will discuss these next). One of the differences between the two
 builders are their approach to port mapping.</p><p> The simpler case is the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span>. This builder only allows building linear
 chains of operators, hence, it can only have at most one <a href="../OutPort.html" class="extype" name="akka.stream.OutPort">OutPort</a> and <a href="../InPort.html" class="extype" name="akka.stream.InPort">InPort</a> unwired. Since there is no
 possible ambiguity between these two port types, there is no need for port mapping for these. Conversely,
 for those internal ports that are already wired, there is no need for port mapping as their relative wiring
 is not ambiguous (see previous section). As a result, the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> does not
 use any port mapping.</p><p> The generic graph builder class <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> needs port mapping as it allows
 adding any kind of builders in any order. When adding a module (encoded as another <span class="extype" name="akka.stream.impl.TraversalBuilder">akka.stream.impl.TraversalBuilder</span>)
 there are two entities in play:</p><p>  * The module (builder) to be added. This builder has a few ports unwired which are usually packaged in a <a href="../Shape.html" class="extype" name="akka.stream.Shape">Shape</a>
    which is stored alongside with the builder in the <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a> of the DSL. When invoking methods on this builder
    these set of ports must be used.
  * The module that we are growing. This module needs a new set of ports to be used as it might add this module
    multiple times and needs to disambiguate these ports.</p><p> Adding to the <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> involves the following steps (pseudocode):</p><p>    val newShape = shape.deepCopy() // Copy the shape of the module we want to add
    val newBuilder = builder.add(submodule, newShape) // Add the module, and register it with the new shape
    newBuilder.wire(newShape.in, ...) // Use the new ports to wire</p><p> What happens in the background is that <span class="extype" name="Shape.deepCopy()">Shape.deepCopy()</span> creates copies of the ports, and fills their
 mappedTo field to point to their original port counterpart. Whenever we call wire in the outer module, it
 delegates calls to the submodule, but using the original port (as the submodule builder has no knowledge of
 the external mapping):</p><p>     submodule.assign(port.mappedTo, ...) // enclosing module delegating to submodule, translating ports back</p><p> Visualizing this relationship:</p><p>   +----------------------------------+
   | in', in&quot; ---------+              | in' and in&quot; both resolve to in
   |   | .mappedTo     v .mappedTo    | but they will be used on _different_ builders
   | +-------------+ +-------------+  |
   | | in          | | in          |  | (delegation happens recursively in AddedModule)
   | | AddedModule | | AddedModule |  |</p><p> It is worth to note that the submodule might also continue this map-and-delegate chain to further submodules until
 a builder is reached that can directly perform the operation. In other words, the depth of nesting is equal to
 the length of mappedTo chaining.</p><p> IMPORTANT: When wiring in the enclosing module the new ports/shape MUST be used, using the original ports/shape
 will lead to incorrect state.</p><h4> TraversalBuilders </h4><p> In order to understand why builders are needed, consider wiring two ports together. Actually, we don't need to
 wire input ports anywhere. Their slot is implicitly assigned by their position in the traversal, there is no
 additional state we need to track. On the other hand, we cannot build a <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>
 node until the mapping array outToSlots is fully calculated. In other words, in reality, we don't wire input ports
 anywhere, we only assign output ports to slots. The builders exist mainly to keep track all the necessary
 information to be able to assign output ports, build the outToSlots array and finally the <span class="extype" name="akka.stream.impl.MaterializeAtomic">akka.stream.impl.MaterializeAtomic</span>
 node. The consequence of this that a <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> can be constructed as soon as all output ports
 are wired (&quot;unwired&quot; inputs don't matter).</p><p> There is a specific builder that is used for the cases where all outputs have been wired:
 <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>. This builder type simply contains the completed traversal plus
 some additional data. The reason why this builder type exists is to keep auxiliary data structures required for
 output port mapping only while they are needed, and shed them as soon as they are not needed anymore. Since builders
 may recursively contain other builders, as soon as internals are completed those contained builders transition
 to completed state and drop all additional data structures. This is very GC friendly as many intermediate graphs
 exist only in a method call, and hence most of the additional data structures are dropped before method return and
 can be efficiently collected by the GC.</p><p> The most generic builder is <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span>. There are two main considerations
 this builder needs to consider:</p><p>  * Enclosed modules (builders) must have a stable position in the final traversal for relative addressing to work.
    Since module offsets are calculated by traversal position, and outputs are wired relative to module offset, this
    is critical.
  * Enclosed builders might not be complete yet (i.e. have unwired outputs) and hence they cannot immediately give
    a Traversal.</p><p> The composite builder keeps a temporary list of traversal steps (in reverse order because of immutable lists)
 it needs to create once it is completed (all outputs wired). These steps refer to the traversal of submodules
 as a <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span> which is just a placeholder where the traversal of the submodule will be
 stitched in. This <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span> is also a key to a map which contains the evolving builder.
 The importance of this &quot;preimage&quot; traversal is that it keeps position of submodules stable, making relative
 addressing possible.</p><p> Once the composite is completed, it takes these steps (now reversing it back to normal), and builds the traversal
 using the submodule traversals referred to by <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span>. Note that at this point all the
 submodules are <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>s because there are no unwired outputs and hence the
 Traversal can be assembled. As the builder evolves over time, more and more of its <span class="extype" name="akka.stream.impl.BuilderKey">akka.stream.impl.BuilderKey</span>s
 will refer to <span class="extype" name="akka.stream.impl.CompletedTraversalBuilder">akka.stream.impl.CompletedTraversalBuilder</span>s, shedding much of the temporary data structures.</p><p> Refer to <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span> for more details.</p><p> The <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> is a much simpler beast. For efficiency, it tries to work as much
 as possible directly on the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> avoiding auxiliary structures. The two main considerations
 for this builder are:</p><p>  * <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">akka.stream.scaladsl.Source</a> and <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">akka.stream.scaladsl.Flow</a> contain an unwired output port. Yet, we would
    like to build the traversal directly as much as possible, even though the builder is not yet completed
  * <span class="extype" name="akka.stream.impl.CompositeTraversalBuilder">akka.stream.impl.CompositeTraversalBuilder</span>s might be included in a linear chain. These cannot provide a
    traversal before they are fully completed.</p><p> The linear builder, although it is one class, comes in basically two flavors:</p><p>  * Purely linear builder: this contains only other linear builders, or all the composites that it includes
    have been fully wired before and hence their traversal is now fully incorporated. Basically this kind
    of builder only contains the <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> and only a couple of extra fields.
  * Linear builder with an incomplete composite at the end (output): In this case, we have an incomplete composite.
    It can only be at the end, since this is the only position where an output port can be unwired. We need to
    carry this builder with us until the output port is finally wired, in which case we incorporate its traversal
    into the already complete one, and hopefully transition to a purely linear builder.</p><p> If we consider the purely linear case, we still need to figure out how can we provide a traversal even though
 the last output port is unwired. The trick that is used is to wire this output port optimistically to the
 relative address -1 which is almost always correct (why -1? explained a bit later). If it turns out to be incorrect
 later, we fix it by the helper method <span class="extype" name="akka.stream.impl.Traversal.rewireFirstTo()">akka.stream.impl.Traversal.rewireFirstTo()</span> which tears down the traversal
 until the wrong module is found, then fixes the port assignment. This is only possible on purely linear layouts though.
 Again, this is an example of the 90% rule. Most appends will not need this rewiring and hence be as fast as possible
 while the rarer cases suffering a minor penalty.</p><p> In the case where the last module is a composite, the above trick would not work as nothing guarantees that the
 module that exposed its output port is at an expected position in the traversal. Instead, we simply keep around
 this composite and delay construction of its part of the traversal. For details see <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span>
 as these cases are heavily commented and explained in the code.</p><p> There is another peculiarity of the linear builder we need to explain. Namely, it builds the traversal in reverse
 order, i.e. from Sinks towards Sources. THIS CAN BE SUPER CONFUSING AT TIMES SO PAY ATTENTION! There are two
 important reasons why this is needed:</p><p>  * Prepending to immutable lists is more efficient. Even though we encode our traversal list as a tree, we would
    need stack space at materialization time as much as the length of the list if we would append to it instead of
    prepending.
  * Prepending means that most output ports refer to slots visited before, i.e. output relative offsets are negative.
    This means that during materialization, output ports will be wired to slots that the materializer visited before
    which enables an efficient one-pass materialization design. The importance of this is discussed later below.</p><p> To visualize this, imagine a simple stream:</p><p>   [Source.out] -&gt; [Map.in, Map.out] -&gt; [Sink.in]</p><p> The traversal:</p><p>    offs = 0         offs = 1                      offs = 1
   [Sink.in = 0] &lt;- [Map.in = 1, Map.out = -1] &lt;- [Source.out = -1]</p><p> Since the traversal steps are reversed compared to the DSL order, it is important to reverse materialized value
 computation, too.</p><h4> Islands and local slots </h4><p> All what we have discussed so far referred to the &quot;mental array&quot;, the global address space in which slots
 are assigned to ports. This model describes the wiring of the graph perfectly, but it does not map to the local
 data structures needed by materialization when there are islands present. One of the important goals of this
 layout data structure is to be able to produce the data structures used by the <span class="extype" name="akka.stream.impl.fusing.GraphInterpreter">akka.stream.impl.fusing.GraphInterpreter</span>
 directly, without much translation. Unfortunately if there is an island inside a traversal, it might leave gaps
 in the address space:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> Since we visit Island2 before returning to Island1, the naive approach would leave a large gap between the last
 input port visited before entering Island2 and the first input port visited when returning to Island1. What
 we would like to have instead is a contiguous slot assignment from the viewpoint of Island1. This is where
 <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span> and its <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> helper comes into
 the picture. These classes do the heavy-lifting of traversing the traversal and then mapping global slots to
 slots local to the island, delegating then the local wiring to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> implementations.
 For example the <span class="extype" name="akka.stream.impl.GraphStageIsland">akka.stream.impl.GraphStageIsland</span> sees only a contigous slot-space and hence it can directly
 construct the array for the interpreter. It is not aware of the presence of other islands or how it is represented
 in the global slot-space.</p><h4> Materialization </h4><p> Materialzation is orchestrated by the <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span>. It basically decodes the
 traversal and handles islands. This top-level materializer does not really handle the wiring _inside_ an island,
 it only handles wiring of Publishers and Subscribers that connect islands. Instead it delegates in-island wiring
 to <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>s. For example a default fused island will be actually wired by
 <span class="extype" name="akka.stream.impl.GraphStageIsland">akka.stream.impl.GraphStageIsland</span>.</p><p> First, look at a traversal that has two islands:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this traversal, we have two islands, and three, so called _segments_. Segments are simply contiguous range of
 slots between <span class="extype" name="akka.stream.impl.EnterIsland">akka.stream.impl.EnterIsland</span> or <span class="extype" name="akka.stream.impl.ExitIsland">akka.stream.impl.ExitIsland</span> tags (in any combination). When
 the materializer encounters either an enter or exit command, it saves various information about the segment it
 just completed (what is its offset, how long it is measured in input slots, etc.). This information is later
 used to figure out if a wiring crosses island boundaries or is it local to the island.</p><p> It is important to note that the data structure for this is only allocated when there are islands. This is again
 the 90% rule in action. In addition, these data structures are <a href="https://docs.oracle.com/javase/11/docs/api/java/util/ArrayList.html" class="extype" name="java.util.ArrayList">java.util.ArrayList</a> instances, where lookups
 according to some value are implemented as simple linear scans. Since in 90% of the cases these structures are
 very short, this is the most efficient approach. Cases where this can be a performance problem are very-very special
 and likely not happen in practice (no graph should contain more than a dozen of islands for example).</p><p> When it comes to deciding whether a wiring is cross-island or local, there are two cases possible:</p><p>  * we encountered an output port that is wired backwards (relative address is negative). In this case we already
    have all the data necessary to resolve the question.
  * we encountered an output port that is wired forward (relative address is positive). In this case we have not
    yet visited that part of the traversal where the assignment points.</p><p> If we want to keep the one-pass design of the materializer, we need to delay forward wirings until we have all
 the information needed, i.e. we visit the target in port. The <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer">akka.stream.impl.PhasedFusingActorMaterializer</span>
 has a data structure for tracking forward wires which it consults whenever it visits an input port. Again, this
 is only allocated if needed, and it is again an array with linear scan lookup. Once the target input port have
 been found, the rules of the wiring are the same as for backwards wiring.</p><p>       backward wire (to the visited part) &lt;------+ +------&gt; forward wire (into the unknown)
                                                  | |
  |----Island1-----|----Island2(enclosed)-------- ... (this is where we are now)</p><p> Remember, the <span class="extype" name="akka.stream.impl.LinearTraversalBuilder">akka.stream.impl.LinearTraversalBuilder</span> builds its <span class="extype" name="akka.stream.impl.Traversal">akka.stream.impl.Traversal</span> in backwards
 order, so since most of the graphs are constructed by the linear DSLs almost all wirings will be backwards
 (90% rule in action again).</p><h5> Backward wirings </h5><p> When it comes to resolving wirings and calculating the local slots for all the islands involved there are three
 distinct cases.</p><p> A wiring can be in-segment:</p><p>                        +--------------+
                        |              |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means that the slot assigned to the output port still belongs to the current segment. This is easy to detect
 as the <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> class tracks the offset of the current segment. If the target input
 slot is larger or equal than this offset, and the wiring is backwards, then the wiring is strictly local to the
 island. The materializer will simply delegate to the <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> to do the internal wiring.
 Since we know the offset of the segment in the local space of this island, calculating the local slot for the
 <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> is simple. (This is fully documented with diagrams
 in <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>)</p><p> A wiring can be cross-segment, in-island:</p><p>               +---------------------------------+
               |                                 |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this case, the target slot is in another, but already visited segment. The <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>
 class needs to first find the segment in which the target slot is. Since each segment keeps a reference to its
 <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> instance that handles the internal wiring a simple reference equality check
 will tell us if the target segment is in the same island or not. In this case it is, so all we need is to
 compensate for any possible holes (punched by enclosed islands) to calculate the local slot for the island
 and call the appropriate callback on the <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span>. (This is fully documented with diagrams
 in <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span>)</p><p> Finally a wiring can be cross-segment, cross-island:</p><p>                        +------------------------+
                        |                        |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means, that the steps were similar as in the previous case until that point where we check the reference
 equality of the current <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> with that of the target segment (we have already found
 the target segment). In this case, we need to calculate the local slot in the target island (similar to the
 previous case) and try to wire the two islands together. Now, instead of delegating the wiring to the phases, we
 ask the output <span class="extype" name="akka.stream.impl.PhaseIsland">akka.stream.impl.PhaseIsland</span> to provide a Publisher and then we ask the target island to
 take this Publisher.</p><p> Refer to <span class="extype" name="akka.stream.impl.IslandTracking">akka.stream.impl.IslandTracking</span> for all the nasty details of local slot resolution. It is also
 recommended to try out a few examples with <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer.Debug">akka.stream.impl.PhasedFusingActorMaterializer.Debug</span> turned on, it
 will detail every step of the island tracking and slot resolution steps.</p><h4> Utilities </h4><p> Useful utilities are:</p><p>  * <span class="extype" name="akka.stream.impl.PhasedFusingActorMaterializer.Debug">akka.stream.impl.PhasedFusingActorMaterializer.Debug</span>: if this flag is turned on, the materializer will
    log the steps it takes
  * <span class="extype" name="akka.stream.impl.TraversalBuilder.printTraversal()">akka.stream.impl.TraversalBuilder.printTraversal()</span>: Prints the Traversal in a readable format
  * <span class="extype" name="akka.stream.impl.TraversalBuilder.printWiring()">akka.stream.impl.TraversalBuilder.printWiring()</span>: Prints the calculated port assignments. Useful for
    debugging if everything is wired to the right thing.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.javadsl" visbl="pub" class="indented3 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="javadsl"></a><a id="javadsl:javadsl"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#javadsl" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">javadsl</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="AsPublisher.html" title=""></a>
                        <a href="AsPublisher.html" title="">AsPublisher</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Balance$.html" title="Fan-out the stream to several streams."></a>
                        <a href="Balance$.html" title="Fan-out the stream to several streams.">Balance</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="BidiFlow$.html" title=""></a>
                        <a class="class" href="BidiFlow.html" title=""></a>
                        <a href="BidiFlow.html" title="">BidiFlow</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Broadcast$.html" title="Fan-out the stream to several streams."></a>
                        <a href="Broadcast$.html" title="Fan-out the stream to several streams.">Broadcast</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="BroadcastHub$.html" title="A BroadcastHub is a special streaming hub that is able to broadcast streamed elements to a dynamic set of consumers."></a>
                        <a href="BroadcastHub$.html" title="A BroadcastHub is a special streaming hub that is able to broadcast streamed elements to a dynamic set of consumers.">BroadcastHub</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Compression$.html" title=""></a>
                        <a href="Compression$.html" title="">Compression</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Concat$.html" title="Takes two streams and outputs an output stream formed from the two input streams by consuming one stream first emitting all of its elements, then consuming the second stream emitting all of its elements."></a>
                        <a href="Concat$.html" title="Takes two streams and outputs an output stream formed from the two input streams by consuming one stream first emitting all of its elements, then consuming the second stream emitting all of its elements.">Concat</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="CoupledTerminationFlow$.html" title="Allows coupling termination (cancellation, completion, erroring) of Sinks and Sources while creating a Flow them them."></a>
                        <a href="CoupledTerminationFlow$.html" title="Allows coupling termination (cancellation, completion, erroring) of Sinks and Sources while creating a Flow them them.">CoupledTerminationFlow</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="FileIO$.html" title="Java API: Factories to create sinks and sources from files"></a>
                        <a href="FileIO$.html" title="Java API: Factories to create sinks and sources from files">FileIO</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="Flow$.html" title=""></a>
                        <a class="class" href="Flow.html" title="Create a Flow which can process elements of type T."></a>
                        <a href="Flow.html" title="Create a Flow which can process elements of type T.">Flow</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="FlowWithContext$.html" title="API MAY CHANGE"></a>
                        <a class="class" href="FlowWithContext.html" title="A flow that provides operations which automatically propagate the context of an element."></a>
                        <a href="FlowWithContext.html" title="A flow that provides operations which automatically propagate the context of an element.">FlowWithContext</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Framing$.html" title=""></a>
                        <a href="Framing$.html" title="">Framing</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="FramingTruncation.html" title="Determines mode in which Framing operates."></a>
                        <a href="FramingTruncation.html" title="Determines mode in which Framing operates.">FramingTruncation</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="GraphDSL$.html" title=""></a>
                        <a href="GraphDSL$.html" title="">GraphDSL</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="JsonFraming$.html" title="Provides JSON framing operators that can separate valid JSON objects from incoming akka.util.ByteString objects."></a>
                        <a href="JsonFraming$.html" title="Provides JSON framing operators that can separate valid JSON objects from incoming akka.util.ByteString objects.">JsonFraming</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Keep$.html" title=""></a>
                        <a href="Keep$.html" title="">Keep</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Merge$.html" title="Merge several streams, taking elements as they arrive from input streams (picking randomly when several have elements ready)."></a>
                        <a href="Merge$.html" title="Merge several streams, taking elements as they arrive from input streams (picking randomly when several have elements ready).">Merge</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="MergeHub$.html" title="A MergeHub is a special streaming hub that is able to collect streamed elements from a dynamic set of producers."></a>
                        <a href="MergeHub$.html" title="A MergeHub is a special streaming hub that is able to collect streamed elements from a dynamic set of producers.">MergeHub</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="MergeLatest$.html" title="MergeLatest joins elements from N input streams into stream of lists of size N."></a>
                        <a href="MergeLatest$.html" title="MergeLatest joins elements from N input streams into stream of lists of size N.">MergeLatest</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="MergePreferred$.html" title="Merge several streams, taking elements as they arrive from input streams (picking from preferred when several have elements ready)."></a>
                        <a href="MergePreferred$.html" title="Merge several streams, taking elements as they arrive from input streams (picking from preferred when several have elements ready).">MergePreferred</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="MergePrioritized$.html" title="Merge several streams, taking elements as they arrive from input streams (picking from prioritized once when several have elements ready)."></a>
                        <a href="MergePrioritized$.html" title="Merge several streams, taking elements as they arrive from input streams (picking from prioritized once when several have elements ready).">MergePrioritized</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Partition$.html" title="Fan-out the stream to several streams."></a>
                        <a href="Partition$.html" title="Fan-out the stream to several streams.">Partition</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="PartitionHub$.html" title="A PartitionHub is a special streaming hub that is able to route streamed elements to a dynamic set of consumers."></a>
                        <a href="PartitionHub$.html" title="A PartitionHub is a special streaming hub that is able to route streamed elements to a dynamic set of consumers.">PartitionHub</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="RestartFlow$.html" title="A RestartFlow wraps a Flow that gets restarted when it completes or fails."></a>
                        <a href="RestartFlow$.html" title="A RestartFlow wraps a Flow that gets restarted when it completes or fails.">RestartFlow</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="RestartSink$.html" title="A RestartSink wraps a Sink that gets restarted when it completes or fails."></a>
                        <a href="RestartSink$.html" title="A RestartSink wraps a Sink that gets restarted when it completes or fails.">RestartSink</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="RestartSource$.html" title="A RestartSource wraps a Source that gets restarted when it completes or fails."></a>
                        <a href="RestartSource$.html" title="A RestartSource wraps a Source that gets restarted when it completes or fails.">RestartSource</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="RunnableGraph$.html" title=""></a>
                        <a class="class" href="RunnableGraph.html" title="Java API"></a>
                        <a href="RunnableGraph.html" title="Java API">RunnableGraph</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="Sink$.html" title="Java API"></a>
                        <a class="class" href="Sink.html" title="Java API"></a>
                        <a href="Sink.html" title="Java API">Sink</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="SinkQueue.html" title="Trait allows to have the queue as a sink for some stream."></a>
                        <a href="SinkQueue.html" title="Trait allows to have the queue as a sink for some stream.">SinkQueue</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="SinkQueueWithCancel.html" title="This trait adds cancel support to SinkQueue."></a>
                        <a href="SinkQueueWithCancel.html" title="This trait adds cancel support to SinkQueue.">SinkQueueWithCancel</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="Source$.html" title="Java API"></a>
                        <a class="class" href="Source.html" title="Java API"></a>
                        <a href="Source.html" title="Java API">Source</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="SourceQueue.html" title="This trait allows to have the queue as a data source for some stream."></a>
                        <a href="SourceQueue.html" title="This trait allows to have the queue as a data source for some stream.">SourceQueue</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="SourceQueueWithComplete.html" title="This trait adds completion support to SourceQueue."></a>
                        <a href="SourceQueueWithComplete.html" title="This trait adds completion support to SourceQueue.">SourceQueueWithComplete</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="SourceWithContext$.html" title="API MAY CHANGE"></a>
                        <a class="class" href="SourceWithContext.html" title="A source that provides operations which automatically propagate the context of an element."></a>
                        <a href="SourceWithContext.html" title="A source that provides operations which automatically propagate the context of an element.">SourceWithContext</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="StreamConverters$.html" title="Converters for interacting with the blocking java.io streams APIs and Java 8 Streams"></a>
                        <a href="StreamConverters$.html" title="Converters for interacting with the blocking java.io streams APIs and Java 8 Streams">StreamConverters</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="StreamRefs$.html" title="API MAY CHANGE: The functionality of stream refs is working, however it is expected that the materialized value will eventually be able to remove the Future wrapping the stream references."></a>
                        <a href="StreamRefs$.html" title="API MAY CHANGE: The functionality of stream refs is working, however it is expected that the materialized value will eventually be able to remove the Future wrapping the stream references.">StreamRefs</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="SubFlow$.html" title=""></a>
                        <a class="class" href="SubFlow.html" title="A “stream of streams” sub-flow of data elements, e.g."></a>
                        <a href="SubFlow.html" title="A “stream of streams” sub-flow of data elements, e.g.">SubFlow</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="SubSource$.html" title="* Upcast a stream of elements to a stream of supertypes of that element."></a>
                        <a class="class" href="SubSource.html" title="A “stream of streams” sub-flow of data elements, e.g."></a>
                        <a href="SubSource.html" title="A “stream of streams” sub-flow of data elements, e.g.">SubSource</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="TLS$.html" title="Stream cipher support based upon JSSE."></a>
                        <a href="TLS$.html" title="Stream cipher support based upon JSSE.">TLS</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="TLSPlacebo$.html" title="This object holds simple wrapping akka.stream.scaladsl.BidiFlow implementations that can be used instead of TLS when no encryption is desired."></a>
                        <a href="TLSPlacebo$.html" title="This object holds simple wrapping akka.stream.scaladsl.BidiFlow implementations that can be used instead of TLS when no encryption is desired.">TLSPlacebo</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="Tcp$.html" title=""></a>
                        <a class="class" href="Tcp.html" title=""></a>
                        <a href="Tcp.html" title="">Tcp</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Unzip$.html" title="Takes a stream of pair elements and splits each pair to two output streams."></a>
                        <a href="Unzip$.html" title="Takes a stream of pair elements and splits each pair to two output streams.">Unzip</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="UnzipWith$.html" title="Split one stream into several streams using a splitting function."></a>
                        <a href="UnzipWith$.html" title="Split one stream into several streams using a splitting function.">UnzipWith</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Zip$.html" title="Combine the elements of 2 streams into a stream of tuples."></a>
                        <a href="Zip$.html" title="Combine the elements of 2 streams into a stream of tuples.">Zip</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="ZipLatest$.html" title="Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each."></a>
                        <a href="ZipLatest$.html" title="Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each.">ZipLatest</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="ZipLatestWith$.html" title="Combine the elements of multiple streams into a stream of combined elements using a combiner function, picking always the latest of the elements of each source."></a>
                        <a href="ZipLatestWith$.html" title="Combine the elements of multiple streams into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.">ZipLatestWith</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="ZipN$.html" title="Combine the elements of multiple streams into a stream of lists."></a>
                        <a href="ZipN$.html" title="Combine the elements of multiple streams into a stream of lists.">ZipN</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="ZipWith$.html" title="Combine the elements of multiple streams into a stream of combined elements using a combiner function."></a>
                        <a href="ZipWith$.html" title="Combine the elements of multiple streams into a stream of combined elements using a combiner function.">ZipWith</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="ZipWithN$.html" title="Combine the elements of multiple streams into a stream of lists using a combiner function."></a>
                        <a href="ZipWithN$.html" title="Combine the elements of multiple streams into a stream of lists using a combiner function.">ZipWithN</a>
                      </li><li name="akka.stream.scaladsl" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scaladsl"></a><a id="scaladsl:scaladsl"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#scaladsl" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Scala API: The flow DSL allows the formulation of stream transformations based on some input." href="../scaladsl/index.html"><span class="name">scaladsl</span></a>
      </span>
      
      <p class="shortcomment cmt">Scala API: The flow DSL allows the formulation of stream transformations based on some
input.</p><div class="fullcomment"><div class="comment cmt"><p>Scala API: The flow DSL allows the formulation of stream transformations based on some
input. The starting point is called <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">Source</a> and can be a collection, an iterator,
a block of code which is evaluated repeatedly or a <span class="extype" name="org.reactivestreams.Publisher">org.reactivestreams.Publisher</span>.
A flow with an attached input and open output is also a <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">Source</a>.</p><p>A flow may also be defined without an attached input or output and that is then
a <a href="../scaladsl/Flow.html" class="extype" name="akka.stream.scaladsl.Flow">Flow</a>. The <code>Flow</code> can be connected to the <code>Source</code> later by using <a href="../scaladsl/Source.html#via[T,Mat2](flow:akka.stream.Graph[akka.stream.FlowShape[Out,T],Mat2]):Source.this.Repr[T]" class="extmbr" name="akka.stream.scaladsl.Source#via">Source#via</a> with
the flow as argument, and it remains a <a href="../scaladsl/Source.html" class="extype" name="akka.stream.scaladsl.Source">Source</a>.</p><p>Transformations can be appended to <code>Source</code> and <code>Flow</code> with the operations
defined in <a href="../scaladsl/FlowOps.html" class="extype" name="akka.stream.scaladsl.FlowOps">FlowOps</a>. Each DSL element produces a new flow that can be further transformed,
building up a description of the complete transformation pipeline.</p><p>The termination point of a flow is called <a href="../scaladsl/Sink.html" class="extype" name="akka.stream.scaladsl.Sink">Sink</a> and can for example be a <code>Future</code> or
<span class="extype" name="org.reactivestreams.Subscriber">org.reactivestreams.Subscriber</span>. A flow with an attached output and open input
is also a <a href="../scaladsl/Sink.html" class="extype" name="akka.stream.scaladsl.Sink">Sink</a>.</p><p>If a flow has both an attached input and an attached output it becomes a <a href="../scaladsl/RunnableGraph.html" class="extype" name="akka.stream.scaladsl.RunnableGraph">RunnableGraph</a>.
In order to execute this pipeline the flow must be materialized by calling <a href="../scaladsl/RunnableGraph.html#run()(implicitmaterializer:akka.stream.Materializer):Mat" class="extmbr" name="akka.stream.scaladsl.RunnableGraph#run">RunnableGraph#run</a> on it.</p><p>You can create your <code>Source</code>, <code>Flow</code> and <code>Sink</code> in any order and then wire them together before
they are materialized by connecting them using <a href="../scaladsl/Flow.html#via[T,Mat2](flow:akka.stream.Graph[akka.stream.FlowShape[Out,T],Mat2]):Flow.this.Repr[T]" class="extmbr" name="akka.stream.scaladsl.Flow#via">Flow#via</a> and <a href="../scaladsl/Flow.html#to[Mat2](sink:akka.stream.Graph[akka.stream.SinkShape[Out],Mat2]):akka.stream.scaladsl.Sink[In,Mat]" class="extmbr" name="akka.stream.scaladsl.Flow#to">Flow#to</a>, or connecting them into a
<a href="../scaladsl/GraphDSL$.html" class="extype" name="akka.stream.scaladsl.GraphDSL">GraphDSL</a> with fan-in and fan-out elements.</p><p>See <a href="https://github.com/reactive-streams/reactive-streams/">Reactive Streams</a> for
details on <span class="extype" name="org.reactivestreams.Publisher">org.reactivestreams.Publisher</span> and <span class="extype" name="org.reactivestreams.Subscriber">org.reactivestreams.Subscriber</span>.</p><p>It should be noted that the streams modeled by this library are “hot”,
meaning that they asynchronously flow through a series of processors without
detailed control by the user. In particular it is not predictable how many
elements a given transformation step might buffer before handing elements
downstream, which means that transformation functions may be invoked more
often than for corresponding transformations on strict collections like
<span class="extype" name="List">List</span>. *An important consequence* is that elements that were produced
into a stream may be discarded by later processors, e.g. when using the
<span class="extype" name="#take">#take</span> operator.</p><p>By default every operation is executed within its own <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">akka.actor.Actor</a>
to enable full pipelining of the chained set of computations. This behavior
is determined by the <a href="../Materializer.html" class="extype" name="akka.stream.Materializer">akka.stream.Materializer</a> which is required
by those methods that materialize the Flow into a series of
<span class="extype" name="org.reactivestreams.Processor">org.reactivestreams.Processor</span> instances. The returned reactive stream
is fully started and active.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.snapshot" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="snapshot"></a><a id="snapshot:snapshot"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#snapshot" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../snapshot/index.html"><span class="name">snapshot</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.stage" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stage"></a><a id="stage:stage"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#stage" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../stage/index.html"><span class="name">stage</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.testkit" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="testkit"></a><a id="testkit:testkit"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#testkit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../testkit/index.html"><span class="name">testkit</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li><li name="akka.stream.typed" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="typed"></a><a id="typed:typed"></a>
      <span class="permalink">
      <a href="../../akka/stream/index.html#typed" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../typed/index.html"><span class="name">typed</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="akka.stream">stream</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../../index.html" class="extype" name="akka">akka</a>.<a href="../index.html" class="extype" name="akka.stream">stream</a></p>
        <h1>javadsl<span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">javadsl</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/akka/akka/tree/v2.5.30//akka-stream/src/main/scala/akka/stream/javadsl/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a>, <a href="http://www.scala-lang.org/api/2.12.8/scala/Any.html#scala.Any" class="extype" name="scala.Any">Any</a></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="akka.stream.javadsl"><span>javadsl</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="akka.stream.javadsl.AsPublisher" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="AsPublisherextendsEnum[akka.stream.javadsl.AsPublisher]"></a><a id="AsPublisher:AsPublisher"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#AsPublisherextendsEnum[akka.stream.javadsl.AsPublisher]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed abstract final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="" href="AsPublisher.html"><span class="name">AsPublisher</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/11/docs/api/java/lang/Enum.html#java.lang.Enum" class="extype" name="java.lang.Enum">Enum</a>[<a href="AsPublisher.html" class="extype" name="akka.stream.javadsl.AsPublisher">AsPublisher</a>]</span>
      </span>
      
      
    </li><li name="akka.stream.javadsl.BidiFlow" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BidiFlow[I1,O1,I2,O2,Mat]extendsGraph[akka.stream.BidiShape[I1,O1,I2,O2],Mat]"></a><a id="BidiFlow[I1,O1,I2,O2,Mat]:BidiFlow[I1,O1,I2,O2,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#BidiFlow[I1,O1,I2,O2,Mat]extendsGraph[akka.stream.BidiShape[I1,O1,I2,O2],Mat]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="" href="BidiFlow.html"><span class="name">BidiFlow</span></a><span class="tparams">[<span name="I1">I1</span>, <span name="O1">O1</span>, <span name="I2">I2</span>, <span name="O2">O2</span>, <span name="Mat">Mat</span>]</span><span class="result"> extends <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a>[<a href="../BidiShape.html" class="extype" name="akka.stream.BidiShape">BidiShape</a>[<span class="extype" name="akka.stream.javadsl.BidiFlow.I1">I1</span>, <span class="extype" name="akka.stream.javadsl.BidiFlow.O1">O1</span>, <span class="extype" name="akka.stream.javadsl.BidiFlow.I2">I2</span>, <span class="extype" name="akka.stream.javadsl.BidiFlow.O2">O2</span>], <span class="extype" name="akka.stream.javadsl.BidiFlow.Mat">Mat</span>]</span>
      </span>
      
      
    </li><li name="akka.stream.javadsl.Flow" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Flow[In,Out,Mat]extendsGraph[akka.stream.FlowShape[In,Out],Mat]"></a><a id="Flow[In,Out,Mat]:Flow[In,Out,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Flow[In,Out,Mat]extendsGraph[akka.stream.FlowShape[In,Out],Mat]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Create a Flow which can process elements of type T." href="Flow.html"><span class="name">Flow</span></a><span class="tparams">[<span name="In">In</span>, <span name="Out">Out</span>, <span name="Mat">Mat</span>]</span><span class="result"> extends <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a>[<a href="../FlowShape.html" class="extype" name="akka.stream.FlowShape">FlowShape</a>[<span class="extype" name="akka.stream.javadsl.Flow.In">In</span>, <span class="extype" name="akka.stream.javadsl.Flow.Out">Out</span>], <span class="extype" name="akka.stream.javadsl.Flow.Mat">Mat</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Create a <code>Flow</code> which can process elements of type <code>T</code>.</p>
    </li><li name="akka.stream.javadsl.FlowWithContext" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FlowWithContext[In,CtxIn,Out,CtxOut,+Mat]extendsGraphDelegate[akka.stream.FlowShape[akka.japi.Pair[In,CtxIn],akka.japi.Pair[Out,CtxOut]],Mat]"></a><a id="FlowWithContext[In,CtxIn,Out,CtxOut,+Mat]:FlowWithContext[In,CtxIn,Out,CtxOut,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#FlowWithContext[In,CtxIn,Out,CtxOut,+Mat]extendsGraphDelegate[akka.stream.FlowShape[akka.japi.Pair[In,CtxIn],akka.japi.Pair[Out,CtxOut]],Mat]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A flow that provides operations which automatically propagate the context of an element." href="FlowWithContext.html"><span class="name">FlowWithContext</span></a><span class="tparams">[<span name="In">In</span>, <span name="CtxIn">CtxIn</span>, <span name="Out">Out</span>, <span name="CtxOut">CtxOut</span>, <span name="Mat">+Mat</span>]</span><span class="result"> extends <span class="extype" name="akka.stream.GraphDelegate">GraphDelegate</span>[<a href="../FlowShape.html" class="extype" name="akka.stream.FlowShape">FlowShape</a>[<a href="../../japi/Pair.html" class="extype" name="akka.japi.Pair">Pair</a>[<span class="extype" name="akka.stream.javadsl.FlowWithContext.In">In</span>, <span class="extype" name="akka.stream.javadsl.FlowWithContext.CtxIn">CtxIn</span>], <a href="../../japi/Pair.html" class="extype" name="akka.japi.Pair">Pair</a>[<span class="extype" name="akka.stream.javadsl.FlowWithContext.Out">Out</span>, <span class="extype" name="akka.stream.javadsl.FlowWithContext.CtxOut">CtxOut</span>]], <span class="extype" name="akka.stream.javadsl.FlowWithContext.Mat">Mat</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A flow that provides operations which automatically propagate the context of an element.</p><div class="fullcomment"><div class="comment cmt"><p>A flow that provides operations which automatically propagate the context of an element.
Only a subset of common operations from <a href="Flow.html" class="extype" name="akka.stream.javadsl.Flow">Flow</a> is supported. As an escape hatch you can
use <a href="FlowWithContext.html#via[Out2,CtxOut2,Mat2](viaFlow:akka.stream.Graph[akka.stream.FlowShape[akka.japi.Pair[Out@scala.annotation.unchecked.uncheckedVariance,CtxOut@scala.annotation.unchecked.uncheckedVariance],akka.japi.Pair[Out2,CtxOut2]],Mat2]):akka.stream.javadsl.FlowWithContext[In,CtxIn,Out2,CtxOut2,Mat]" class="extmbr" name="akka.stream.javadsl.FlowWithContext#via">FlowWithContext.via</a> to manually provide the context propagation for otherwise unsupported
operations.</p><p>An &quot;empty&quot; flow can be created by calling <code>FlowWithContext[Ctx, T]</code>.</p><p>API MAY CHANGE
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@<a href="../../annotation/ApiMayChange.html" class="extype" name="akka.annotation.ApiMayChange">ApiMayChange</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="akka.stream.javadsl.FramingTruncation" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="FramingTruncationextendsEnum[akka.stream.javadsl.FramingTruncation]"></a><a id="FramingTruncation:FramingTruncation"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#FramingTruncationextendsEnum[akka.stream.javadsl.FramingTruncation]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed abstract final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Determines mode in which Framing operates." href="FramingTruncation.html"><span class="name">FramingTruncation</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/11/docs/api/java/lang/Enum.html#java.lang.Enum" class="extype" name="java.lang.Enum">Enum</a>[<a href="FramingTruncation.html" class="extype" name="akka.stream.javadsl.FramingTruncation">FramingTruncation</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Determines mode in which <a href="Framing$.html" class="extype" name="akka.stream.javadsl.Framing">Framing</a> operates.</p>
    </li><li name="akka.stream.javadsl.RunnableGraph" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RunnableGraph[+Mat]extendsGraph[akka.stream.ClosedShape,Mat]"></a><a id="RunnableGraph[+Mat]:RunnableGraph[Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#RunnableGraph[+Mat]extendsGraph[akka.stream.ClosedShape,Mat]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Java API" href="RunnableGraph.html"><span class="name">RunnableGraph</span></a><span class="tparams">[<span name="Mat">+Mat</span>]</span><span class="result"> extends <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a>[<a href="../ClosedShape.html" class="extype" name="akka.stream.ClosedShape">ClosedShape</a>, <span class="extype" name="akka.stream.javadsl.RunnableGraph.Mat">Mat</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Java API</p><div class="fullcomment"><div class="comment cmt"><p>Java API</p><p>Flow with attached input and output, can be executed.
</p></div></div>
    </li><li name="akka.stream.javadsl.Sink" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Sink[In,Mat]extendsGraph[akka.stream.SinkShape[In],Mat]"></a><a id="Sink[In,Mat]:Sink[In,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Sink[In,Mat]extendsGraph[akka.stream.SinkShape[In],Mat]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Java API" href="Sink.html"><span class="name">Sink</span></a><span class="tparams">[<span name="In">In</span>, <span name="Mat">Mat</span>]</span><span class="result"> extends <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a>[<a href="../SinkShape.html" class="extype" name="akka.stream.SinkShape">SinkShape</a>[<span class="extype" name="akka.stream.javadsl.Sink.In">In</span>], <span class="extype" name="akka.stream.javadsl.Sink.Mat">Mat</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Java API</p><div class="fullcomment"><div class="comment cmt"><p>Java API</p><p>A <code>Sink</code> is a set of stream processing steps that has one open input.
Can be used as a <code>Subscriber</code>
</p></div></div>
    </li><li name="akka.stream.javadsl.SinkQueue" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="SinkQueue[T]extendsAnyRef"></a><a id="SinkQueue[T]:SinkQueue[T]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SinkQueue[T]extendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Trait allows to have the queue as a sink for some stream." href="SinkQueue.html"><span class="name">SinkQueue</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a></span>
      </span>
      
      <p class="shortcomment cmt">Trait allows to have the queue as a sink for some stream.</p><div class="fullcomment"><div class="comment cmt"><p>Trait allows to have the queue as a sink for some stream.
&quot;SinkQueue&quot; pulls data from stream with backpressure mechanism.
</p></div></div>
    </li><li name="akka.stream.javadsl.SinkQueueWithCancel" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="SinkQueueWithCancel[T]extendsSinkQueue[T]"></a><a id="SinkQueueWithCancel[T]:SinkQueueWithCancel[T]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SinkQueueWithCancel[T]extendsSinkQueue[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="This trait adds cancel support to SinkQueue." href="SinkQueueWithCancel.html"><span class="name">SinkQueueWithCancel</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="SinkQueue.html" class="extype" name="akka.stream.javadsl.SinkQueue">SinkQueue</a>[<span class="extype" name="akka.stream.javadsl.SinkQueueWithCancel.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">This trait adds cancel support to <a href="SinkQueue.html" class="extype" name="akka.stream.javadsl.SinkQueue">SinkQueue</a>.</p>
    </li><li name="akka.stream.javadsl.Source" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Source[Out,Mat]extendsGraph[akka.stream.SourceShape[Out],Mat]"></a><a id="Source[Out,Mat]:Source[Out,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Source[Out,Mat]extendsGraph[akka.stream.SourceShape[Out],Mat]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Java API" href="Source.html"><span class="name">Source</span></a><span class="tparams">[<span name="Out">Out</span>, <span name="Mat">Mat</span>]</span><span class="result"> extends <a href="../Graph.html" class="extype" name="akka.stream.Graph">Graph</a>[<a href="../SourceShape.html" class="extype" name="akka.stream.SourceShape">SourceShape</a>[<span class="extype" name="akka.stream.javadsl.Source.Out">Out</span>], <span class="extype" name="akka.stream.javadsl.Source.Mat">Mat</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Java API</p><div class="fullcomment"><div class="comment cmt"><p>Java API</p><p>A <code>Source</code> is a set of stream processing steps that has one open output and an attached input.
Can be used as a <code>Publisher</code>
</p></div></div>
    </li><li name="akka.stream.javadsl.SourceQueue" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="SourceQueue[T]extendsAnyRef"></a><a id="SourceQueue[T]:SourceQueue[T]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SourceQueue[T]extendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="This trait allows to have the queue as a data source for some stream." href="SourceQueue.html"><span class="name">SourceQueue</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a></span>
      </span>
      
      <p class="shortcomment cmt">This trait allows to have the queue as a data source for some stream.</p>
    </li><li name="akka.stream.javadsl.SourceQueueWithComplete" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="SourceQueueWithComplete[T]extendsSourceQueue[T]"></a><a id="SourceQueueWithComplete[T]:SourceQueueWithComplete[T]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SourceQueueWithComplete[T]extendsSourceQueue[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="This trait adds completion support to SourceQueue." href="SourceQueueWithComplete.html"><span class="name">SourceQueueWithComplete</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="SourceQueue.html" class="extype" name="akka.stream.javadsl.SourceQueue">SourceQueue</a>[<span class="extype" name="akka.stream.javadsl.SourceQueueWithComplete.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">This trait adds completion support to <a href="SourceQueue.html" class="extype" name="akka.stream.javadsl.SourceQueue">SourceQueue</a>.</p>
    </li><li name="akka.stream.javadsl.SourceWithContext" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SourceWithContext[+Out,+Ctx,+Mat]extendsGraphDelegate[akka.stream.SourceShape[(Out,Ctx)],Mat]"></a><a id="SourceWithContext[+Out,+Ctx,+Mat]:SourceWithContext[Out,Ctx,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SourceWithContext[+Out,+Ctx,+Mat]extendsGraphDelegate[akka.stream.SourceShape[(Out,Ctx)],Mat]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A source that provides operations which automatically propagate the context of an element." href="SourceWithContext.html"><span class="name">SourceWithContext</span></a><span class="tparams">[<span name="Out">+Out</span>, <span name="Ctx">+Ctx</span>, <span name="Mat">+Mat</span>]</span><span class="result"> extends <span class="extype" name="akka.stream.GraphDelegate">GraphDelegate</span>[<a href="../SourceShape.html" class="extype" name="akka.stream.SourceShape">SourceShape</a>[(<span class="extype" name="akka.stream.javadsl.SourceWithContext.Out">Out</span>, <span class="extype" name="akka.stream.javadsl.SourceWithContext.Ctx">Ctx</span>)], <span class="extype" name="akka.stream.javadsl.SourceWithContext.Mat">Mat</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A source that provides operations which automatically propagate the context of an element.</p><div class="fullcomment"><div class="comment cmt"><p>A source that provides operations which automatically propagate the context of an element.
Only a subset of common operations from <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> is supported. As an escape hatch you can
use <a href="SourceWithContext.html#via[Out2,Ctx2,Mat2](viaFlow:akka.stream.Graph[akka.stream.FlowShape[akka.japi.Pair[Out@scala.annotation.unchecked.uncheckedVariance,Ctx@scala.annotation.unchecked.uncheckedVariance],akka.japi.Pair[Out2,Ctx2]],Mat2]):akka.stream.javadsl.SourceWithContext[Out2,Ctx2,Mat]" class="extmbr" name="akka.stream.javadsl.SourceWithContext#via">SourceWithContext#via</a> to manually provide the context propagation for otherwise unsupported
operations.</p><p>Can be created by calling <span class="extype" name="Source.asSourceWithContext()">Source.asSourceWithContext()</span></p><p>API MAY CHANGE
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@<a href="../../annotation/ApiMayChange.html" class="extype" name="akka.annotation.ApiMayChange">ApiMayChange</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="akka.stream.javadsl.SubFlow" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SubFlow[In,Out,Mat]extendsAnyRef"></a><a id="SubFlow[In,Out,Mat]:SubFlow[In,Out,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SubFlow[In,Out,Mat]extendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A “stream of streams” sub-flow of data elements, e.g." href="SubFlow.html"><span class="name">SubFlow</span></a><span class="tparams">[<span name="In">In</span>, <span name="Out">Out</span>, <span name="Mat">Mat</span>]</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a></span>
      </span>
      
      <p class="shortcomment cmt">A “stream of streams” sub-flow of data elements, e.g.</p><div class="fullcomment"><div class="comment cmt"><p>A “stream of streams” sub-flow of data elements, e.g. produced by <code>groupBy</code>.
SubFlows cannot contribute to the super-flow’s materialized value since they
are materialized later, during the runtime of the flow graph processing.
</p></div></div>
    </li><li name="akka.stream.javadsl.SubSource" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SubSource[Out,Mat]extendsAnyRef"></a><a id="SubSource[Out,Mat]:SubSource[Out,Mat]"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SubSource[Out,Mat]extendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A “stream of streams” sub-flow of data elements, e.g." href="SubSource.html"><span class="name">SubSource</span></a><span class="tparams">[<span name="Out">Out</span>, <span name="Mat">Mat</span>]</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a></span>
      </span>
      
      <p class="shortcomment cmt">A “stream of streams” sub-flow of data elements, e.g.</p><div class="fullcomment"><div class="comment cmt"><p>A “stream of streams” sub-flow of data elements, e.g. produced by <code>groupBy</code>.
SubFlows cannot contribute to the super-flow’s materialized value since they
are materialized later, during the runtime of the flow graph processing.
</p></div></div>
    </li><li name="akka.stream.javadsl.Tcp" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TcpextendsExtension"></a><a id="Tcp:Tcp"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#TcpextendsExtension" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="" href="Tcp.html"><span class="name">Tcp</span></a><span class="result"> extends <a href="../../actor/Extension.html" class="extype" name="akka.actor.Extension">Extension</a></span>
      </span>
      
      
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="akka.stream.javadsl#combinerToScala" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="combinerToScala[M1,M2,M](f:akka.japi.function.Function2[M1,M2,M]):(M1,M2)=&gt;M"></a><a id="combinerToScala[M1,M2,M](Function2[M1,M2,M]):(M1,M2)⇒M"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#combinerToScala[M1,M2,M](f:akka.japi.function.Function2[M1,M2,M]):(M1,M2)=&gt;M" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">combinerToScala</span><span class="tparams">[<span name="M1">M1</span>, <span name="M2">M2</span>, <span name="M">M</span>]</span><span class="params">(<span name="f">f: <a href="../../japi/function/Function2.html" class="extype" name="akka.japi.function.Function2">Function2</a>[<span class="extype" name="akka.stream.javadsl.combinerToScala.M1">M1</span>, <span class="extype" name="akka.stream.javadsl.combinerToScala.M2">M2</span>, <span class="extype" name="akka.stream.javadsl.combinerToScala.M">M</span>]</span>)</span><span class="result">: (<span class="extype" name="akka.stream.javadsl.combinerToScala.M1">M1</span>, <span class="extype" name="akka.stream.javadsl.combinerToScala.M2">M2</span>) ⇒ <span class="extype" name="akka.stream.javadsl.combinerToScala.M">M</span></span>
      </span>
      
      
    </li><li name="akka.stream.javadsl.Balance" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Balance"></a><a id="Balance:Balance"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Balance" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Fan-out the stream to several streams." href="Balance$.html"><span class="name">Balance</span></a>
      </span>
      
      <p class="shortcomment cmt">Fan-out the stream to several streams.</p><div class="fullcomment"><div class="comment cmt"><p>Fan-out the stream to several streams. Each upstream element is emitted to the first available downstream consumer.
It will not shutdown until the subscriptions for at least
two downstream subscribers have been established.</p><p><b>Emits when</b> any of the outputs stops backpressuring; emits the element to the first available output</p><p><b>Backpressures when</b> all of the outputs backpressure</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> If eagerCancel is enabled: when any downstream cancels; otherwise: when all downstreams cancel
</p></div></div>
    </li><li name="akka.stream.javadsl.BidiFlow" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BidiFlow"></a><a id="BidiFlow:BidiFlow"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#BidiFlow" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="BidiFlow$.html"><span class="name">BidiFlow</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl.Broadcast" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Broadcast"></a><a id="Broadcast:Broadcast"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Broadcast" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Fan-out the stream to several streams." href="Broadcast$.html"><span class="name">Broadcast</span></a>
      </span>
      
      <p class="shortcomment cmt">Fan-out the stream to several streams.</p><div class="fullcomment"><div class="comment cmt"><p>Fan-out the stream to several streams. emitting each incoming upstream element to all downstream consumers.
It will not shutdown until the subscriptions for at least
two downstream subscribers have been established.</p><p><b>Emits when</b> all of the outputs stops backpressuring and there is an input element available</p><p><b>Backpressures when</b> any of the outputs backpressure</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b>
  If eagerCancel is enabled: when any downstream cancels; otherwise: when all downstreams cancel
</p></div></div>
    </li><li name="akka.stream.javadsl.BroadcastHub" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BroadcastHub"></a><a id="BroadcastHub:BroadcastHub"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#BroadcastHub" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A BroadcastHub is a special streaming hub that is able to broadcast streamed elements to a dynamic set of consumers." href="BroadcastHub$.html"><span class="name">BroadcastHub</span></a>
      </span>
      
      <p class="shortcomment cmt">A BroadcastHub is a special streaming hub that is able to broadcast streamed elements to a dynamic set of consumers.</p><div class="fullcomment"><div class="comment cmt"><p>A BroadcastHub is a special streaming hub that is able to broadcast streamed elements to a dynamic set of consumers.
It consists of two parts, a <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> and a <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a>. The <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> broadcasts elements from a producer to the
actually live consumers it has. Once the producer has been materialized, the <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> it feeds into returns a
materialized value which is the corresponding <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a>. This <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> can be materialized an arbitrary number
of times, where each of the new materializations will receive their elements from the original <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a>.
</p></div></div>
    </li><li name="akka.stream.javadsl.Compression" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Compression"></a><a id="Compression:Compression"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Compression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Compression$.html"><span class="name">Compression</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl.Concat" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Concat"></a><a id="Concat:Concat"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Concat" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Takes two streams and outputs an output stream formed from the two input streams by consuming one stream first emitting all of its elements, then consuming the second stream emitting all of its elements." href="Concat$.html"><span class="name">Concat</span></a>
      </span>
      
      <p class="shortcomment cmt">Takes two streams and outputs an output stream formed from the two input streams
by consuming one stream first emitting all of its elements, then consuming the
second stream emitting all of its elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes two streams and outputs an output stream formed from the two input streams
by consuming one stream first emitting all of its elements, then consuming the
second stream emitting all of its elements.</p><p><b>Emits when</b> the current stream has an element available; if the current input completes, it tries the next one</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstreams complete</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.CoupledTerminationFlow" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CoupledTerminationFlow"></a><a id="CoupledTerminationFlow:CoupledTerminationFlow"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#CoupledTerminationFlow" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Allows coupling termination (cancellation, completion, erroring) of Sinks and Sources while creating a Flow them them." href="CoupledTerminationFlow$.html"><span class="name">CoupledTerminationFlow</span></a>
      </span>
      
      <p class="shortcomment cmt">Allows coupling termination (cancellation, completion, erroring) of Sinks and Sources while creating a Flow them them.</p><div class="fullcomment"><div class="comment cmt"><p>Allows coupling termination (cancellation, completion, erroring) of Sinks and Sources while creating a Flow them them.
Similar to <code>Flow.fromSinkAndSource</code> however that API does not connect the completion signals of the wrapped operators.
</p></div></div>
    </li><li name="akka.stream.javadsl.FileIO" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="FileIO"></a><a id="FileIO:FileIO"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#FileIO" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Java API: Factories to create sinks and sources from files" href="FileIO$.html"><span class="name">FileIO</span></a>
      </span>
      
      <p class="shortcomment cmt">Java API: Factories to create sinks and sources from files
</p>
    </li><li name="akka.stream.javadsl.Flow" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Flow"></a><a id="Flow:Flow"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Flow" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Flow$.html"><span class="name">Flow</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl.FlowWithContext" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FlowWithContext"></a><a id="FlowWithContext:FlowWithContext"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#FlowWithContext" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="API MAY CHANGE" href="FlowWithContext$.html"><span class="name">FlowWithContext</span></a>
      </span>
      
      <p class="shortcomment cmt">API MAY CHANGE
</p><div class="fullcomment"><div class="comment cmt"><p>API MAY CHANGE
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@<a href="../../annotation/ApiMayChange.html" class="extype" name="akka.annotation.ApiMayChange">ApiMayChange</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="akka.stream.javadsl.Framing" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Framing"></a><a id="Framing:Framing"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Framing" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Framing$.html"><span class="name">Framing</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl.GraphDSL" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="GraphDSL"></a><a id="GraphDSL:GraphDSL"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#GraphDSL" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="GraphDSL$.html"><span class="name">GraphDSL</span></a><span class="result"> extends <span class="extype" name="akka.stream.javadsl.GraphCreate">GraphCreate</span></span>
      </span>
      
      
    </li><li name="akka.stream.javadsl.JsonFraming" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="JsonFraming"></a><a id="JsonFraming:JsonFraming"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#JsonFraming" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Provides JSON framing operators that can separate valid JSON objects from incoming akka.util.ByteString objects." href="JsonFraming$.html"><span class="name">JsonFraming</span></a>
      </span>
      
      <p class="shortcomment cmt">Provides JSON framing operators that can separate valid JSON objects from incoming <a href="../../util/ByteString.html" class="extype" name="akka.util.ByteString">akka.util.ByteString</a> objects.</p>
    </li><li name="akka.stream.javadsl.Keep" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Keep"></a><a id="Keep:Keep"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Keep" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Keep$.html"><span class="name">Keep</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl.Merge" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Merge"></a><a id="Merge:Merge"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Merge" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Merge several streams, taking elements as they arrive from input streams (picking randomly when several have elements ready)." href="Merge$.html"><span class="name">Merge</span></a>
      </span>
      
      <p class="shortcomment cmt">Merge several streams, taking elements as they arrive from input streams
(picking randomly when several have elements ready).</p><div class="fullcomment"><div class="comment cmt"><p>Merge several streams, taking elements as they arrive from input streams
(picking randomly when several have elements ready).</p><p><b>Emits when</b> one of the inputs has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true)</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.MergeHub" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="MergeHub"></a><a id="MergeHub:MergeHub"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#MergeHub" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A MergeHub is a special streaming hub that is able to collect streamed elements from a dynamic set of producers." href="MergeHub$.html"><span class="name">MergeHub</span></a>
      </span>
      
      <p class="shortcomment cmt">A MergeHub is a special streaming hub that is able to collect streamed elements from a dynamic set of
producers.</p><div class="fullcomment"><div class="comment cmt"><p>A MergeHub is a special streaming hub that is able to collect streamed elements from a dynamic set of
producers. It consists of two parts, a <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> and a <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a>. The <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> streams the element to a consumer from
its merged inputs. Once the consumer has been materialized, the <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> returns a materialized value which is
the corresponding <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a>. This <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> can then be materialized arbitrary many times, where each of the new
materializations will feed its consumed elements to the original <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a>.
</p></div></div>
    </li><li name="akka.stream.javadsl.MergeLatest" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="MergeLatest"></a><a id="MergeLatest:MergeLatest"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#MergeLatest" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="MergeLatest joins elements from N input streams into stream of lists of size N." href="MergeLatest$.html"><span class="name">MergeLatest</span></a>
      </span>
      
      <p class="shortcomment cmt">MergeLatest joins elements from N input streams into stream of lists of size N.</p><div class="fullcomment"><div class="comment cmt"><p>MergeLatest joins elements from N input streams into stream of lists of size N.
i-th element in list is the latest emitted element from i-th input stream.
MergeLatest emits list for each element emitted from some input stream,
but only after each stream emitted at least one element</p><p><b>Emits when</b> element is available from some input and each input emits at least one element from stream start</p><p><b>Completes when</b> all upstreams complete (eagerClose=false) or one upstream completes (eagerClose=true)</p><p><b>Cancels when</b> downstream cancels</p></div></div>
    </li><li name="akka.stream.javadsl.MergePreferred" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="MergePreferred"></a><a id="MergePreferred:MergePreferred"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#MergePreferred" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Merge several streams, taking elements as they arrive from input streams (picking from preferred when several have elements ready)." href="MergePreferred$.html"><span class="name">MergePreferred</span></a>
      </span>
      
      <p class="shortcomment cmt">Merge several streams, taking elements as they arrive from input streams
(picking from preferred when several have elements ready).</p><div class="fullcomment"><div class="comment cmt"><p>Merge several streams, taking elements as they arrive from input streams
(picking from preferred when several have elements ready).</p><p><b>Emits when</b> one of the inputs has an element available, preferring
a specified input if multiple have elements available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true)</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.MergePrioritized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="MergePrioritized"></a><a id="MergePrioritized:MergePrioritized"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#MergePrioritized" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Merge several streams, taking elements as they arrive from input streams (picking from prioritized once when several have elements ready)." href="MergePrioritized$.html"><span class="name">MergePrioritized</span></a>
      </span>
      
      <p class="shortcomment cmt">Merge several streams, taking elements as they arrive from input streams
(picking from prioritized once when several have elements ready).</p><div class="fullcomment"><div class="comment cmt"><p>Merge several streams, taking elements as they arrive from input streams
(picking from prioritized once when several have elements ready).</p><p>A <code>MergePrioritized</code> has one <code>out</code> port, one or more input port with their priorities.</p><p><b>Emits when</b> one of the inputs has an element available, preferring
a input based on its priority if multiple have elements available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true), default value is <code>false</code></p><p><b>Cancels when</b> downstream cancels</p><p>A <code>Broadcast</code> has one <code>in</code> port and 2 or more <code>out</code> ports.
</p></div></div>
    </li><li name="akka.stream.javadsl.Partition" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Partition"></a><a id="Partition:Partition"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Partition" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Fan-out the stream to several streams." href="Partition$.html"><span class="name">Partition</span></a>
      </span>
      
      <p class="shortcomment cmt">Fan-out the stream to several streams.</p><div class="fullcomment"><div class="comment cmt"><p>Fan-out the stream to several streams. emitting an incoming upstream element to one downstream consumer according
to the partitioner function applied to the element</p><p><b>Emits when</b> all of the outputs stops backpressuring and there is an input element available</p><p><b>Backpressures when</b> one of the outputs backpressure</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b>
  when any (eagerCancel=true) or all (eagerCancel=false) of the downstreams cancel
</p></div></div>
    </li><li name="akka.stream.javadsl.PartitionHub" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PartitionHub"></a><a id="PartitionHub:PartitionHub"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#PartitionHub" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A PartitionHub is a special streaming hub that is able to route streamed elements to a dynamic set of consumers." href="PartitionHub$.html"><span class="name">PartitionHub</span></a>
      </span>
      
      <p class="shortcomment cmt">A <code>PartitionHub</code> is a special streaming hub that is able to route streamed elements to a dynamic set of consumers.</p><div class="fullcomment"><div class="comment cmt"><p>A <code>PartitionHub</code> is a special streaming hub that is able to route streamed elements to a dynamic set of consumers.
It consists of two parts, a <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> and a <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a>. The <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> e elements from a producer to the
actually live consumers it has. The selection of consumer is done with a function. Each element can be routed to
only one consumer. Once the producer has been materialized, the <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> it feeds into returns a
materialized value which is the corresponding <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a>. This <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> can be materialized an arbitrary number
of times, where each of the new materializations will receive their elements from the original <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a>.
</p></div></div>
    </li><li name="akka.stream.javadsl.RestartFlow" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RestartFlow"></a><a id="RestartFlow:RestartFlow"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#RestartFlow" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A RestartFlow wraps a Flow that gets restarted when it completes or fails." href="RestartFlow$.html"><span class="name">RestartFlow</span></a>
      </span>
      
      <p class="shortcomment cmt">A RestartFlow wraps a <a href="Flow.html" class="extype" name="akka.stream.javadsl.Flow">Flow</a> that gets restarted when it completes or fails.</p><div class="fullcomment"><div class="comment cmt"><p>A RestartFlow wraps a <a href="Flow.html" class="extype" name="akka.stream.javadsl.Flow">Flow</a> that gets restarted when it completes or fails.</p><p>They are useful for graphs that need to run for longer than the <a href="Flow.html" class="extype" name="akka.stream.javadsl.Flow">Flow</a> can necessarily guarantee it will, for
example, for <a href="Flow.html" class="extype" name="akka.stream.javadsl.Flow">Flow</a> streams that depend on a remote server that may crash or become partitioned. The
RestartFlow ensures that the graph can continue running while the <a href="Flow.html" class="extype" name="akka.stream.javadsl.Flow">Flow</a> restarts.
</p></div></div>
    </li><li name="akka.stream.javadsl.RestartSink" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RestartSink"></a><a id="RestartSink:RestartSink"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#RestartSink" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A RestartSink wraps a Sink that gets restarted when it completes or fails." href="RestartSink$.html"><span class="name">RestartSink</span></a>
      </span>
      
      <p class="shortcomment cmt">A RestartSink wraps a <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> that gets restarted when it completes or fails.</p><div class="fullcomment"><div class="comment cmt"><p>A RestartSink wraps a <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> that gets restarted when it completes or fails.</p><p>They are useful for graphs that need to run for longer than the <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> can necessarily guarantee it will, for
example, for <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> streams that depend on a remote server that may crash or become partitioned. The
RestartSink ensures that the graph can continue running while the <a href="Sink.html" class="extype" name="akka.stream.javadsl.Sink">Sink</a> restarts.
</p></div></div>
    </li><li name="akka.stream.javadsl.RestartSource" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RestartSource"></a><a id="RestartSource:RestartSource"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#RestartSource" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A RestartSource wraps a Source that gets restarted when it completes or fails." href="RestartSource$.html"><span class="name">RestartSource</span></a>
      </span>
      
      <p class="shortcomment cmt">A RestartSource wraps a <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> that gets restarted when it completes or fails.</p><div class="fullcomment"><div class="comment cmt"><p>A RestartSource wraps a <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> that gets restarted when it completes or fails.</p><p>They are useful for graphs that need to run for longer than the <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> can necessarily guarantee it will, for
example, for <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> streams that depend on a remote server that may crash or become partitioned. The
RestartSource ensures that the graph can continue running while the <a href="Source.html" class="extype" name="akka.stream.javadsl.Source">Source</a> restarts.
</p></div></div>
    </li><li name="akka.stream.javadsl.RunnableGraph" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RunnableGraph"></a><a id="RunnableGraph:RunnableGraph"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#RunnableGraph" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="RunnableGraph$.html"><span class="name">RunnableGraph</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl.Sink" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Sink"></a><a id="Sink:Sink"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Sink" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Java API" href="Sink$.html"><span class="name">Sink</span></a>
      </span>
      
      <p class="shortcomment cmt">Java API</p>
    </li><li name="akka.stream.javadsl.Source" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Source"></a><a id="Source:Source"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Source" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Java API" href="Source$.html"><span class="name">Source</span></a>
      </span>
      
      <p class="shortcomment cmt">Java API</p>
    </li><li name="akka.stream.javadsl.SourceWithContext" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SourceWithContext"></a><a id="SourceWithContext:SourceWithContext"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SourceWithContext" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="API MAY CHANGE" href="SourceWithContext$.html"><span class="name">SourceWithContext</span></a>
      </span>
      
      <p class="shortcomment cmt">API MAY CHANGE
</p><div class="fullcomment"><div class="comment cmt"><p>API MAY CHANGE
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@<a href="../../annotation/ApiMayChange.html" class="extype" name="akka.annotation.ApiMayChange">ApiMayChange</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="akka.stream.javadsl.StreamConverters" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="StreamConverters"></a><a id="StreamConverters:StreamConverters"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#StreamConverters" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Converters for interacting with the blocking java.io streams APIs and Java 8 Streams" href="StreamConverters$.html"><span class="name">StreamConverters</span></a>
      </span>
      
      <p class="shortcomment cmt">Converters for interacting with the blocking <code>java.io</code> streams APIs and Java 8 Streams
</p>
    </li><li name="akka.stream.javadsl.StreamRefs" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamRefs"></a><a id="StreamRefs:StreamRefs"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#StreamRefs" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="API MAY CHANGE: The functionality of stream refs is working, however it is expected that the materialized value will eventually be able to remove the Future wrapping the stream references." href="StreamRefs$.html"><span class="name">StreamRefs</span></a>
      </span>
      
      <p class="shortcomment cmt">API MAY CHANGE: The functionality of stream refs is working, however it is expected that the materialized value
will eventually be able to remove the Future wrapping the stream references.</p><div class="fullcomment"><div class="comment cmt"><p>API MAY CHANGE: The functionality of stream refs is working, however it is expected that the materialized value
will eventually be able to remove the Future wrapping the stream references. For this reason the API is now marked
as API may change. See ticket https://github.com/akka/akka/issues/24372 for more details.</p><p>Factories for creating stream refs.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@<a href="../../annotation/ApiMayChange.html" class="extype" name="akka.annotation.ApiMayChange">ApiMayChange</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="akka.stream.javadsl.SubFlow" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SubFlow"></a><a id="SubFlow:SubFlow"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SubFlow" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="SubFlow$.html"><span class="name">SubFlow</span></a>
      </span>
      
      
    </li><li name="akka.stream.javadsl.SubSource" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SubSource"></a><a id="SubSource:SubSource"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#SubSource" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="* Upcast a stream of elements to a stream of supertypes of that element." href="SubSource$.html"><span class="name">SubSource</span></a>
      </span>
      
      <p class="shortcomment cmt">* Upcast a stream of elements to a stream of supertypes of that element.</p><div class="fullcomment"><div class="comment cmt"><p>* Upcast a stream of elements to a stream of supertypes of that element. Useful in combination with
fan-in operators where you do not want to pay the cost of casting each element in a <code>map</code>.
</p></div></div>
    </li><li name="akka.stream.javadsl.TLS" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TLS"></a><a id="TLS:TLS"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#TLS" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Stream cipher support based upon JSSE." href="TLS$.html"><span class="name">TLS</span></a>
      </span>
      
      <p class="shortcomment cmt">Stream cipher support based upon JSSE.</p><div class="fullcomment"><div class="comment cmt"><p>Stream cipher support based upon JSSE.</p><p>The underlying SSLEngine has four ports: plaintext input/output and
ciphertext input/output. These are modeled as a <a href="../BidiShape.html" class="extype" name="akka.stream.BidiShape">akka.stream.BidiShape</a>
element for use in stream topologies, where the plaintext ports are on the
left hand side of the shape and the ciphertext ports on the right hand side.</p><p>Configuring JSSE is a rather complex topic, please refer to the JDK platform
documentation or the excellent user guide that is part of the Play Framework
documentation. The philosophy of this integration into Akka Streams is to
expose all knobs and dials to client code and therefore not limit the
configuration possibilities. In particular the client code will have to
provide the SSLContext from which the SSLEngine is then created. Handshake
parameters are set using <span class="extype" name="NegotiateNewSession">NegotiateNewSession</span> messages, the settings for
the initial handshake need to be provided up front using the same class;
please refer to the method documentation below.</p><p><b>IMPORTANT NOTE</b></p><p>The TLS specification does not permit half-closing of the user data session
that it transports—to be precise a half-close will always promptly lead to a
full close. This means that canceling the plaintext output or completing the
plaintext input of the SslTls operator will lead to full termination of the
secure connection without regard to whether bytes are remaining to be sent or
received, respectively. Especially for a client the common idiom of attaching
a finite Source to the plaintext input and transforming the plaintext response
bytes coming out will not work out of the box due to early termination of the
connection. For this reason there is a parameter that determines whether the
SslTls operator shall ignore completion and/or cancellation events, and the
default is to ignore completion (in view of the client–server scenario). In
order to terminate the connection the client will then need to cancel the
plaintext output as soon as all expected bytes have been received. When
ignoring both types of events the operator will shut down once both events have
been received. See also <a href="../TLSClosing.html" class="extype" name="akka.stream.TLSClosing">TLSClosing</a>.
</p></div></div>
    </li><li name="akka.stream.javadsl.TLSPlacebo" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TLSPlacebo"></a><a id="TLSPlacebo:TLSPlacebo"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#TLSPlacebo" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This object holds simple wrapping akka.stream.scaladsl.BidiFlow implementations that can be used instead of TLS when no encryption is desired." href="TLSPlacebo$.html"><span class="name">TLSPlacebo</span></a>
      </span>
      
      <p class="shortcomment cmt">This object holds simple wrapping <a href="../scaladsl/BidiFlow.html" class="extype" name="akka.stream.scaladsl.BidiFlow">akka.stream.scaladsl.BidiFlow</a> implementations that can
be used instead of <a href="TLS$.html" class="extype" name="akka.stream.javadsl.TLS">TLS</a> when no encryption is desired.</p><div class="fullcomment"><div class="comment cmt"><p>This object holds simple wrapping <a href="../scaladsl/BidiFlow.html" class="extype" name="akka.stream.scaladsl.BidiFlow">akka.stream.scaladsl.BidiFlow</a> implementations that can
be used instead of <a href="TLS$.html" class="extype" name="akka.stream.javadsl.TLS">TLS</a> when no encryption is desired. The flows will
just adapt the message protocol by wrapping into <span class="extype" name="SessionBytes">SessionBytes</span> and
unwrapping <span class="extype" name="SendBytes">SendBytes</span>.
</p></div></div>
    </li><li name="akka.stream.javadsl.Tcp" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Tcp"></a><a id="Tcp:Tcp"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Tcp" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="Tcp$.html"><span class="name">Tcp</span></a><span class="result"> extends <a href="../../actor/ExtensionId.html" class="extype" name="akka.actor.ExtensionId">ExtensionId</a>[<a href="Tcp.html" class="extype" name="akka.stream.javadsl.Tcp">Tcp</a>] with <a href="../../actor/ExtensionIdProvider.html" class="extype" name="akka.actor.ExtensionIdProvider">ExtensionIdProvider</a></span>
      </span>
      
      
    </li><li name="akka.stream.javadsl.Unzip" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Unzip"></a><a id="Unzip:Unzip"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Unzip" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Takes a stream of pair elements and splits each pair to two output streams." href="Unzip$.html"><span class="name">Unzip</span></a>
      </span>
      
      <p class="shortcomment cmt">Takes a stream of pair elements and splits each pair to two output streams.</p><div class="fullcomment"><div class="comment cmt"><p>Takes a stream of pair elements and splits each pair to two output streams.</p><p>An <code>Unzip</code> has one <code>in</code> port and one <code>left</code> and one <code>right</code> output port.</p><p><b>Emits when</b> all of the outputs stops backpressuring and there is an input element available</p><p><b>Backpressures when</b> any of the outputs backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> any downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.UnzipWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="UnzipWith"></a><a id="UnzipWith:UnzipWith"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#UnzipWith" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Split one stream into several streams using a splitting function." href="UnzipWith$.html"><span class="name">UnzipWith</span></a>
      </span>
      
      <p class="shortcomment cmt">Split one stream into several streams using a splitting function.</p><div class="fullcomment"><div class="comment cmt"><p>Split one stream into several streams using a splitting function.</p><p><b>Emits when</b> all of the outputs stops backpressuring and there is an input element available</p><p><b>Backpressures when</b> any of the outputs backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> any downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.Zip" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Zip"></a><a id="Zip:Zip"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#Zip" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combine the elements of 2 streams into a stream of tuples." href="Zip$.html"><span class="name">Zip</span></a>
      </span>
      
      <p class="shortcomment cmt">Combine the elements of 2 streams into a stream of tuples.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of 2 streams into a stream of tuples.</p><p>A <code>Zip</code> has a <code>left</code> and a <code>right</code> input port and one <code>out</code> port</p><p><b>Emits when</b> all of the inputs has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.ZipLatest" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ZipLatest"></a><a id="ZipLatest:ZipLatest"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#ZipLatest" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each." href="ZipLatest$.html"><span class="name">ZipLatest</span></a>
      </span>
      
      <p class="shortcomment cmt">Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each.</p><p>A <code>Zip</code> has a <code>left</code> and a <code>right</code> input port and one <code>out</code> port</p><p><b>Emits when</b> all of the inputs have at least an element available, and then each time an element becomes
                 available on either of the inputs</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.ZipLatestWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ZipLatestWith"></a><a id="ZipLatestWith:ZipLatestWith"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#ZipLatestWith" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combine the elements of multiple streams into a stream of combined elements using a combiner function, picking always the latest of the elements of each source." href="ZipLatestWith$.html"><span class="name">ZipLatestWith</span></a>
      </span>
      
      <p class="shortcomment cmt">Combine the elements of multiple streams into a stream of combined elements using a combiner function,
picking always the latest of the elements of each source.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of multiple streams into a stream of combined elements using a combiner function,
picking always the latest of the elements of each source.</p><p>No element is emitted until at least one element from each Source becomes available. Whenever a new
element appears, the zipping function is invoked with a tuple containing the new element
and the other last seen elements.</p><p>  <b>Emits when</b> all of the inputs have at least an element available, and then each time an element becomes
  available on either of the inputs</p><p>  <b>Backpressures when</b> downstream backpressures</p><p>  <b>Completes when</b> any of the upstreams completes</p><p>  <b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.ZipN" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ZipN"></a><a id="ZipN:ZipN"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#ZipN" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combine the elements of multiple streams into a stream of lists." href="ZipN$.html"><span class="name">ZipN</span></a>
      </span>
      
      <p class="shortcomment cmt">Combine the elements of multiple streams into a stream of lists.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of multiple streams into a stream of lists.</p><p>A <code>ZipN</code> has a <code>n</code> input ports and one <code>out</code> port</p><p><b>Emits when</b> all of the inputs has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.ZipWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ZipWith"></a><a id="ZipWith:ZipWith"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#ZipWith" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combine the elements of multiple streams into a stream of combined elements using a combiner function." href="ZipWith$.html"><span class="name">ZipWith</span></a>
      </span>
      
      <p class="shortcomment cmt">Combine the elements of multiple streams into a stream of combined elements using a combiner function.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of multiple streams into a stream of combined elements using a combiner function.</p><p><b>Emits when</b> all of the inputs has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li><li name="akka.stream.javadsl.ZipWithN" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ZipWithN"></a><a id="ZipWithN:ZipWithN"></a>
      <span class="permalink">
      <a href="../../../akka/stream/javadsl/index.html#ZipWithN" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combine the elements of multiple streams into a stream of lists using a combiner function." href="ZipWithN$.html"><span class="name">ZipWithN</span></a>
      </span>
      
      <p class="shortcomment cmt">Combine the elements of multiple streams into a stream of lists using a combiner function.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of multiple streams into a stream of lists using a combiner function.</p><p>A <code>ZipWithN</code> has a <code>n</code> input ports and one <code>out</code> port</p><p><b>Emits when</b> all of the inputs has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.8/scala/AnyRef.html#scala.AnyRef" class="extype" name="scala.AnyRef">AnyRef</a></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <a href="http://www.scala-lang.org/api/2.12.8/scala/Any.html#scala.Any" class="extype" name="scala.Any">Any</a></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
