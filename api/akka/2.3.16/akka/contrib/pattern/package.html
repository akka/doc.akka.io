<!DOCTYPE html >
<html>
        <head>
         <link rel="canonical" href="https://doc.akka.io/api/akka/current/akka/contrib/pattern/package.html" />
          <title>pattern - akka.contrib.pattern</title>
          <meta name="description" content="pattern - akka.contrib.pattern" />
          <meta name="keywords" content="pattern akka.contrib.pattern" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      <script type="text/javascript" src="../../../lib/modernizr.custom.js"></script><script type="text/javascript" src="../../../lib/diagrams.js" id="diagrams-js"></script>
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'akka.contrib.pattern.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img src="../../../lib/package_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="akka">akka</a>.<a href="../package.html" class="extype" name="akka.contrib">contrib</a></p>
        <h1>pattern</h1><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">pattern</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="akka.contrib.pattern.Aggregator" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="AggregatorextendsAnyRef"></a>
      <a id="Aggregator:Aggregator"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Aggregator.html"><span class="name">Aggregator</span></a><span class="result"> extends <a href="http://www.scala-lang.org/api/2.11.5/index.html#scala.AnyRef" class="extype" target="_top">AnyRef</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@AggregatorextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">The aggregator is to be mixed into an actor for the aggregator behavior.</p>
    </li><li name="akka.contrib.pattern.ClusterClient" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterClientextendsActorwithStashwithActorLogging"></a>
      <a id="ClusterClient:ClusterClient"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClusterClient.html"><span class="name">ClusterClient</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a> with <a href="../../actor/Stash.html" class="extype" name="akka.actor.Stash">Stash</a> with <a href="../../actor/ActorLogging.html" class="extype" name="akka.actor.ActorLogging">ActorLogging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterClientextendsActorwithStashwithActorLogging" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">This actor is intended to be used on an external node that is not member
of the cluster.</p><div class="fullcomment"><div class="comment cmt"><p>This actor is intended to be used on an external node that is not member
of the cluster. It acts like a gateway for sending messages to actors
somewhere in the cluster. From the initial contact points it will establish
a connection to a <a href="ClusterReceptionist.html" class="extype" name="akka.contrib.pattern.ClusterReceptionist">ClusterReceptionist</a> somewhere in the cluster. It will
monitor the connection to the receptionist and establish a new connection if
the link goes down. When looking for a new receptionist it uses fresh contact
points retrieved from previous establishment, or periodically refreshed
contacts, i.e. not necessarily the initial contact points.</p><p>You can send messages via the <code>ClusterClient</code> to any actor in the cluster
that is registered in the <a href="ClusterReceptionist.html" class="extype" name="akka.contrib.pattern.ClusterReceptionist">ClusterReceptionist</a>.
Messages are wrapped in <a href="ClusterClient$$Send.html" class="extype" name="akka.contrib.pattern.ClusterClient.Send">ClusterClient.Send</a>, <a href="ClusterClient$$SendToAll.html" class="extype" name="akka.contrib.pattern.ClusterClient.SendToAll">ClusterClient.SendToAll</a>
or <a href="ClusterClient$$Publish.html" class="extype" name="akka.contrib.pattern.ClusterClient.Publish">ClusterClient.Publish</a>.</p><p>1. <a href="ClusterClient$$Send.html" class="extype" name="akka.contrib.pattern.ClusterClient.Send">ClusterClient.Send</a> -
The message will be delivered to one recipient with a matching path, if any such
exists. If several entries match the path the message will be delivered
to one random destination. The sender of the message can specify that local
affinity is preferred, i.e. the message is sent to an actor in the same local actor
system as the used receptionist actor, if any such exists, otherwise random to any other
matching entry.</p><p>2. <a href="ClusterClient$$SendToAll.html" class="extype" name="akka.contrib.pattern.ClusterClient.SendToAll">ClusterClient.SendToAll</a> -
The message will be delivered to all recipients with a matching path.</p><p>3. <a href="ClusterClient$$Publish.html" class="extype" name="akka.contrib.pattern.ClusterClient.Publish">ClusterClient.Publish</a> -
The message will be delivered to all recipients Actors that have been registered as subscribers to
to the named topic.</p><p> Use the factory method <a href="ClusterClient$.html#props(initialContacts:java.util.Set[akka.actor.ActorSelection],establishingGetContactsInterval:scala.concurrent.duration.FiniteDuration,refreshContactsInterval:scala.concurrent.duration.FiniteDuration):akka.actor.Props" class="extmbr" name="akka.contrib.pattern.ClusterClient#props">ClusterClient#props</a>) to create the
<a href="../../actor/Props.html" class="extype" name="akka.actor.Props">akka.actor.Props</a> for the actor.
</p></div></div>
    </li><li name="akka.contrib.pattern.ClusterReceptionist" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterReceptionistextendsActorwithActorLogging"></a>
      <a id="ClusterReceptionist:ClusterReceptionist"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClusterReceptionist.html"><span class="name">ClusterReceptionist</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a> with <a href="../../actor/ActorLogging.html" class="extype" name="akka.actor.ActorLogging">ActorLogging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterReceptionistextendsActorwithActorLogging" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt"><a href="ClusterClient.html" class="extype" name="akka.contrib.pattern.ClusterClient">ClusterClient</a> connects to this actor to retrieve.</p><div class="fullcomment"><div class="comment cmt"><p><a href="ClusterClient.html" class="extype" name="akka.contrib.pattern.ClusterClient">ClusterClient</a> connects to this actor to retrieve. The <code>ClusterReceptionist</code> is
supposed to be started on all nodes, or all nodes with specified role, in the cluster.
The receptionist can be started with the <a href="ClusterReceptionistExtension.html" class="extype" name="akka.contrib.pattern.ClusterReceptionistExtension">ClusterReceptionistExtension</a> or as an
ordinary actor (use the factory method <a href="ClusterReceptionist$.html#props(pubSubMediator:akka.actor.ActorRef,role:String):akka.actor.Props" class="extmbr" name="akka.contrib.pattern.ClusterReceptionist#props">ClusterReceptionist#props</a>).</p><p>The receptionist forwards messages from the client to the associated <a href="DistributedPubSubMediator.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator">DistributedPubSubMediator</a>,
i.e. the client can send messages to any actor in the cluster that is registered in the
<code>DistributedPubSubMediator</code>. Messages from the client are wrapped in
<a href="DistributedPubSubMediator$$Send.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Send">DistributedPubSubMediator.Send</a>, <a href="DistributedPubSubMediator$$SendToAll.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.SendToAll">DistributedPubSubMediator.SendToAll</a>
or <a href="DistributedPubSubMediator$$Publish.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Publish">DistributedPubSubMediator.Publish</a> with the semantics described in
<a href="DistributedPubSubMediator.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator">DistributedPubSubMediator</a>.</p><p>Response messages from the destination actor are tunneled via the receptionist
to avoid inbound connections from other cluster nodes to the client, i.e.
the <code>sender</code>, as seen by the destination actor, is not the client itself.
The <code>sender</code> of the response messages, as seen by the client, is preserved
as the original sender, so the client can choose to send subsequent messages
directly to the actor in the cluster.
</p></div></div>
    </li><li name="akka.contrib.pattern.ClusterReceptionistExtension" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ClusterReceptionistExtensionextendsExtension"></a>
      <a id="ClusterReceptionistExtension:ClusterReceptionistExtension"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClusterReceptionistExtension.html"><span class="name">ClusterReceptionistExtension</span></a><span class="result"> extends <a href="../../actor/Extension.html" class="extype" name="akka.actor.Extension">Extension</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterReceptionistExtensionextendsExtension" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.ClusterSharding" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterShardingextendsExtension"></a>
      <a id="ClusterSharding:ClusterSharding"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClusterSharding.html"><span class="name">ClusterSharding</span></a><span class="result"> extends <a href="../../actor/Extension.html" class="extype" name="akka.actor.Extension">Extension</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterShardingextendsExtension" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="ClusterSharding$.html" class="extype" name="akka.contrib.pattern.ClusterSharding">ClusterSharding companion object</a>
</p></span></dd></dl></div>
    </li><li name="akka.contrib.pattern.ClusterSingletonManager" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterSingletonManagerextendsActorwithFSM[akka.contrib.pattern.ClusterSingletonManager.State,akka.contrib.pattern.ClusterSingletonManager.Data]"></a>
      <a id="ClusterSingletonManager:ClusterSingletonManager"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClusterSingletonManager.html"><span class="name">ClusterSingletonManager</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a> with <a href="../../actor/FSM.html" class="extype" name="akka.actor.FSM">FSM</a>[<a href="ClusterSingletonManager$$State.html" class="extype" name="akka.contrib.pattern.ClusterSingletonManager.State">State</a>, <a href="ClusterSingletonManager$$Data.html" class="extype" name="akka.contrib.pattern.ClusterSingletonManager.Data">Data</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterSingletonManagerextendsActorwithFSM[akka.contrib.pattern.ClusterSingletonManager.State,akka.contrib.pattern.ClusterSingletonManager.Data]" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Manages singleton actor instance among all cluster nodes or a group
of nodes tagged with a specific role.</p><div class="fullcomment"><div class="comment cmt"><p>Manages singleton actor instance among all cluster nodes or a group
of nodes tagged with a specific role. At most one singleton instance
is running at any point in time.</p><p>The ClusterSingletonManager is supposed to be started on all nodes,
or all nodes with specified role, in the cluster with <code>actorOf</code>.
The actual singleton is started on the oldest node by creating a child
actor from the supplied <code>singletonProps</code>.</p><p>The singleton actor is always running on the oldest member, which can
be determined by <a href="../../cluster/Member.html#isOlderThan(other:akka.cluster.Member):Boolean" class="extmbr" name="akka.cluster.Member#isOlderThan">akka.cluster.Member#isOlderThan</a>.
This can change when removing members. A graceful hand over can normally
be performed when current oldest node is leaving the cluster. Be aware that
there is a short time period when there is no active singleton during the
hand-over process.</p><p>The cluster failure detector will notice when oldest node
becomes unreachable due to things like JVM crash, hard shut down,
or network failure. When the crashed node has been removed (via down) from the
cluster then a new oldest node will take over and a new singleton actor is
created. For these failure scenarios there will not be a graceful hand-over,
but more than one active singletons is prevented by all reasonable means. Some
corner cases are eventually resolved by configurable timeouts.</p><p>You access the singleton actor with <code>actorSelection</code> using the names you have
specified when creating the ClusterSingletonManager. You can subscribe to
<a href="../../cluster/ClusterEvent$$MemberEvent.html" class="extype" name="akka.cluster.ClusterEvent.MemberEvent">akka.cluster.ClusterEvent.MemberEvent</a> and sort the members by age
(<span class="extype" name="akka.cluster.ClusterEvent.Member#isOlderThan">akka.cluster.ClusterEvent.Member#isOlderThan</span>) to keep track of oldest member.
Alternatively the singleton actor may broadcast its existence when it is started.</p><p>Use factory method <span class="extype" name="ClusterSingletonManager#props]">to create the
<a href="../../actor/Props.html" class="extype" name="akka.actor.Props">akka.actor.Props</a> for the actor.</span></p><h4>Arguments</h4><p><b><i>singletonProps</i></b> <a href="../../actor/Props.html" class="extype" name="akka.actor.Props">akka.actor.Props</a> of the singleton actor instance.</p><p><b><i>singletonName</i></b> The actor name of the child singleton actor.</p><p><b><i>terminationMessage</i></b> When handing over to a new oldest node
  this <code>terminationMessage</code> is sent to the singleton actor to tell
  it to finish its work, close resources, and stop.
  The hand-over to the new oldest node is completed when the
  singleton actor is terminated.
  Note that <a href="../../actor/PoisonPill.html" class="extype" name="akka.actor.PoisonPill">akka.actor.PoisonPill</a> is a perfectly fine
  <code>terminationMessage</code> if you only need to stop the actor.</p><p><b><i>role</i></b> Singleton among the nodes tagged with specified role.
  If the role is not specified it's a singleton among all nodes in
  the cluster.</p><p><b><i>maxHandOverRetries</i></b> When a node is becoming oldest it sends
  hand-over request to previous oldest. This is retried with the
  <code>retryInterval</code> until the previous oldest confirms that the hand
  over has started, or this <code>maxHandOverRetries</code> limit has been
  reached. If the retry limit is reached it takes the decision to be
  the new oldest if previous oldest is unknown (typically removed),
  otherwise it initiates a new round by throwing
  <a href="ClusterSingletonManagerIsStuck.html" class="extype" name="akka.contrib.pattern.ClusterSingletonManagerIsStuck">akka.contrib.pattern.ClusterSingletonManagerIsStuck</a> and expecting
  restart with fresh state. For a cluster with many members you might
  need to increase this retry limit because it takes longer time to
  propagate changes across all nodes.</p><p><b><i>maxTakeOverRetries</i></b> When a oldest node is not oldest any more
  it sends take over request to the new oldest to initiate the normal
  hand-over process. This is especially useful when new node joins and becomes
  oldest immediately, without knowing who was previous oldest. This is retried
  with the <code>retryInterval</code> until this retry limit has been reached. If the retry
  limit is reached it initiates a new round by throwing
  <a href="ClusterSingletonManagerIsStuck.html" class="extype" name="akka.contrib.pattern.ClusterSingletonManagerIsStuck">akka.contrib.pattern.ClusterSingletonManagerIsStuck</a> and expecting
  restart with fresh state. This will also cause the singleton actor to be
  stopped. <code>maxTakeOverRetries</code> must be less than <code>maxHandOverRetries</code> to
  ensure that new oldest doesn't start singleton actor before previous is
  stopped for certain corner cases.
</p></div></div>
    </li><li name="akka.contrib.pattern.ClusterSingletonManagerIsStuck" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterSingletonManagerIsStuckextendsAkkaException"></a>
      <a id="ClusterSingletonManagerIsStuck:ClusterSingletonManagerIsStuck"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClusterSingletonManagerIsStuck.html"><span class="name">ClusterSingletonManagerIsStuck</span></a><span class="result"> extends <a href="../../AkkaException.html" class="extype" name="akka.AkkaException">AkkaException</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterSingletonManagerIsStuckextendsAkkaException" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Thrown when a consistent state can't be determined within the
defined retry limits.</p><div class="fullcomment"><div class="comment cmt"><p>Thrown when a consistent state can't be determined within the
defined retry limits. Eventually it will reach a stable state and
can continue, and that is simplified by starting over with a clean
state. Parent supervisor should typically restart the actor, i.e.
default decision.
</p></div></div>
    </li><li name="akka.contrib.pattern.ClusterSingletonProxy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterSingletonProxyextendsActorwithStashwithActorLogging"></a>
      <a id="ClusterSingletonProxy:ClusterSingletonProxy"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClusterSingletonProxy.html"><span class="name">ClusterSingletonProxy</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a> with <a href="../../actor/Stash.html" class="extype" name="akka.actor.Stash">Stash</a> with <a href="../../actor/ActorLogging.html" class="extype" name="akka.actor.ActorLogging">ActorLogging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterSingletonProxyextendsActorwithStashwithActorLogging" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">The <code>ClusterSingletonProxy</code> works together with the <a href="ClusterSingletonManager.html" class="extype" name="akka.contrib.pattern.ClusterSingletonManager">akka.contrib.pattern.ClusterSingletonManager</a> to provide a
distributed proxy to the singleton actor.</p><div class="fullcomment"><div class="comment cmt"><p>The <code>ClusterSingletonProxy</code> works together with the <a href="ClusterSingletonManager.html" class="extype" name="akka.contrib.pattern.ClusterSingletonManager">akka.contrib.pattern.ClusterSingletonManager</a> to provide a
distributed proxy to the singleton actor.</p><p>The proxy can be started on every node where the singleton needs to be reached and used as if it were the singleton
itself. It will then act as a router to the currently running singleton instance. If the singleton is not currently
available, e.g., during hand off or startup, the proxy will stash the messages sent to the singleton and then unstash
them when the singleton is finally available. The proxy mixes in the <a href="../../actor/Stash.html" class="extype" name="akka.actor.Stash">akka.actor.Stash</a> trait, so it can be
configured accordingly.</p><p>The proxy works by keeping track of the oldest cluster member. When a new oldest member is identified, e.g., because
the older one left the cluster, or at startup, the proxy will try to identify the singleton on the oldest member by
periodically sending an <a href="../../actor/Identify.html" class="extype" name="akka.actor.Identify">akka.actor.Identify</a> message until the singleton responds with its
<a href="../../actor/ActorIdentity.html" class="extype" name="akka.actor.ActorIdentity">akka.actor.ActorIdentity</a>.</p><p>Note that this is a best effort implementation: messages can always be lost due to the distributed nature of the
actors involved.
</p></div></div>
    </li><li name="akka.contrib.pattern.DistributedPubSubExtension" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DistributedPubSubExtensionextendsExtension"></a>
      <a id="DistributedPubSubExtension:DistributedPubSubExtension"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="DistributedPubSubExtension.html"><span class="name">DistributedPubSubExtension</span></a><span class="result"> extends <a href="../../actor/Extension.html" class="extype" name="akka.actor.Extension">Extension</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@DistributedPubSubExtensionextendsExtension" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.DistributedPubSubMediator" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DistributedPubSubMediatorextendsActorwithActorLogging"></a>
      <a id="DistributedPubSubMediator:DistributedPubSubMediator"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="DistributedPubSubMediator.html"><span class="name">DistributedPubSubMediator</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a> with <a href="../../actor/ActorLogging.html" class="extype" name="akka.actor.ActorLogging">ActorLogging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@DistributedPubSubMediatorextendsActorwithActorLogging" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">This actor manages a registry of actor references and replicates
the entries to peer actors among all cluster nodes or a group of nodes
tagged with a specific role.</p><div class="fullcomment"><div class="comment cmt"><p>This actor manages a registry of actor references and replicates
the entries to peer actors among all cluster nodes or a group of nodes
tagged with a specific role.</p><p>The <code>DistributedPubSubMediator</code> is supposed to be started on all nodes,
or all nodes with specified role, in the cluster. The mediator can be
started with the <a href="DistributedPubSubExtension.html" class="extype" name="akka.contrib.pattern.DistributedPubSubExtension">DistributedPubSubExtension</a> or as an ordinary actor.</p><p>Changes are only performed in the own part of the registry and those changes
are versioned. Deltas are disseminated in a scalable way to other nodes with
a gossip protocol. The registry is eventually consistent, i.e. changes are not
immediately visible at other nodes, but typically they will be fully replicated
to all other nodes after a few seconds.</p><p>You can send messages via the mediator on any node to registered actors on
any other node. There is three modes of message delivery.</p><p>1. <a href="DistributedPubSubMediator$$Send.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Send">DistributedPubSubMediator.Send</a> -
The message will be delivered to one recipient with a matching path, if any such
exists in the registry. If several entries match the path the message will be sent
via the supplied <code>routingLogic</code> (default random) to one destination. The sender of the
message can specify that local affinity is preferred, i.e. the message is sent to an actor
in the same local actor system as the used mediator actor, if any such exists, otherwise
route to any other matching entry. A typical usage of this mode is private chat to one
other user in an instant messaging application. It can also be used for distributing
tasks to registered workers, like a cluster aware router where the routees dynamically
can register themselves.</p><p>2. <a href="DistributedPubSubMediator$$SendToAll.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.SendToAll">DistributedPubSubMediator.SendToAll</a> -
The message will be delivered to all recipients with a matching path. Actors with
the same path, without address information, can be registered on different nodes.
On each node there can only be one such actor, since the path is unique within one
local actor system. Typical usage of this mode is to broadcast messages to all replicas
with the same path, e.g. 3 actors on different nodes that all perform the same actions,
for redundancy.</p><p>3. <a href="DistributedPubSubMediator$$Publish.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Publish">DistributedPubSubMediator.Publish</a> -
Actors may be registered to a named topic instead of path. This enables many subscribers
on each node. The message will be delivered to all subscribers of the topic. For
efficiency the message is sent over the wire only once per node (that has a matching topic),
and then delivered to all subscribers of the local topic representation. This is the
true pub/sub mode. A typical usage of this mode is a chat room in an instant messaging
application.</p><p>4. <a href="DistributedPubSubMediator$$Publish.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Publish">DistributedPubSubMediator.Publish</a> with sendOneMessageToEachGroup -
Actors may be subscribed to a named topic with an optional property <code>group</code>.
If subscribing with a group name, each message published to a topic with the
<code>sendOneMessageToEachGroup</code> flag is delivered via the supplied <code>routingLogic</code>
(default random) to one actor within each subscribing group.
If all the subscribed actors have the same group name, then this works just like
<a href="DistributedPubSubMediator$$Send.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Send">DistributedPubSubMediator.Send</a> and all messages are delivered to one subscribe.
If all the subscribed actors have different group names, then this works like normal
<a href="DistributedPubSubMediator$$Publish.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Publish">DistributedPubSubMediator.Publish</a> and all messages are broadcast to all subscribers.</p><p>You register actors to the local mediator with <a href="DistributedPubSubMediator$$Put.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Put">DistributedPubSubMediator.Put</a> or
<a href="DistributedPubSubMediator$$Subscribe.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Subscribe">DistributedPubSubMediator.Subscribe</a>. <code>Put</code> is used together with <code>Send</code> and
<code>SendToAll</code> message delivery modes. The <code>ActorRef</code> in <code>Put</code> must belong to the same
local actor system as the mediator. <code>Subscribe</code> is used together with <code>Publish</code>.
Actors are automatically removed from the registry when they are terminated, or you
can explicitly remove entries with <a href="DistributedPubSubMediator$$Remove.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Remove">DistributedPubSubMediator.Remove</a> or
<a href="DistributedPubSubMediator$$Unsubscribe.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.Unsubscribe">DistributedPubSubMediator.Unsubscribe</a>.</p><p>Successful <code>Subscribe</code> and <code>Unsubscribe</code> is acknowledged with
<a href="DistributedPubSubMediator$$SubscribeAck.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.SubscribeAck">DistributedPubSubMediator.SubscribeAck</a> and <a href="DistributedPubSubMediator$$UnsubscribeAck.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator.UnsubscribeAck">DistributedPubSubMediator.UnsubscribeAck</a>
replies.
</p></div></div>
    </li><li name="akka.contrib.pattern.DistributedPubSubMessage" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="DistributedPubSubMessageextendsSerializable"></a>
      <a id="DistributedPubSubMessage:DistributedPubSubMessage"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="DistributedPubSubMessage.html"><span class="name">DistributedPubSubMessage</span></a><span class="result"> extends <a href="http://www.scala-lang.org/api/2.11.5/index.html#scala.Serializable" class="extype" target="_top">Serializable</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@DistributedPubSubMessageextendsSerializable" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Marker trait for remote messages with special serializer.</p>
    </li><li name="akka.contrib.pattern.ReliableProxy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReliableProxyextendsActorwithLoggingFSM[akka.contrib.pattern.ReliableProxy.State,Vector[akka.contrib.pattern.ReliableProxy.Message]]withReliableProxyDebugLogging"></a>
      <a id="ReliableProxy:ReliableProxy"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ReliableProxy.html"><span class="name">ReliableProxy</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a> with <a href="../../actor/LoggingFSM.html" class="extype" name="akka.actor.LoggingFSM">LoggingFSM</a>[<a href="ReliableProxy$$State.html" class="extype" name="akka.contrib.pattern.ReliableProxy.State">State</a>, <span class="extype" name="scala.Vector">Vector</span>[<a href="ReliableProxy$$Message.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Message">Message</a>]] with <span class="extype" name="akka.contrib.pattern.ReliableProxyDebugLogging">ReliableProxyDebugLogging</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ReliableProxyextendsActorwithLoggingFSM[akka.contrib.pattern.ReliableProxy.State,Vector[akka.contrib.pattern.ReliableProxy.Message]]withReliableProxyDebugLogging" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">A ReliableProxy is a means to wrap a remote actor reference in order to
obtain certain improved delivery guarantees:</p><div class="fullcomment"><div class="comment cmt"><p>A ReliableProxy is a means to wrap a remote actor reference in order to
obtain certain improved delivery guarantees:</p><ul><li>as long as the proxy is not terminated before it sends all of its queued
   messages then no messages will be lost</li><li>messages re-sent due to the first point will not be delivered out-of-order,
   message ordering is preserved</li></ul><p>These guarantees are valid for the communication between the two end-points
of the reliable “tunnel”, which usually spans an unreliable network.</p><p>Note that the ReliableProxy guarantees at-least-once, not exactly-once, delivery.</p><p>Delivery from the remote end-point to the target actor is still subject to in-JVM
delivery semantics (i.e. not strictly guaranteed due to possible OutOfMemory
situations or other VM errors).</p><p>You can create a reliable connection like this:</p><p>In Scala:</p><pre><span class="kw">val</span> proxy = context.actorOf(ReliableProxy.props(target, <span class="num">100.</span>millis, <span class="num">120.</span>seconds)</pre><p>or in Java:</p><pre><span class="kw">final</span> ActorRef proxy = getContext().actorOf(ReliableProxy.props(
  target, Duration.create(<span class="num">100</span>, <span class="lit">"millis"</span>), Duration.create(<span class="num">120</span>, <span class="lit">"seconds"</span>)));</pre><p><b><i>Please note:</i></b> the tunnel is uni-directional, and original sender
information is retained, hence replies by the wrapped target reference will
go back in the normal “unreliable” way unless also secured by a ReliableProxy
from the remote end.</p><h4>Message Types</h4><p>This actor is an <a href="../../actor/FSM.html" class="extype" name="akka.actor.FSM">akka.actor.FSM</a>, hence it offers the service of
transition callbacks to those actors which subscribe using the
<code><code>SubscribeTransitionCallBack</code></code> and <code><code>UnsubscribeTransitionCallBack</code></code>
messages; see <a href="../../actor/FSM.html" class="extype" name="akka.actor.FSM">akka.actor.FSM</a> for more documentation. The proxy will
transition into <a href="ReliableProxy$$Active$.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Active">ReliableProxy.Active</a> state when ACKs
are outstanding and return to the <a href="ReliableProxy$$Idle$.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Idle">ReliableProxy.Idle</a>
state when every message send so far has been confirmed by the peer end-point.</p><p>The initial state of the proxy is <a href="ReliableProxy$$Connecting$.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Connecting">ReliableProxy.Connecting</a>. In this state the
proxy will repeatedly send <a href="../../actor/Identify.html" class="extype" name="akka.actor.Identify">akka.actor.Identify</a> messages to <code>ActorSelection(targetPath)</code>
in order to obtain a new <code>ActorRef</code> for the target. When an <a href="../../actor/ActorIdentity.html" class="extype" name="akka.actor.ActorIdentity">akka.actor.ActorIdentity</a>
for the target is received a new tunnel will be created, a <a href="ReliableProxy$$TargetChanged.html" class="extype" name="akka.contrib.pattern.ReliableProxy.TargetChanged">ReliableProxy.TargetChanged</a>
message containing the target <code>ActorRef</code> will be sent to the proxy's transition subscribers
and the proxy will transition into either the <a href="ReliableProxy$$Idle$.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Idle">ReliableProxy.Idle</a> or <a href="ReliableProxy$$Active$.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Active">ReliableProxy.Active</a>
state, depending if there are any outstanding messages that need to be delivered.  If
<code>maxConnectAttempts</code> is defined this actor will stop itself after <code>Identify</code> is sent
<code>maxConnectAttempts</code> times.</p><p>While in the <code>Idle</code> or <code>Active</code> states, if a communication failure causes the tunnel to
terminate via Remote Deathwatch the proxy will transition into the <a href="ReliableProxy$$Connecting$.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Connecting">ReliableProxy.Connecting</a>
state as described above.  After reconnecting <code>TargetChanged</code> will be sent only if the target
<code>ActorRef</code> has changed.</p><p>If this actor is stopped and it still has outstanding messages a
<a href="ReliableProxy$$ProxyTerminated.html" class="extype" name="akka.contrib.pattern.ReliableProxy.ProxyTerminated">ReliableProxy.ProxyTerminated</a> message will be sent to the
transition subscribers.  It contains an <code>Unsent</code> object with the outstanding messages.</p><p>If an <a href="ReliableProxy$$Unsent.html" class="extype" name="akka.contrib.pattern.ReliableProxy.Unsent">ReliableProxy.Unsent</a> message is sent to this actor
the messages contained within it will be relayed through the tunnel to the target.</p><p>Any other message type sent to this actor will be delivered via a remote-deployed
child actor to the designated target.</p><h4>Failure Cases</h4><p>All failures of either the local or the remote end-point are escalated to the
parent of this actor; there are no specific error cases which are predefined.</p><h4>Arguments</h4><p>See the constructor below for the arguments for this actor.  However, prefer using
<a href="ReliableProxy$.html#props(targetPath:akka.actor.ActorPath,retryAfter:scala.concurrent.duration.FiniteDuration):akka.actor.Props" class="extmbr" name="akka.contrib.pattern.ReliableProxy#props">akka.contrib.pattern.ReliableProxy#props</a> to this actor's constructor.
</p></div></div>
    </li><li name="akka.contrib.pattern.ShardCoordinator" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ShardCoordinatorextendsPersistentActorwithActorLogging"></a>
      <a id="ShardCoordinator:ShardCoordinator"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ShardCoordinator.html"><span class="name">ShardCoordinator</span></a><span class="result"> extends <a href="../../persistence/PersistentActor.html" class="extype" name="akka.persistence.PersistentActor">PersistentActor</a> with <a href="../../actor/ActorLogging.html" class="extype" name="akka.actor.ActorLogging">ActorLogging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ShardCoordinatorextendsPersistentActorwithActorLogging" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Singleton coordinator that decides where to allocate shards.</p><div class="fullcomment"><div class="comment cmt"><p>Singleton coordinator that decides where to allocate shards.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="ClusterSharding$.html" class="extype" name="akka.contrib.pattern.ClusterSharding">ClusterSharding extension</a>
</p></span></dd></dl></div>
    </li><li name="akka.contrib.pattern.ShardCoordinatorSupervisor" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ShardCoordinatorSupervisorextendsActor"></a>
      <a id="ShardCoordinatorSupervisor:ShardCoordinatorSupervisor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ShardCoordinatorSupervisor.html"><span class="name">ShardCoordinatorSupervisor</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ShardCoordinatorSupervisorextendsActor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.ShardRegion" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ShardRegionextendsActorwithActorLogging"></a>
      <a id="ShardRegion:ShardRegion"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ShardRegion.html"><span class="name">ShardRegion</span></a><span class="result"> extends <a href="../../actor/Actor.html" class="extype" name="akka.actor.Actor">Actor</a> with <a href="../../actor/ActorLogging.html" class="extype" name="akka.actor.ActorLogging">ActorLogging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ShardRegionextendsActorwithActorLogging" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">This actor creates children entry actors on demand for the shards that it is told to be
responsible for.</p><div class="fullcomment"><div class="comment cmt"><p>This actor creates children entry actors on demand for the shards that it is told to be
responsible for. It delegates messages targeted to other shards to the responsible
<code>ShardRegion</code> actor on other nodes.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="ClusterSharding$.html" class="extype" name="akka.contrib.pattern.ClusterSharding">ClusterSharding extension</a>
</p></span></dd></dl></div>
    </li><li name="akka.contrib.pattern.WorkList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="WorkList[T]extendsAnyRef"></a>
      <a id="WorkList[T]:WorkList[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="WorkList.html"><span class="name">WorkList</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="http://www.scala-lang.org/api/2.11.5/index.html#scala.AnyRef" class="extype" target="_top">AnyRef</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@WorkList[T]extendsAnyRef" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Fast, small, and dirty implementation of a linked list that removes transient work entries once they are processed.</p><div class="fullcomment"><div class="comment cmt"><p>Fast, small, and dirty implementation of a linked list that removes transient work entries once they are processed.
The list is not thread safe! However it is expected to be reentrant. This means a processing function can add/remove
entries from the list while processing. Most important, a processing function can remove its own entry from the list.
The first remove must return true and any subsequent removes must return false.</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the item
</p></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="akka.contrib.pattern.ClusterClient" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ClusterClient"></a>
      <a id="ClusterClient:ClusterClient"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ClusterClient$.html"><span class="name">ClusterClient</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterClient" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.ClusterReceptionist" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ClusterReceptionist"></a>
      <a id="ClusterReceptionist:ClusterReceptionist"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ClusterReceptionist$.html"><span class="name">ClusterReceptionist</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterReceptionist" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.ClusterReceptionistExtension" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterReceptionistExtension"></a>
      <a id="ClusterReceptionistExtension:ClusterReceptionistExtension"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ClusterReceptionistExtension$.html"><span class="name">ClusterReceptionistExtension</span></a><span class="result"> extends <a href="../../actor/ExtensionId.html" class="extype" name="akka.actor.ExtensionId">ExtensionId</a>[<a href="ClusterReceptionistExtension.html" class="extype" name="akka.contrib.pattern.ClusterReceptionistExtension">ClusterReceptionistExtension</a>] with <a href="../../actor/ExtensionIdProvider.html" class="extype" name="akka.actor.ExtensionIdProvider">ExtensionIdProvider</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterReceptionistExtension" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Extension that starts <a href="ClusterReceptionist.html" class="extype" name="akka.contrib.pattern.ClusterReceptionist">ClusterReceptionist</a> and accompanying <a href="DistributedPubSubMediator.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator">DistributedPubSubMediator</a>
with settings defined in config section <code>akka.contrib.cluster.receptionist</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Extension that starts <a href="ClusterReceptionist.html" class="extype" name="akka.contrib.pattern.ClusterReceptionist">ClusterReceptionist</a> and accompanying <a href="DistributedPubSubMediator.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator">DistributedPubSubMediator</a>
with settings defined in config section <code>akka.contrib.cluster.receptionist</code>.
The <a href="DistributedPubSubMediator.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator">DistributedPubSubMediator</a> is started by the <a href="DistributedPubSubExtension.html" class="extype" name="akka.contrib.pattern.DistributedPubSubExtension">DistributedPubSubExtension</a>.
</p></div></div>
    </li><li name="akka.contrib.pattern.ClusterSharding" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ClusterSharding"></a>
      <a id="ClusterSharding:ClusterSharding"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ClusterSharding$.html"><span class="name">ClusterSharding</span></a><span class="result"> extends <a href="../../actor/ExtensionId.html" class="extype" name="akka.actor.ExtensionId">ExtensionId</a>[<a href="ClusterSharding.html" class="extype" name="akka.contrib.pattern.ClusterSharding">ClusterSharding</a>] with <a href="../../actor/ExtensionIdProvider.html" class="extype" name="akka.actor.ExtensionIdProvider">ExtensionIdProvider</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterSharding" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">This extension provides sharding functionality of actors in a cluster.</p><div class="fullcomment"><div class="comment cmt"><p>This extension provides sharding functionality of actors in a cluster.
The typical use case is when you have many stateful actors that together consume
more resources (e.g. memory) than fit on one machine. You need to distribute them across
several nodes in the cluster and you want to be able to interact with them using their
logical identifier, but without having to care about their physical location in the cluster,
which might also change over time. It could for example be actors representing Aggregate Roots in
Domain-Driven Design terminology. Here we call these actors &quot;entries&quot;. These actors
typically have persistent (durable) state, but this feature is not limited to
actors with persistent state.</p><p>In this context sharding means that actors with an identifier, so called entries,
can be automatically distributed across multiple nodes in the cluster. Each entry
actor runs only at one place, and messages can be sent to the entry without requiring
the sender to know the location of the destination actor. This is achieved by sending
the messages via a <a href="ShardRegion.html" class="extype" name="akka.contrib.pattern.ShardRegion">ShardRegion</a> actor provided by this extension, which knows how
to route the message with the entry id to the final destination.</p><p>This extension is supposed to be used by first, typically at system startup on each node
in the cluster, registering the supported entry types with the <a href="ClusterSharding.html#start(typeName:String,entryProps:akka.actor.Props,messageExtractor:akka.contrib.pattern.ShardRegion.MessageExtractor):akka.actor.ActorRef" class="extmbr" name="akka.contrib.pattern.ClusterSharding#start">ClusterSharding#start</a>
method and then the <code>ShardRegion</code> actor for a named entry type can be retrieved with
<a href="ClusterSharding.html#shardRegion(typeName:String):akka.actor.ActorRef" class="extmbr" name="akka.contrib.pattern.ClusterSharding#shardRegion">ClusterSharding#shardRegion</a>. Messages to the entries are always sent via the local
<code>ShardRegion</code>. Some settings can be configured as described in the <code>akka.contrib.cluster.sharding</code>
section of the <code>reference.conf</code>.</p><p>The <code>ShardRegion</code> actor is started on each node in the cluster, or group of nodes
tagged with a specific role. The <code>ShardRegion</code> is created with two application specific
functions to extract the entry identifier and the shard identifier from incoming messages.
A shard is a group of entries that will be managed together. For the first message in a
specific shard the <code>ShardRegion</code> request the location of the shard from a central coordinator,
the <a href="ShardCoordinator.html" class="extype" name="akka.contrib.pattern.ShardCoordinator">ShardCoordinator</a>. The <code>ShardCoordinator</code> decides which <code>ShardRegion</code> that
owns the shard. The <code>ShardRegion</code> receives the decided home of the shard
and if that is the <code>ShardRegion</code> instance itself it will create a local child
actor representing the entry and direct all messages for that entry to it.
If the shard home is another <code>ShardRegion</code> instance messages will be forwarded
to that <code>ShardRegion</code> instance instead. While resolving the location of a
shard incoming messages for that shard are buffered and later delivered when the
shard home is known. Subsequent messages to the resolved shard can be delivered
to the target destination immediately without involving the <code>ShardCoordinator</code>.</p><p>To make sure that at most one instance of a specific entry actor is running somewhere
in the cluster it is important that all nodes have the same view of where the shards
are located. Therefore the shard allocation decisions are taken by the central
<code>ShardCoordinator</code>, which is running as a cluster singleton, i.e. one instance on
the oldest member among all cluster nodes or a group of nodes tagged with a specific
role. The oldest member can be determined by <a href="../../cluster/Member.html#isOlderThan(other:akka.cluster.Member):Boolean" class="extmbr" name="akka.cluster.Member#isOlderThan">akka.cluster.Member#isOlderThan</a>.</p><p>The logic that decides where a shard is to be located is defined in a pluggable shard
allocation strategy. The default implementation <a href="ShardCoordinator$$LeastShardAllocationStrategy.html" class="extype" name="akka.contrib.pattern.ShardCoordinator.LeastShardAllocationStrategy">ShardCoordinator.LeastShardAllocationStrategy</a>
allocates new shards to the <code>ShardRegion</code> with least number of previously allocated shards.
This strategy can be replaced by an application specific implementation.</p><p>To be able to use newly added members in the cluster the coordinator facilitates rebalancing
of shards, i.e. migrate entries from one node to another. In the rebalance process the
coordinator first notifies all <code>ShardRegion</code> actors that a handoff for a shard has started.
That means they will start buffering incoming messages for that shard, in the same way as if the
shard location is unknown. During the rebalance process the coordinator will not answer any
requests for the location of shards that are being rebalanced, i.e. local buffering will
continue until the handoff is completed. The <code>ShardRegion</code> responsible for the rebalanced shard
will stop all entries in that shard by sending <code>PoisonPill</code> to them. When all entries have
been terminated the <code>ShardRegion</code> owning the entries will acknowledge the handoff as completed
to the coordinator. Thereafter the coordinator will reply to requests for the location of
the shard and thereby allocate a new home for the shard and then buffered messages in the
<code>ShardRegion</code> actors are delivered to the new location. This means that the state of the entries
are not transferred or migrated. If the state of the entries are of importance it should be
persistent (durable), e.g. with <code>akka-persistence</code>, so that it can be recovered at the new
location.</p><p>The logic that decides which shards to rebalance is defined in a pluggable shard
allocation strategy. The default implementation <a href="ShardCoordinator$$LeastShardAllocationStrategy.html" class="extype" name="akka.contrib.pattern.ShardCoordinator.LeastShardAllocationStrategy">ShardCoordinator.LeastShardAllocationStrategy</a>
picks shards for handoff from the <code>ShardRegion</code> with most number of previously allocated shards.
They will then be allocated to the <code>ShardRegion</code> with least number of previously allocated shards,
i.e. new members in the cluster. There is a configurable threshold of how large the difference
must be to begin the rebalancing. This strategy can be replaced by an application specific
implementation.</p><p>The state of shard locations in the <code>ShardCoordinator</code> is persistent (durable) with
<code>akka-persistence</code> to survive failures. Since it is running in a cluster <code>akka-persistence</code>
must be configured with a distributed journal. When a crashed or unreachable coordinator
node has been removed (via down) from the cluster a new <code>ShardCoordinator</code> singleton
actor will take over and the state is recovered. During such a failure period shards
with known location are still available, while messages for new (unknown) shards
are buffered until the new <code>ShardCoordinator</code> becomes available.</p><p>As long as a sender uses the same <code>ShardRegion</code> actor to deliver messages to an entry
actor the order of the messages is preserved. As long as the buffer limit is not reached
messages are delivered on a best effort basis, with at-most once delivery semantics,
in the same way as ordinary message sending. Reliable end-to-end messaging, with
at-least-once semantics can be added by using channels in <code>akka-persistence</code>.</p><p>Some additional latency is introduced for messages targeted to new or previously
unused shards due to the round-trip to the coordinator. Rebalancing of shards may
also add latency. This should be considered when designing the application specific
shard resolution, e.g. to avoid too fine grained shards.</p><p>The <code>ShardRegion</code> actor can also be started in proxy only mode, i.e. it will not
host any entries itself, but knows how to delegate messages to the right location.
A <code>ShardRegion</code> starts in proxy only mode if the roles of the node does not include
the node role specified in <code>akka.contrib.cluster.sharding.role</code> config property
or if the specified <code>entryProps</code> is <code>None</code>/<code>null</code>.</p><p>If the state of the entries are persistent you may stop entries that are not used to
reduce memory consumption. This is done by the application specific implementation of
the entry actors for example by defining receive timeout (<code>context.setReceiveTimeout</code>).
If a message is already enqueued to the entry when it stops itself the enqueued message
in the mailbox will be dropped. To support graceful passivation without loosing such
messages the entry actor can send <a href="ShardRegion$$Passivate.html" class="extype" name="akka.contrib.pattern.ShardRegion.Passivate">ShardRegion.Passivate</a> to its parent <code>ShardRegion</code>.
The specified wrapped message in <code>Passivate</code> will be sent back to the entry, which is
then supposed to stop itself. Incoming messages will be buffered by the <code>ShardRegion</code>
between reception of <code>Passivate</code> and termination of the entry. Such buffered messages
are thereafter delivered to a new incarnation of the entry.</p></div></div>
    </li><li name="akka.contrib.pattern.ClusterSingletonManager" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ClusterSingletonManager"></a>
      <a id="ClusterSingletonManager:ClusterSingletonManager"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ClusterSingletonManager$.html"><span class="name">ClusterSingletonManager</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterSingletonManager" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.ClusterSingletonProxy" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ClusterSingletonProxy"></a>
      <a id="ClusterSingletonProxy:ClusterSingletonProxy"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ClusterSingletonProxy$.html"><span class="name">ClusterSingletonProxy</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ClusterSingletonProxy" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.DistributedPubSubExtension" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DistributedPubSubExtension"></a>
      <a id="DistributedPubSubExtension:DistributedPubSubExtension"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="DistributedPubSubExtension$.html"><span class="name">DistributedPubSubExtension</span></a><span class="result"> extends <a href="../../actor/ExtensionId.html" class="extype" name="akka.actor.ExtensionId">ExtensionId</a>[<a href="DistributedPubSubExtension.html" class="extype" name="akka.contrib.pattern.DistributedPubSubExtension">DistributedPubSubExtension</a>] with <a href="../../actor/ExtensionIdProvider.html" class="extype" name="akka.actor.ExtensionIdProvider">ExtensionIdProvider</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@DistributedPubSubExtension" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Extension that starts a <a href="DistributedPubSubMediator.html" class="extype" name="akka.contrib.pattern.DistributedPubSubMediator">DistributedPubSubMediator</a> actor
with settings defined in config section <code>akka.contrib.cluster.pub-sub</code>.</p>
    </li><li name="akka.contrib.pattern.DistributedPubSubMediator" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DistributedPubSubMediator"></a>
      <a id="DistributedPubSubMediator:DistributedPubSubMediator"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="DistributedPubSubMediator$.html"><span class="name">DistributedPubSubMediator</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@DistributedPubSubMediator" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.ReliableProxy" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ReliableProxy"></a>
      <a id="ReliableProxy:ReliableProxy"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ReliableProxy$.html"><span class="name">ReliableProxy</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ReliableProxy" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li><li name="akka.contrib.pattern.ShardCoordinator" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ShardCoordinator"></a>
      <a id="ShardCoordinator:ShardCoordinator"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ShardCoordinator$.html"><span class="name">ShardCoordinator</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ShardCoordinator" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="ClusterSharding$.html" class="extype" name="akka.contrib.pattern.ClusterSharding">ClusterSharding extension</a>
</p></span></dd></dl></div>
    </li><li name="akka.contrib.pattern.ShardCoordinatorSupervisor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ShardCoordinatorSupervisor"></a>
      <a id="ShardCoordinatorSupervisor:ShardCoordinatorSupervisor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ShardCoordinatorSupervisor$.html"><span class="name">ShardCoordinatorSupervisor</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ShardCoordinatorSupervisor" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="ClusterSharding$.html" class="extype" name="akka.contrib.pattern.ClusterSharding">ClusterSharding extension</a>
</p></span></dd></dl></div>
    </li><li name="akka.contrib.pattern.ShardRegion" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ShardRegion"></a>
      <a id="ShardRegion:ShardRegion"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ShardRegion$.html"><span class="name">ShardRegion</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@ShardRegion" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="ClusterSharding$.html" class="extype" name="akka.contrib.pattern.ClusterSharding">ClusterSharding extension</a>
</p></span></dd></dl></div>
    </li><li name="akka.contrib.pattern.WorkList" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="WorkList"></a>
      <a id="WorkList:WorkList"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="WorkList$.html"><span class="name">WorkList</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@WorkList" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      <p class="shortcomment cmt">Provides the utility methods and constructors to the WorkList class.</p>
    </li><li name="akka.contrib.pattern.protobuf" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="protobuf"></a>
      <a id="protobuf:protobuf"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a href="protobuf/package.html"><span class="name">protobuf</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../index.html#akka.contrib.pattern.package@protobuf" title="Permalink" target="_top">
        <img src="../../../lib/permalink.png" />
      </a>
    </span>
      
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>