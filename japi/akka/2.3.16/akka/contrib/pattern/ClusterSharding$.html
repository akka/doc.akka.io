<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_65) on Fri Oct 28 18:47:32 CEST 2016 -->
<TITLE>
ClusterSharding$
</TITLE>

<META NAME="date" CONTENT="2016-10-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ClusterSharding$";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterSharding.Settings$.html" title="class in akka.contrib.pattern"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterShardingGuardian.html" title="class in akka.contrib.pattern"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?akka/contrib/pattern/ClusterSharding$.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ClusterSharding$.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
akka.contrib.pattern</FONT>
<BR>
Class ClusterSharding$</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>akka.contrib.pattern.ClusterSharding$</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../akka/actor/ExtensionId.html" title="interface in akka.actor">ExtensionId</A>&lt;<A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A>&gt;, <A HREF="../../../akka/actor/ExtensionIdProvider.html" title="interface in akka.actor">ExtensionIdProvider</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ClusterSharding$</B><DT>extends java.lang.Object<DT>implements <A HREF="../../../akka/actor/ExtensionId.html" title="interface in akka.actor">ExtensionId</A>&lt;<A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A>&gt;, <A HREF="../../../akka/actor/ExtensionIdProvider.html" title="interface in akka.actor">ExtensionIdProvider</A></DL>
</PRE>

<P>
This extension provides sharding functionality of actors in a cluster.
 The typical use case is when you have many stateful actors that together consume
 more resources (e.g. memory) than fit on one machine. You need to distribute them across
 several nodes in the cluster and you want to be able to interact with them using their
 logical identifier, but without having to care about their physical location in the cluster,
 which might also change over time. It could for example be actors representing Aggregate Roots in
 Domain-Driven Design terminology. Here we call these actors "entries". These actors
 typically have persistent (durable) state, but this feature is not limited to
 actors with persistent state.
 <p>
 In this context sharding means that actors with an identifier, so called entries,
 can be automatically distributed across multiple nodes in the cluster. Each entry
 actor runs only at one place, and messages can be sent to the entry without requiring
 the sender to know the location of the destination actor. This is achieved by sending
 the messages via a <A HREF="../../../akka/contrib/pattern/ShardRegion.html" title="class in akka.contrib.pattern"><CODE>ShardRegion</CODE></A> actor provided by this extension, which knows how
 to route the message with the entry id to the final destination.
 <p>
 This extension is supposed to be used by first, typically at system startup on each node
 in the cluster, registering the supported entry types with the <A HREF="../../../akka/contrib/pattern/ClusterSharding.html#start(java.lang.String, scala.Option, scala.PartialFunction, scala.Function1, akka.contrib.pattern.ShardCoordinator.ShardAllocationStrategy)"><CODE>ClusterSharding.start(java.lang.String, scala.Option<akka.actor.Props>, scala.PartialFunction<java.lang.Object, scala.Tuple2<java.lang.String, java.lang.Object>>, scala.Function1<java.lang.Object, java.lang.String>, akka.contrib.pattern.ShardCoordinator.ShardAllocationStrategy)</CODE></A>
 method and then the <code>ShardRegion</code> actor for a named entry type can be retrieved with
 <A HREF="../../../akka/contrib/pattern/ClusterSharding.html#shardRegion(java.lang.String)"><CODE>ClusterSharding.shardRegion(java.lang.String)</CODE></A>. Messages to the entries are always sent via the local
 <code>ShardRegion</code>. Some settings can be configured as described in the <code>akka.contrib.cluster.sharding</code>
 section of the <code>reference.conf</code>.
 <p>
 The <code>ShardRegion</code> actor is started on each node in the cluster, or group of nodes
 tagged with a specific role. The <code>ShardRegion</code> is created with two application specific
 functions to extract the entry identifier and the shard identifier from incoming messages.
 A shard is a group of entries that will be managed together. For the first message in a
 specific shard the <code>ShardRegion</code> request the location of the shard from a central coordinator,
 the <A HREF="../../../akka/contrib/pattern/ShardCoordinator.html" title="class in akka.contrib.pattern"><CODE>ShardCoordinator</CODE></A>. The <code>ShardCoordinator</code> decides which <code>ShardRegion</code> that
 owns the shard. The <code>ShardRegion</code> receives the decided home of the shard
 and if that is the <code>ShardRegion</code> instance itself it will create a local child
 actor representing the entry and direct all messages for that entry to it.
 If the shard home is another <code>ShardRegion</code> instance messages will be forwarded
 to that <code>ShardRegion</code> instance instead. While resolving the location of a
 shard incoming messages for that shard are buffered and later delivered when the
 shard home is known. Subsequent messages to the resolved shard can be delivered
 to the target destination immediately without involving the <code>ShardCoordinator</code>.
 <p>
 To make sure that at most one instance of a specific entry actor is running somewhere
 in the cluster it is important that all nodes have the same view of where the shards
 are located. Therefore the shard allocation decisions are taken by the central
 <code>ShardCoordinator</code>, which is running as a cluster singleton, i.e. one instance on
 the oldest member among all cluster nodes or a group of nodes tagged with a specific
 role. The oldest member can be determined by <A HREF="../../../akka/cluster/Member.html#isOlderThan(akka.cluster.Member)"><CODE>Member.isOlderThan(akka.cluster.Member)</CODE></A>.
 <p>
 The logic that decides where a shard is to be located is defined in a pluggable shard
 allocation strategy. The default implementation <A HREF="../../../akka/contrib/pattern/ShardCoordinator.LeastShardAllocationStrategy.html" title="class in akka.contrib.pattern"><CODE>ShardCoordinator.LeastShardAllocationStrategy</CODE></A>
 allocates new shards to the <code>ShardRegion</code> with least number of previously allocated shards.
 This strategy can be replaced by an application specific implementation.
 <p>
 To be able to use newly added members in the cluster the coordinator facilitates rebalancing
 of shards, i.e. migrate entries from one node to another. In the rebalance process the
 coordinator first notifies all <code>ShardRegion</code> actors that a handoff for a shard has started.
 That means they will start buffering incoming messages for that shard, in the same way as if the
 shard location is unknown. During the rebalance process the coordinator will not answer any
 requests for the location of shards that are being rebalanced, i.e. local buffering will
 continue until the handoff is completed. The <code>ShardRegion</code> responsible for the rebalanced shard
 will stop all entries in that shard by sending <code>PoisonPill</code> to them. When all entries have
 been terminated the <code>ShardRegion</code> owning the entries will acknowledge the handoff as completed
 to the coordinator. Thereafter the coordinator will reply to requests for the location of
 the shard and thereby allocate a new home for the shard and then buffered messages in the
 <code>ShardRegion</code> actors are delivered to the new location. This means that the state of the entries
 are not transferred or migrated. If the state of the entries are of importance it should be
 persistent (durable), e.g. with <code>akka-persistence</code>, so that it can be recovered at the new
 location.
 <p>
 The logic that decides which shards to rebalance is defined in a pluggable shard
 allocation strategy. The default implementation <A HREF="../../../akka/contrib/pattern/ShardCoordinator.LeastShardAllocationStrategy.html" title="class in akka.contrib.pattern"><CODE>ShardCoordinator.LeastShardAllocationStrategy</CODE></A>
 picks shards for handoff from the <code>ShardRegion</code> with most number of previously allocated shards.
 They will then be allocated to the <code>ShardRegion</code> with least number of previously allocated shards,
 i.e. new members in the cluster. There is a configurable threshold of how large the difference
 must be to begin the rebalancing. This strategy can be replaced by an application specific
 implementation.
 <p>
 The state of shard locations in the <code>ShardCoordinator</code> is persistent (durable) with
 <code>akka-persistence</code> to survive failures. Since it is running in a cluster <code>akka-persistence</code>
 must be configured with a distributed journal. When a crashed or unreachable coordinator
 node has been removed (via down) from the cluster a new <code>ShardCoordinator</code> singleton
 actor will take over and the state is recovered. During such a failure period shards
 with known location are still available, while messages for new (unknown) shards
 are buffered until the new <code>ShardCoordinator</code> becomes available.
 <p>
 As long as a sender uses the same <code>ShardRegion</code> actor to deliver messages to an entry
 actor the order of the messages is preserved. As long as the buffer limit is not reached
 messages are delivered on a best effort basis, with at-most once delivery semantics,
 in the same way as ordinary message sending. Reliable end-to-end messaging, with
 at-least-once semantics can be added by using channels in <code>akka-persistence</code>.
 <p>
 Some additional latency is introduced for messages targeted to new or previously
 unused shards due to the round-trip to the coordinator. Rebalancing of shards may
 also add latency. This should be considered when designing the application specific
 shard resolution, e.g. to avoid too fine grained shards.
 <p>
 The <code>ShardRegion</code> actor can also be started in proxy only mode, i.e. it will not
 host any entries itself, but knows how to delegate messages to the right location.
 A <code>ShardRegion</code> starts in proxy only mode if the roles of the node does not include
 the node role specified in <code>akka.contrib.cluster.sharding.role</code> config property
 or if the specified <code>entryProps</code> is <code>None</code>/<code>null</code>.
 <p>
 If the state of the entries are persistent you may stop entries that are not used to
 reduce memory consumption. This is done by the application specific implementation of
 the entry actors for example by defining receive timeout (<code>context.setReceiveTimeout</code>).
 If a message is already enqueued to the entry when it stops itself the enqueued message
 in the mailbox will be dropped. To support graceful passivation without loosing such
 messages the entry actor can send <A HREF="../../../akka/contrib/pattern/ShardRegion.Passivate.html" title="class in akka.contrib.pattern"><CODE>ShardRegion.Passivate</CODE></A> to its parent <code>ShardRegion</code>.
 The specified wrapped message in <code>Passivate</code> will be sent back to the entry, which is
 then supposed to stop itself. Incoming messages will be buffered by the <code>ShardRegion</code>
 between reception of <code>Passivate</code> and termination of the entry. Such buffered messages
 are thereafter delivered to a new incarnation of the entry.
 <p>
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterSharding$.html" title="class in akka.contrib.pattern">ClusterSharding$</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../akka/contrib/pattern/ClusterSharding$.html#MODULE$">MODULE$</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static reference to the singleton instance of this Scala object.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../akka/contrib/pattern/ClusterSharding$.html#ClusterSharding$()">ClusterSharding$</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../akka/contrib/pattern/ClusterSharding$.html#createExtension(akka.actor.ExtendedActorSystem)">createExtension</A></B>(<A HREF="../../../akka/actor/ExtendedActorSystem.html" title="class in akka.actor">ExtendedActorSystem</A>&nbsp;system)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is used by Akka to instantiate the Extension identified by this ExtensionId,
 internal use only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../akka/contrib/pattern/ClusterSharding$.html#get(akka.actor.ActorSystem)">get</A></B>(<A HREF="../../../akka/actor/ActorSystem.html" title="class in akka.actor">ActorSystem</A>&nbsp;system)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an instance of the extension identified by this ExtensionId instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterSharding$.html" title="class in akka.contrib.pattern">ClusterSharding$</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../akka/contrib/pattern/ClusterSharding$.html#lookup()">lookup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the canonical ExtensionId for this Extension</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_akka.actor.ExtensionId"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface akka.actor.<A HREF="../../../akka/actor/ExtensionId.html" title="interface in akka.actor">ExtensionId</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../akka/actor/ExtensionId.html#apply(akka.actor.ActorSystem)">apply</A>, <A HREF="../../../akka/actor/ExtensionId.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../akka/actor/ExtensionId.html#hashCode()">hashCode</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MODULE$"><!-- --></A><H3>
MODULE$</H3>
<PRE>
public static final <A HREF="../../../akka/contrib/pattern/ClusterSharding$.html" title="class in akka.contrib.pattern">ClusterSharding$</A> <B>MODULE$</B></PRE>
<DL>
<DD>Static reference to the singleton instance of this Scala object.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ClusterSharding$()"><!-- --></A><H3>
ClusterSharding$</H3>
<PRE>
public <B>ClusterSharding$</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="get(akka.actor.ActorSystem)"><!-- --></A><H3>
get</H3>
<PRE>
public <A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A> <B>get</B>(<A HREF="../../../akka/actor/ActorSystem.html" title="class in akka.actor">ActorSystem</A>&nbsp;system)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../akka/actor/ExtensionId.html#get(akka.actor.ActorSystem)">ExtensionId</A></CODE></B></DD>
<DD>Returns an instance of the extension identified by this ExtensionId instance.
 Java API
 For extensions written in Scala that are to be used used from Java also,
 this method should be overridden to get correct return type.
 <pre><code>
 override def get(system: ActorSystem): TheExtension = super.get(system)
 </code></pre>
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../akka/actor/ExtensionId.html#get(akka.actor.ActorSystem)">get</A></CODE> in interface <CODE><A HREF="../../../akka/actor/ExtensionId.html" title="interface in akka.actor">ExtensionId</A>&lt;<A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A>&gt;</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>system</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="lookup()"><!-- --></A><H3>
lookup</H3>
<PRE>
public <A HREF="../../../akka/contrib/pattern/ClusterSharding$.html" title="class in akka.contrib.pattern">ClusterSharding$</A> <B>lookup</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../akka/actor/ExtensionIdProvider.html#lookup()">ExtensionIdProvider</A></CODE></B></DD>
<DD>Returns the canonical ExtensionId for this Extension
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../akka/actor/ExtensionIdProvider.html#lookup()">lookup</A></CODE> in interface <CODE><A HREF="../../../akka/actor/ExtensionIdProvider.html" title="interface in akka.actor">ExtensionIdProvider</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="createExtension(akka.actor.ExtendedActorSystem)"><!-- --></A><H3>
createExtension</H3>
<PRE>
public <A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A> <B>createExtension</B>(<A HREF="../../../akka/actor/ExtendedActorSystem.html" title="class in akka.actor">ExtendedActorSystem</A>&nbsp;system)</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../../akka/actor/ExtensionId.html#createExtension(akka.actor.ExtendedActorSystem)">ExtensionId</A></CODE></B></DD>
<DD>Is used by Akka to instantiate the Extension identified by this ExtensionId,
 internal use only.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../akka/actor/ExtensionId.html#createExtension(akka.actor.ExtendedActorSystem)">createExtension</A></CODE> in interface <CODE><A HREF="../../../akka/actor/ExtensionId.html" title="interface in akka.actor">ExtensionId</A>&lt;<A HREF="../../../akka/contrib/pattern/ClusterSharding.html" title="class in akka.contrib.pattern">ClusterSharding</A>&gt;</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>system</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterSharding.Settings$.html" title="class in akka.contrib.pattern"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../akka/contrib/pattern/ClusterShardingGuardian.html" title="class in akka.contrib.pattern"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?akka/contrib/pattern/ClusterSharding$.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ClusterSharding$.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
