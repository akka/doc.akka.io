<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_111) on Tue May 02 11:54:33 CEST 2017 -->
<title>Sink$</title>
<meta name="date" content="2017-05-02">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Sink$";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":42,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../akka/stream/scaladsl/SinkQueue.html" title="interface in akka.stream.scaladsl"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?akka/stream/scaladsl/Sink$.html" target="_top">Frames</a></li>
<li><a href="Sink$.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">akka.stream.scaladsl</div>
<h2 title="Class Sink$" class="title">Class Sink$</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>akka.stream.scaladsl.Sink$</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Sink$</span>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../akka/stream/scaladsl/Sink$.html" title="class in akka.stream.scaladsl">Sink$</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#MODULE:D">MODULE$</a></span></code>
<div class="block">Static reference to the singleton instance of this Scala object.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#Sink:D--">Sink$</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#actorRef-akka.actor.ActorRef-java.lang.Object-">actorRef</a></span>(<a href="../../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</a>&nbsp;ref,
        java.lang.Object&nbsp;onCompleteMessage)</code>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#actorRefWithAck-akka.actor.ActorRef-java.lang.Object-java.lang.Object-java.lang.Object-scala.Function1-">actorRefWithAck</a></span>(<a href="../../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</a>&nbsp;ref,
               java.lang.Object&nbsp;onInitMessage,
               java.lang.Object&nbsp;ackMessage,
               java.lang.Object&nbsp;onCompleteMessage,
               scala.Function1&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;onFailureMessage)</code>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#actorSubscriber-akka.actor.Props-">actorSubscriber</a></span>(<a href="../../../akka/actor/Props.html" title="class in akka.actor">Props</a>&nbsp;props)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use <code>akka.stream.stage.GraphStage</code> and <code>fromGraph</code> instead, it allows for all operations an Actor would and is more type-safe as well as guaranteed to be ReactiveStreams compliant.</span></div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,org.reactivestreams.Publisher&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#asPublisher-boolean-">asPublisher</a></span>(boolean&nbsp;fanout)</code>
<div class="block">A <code>Sink</code> that materializes into a <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#cancelled--">cancelled</a></span>()</code>
<div class="block">A <code>Sink</code> that immediately cancels its upstream after materialization.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;T,U&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#combine-akka.stream.scaladsl.Sink-akka.stream.scaladsl.Sink-scala.collection.Seq-scala.Function1-">combine</a></span>(<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;U,?&gt;&nbsp;first,
       <a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;U,?&gt;&nbsp;second,
       scala.collection.Seq&lt;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;U,?&gt;&gt;&nbsp;rest,
       scala.Function1&lt;java.lang.Object,<a href="../../../akka/stream/Graph.html" title="interface in akka.stream">Graph</a>&lt;<a href="../../../akka/stream/UniformFanOutShape.html" title="class in akka.stream">UniformFanOutShape</a>&lt;T,U&gt;,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&gt;&nbsp;strategy)</code>
<div class="block">Combine several sinks with fan-out strategy like <code>Broadcast</code> or <code>Balance</code> and returns <code>Sink</code>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;U,T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;U&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#fold-U-scala.Function2-">fold</a></span>(U&nbsp;zero,
    scala.Function2&lt;U,T,U&gt;&nbsp;f)</code>
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>&lt;U,T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;U&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#foldAsync-U-scala.Function2-">foldAsync</a></span>(U&nbsp;zero,
         scala.Function2&lt;U,T,scala.concurrent.Future&lt;U&gt;&gt;&nbsp;f)</code>
<div class="block">A <code>Sink</code> that will invoke the given asynchronous function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#foreach-scala.Function1-">foreach</a></span>(scala.Function1&lt;T,scala.runtime.BoxedUnit&gt;&nbsp;f)</code>
<div class="block">A <code>Sink</code> that will invoke the given procedure for each received element.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#foreachParallel-int-scala.Function1-scala.concurrent.ExecutionContext-">foreachParallel</a></span>(int&nbsp;parallelism,
               scala.Function1&lt;T,scala.runtime.BoxedUnit&gt;&nbsp;f,
               scala.concurrent.ExecutionContext&nbsp;ec)</code>
<div class="block">A <code>Sink</code> that will invoke the given function to each of the elements
 as they pass in.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;T,M&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,M&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#fromGraph-akka.stream.Graph-">fromGraph</a></span>(<a href="../../../akka/stream/Graph.html" title="interface in akka.stream">Graph</a>&lt;<a href="../../../akka/stream/SinkShape.html" title="class in akka.stream">SinkShape</a>&lt;T&gt;,M&gt;&nbsp;g)</code>
<div class="block">A graph with the shape of a sink logically is a sink, this method makes
 it so also in type.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#fromSubscriber-org.reactivestreams.Subscriber-">fromSubscriber</a></span>(org.reactivestreams.Subscriber&lt;T&gt;&nbsp;subscriber)</code>
<div class="block">Helper to create <a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl"><code>Sink</code></a> from <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#head--">head</a></span>()</code>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the first value received.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#headOption--">headOption</a></span>()</code>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional first value received.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;java.lang.Object,scala.concurrent.Future&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#ignore--">ignore</a></span>()</code>
<div class="block">A <code>Sink</code> that will consume the stream and discard the elements.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#last--">last</a></span>()</code>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the last value received.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#lastOption--">lastOption</a></span>()</code>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional last value received.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;T,M&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#lazyInit-scala.Function1-scala.Function0-">lazyInit</a></span>(scala.Function1&lt;T,scala.concurrent.Future&lt;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,M&gt;&gt;&gt;&nbsp;sinkFactory,
        scala.Function0&lt;M&gt;&nbsp;fallback)</code>
<div class="block">Creates a real <code>Sink</code> upon receiving the first element.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#onComplete-scala.Function1-">onComplete</a></span>(scala.Function1&lt;scala.util.Try&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;,scala.runtime.BoxedUnit&gt;&nbsp;callback)</code>
<div class="block">A <code>Sink</code> that when the flow is completed, either through a failure or normal
 completion, apply the provided function with <code>Success</code>
 or <code>Failure</code>.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/stream/scaladsl/SinkQueueWithCancel.html" title="interface in akka.stream.scaladsl">SinkQueueWithCancel</a>&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#queue--">queue</a></span>()</code>
<div class="block">Creates a <code>Sink</code> that is materialized as an <a href="../../../akka/stream/scaladsl/SinkQueue.html" title="interface in akka.stream.scaladsl"><code>SinkQueue</code></a>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#reduce-scala.Function2-">reduce</a></span>(scala.Function2&lt;T,T,T&gt;&nbsp;f)</code>
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (from the second element) and the element as input.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;T&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#seq--">seq</a></span>()</code>
<div class="block">A <code>Sink</code> that keeps on collecting incoming elements until upstream terminates.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../akka/stream/SinkShape.html" title="class in akka.stream">SinkShape</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../akka/stream/scaladsl/Sink$.html#shape-java.lang.String-">shape</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">INTERNAL API</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="MODULE:D">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>MODULE$</h4>
<pre>public static final&nbsp;<a href="../../../akka/stream/scaladsl/Sink$.html" title="class in akka.stream.scaladsl">Sink$</a> MODULE$</pre>
<div class="block">Static reference to the singleton instance of this Scala object.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Sink:D--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Sink$</h4>
<pre>public&nbsp;Sink$()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="shape-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shape</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/SinkShape.html" title="class in akka.stream">SinkShape</a>&lt;T&gt;&nbsp;shape(java.lang.String&nbsp;name)</pre>
<div class="block">INTERNAL API</div>
</li>
</ul>
<a name="fromGraph-akka.stream.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromGraph</h4>
<pre>public&nbsp;&lt;T,M&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,M&gt;&nbsp;fromGraph(<a href="../../../akka/stream/Graph.html" title="interface in akka.stream">Graph</a>&lt;<a href="../../../akka/stream/SinkShape.html" title="class in akka.stream">SinkShape</a>&lt;T&gt;,M&gt;&nbsp;g)</pre>
<div class="block">A graph with the shape of a sink logically is a sink, this method makes
 it so also in type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>g</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="fromSubscriber-org.reactivestreams.Subscriber-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromSubscriber</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&nbsp;fromSubscriber(org.reactivestreams.Subscriber&lt;T&gt;&nbsp;subscriber)</pre>
<div class="block">Helper to create <a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl"><code>Sink</code></a> from <code>Subscriber</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="cancelled--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cancelled</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&nbsp;cancelled()</pre>
<div class="block">A <code>Sink</code> that immediately cancels its upstream after materialization.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="head--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>head</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;T&gt;&gt;&nbsp;head()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the first value received.
 If the stream completes before signaling at least a single element, the Future will be failed with a <code>NoSuchElementException</code>.
 If the stream signals an error errors before signaling at least a single element, the Future will be failed with the streams exception.
 <p>
 See also <code>headOption</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="headOption--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headOption</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;&nbsp;headOption()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional first value received.
 If the stream completes before signaling at least a single element, the value of the Future will be <code>None</code>.
 If the stream signals an error errors before signaling at least a single element, the Future will be failed with the streams exception.
 <p>
 See also <code>head</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="last--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>last</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;T&gt;&gt;&nbsp;last()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the last value received.
 If the stream completes before signaling at least a single element, the Future will be failed with a <code>NoSuchElementException</code>.
 If the stream signals an error, the Future will be failed with the stream's exception.
 <p>
 See also <code>lastOption</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="lastOption--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lastOption</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;&nbsp;lastOption()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional last value received.
 If the stream completes before signaling at least a single element, the value of the Future will be <code>None</code>.
 If the stream signals an error, the Future will be failed with the stream's exception.
 <p>
 See also <code>last</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="seq--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>seq</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;T&gt;&gt;&gt;&nbsp;seq()</pre>
<div class="block">A <code>Sink</code> that keeps on collecting incoming elements until upstream terminates.
 As upstream may be unbounded, <code>Flow[T].take</code> or the stricter <code>Flow[T].limit</code> (and their variants)
 may be used to ensure boundedness.
 Materializes into a <code>Future</code> of <code>Seq[T]</code> containing all the collected elements.
 <code>Seq</code> is limited to <code>Int.MaxValue</code> elements, this Sink will cancel the stream
 after having received that many elements.
 <p>
 See also <code>Flow.limit</code>, <code>Flow.limitWeighted</code>, <code>Flow.take</code>, <code>Flow.takeWithin</code>, <code>Flow.takeWhile</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="asPublisher-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asPublisher</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;asPublisher(boolean&nbsp;fanout)</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Publisher</code>.
 <p>
 If <code>fanout</code> is <code>true</code>, the materialized <code>Publisher</code> will support multiple <code>Subscriber</code>s and
 the size of the <code>inputBuffer</code> configured for this stage becomes the maximum number of elements that
 the fastest <code>Subscriber</code> can be ahead of the slowest one before slowing
 the processing down due to back pressure.
 <p>
 If <code>fanout</code> is <code>false</code> then the materialized <code>Publisher</code> will only support a single <code>Subscriber</code> and
 reject any additional <code>Subscriber</code>s.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fanout</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="ignore--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignore</h4>
<pre>public&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;java.lang.Object,scala.concurrent.Future&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;&gt;&nbsp;ignore()</pre>
<div class="block">A <code>Sink</code> that will consume the stream and discard the elements.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="foreach-scala.Function1-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foreach</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;&gt;&nbsp;foreach(scala.Function1&lt;T,scala.runtime.BoxedUnit&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given procedure for each received element. The sink is materialized
 into a <code>Future</code> will be completed with <code>Success</code> when reaching the
 normal end of the stream, or completed with <code>Failure</code> if there is a failure signaled in
 the stream..</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>f</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="combine-akka.stream.scaladsl.Sink-akka.stream.scaladsl.Sink-scala.collection.Seq-scala.Function1-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combine</h4>
<pre>public&nbsp;&lt;T,U&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&nbsp;combine(<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;U,?&gt;&nbsp;first,
                                     <a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;U,?&gt;&nbsp;second,
                                     scala.collection.Seq&lt;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;U,?&gt;&gt;&nbsp;rest,
                                     scala.Function1&lt;java.lang.Object,<a href="../../../akka/stream/Graph.html" title="interface in akka.stream">Graph</a>&lt;<a href="../../../akka/stream/UniformFanOutShape.html" title="class in akka.stream">UniformFanOutShape</a>&lt;T,U&gt;,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&gt;&nbsp;strategy)</pre>
<div class="block">Combine several sinks with fan-out strategy like <code>Broadcast</code> or <code>Balance</code> and returns <code>Sink</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>first</code> - (undocumented)</dd>
<dd><code>second</code> - (undocumented)</dd>
<dd><code>rest</code> - (undocumented)</dd>
<dd><code>strategy</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="foreachParallel-int-scala.Function1-scala.concurrent.ExecutionContext-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foreachParallel</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;&gt;&nbsp;foreachParallel(int&nbsp;parallelism,
                                                                 scala.Function1&lt;T,scala.runtime.BoxedUnit&gt;&nbsp;f,
                                                                 scala.concurrent.ExecutionContext&nbsp;ec)</pre>
<div class="block">A <code>Sink</code> that will invoke the given function to each of the elements
 as they pass in. The sink is materialized into a <code>Future</code>
 <p>
 If <code>f</code> throws an exception and the supervision decision is
 <code>akka.stream.Supervision.Stop</code> the <code>Future</code> will be completed with failure.
 <p>
 If <code>f</code> throws an exception and the supervision decision is
 <code>akka.stream.Supervision.Resume</code> or <code>akka.stream.Supervision.Restart</code> the
 element is dropped and the stream continues.
 <p>
 See also <code>Flow.mapAsyncUnordered</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parallelism</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>ec</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="fold-java.lang.Object-scala.Function2-">
<!--   -->
</a><a name="fold-U-scala.Function2-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fold</h4>
<pre>public&nbsp;&lt;U,T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;U&gt;&gt;&nbsp;fold(U&nbsp;zero,
                                                     scala.Function2&lt;U,T,U&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>Future</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure signaled in the stream.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>zero</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../akka/stream/scaladsl/Sink$.html#foldAsync-U-scala.Function2-"><code>foldAsync(U, scala.Function2&lt;U, T, scala.concurrent.Future&lt;U&gt;&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a name="foldAsync-java.lang.Object-scala.Function2-">
<!--   -->
</a><a name="foldAsync-U-scala.Function2-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foldAsync</h4>
<pre>public&nbsp;&lt;U,T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;U&gt;&gt;&nbsp;foldAsync(U&nbsp;zero,
                                                          scala.Function2&lt;U,T,scala.concurrent.Future&lt;U&gt;&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given asynchronous function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>Future</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure signaled in the stream.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>zero</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../akka/stream/scaladsl/Sink$.html#fold-U-scala.Function2-"><code>fold(U, scala.Function2&lt;U, T, U&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a name="reduce-scala.Function2-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;T&gt;&gt;&nbsp;reduce(scala.Function2&lt;T,T,T&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (from the second element) and the element as input.
 The returned <code>Future</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure signaled in the stream.
 <p>
 If the stream is empty (i.e. completes before signalling any elements),
 the reduce stage will fail its downstream with a <code>NoSuchElementException</code>,
 which is semantically in-line with that Scala's standard library collections
 do in such situations.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>f</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="onComplete-scala.Function1-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onComplete</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&nbsp;onComplete(scala.Function1&lt;scala.util.Try&lt;<a href="../../../akka/Done.html" title="class in akka">Done</a>&gt;,scala.runtime.BoxedUnit&gt;&nbsp;callback)</pre>
<div class="block">A <code>Sink</code> that when the flow is completed, either through a failure or normal
 completion, apply the provided function with <code>Success</code>
 or <code>Failure</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="actorRef-akka.actor.ActorRef-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRef</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&nbsp;actorRef(<a href="../../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</a>&nbsp;ref,
                                    java.lang.Object&nbsp;onCompleteMessage)</pre>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code>.
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given <code>onCompleteMessage</code>
 will be sent to the destination actor.
 When the stream is completed with failure a <a href="../../../akka/actor/Status.Failure.html" title="class in akka.actor"><code>Status.Failure</code></a>
 message will be sent to the destination actor.
 <p>
 It will request at most <code>maxInputBufferSize</code> number of elements from
 upstream, but there is no back-pressure signal from the destination actor,
 i.e. if the actor is not consuming the messages fast enough the mailbox
 of the actor will grow. For potentially slow consumer actors it is recommended
 to use a bounded mailbox with zero <code>mailbox-push-timeout-time</code> or use a rate
 limiting stage in front of this <code>Sink</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ref</code> - (undocumented)</dd>
<dd><code>onCompleteMessage</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="actorRefWithAck-akka.actor.ActorRef-java.lang.Object-java.lang.Object-java.lang.Object-scala.Function1-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithAck</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/NotUsed.html" title="class in akka">NotUsed</a>&gt;&nbsp;actorRefWithAck(<a href="../../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</a>&nbsp;ref,
                                           java.lang.Object&nbsp;onInitMessage,
                                           java.lang.Object&nbsp;ackMessage,
                                           java.lang.Object&nbsp;onCompleteMessage,
                                           scala.Function1&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;onFailureMessage)</pre>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal.
 First element is always <code>onInitMessage</code>, then stream is waiting for acknowledgement message
 <code>ackMessage</code> from the given actor which means that it is ready to process
 elements. It also requires <code>ackMessage</code> message after each stream element
 to make backpressure work.
 <p>
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given <code>onCompleteMessage</code>
 will be sent to the destination actor.
 When the stream is completed with failure - result of <code>onFailureMessage(throwable)</code>
 function will be sent to the destination actor.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ref</code> - (undocumented)</dd>
<dd><code>onInitMessage</code> - (undocumented)</dd>
<dd><code>ackMessage</code> - (undocumented)</dd>
<dd><code>onCompleteMessage</code> - (undocumented)</dd>
<dd><code>onFailureMessage</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="actorSubscriber-akka.actor.Props-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorSubscriber</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</a>&gt;&nbsp;actorSubscriber(<a href="../../../akka/actor/Props.html" title="class in akka.actor">Props</a>&nbsp;props)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use <code>akka.stream.stage.GraphStage</code> and <code>fromGraph</code> instead, it allows for all operations an Actor would and is more type-safe as well as guaranteed to be ReactiveStreams compliant.</span></div>
<div class="block">Creates a <code>Sink</code> that is materialized to an <a href="../../../akka/actor/ActorRef.html" title="class in akka.actor"><code>ActorRef</code></a> which points to an Actor
 created according to the passed in <a href="../../../akka/actor/Props.html" title="class in akka.actor"><code>Props</code></a>. Actor created by the <code>props</code> must
 be <a href="../../../akka/stream/actor/ActorSubscriber.html" title="interface in akka.stream.actor"><code>ActorSubscriber</code></a>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>props</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="queue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,<a href="../../../akka/stream/scaladsl/SinkQueueWithCancel.html" title="interface in akka.stream.scaladsl">SinkQueueWithCancel</a>&lt;T&gt;&gt;&nbsp;queue()</pre>
<div class="block">Creates a <code>Sink</code> that is materialized as an <a href="../../../akka/stream/scaladsl/SinkQueue.html" title="interface in akka.stream.scaladsl"><code>SinkQueue</code></a>.
 <code>akka.stream.scaladsl.SinkQueue.pull</code> method is pulling element from the stream and returns <code></code>Future[Option[T}<code></code>.
 <code>Future</code> completes when element is available.
 <p>
 Before calling pull method second time you need to wait until previous Future completes.
 Pull returns Failed future with ''IllegalStateException'' if previous future has not yet completed.
 <p>
 <code>Sink</code> will request at most number of elements equal to size of <code>inputBuffer</code> from
 upstream and then stop back pressure.  You can configure size of input
 buffer by using <code>Sink.withAttributes</code> method.
 <p>
 For stream completion you need to pull all elements from <a href="../../../akka/stream/scaladsl/SinkQueue.html" title="interface in akka.stream.scaladsl"><code>SinkQueue</code></a> including last None
 as completion marker
 <p>
 See also <a href="../../../akka/stream/scaladsl/SinkQueueWithCancel.html" title="interface in akka.stream.scaladsl"><code>SinkQueueWithCancel</code></a></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
<a name="lazyInit-scala.Function1-scala.Function0-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>lazyInit</h4>
<pre>public&nbsp;&lt;T,M&gt;&nbsp;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,scala.concurrent.Future&lt;M&gt;&gt;&nbsp;lazyInit(scala.Function1&lt;T,scala.concurrent.Future&lt;<a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl">Sink</a>&lt;T,M&gt;&gt;&gt;&nbsp;sinkFactory,
                                                         scala.Function0&lt;M&gt;&nbsp;fallback)</pre>
<div class="block">Creates a real <code>Sink</code> upon receiving the first element. Internal <code>Sink</code> will not be created if there are no elements,
 because of completion or error.
 <p>
 If <code>sinkFactory</code> throws an exception and the supervision decision is
 <code>akka.stream.Supervision.Stop</code> the <code>Future</code> will be completed with failure. For all other supervision options it will
 try to create sink with next element
 <p>
 <code>fallback</code> will be executed when there was no elements and completed is received from upstream.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sinkFactory</code> - (undocumented)</dd>
<dd><code>fallback</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../akka/stream/scaladsl/Sink.html" title="class in akka.stream.scaladsl"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../akka/stream/scaladsl/SinkQueue.html" title="interface in akka.stream.scaladsl"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?akka/stream/scaladsl/Sink$.html" target="_top">Frames</a></li>
<li><a href="Sink$.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
