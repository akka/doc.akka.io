<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_31) on Fri Mar 15 14:22:53 CET 2013 -->
<TITLE>
Patterns
</TITLE>

<META NAME="date" CONTENT="2013-03-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Patterns";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../akka/pattern/GracefulStopSupport.html" title="interface in akka.pattern"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../akka/pattern/Patterns$.html" title="class in akka.pattern"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?akka/pattern/Patterns.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Patterns.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
akka.pattern</FONT>
<BR>
Class Patterns</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>akka.pattern.Patterns</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Patterns</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../akka/pattern/Patterns.html#Patterns()">Patterns</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; scala.concurrent.Future&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../akka/pattern/Patterns.html#after(scala.concurrent.duration.FiniteDuration, akka.actor.Scheduler, scala.concurrent.ExecutionContext, java.util.concurrent.Callable)">after</A></B>(scala.concurrent.duration.FiniteDuration&nbsp;duration,
      <A HREF="../../akka/actor/Scheduler.html" title="interface in akka.actor">Scheduler</A>&nbsp;scheduler,
      scala.concurrent.ExecutionContext&nbsp;context,
      java.util.concurrent.Callable&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <CODE>Future</CODE> that will be completed with the success or failure of the provided Callable
 after the specified duration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; scala.concurrent.Future&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../akka/pattern/Patterns.html#after(scala.concurrent.duration.FiniteDuration, akka.actor.Scheduler, scala.concurrent.ExecutionContext, scala.concurrent.Future)">after</A></B>(scala.concurrent.duration.FiniteDuration&nbsp;duration,
      <A HREF="../../akka/actor/Scheduler.html" title="interface in akka.actor">Scheduler</A>&nbsp;scheduler,
      scala.concurrent.ExecutionContext&nbsp;context,
      scala.concurrent.Future&lt;T&gt;&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <CODE>Future</CODE> that will be completed with the success or failure of the provided value
 after the specified duration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../akka/pattern/Patterns.html#ask(akka.actor.ActorRef, java.lang.Object, long)">ask</A></B>(<A HREF="../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</A>&nbsp;actor,
    java.lang.Object&nbsp;message,
    long&nbsp;timeoutMillis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Java API for `akka.pattern.ask`:</i>
 Sends a message asynchronously and returns a <CODE>Future</CODE>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the `sender` reference provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;scala.concurrent.Future&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../akka/pattern/Patterns.html#ask(akka.actor.ActorRef, java.lang.Object, akka.util.Timeout)">ask</A></B>(<A HREF="../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</A>&nbsp;actor,
    java.lang.Object&nbsp;message,
    <A HREF="../../akka/util/Timeout.html" title="class in akka.util">Timeout</A>&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Java API for `akka.pattern.ask`:</i>
 Sends a message asynchronously and returns a <CODE>Future</CODE>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the `sender` reference provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;scala.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../akka/pattern/Patterns.html#gracefulStop(akka.actor.ActorRef, scala.concurrent.duration.FiniteDuration, akka.actor.ActorSystem)">gracefulStop</A></B>(<A HREF="../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</A>&nbsp;target,
             scala.concurrent.duration.FiniteDuration&nbsp;timeout,
             <A HREF="../../akka/actor/ActorSystem.html" title="class in akka.actor">ActorSystem</A>&nbsp;system)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <CODE>Future</CODE> that will be completed with success (value `true`) when
 existing messages of the target actor has been processed and the actor has been
 terminated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../akka/pattern/PipeToSupport.PipeableFuture.html" title="class in akka.pattern">PipeToSupport.PipeableFuture</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../akka/pattern/Patterns.html#pipe(scala.concurrent.Future, scala.concurrent.ExecutionContext)">pipe</A></B>(scala.concurrent.Future&lt;T&gt;&nbsp;future,
     scala.concurrent.ExecutionContext&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register an onComplete callback on this <CODE>Future</CODE> to send
 the result to the given actor reference.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Patterns()"><!-- --></A><H3>
Patterns</H3>
<PRE>
public <B>Patterns</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ask(akka.actor.ActorRef, java.lang.Object, akka.util.Timeout)"><!-- --></A><H3>
ask</H3>
<PRE>
public static scala.concurrent.Future&lt;java.lang.Object&gt; <B>ask</B>(<A HREF="../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</A>&nbsp;actor,
                                                            java.lang.Object&nbsp;message,
                                                            <A HREF="../../akka/util/Timeout.html" title="class in akka.util">Timeout</A>&nbsp;timeout)</PRE>
<DL>
<DD><i>Java API for `akka.pattern.ask`:</i>
 Sends a message asynchronously and returns a <CODE>Future</CODE>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the `sender` reference provided. The Future
 will be completed with an <A HREF="../../akka/pattern/AskTimeoutException.html" title="class in akka.pattern"><CODE>AskTimeoutException</CODE></A> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 `Await.result(..., timeout)`).
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(worker, request, timeout);
   f.onSuccess(new Procedure&lt;Object&gt;() {
     public void apply(Object o) {
       nextActor.tell(new EnrichedResult(request, o));
     }
   });
 </code></pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="ask(akka.actor.ActorRef, java.lang.Object, long)"><!-- --></A><H3>
ask</H3>
<PRE>
public static scala.concurrent.Future&lt;java.lang.Object&gt; <B>ask</B>(<A HREF="../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</A>&nbsp;actor,
                                                            java.lang.Object&nbsp;message,
                                                            long&nbsp;timeoutMillis)</PRE>
<DL>
<DD><i>Java API for `akka.pattern.ask`:</i>
 Sends a message asynchronously and returns a <CODE>Future</CODE>
 holding the eventual reply message; this means that the target actor
 needs to send the result to the `sender` reference provided. The Future
 will be completed with an <A HREF="../../akka/pattern/AskTimeoutException.html" title="class in akka.pattern"><CODE>AskTimeoutException</CODE></A> after the
 given timeout has expired; this is independent from any timeout applied
 while awaiting a result for this future (i.e. in
 `Await.result(..., timeout)`).
 <p>
 <b>Warning:</b>
 When using future callbacks, inside actors you need to carefully avoid closing over
 the containing actor&rsquo;s object, i.e. do not call methods or access mutable state
 on the enclosing actor from within the callback. This would break the actor
 encapsulation and may introduce synchronization bugs and race conditions because
 the callback will be scheduled concurrently to the enclosing actor. Unfortunately
 there is not yet a way to detect these illegal accesses at compile time.
 <p>
 <b>Recommended usage:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(worker, request, timeout);
   f.onSuccess(new Procedure&lt;Object&gt;() {
     public void apply(Object o) {
       nextActor.tell(new EnrichedResult(request, o));
     }
   });
 </code></pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pipe(scala.concurrent.Future, scala.concurrent.ExecutionContext)"><!-- --></A><H3>
pipe</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../akka/pattern/PipeToSupport.PipeableFuture.html" title="class in akka.pattern">PipeToSupport.PipeableFuture</A>&lt;T&gt; <B>pipe</B>(scala.concurrent.Future&lt;T&gt;&nbsp;future,
                                                       scala.concurrent.ExecutionContext&nbsp;context)</PRE>
<DL>
<DD>Register an onComplete callback on this <CODE>Future</CODE> to send
 the result to the given actor reference. Returns the original Future to
 allow method chaining.
 <p>
 <b>Recommended usage example:</b>
 <p>
 <pre><code>
   final Future&lt;Object&gt; f = Patterns.ask(worker, request, timeout);
   // apply some transformation (i.e. enrich with request info)
   final Future&lt;Object&gt; transformed = f.map(new akka.japi.Function&lt;Object, Object&gt;() { ... });
   // send it on to the next stage
   Patterns.pipe(transformed).to(nextActor);
 </code></pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="gracefulStop(akka.actor.ActorRef, scala.concurrent.duration.FiniteDuration, akka.actor.ActorSystem)"><!-- --></A><H3>
gracefulStop</H3>
<PRE>
public static scala.concurrent.Future&lt;java.lang.Boolean&gt; <B>gracefulStop</B>(<A HREF="../../akka/actor/ActorRef.html" title="class in akka.actor">ActorRef</A>&nbsp;target,
                                                                      scala.concurrent.duration.FiniteDuration&nbsp;timeout,
                                                                      <A HREF="../../akka/actor/ActorSystem.html" title="class in akka.actor">ActorSystem</A>&nbsp;system)</PRE>
<DL>
<DD>Returns a <CODE>Future</CODE> that will be completed with success (value `true`) when
 existing messages of the target actor has been processed and the actor has been
 terminated.
 <p>
 Useful when you need to wait for termination or compose ordered termination of several actors.
 <p>
 If the target actor isn't terminated within the timeout the <CODE>Future</CODE>
 is completed with failure <A HREF="../../akka/pattern/AskTimeoutException.html" title="class in akka.pattern"><CODE>AskTimeoutException</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="after(scala.concurrent.duration.FiniteDuration, akka.actor.Scheduler, scala.concurrent.ExecutionContext, java.util.concurrent.Callable)"><!-- --></A><H3>
after</H3>
<PRE>
public static &lt;T&gt; scala.concurrent.Future&lt;T&gt; <B>after</B>(scala.concurrent.duration.FiniteDuration&nbsp;duration,
                                                   <A HREF="../../akka/actor/Scheduler.html" title="interface in akka.actor">Scheduler</A>&nbsp;scheduler,
                                                   scala.concurrent.ExecutionContext&nbsp;context,
                                                   java.util.concurrent.Callable&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;value)</PRE>
<DL>
<DD>Returns a <CODE>Future</CODE> that will be completed with the success or failure of the provided Callable
 after the specified duration.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="after(scala.concurrent.duration.FiniteDuration, akka.actor.Scheduler, scala.concurrent.ExecutionContext, scala.concurrent.Future)"><!-- --></A><H3>
after</H3>
<PRE>
public static &lt;T&gt; scala.concurrent.Future&lt;T&gt; <B>after</B>(scala.concurrent.duration.FiniteDuration&nbsp;duration,
                                                   <A HREF="../../akka/actor/Scheduler.html" title="interface in akka.actor">Scheduler</A>&nbsp;scheduler,
                                                   scala.concurrent.ExecutionContext&nbsp;context,
                                                   scala.concurrent.Future&lt;T&gt;&nbsp;value)</PRE>
<DL>
<DD>Returns a <CODE>Future</CODE> that will be completed with the success or failure of the provided value
 after the specified duration.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../akka/pattern/GracefulStopSupport.html" title="interface in akka.pattern"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../akka/pattern/Patterns$.html" title="class in akka.pattern"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?akka/pattern/Patterns.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Patterns.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
